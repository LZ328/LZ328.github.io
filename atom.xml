<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2023-03-07T06:00:26.712Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【设计模式】状态模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-07T05:57:54.000Z</published>
    <updated>2023-03-07T06:00:26.712Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了状态模式及相关的面向对象设计原则。状态模式允许对象在内部状态改变时改变它的行为，从而使对象看起来像是修改了它的行为。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>一些情况下某些对象的状态如果改变，那么它的行为也会随着发生变化。比如一个网络管理器，存在三种状态：网络开启、关闭和连接。通过某些操作能在这些状态间进行转换，但是在不同状态下时，同样的操作导致的结果可能不同（行为发生变化），下面是一个简单的实现，利用枚举存储了三种状态，然后通过最直接的 if-else 来判断当前状态并实现不同的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkState</span> &#123;</span><br><span class="line">    Network_Open,</span><br><span class="line">    Network_Close,</span><br><span class="line">    Network_Connect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    NetworkState state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照这种实现方式，当我们要加入新的状态或者新的操作的时候，就大量需要修改类中的代码，当状态复杂的时候很容易就出现各种错误，带来维护问题。</p><h3 id="2-状态模式"><a href="#2-状态模式" class="headerlink" title="2 状态模式"></a>2 状态模式</h3><p>状态模式将所有的状态打包成一个状态族，每一个具体的状态只负责当前状态下的操作，而原本对象的所有操作都委托给当前的状态对象去进行。对于客户来说，就好像原本的对象在不同状态下改变了它本身的行为，但实际上是通过和状态对象的组合来实现的。</p><p>状态模式的类图如下：<br><img src="https://lz328.github.io/LycTechStack.github.io/TechStack\Blogs\lz328\source_posts\20230307-设计模式-状态模式\image-20230307134445001.png" alt="image-20230307134445001"></p><p>形式上与策略模式一模一样，但策略模式是将操作打包成为一族算法，与对象进行组合从而使对象能够切换行为。而状态模式将状态独立出来，使对象可以随着客户的操作自动切换状态并改变行为，而对象本身对此无需知情，只要将对应的操作委托给当前的状态对象去执行即可。</p><p>接下来我们将上面的例子使用状态模式进行实现。首先需要实现一个状态接口，其中包含了系统中的所有操作，每个状态都要实现这些操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkState</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext;<span class="comment">// 记录转换后的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后每一个具体的状态都实现自己的操作，这里以网络开状态为例，其他两个状态同理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenState</span> :<span class="keyword">public</span> NetworkState&#123;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="type">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 状态对象只能有一个，使用简单单例模式</span></span><br><span class="line">    <span class="function"><span class="type">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现操作并进行状态转换</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后网络管理器的代码也需要修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NetworkState* pState;<span class="comment">// 管理器的当前状态   </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 构造的时候要初始化一个状态</span></span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* pState) &#123;       </span><br><span class="line">        <span class="keyword">this</span>-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation1</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation2</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation3</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来，当新增状态或者操作有变化时，网络管理器对象的代码完全不需要更改，只需修改对应的状态对象的部分就可以了，实现了对象和其状态之间的解耦，或者说实现了具体操作和状态转换之间的解耦。状态模式的另一个潜在好处是，为不同状态引入不同的对象使得状态转换更加明确，可以保证不会出现状态不一致的情况，因为状态的转换是原子的，即要么彻底转换为另一状态，要么不转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了状态模式及相关的面向对象设计原则。状态模式允许对象在内部状态改变时改变它的行为，从而使对象看起来像是修改了它的行为。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】迭代器模式和组合模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-07T04:06:03.000Z</published>
    <updated>2023-03-07T06:00:35.667Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了迭代器模式和组合模式及相关的面向对象设计原则。这两种模式都是面向数据结构的设计模式。</p><ul><li>迭代器模式（Iterator）提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</li><li>组合模式（Composite）将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-迭代器模式"><a href="#1-迭代器模式" class="headerlink" title="1 迭代器模式"></a>1 迭代器模式</h3><p>我们对迭代器的概念非常熟悉，许多情况下面对不同的对象集合，我们希望能有统一的方式遍历他们，但不对外暴露其内部的实现方式。比如 C++ 的 vector、list、map 等容器都支持迭代器，利用迭代器我们可以使用统一的方法，比如 <code>first()</code>、<code>end()</code>、<code>next()</code> 等，对不同集合的对象进行统一的操作。</p><p>迭代器模式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230307111924414.png" alt="image-20230307111924414"></p><p>首先实现迭代器接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个和自己的元素容器，该容器需要有一个迭代器对象，并能够返回该迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCollection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">GetIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 提供当前容器的迭代器</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现我们容器的具体迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollectionIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollectionIterator</span>(<span class="type">const</span> MyCollection&lt;T&gt; &amp; c): <span class="built_in">mc</span>(c) &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">// 是否指向最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回当前指向的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后调用时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="type">int</span>&gt; mc;</span><br><span class="line">    Iterator&lt;<span class="type">int</span>&gt; iter = mc.<span class="built_in">GetIterator</span>();</span><br><span class="line">    <span class="keyword">for</span> (iter.<span class="built_in">first</span>(); !iter.<span class="built_in">end</span>(); iter.<span class="built_in">next</span>())&#123;</span><br><span class="line">        cout &lt;&lt; iter.<span class="built_in">current</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器模式把元素之间游走的责任交给迭代器去处理，这样一来元素容器本身就不需要关注如何处理对象的遍历，而是专注于对象的管理操作上。迭代器模式不仅让客户遍历不同的容器更加方便，也会让元素容器的接口更加简洁。</p><p>那么为什么不让元素容器本身去实现各自的遍历操作呢，因为一个类的每个责任都有发生变化的可能，容器管理对象是一个责任，负责对象的遍历和访问又是一个责任，责任越多，意味着未来发生变化的可能性越大，要修改的代码也就越多。因此迭代器模式引出了一个重要的设计原则：</p><blockquote><p><strong>设计原则：单一责任原则</strong></p><p>一个类应该只有一个引起变化的原因，尽量让每个类保持单一责任。</p></blockquote><h3 id="2-组合模式"><a href="#2-组合模式" class="headerlink" title="2 组合模式"></a>2 组合模式</h3><p>在一些情况下，对象内部的结构可能较为复杂，不再是单一的容器了。比如一个容器内部的每一个元素又是一个可以容纳多个对象的容器，此时使用迭代器模式就没有办法直接遍历这样的复杂结构了，因此需要使用组合模式。</p><p>组合模式将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。上面的例子中，一级容器的每个元素相当于树的一个中间节点，节点包含二级容器中的各个元素，因此我们可以将这个树状结构构建出来，并让每一级容器中的元素都继承自同一个父类，这个父类被称为基本的组件（Component），这样在客户代码中就无需关注对象是叶子节点（单一对象）还是中间节点（组合对象）了，因为他们都有相同的接口。</p><p>组合模式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230307115555425.png" alt="image-20230307115555425"></p><p>首先是实现 Component 接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现叶子节点，叶子节点不包含其他子节点，只实现对应的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是中间节点，也就是组合对象，中间节点包含其他叶子节点，执行操作时就是先处理自身，然后遍历所有叶子节点，按顺序调用叶子节点的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;<span class="comment">// 包含的子节点集合，子节点可以是其他组合对象，也可以是叶子节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 组合对象还支持增加或删除节点的操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合节点的操作就是处理自身，并依次调用叶子节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>();  <span class="comment">// 递归多态调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后为该对象的处理写一个统一的接口供客户代码使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建对象关系</span></span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">&quot;treeNode4&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">&quot;left2&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line">    </span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;treeNode4);</span><br><span class="line">    treeNode4.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对组合对象和单一对象的调用是统一的</span></span><br><span class="line">    <span class="built_in">Invoke</span>(root);</span><br><span class="line">    <span class="built_in">Invoke</span>(leaf2);</span><br><span class="line">    <span class="built_in">Invoke</span>(treeNode3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们也可以结合组合模式和迭代器，实现组合迭代器，只要为每个组件加上一个迭代器对象，然后递归的遍历即可。之前在实现光线追踪时的 BVH 结构就是组合模式的典型例子，可以回顾一下<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/">【RayTracer】（十）实现 BVH</a>。</p><p>组合模式采用树形结构来表达层次关系，将“一对多”的关系转变为“一对一”的关系，使客户代码可以一致的处理对象本身和对象容器，而无需关心处理的是单个对象还是组合对象。组合模式将客户代码和复杂的对象容器结构解耦，客户代码只与纯粹的抽象接口发生依赖，而不是具体的对象容器，从而更能应对变化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了迭代器模式和组合模式及相关的面向对象设计原则。这两种模式都是面向数据结构的设计模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代器模式（Iterator）提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。&lt;/li&gt;
&lt;li&gt;组合模式（Composite）将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T07:11:09.000Z</published>
    <updated>2023-03-05T07:12:06.845Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了模板方法模式及相关的面向对象设计原则。模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>例如有一个任务需要用到某个程序库，程序库开发人员设计了一个 Library 类，它实现了三种方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBRARY_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而应用程序开发人员要实现这个任务的话，还需要编写一些代码，并调用程序库，因此他可能会编写以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLICATION_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#endlif</span></span><br></pre></td></tr></table></figure><p>最终实现整个任务流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Application.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(app.<span class="built_in">Step2</span>())&#123;</span><br><span class="line">lib.<span class="built_in">Step3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">app.<span class="built_in">Step4</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2 模板方法模式"></a>2 模板方法模式</h3><p>上面的实现的问题在于，无论谁来使用程序库，完成类似的任务，都需要编写主函数中的一个完整流程，并编写自己的 Application 类，因此对于这类任务来说，流程是固定的，而库代码是不变的部分，Application 代码是变化的部分，因此我们可以设计一个方法模板，改模板按照固定流程实现某类任务，任务中有些步骤固定不变，但某些步骤可能发生改变，将这些可能发生变化的部分设定为纯虚函数，交给子类去实现，这样在客户代码中只需要调用统一的接口，就可以实现不同的任务了。</p><p>于是首先是模板方法接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBRARY_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//稳定的template Method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Step2</span>())&#123;<span class="comment">//支持变化===&gt;虚函数的多态调用 </span></span><br><span class="line"><span class="built_in">Step3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">Step4</span>();<span class="comment">//支持变化===&gt;虚函数的多态调用 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化 </span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后让具体的程序继承该接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Library.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> : <span class="keyword">public</span> Library&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样一来，主程序就变得非常简单，并且h后续维护也不需要做任何更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Application.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Library *pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">pLib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Template Method 模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性） 为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了模板方法模式及相关的面向对象设计原则。模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】适配器模式和外观模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T06:45:32.000Z</published>
    <updated>2023-03-05T07:40:23.222Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了适配器模式和外观模式及相关的面向对象设计原则。适配器模式（Adapter）和外观模式（Facade）都是用于“接口隔离”的设计模式。</p><ul><li>适配器模式将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。</li><li>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1 适配器模式"></a>1 适配器模式</h3><p>很多情况下，当我们已经有一个软件系统，并希望和一个新的厂商类库搭配使用，但厂商类库的接口和当前软件的接口不适配：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142721206.png" alt="image-20230305142721206"></p><p>而我们又不想改变现有代码，于是就需要写一个适配器，来讲类库的接口转变为当前软件支持的接口：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142803328.png" alt="image-20230305142803328"></p><p>这就是适配器模式。</p><p>适配器模式有两种实现方式，一种称为对象适配器，我们可以将被适配对象包含在适配器对象中，这样适配器就可以调用被适配对象的方法，并实现一个客户支持的接口，这种方式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142925575.png" alt="image-20230305142925575"></p><p>另一种方式是类适配器，可以利用多重继承，让适配器成为被适配对象和目标接口的子类，这样就可以将被适配对象的接口转化为目标接口了，这种方式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305143022285.png" alt="image-20230305143022285"></p><p>显然，对象适配器通过组合来实现适配，而类适配器通过继承来实现适配，二者各有优劣，可以根据实际情况使用。</p><h3 id="2-外观模式"><a href="#2-外观模式" class="headerlink" title="2 外观模式"></a>2 外观模式</h3><p>外观模式非常简单，直接来看类图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305143835788.png" alt="image-20230305143835788"></p><p>需要注意的是，外观模式并不是要把所有类的接口都整合到一起，外观对象的内部应该是一个相互关联的子系统，而不是简单的功能集合。</p><p>从客户程序的角度来看，外观模式简化了整个组件系统的接口，将他们统一起来，方便客户程序调用，这样一来子系统内部的任何变化都不会改变客户程序的调用接口，从而实现了解耦。</p><p>外观模式带来了新的设计原则：</p><blockquote><p><strong>设计原则：最少知识原则</strong></p><p>设计中尽可能减少对象之间的交互。当然，减少对象之间的交互意味着需要更多的包装，这也可能为程序带来更高的运行开销。</p></blockquote><p>外观模式更注重从架构的层次去看整个系统，而不仅仅是单个类，因此外观模式更像是一种架构设计模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了适配器模式和外观模式及相关的面向对象设计原则。适配器模式（Adapter）和外观模式（Facade）都是用于“接口隔离”的设计模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。&lt;/li&gt;
&lt;li&gt;外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】命令模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T06:06:52.000Z</published>
    <updated>2023-03-05T06:08:18.476Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了命令模式及相关的面向对象设计原则。命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象，从而实现请求发出者和请求执行者之间的解耦。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>我们需要设计这样一个系统，有一个遥控器，遥控器有一个插槽和三个按钮，其中两个按钮对应“开”和“关”，一个按钮对应“撤销”操作，插槽中可以插入不同的控制模块来控制不同的电器，比如电灯、热水器、电动窗帘、空调等等，也就是说遥控器的功能取决于插槽内的控制模块。而不同电器的“开”和“关”操作都有各自的实现，他们是毫无关联的单独的类。</p><p>直观的方式是判断当前插槽内是什么模块，然后为按钮调用对应的电器的命令，但是当出现更多的电器时，需要不停的修改遥控器的代码。因为此时请求发出者（遥控器）和请求执行者（被操控的电器）是紧耦合的，如果能将它们解耦，那么系统将具有更好的弹性来应对各种变化。</p><h3 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2 命令模式"></a>2 命令模式</h3><p>我们可以将遥控器的命令封装成一系列统一的命令对象，让命令对象和具体的命令执行者绑定，负责执行对应的命令，而命令发出者只需要调用命令对象的统一接口就可以实现对不同执行者的控制。</p><p>在上例中，遥控器的命令只有三种：开、关和撤销。接下来以电灯为例，按照上述思路来设计一个遥控器。电灯类非常简单，只具有开和关两种操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是遥控器系统的实现，按照上面的思路，首先设计一个命令对象的接口，所有命令对象只有一个方法，那就是执行操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">// 执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">// 撤销命令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，开和关是两种命令，因此要定义为两类命令对象，命令对象需要包含命令的执行对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light* light;</span><br><span class="line">    <span class="built_in">LightOnCommand</span>(Light* lt) : <span class="built_in">light</span>(lt) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销开灯即为关灯</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 关灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOffCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light* light;</span><br><span class="line">    <span class="built_in">LightOffCommand</span>(Light* lt) : <span class="built_in">light</span>(lt) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销关灯即为开灯</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后是遥控器，遥控器需要包含命令对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Command* OnCommand;<span class="comment">// 开按钮对应的命令对象</span></span><br><span class="line">    Command* OffCommand;<span class="comment">// 关按钮对应的命令对象</span></span><br><span class="line">    Command* undoCommand;<span class="comment">// 记录上一次按的按钮对应的命令，用于撤销按钮</span></span><br><span class="line">    <span class="comment">// 初始为按钮绑定一个默认命令对象，该命令不做任何操作，这样可以避免对象是否为空的判断</span></span><br><span class="line">    <span class="built_in">RemoteControl</span>() &#123;</span><br><span class="line">        OnCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">        OffCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">        undoCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为按钮绑定对应的命令对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommand</span><span class="params">(Command* on, Command* off)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> OnCommand;</span><br><span class="line">        OnCommand = on;</span><br><span class="line">        <span class="keyword">delete</span> OffCommand;</span><br><span class="line">        OffCommand = off;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressOnButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OnCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        undoCommand = OnCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressOffButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OffCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        undoCommand = OffCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressUndoButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand-&gt;<span class="built_in">undo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以使用这个遥控器了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RemoteControl* rc = <span class="keyword">new</span> <span class="built_in">RemoteControl</span>();</span><br><span class="line">    Light* lt = <span class="keyword">new</span> <span class="built_in">light</span>();</span><br><span class="line">    Command* OnCommand = <span class="keyword">new</span> <span class="built_in">LightOnCommand</span>(lt);</span><br><span class="line">    Command* OffCommand = <span class="keyword">new</span> <span class="built_in">LightOffCommand</span>(lt);</span><br><span class="line">    </span><br><span class="line">    rc.<span class="built_in">setCommand</span>(OnCommand, OffCommand);</span><br><span class="line">    rc.<span class="built_in">PressOnButton</span>();</span><br><span class="line">    rc.<span class="built_in">PressOffButton</span>();</span><br><span class="line">    rc.<span class="built_in">PressUndoButton</span>();</span><br><span class="line">    <span class="comment">// delete ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来遥控器不需要知道命令的执行者是谁，只要为按钮绑定好对应的命令对象，然后发出命令，命令对象就会让对应的命令执行者执行对应的动作。同时，遥控器、命令和电器这三者之间是组合的关系，组合意味着可以随意替换，也就是说遥控器可以更换不同的命令对象，而命令对象同样可以更换不同的电器，只要这个电器符合该命令的接口就可以，比如客厅的电灯和卧室的电灯就可以分别绑定到两个不同的 <code>LightXXXCommand</code> 对象上，而无需重新编码。</p><p>命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象。命令模式的类图如下所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20230305134334949.png" alt="image-20230305134334949"></p><p>当然，具体命令对象的实现非常灵活，命令要实现什么功能完全取决于 <code>execute()</code> 方法的实现，比如要打开电视，同时将电视的音量设定为 10，那么命令对象可以设计成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TVOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TV* tv;</span><br><span class="line">    <span class="built_in">TVOnCommand</span>(TV* t) : <span class="built_in">tv</span>(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv-&gt;<span class="built_in">on</span>();</span><br><span class="line">        tv-&gt;<span class="built_in">setVolume</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，命令对象还可以实现复合命令，来执行一系列命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MacroCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;Command*&gt; commands;</span><br><span class="line">    <span class="built_in">MacroCommand</span>(<span class="type">const</span> vector&lt;Command*&gt;&amp; cs) : <span class="built_in">commands</span>(cs) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">undo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命令模式应用非常广泛，比如可以实现命令队列，让多个线程从队列中获取命令对象并执行，这样一来线程无需知道命令执行的具体对象是谁，只要调用命令对象的执行方法即可；再比如软件中的执行日志，可以将软件运行时执行过的命令对象序列化到磁盘上，在软件异常中断恢复数据时，只需要按顺序再从磁盘读取该对象并执行命令就可以恢复到中断前的状态了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了命令模式及相关的面向对象设计原则。命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象，从而实现请求发出者和请求执行者之间的解耦。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】单例模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-04T09:08:43.000Z</published>
    <updated>2023-03-04T09:15:34.836Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了单例模式及相关的面向对象设计原则。单例模式保证一个类仅有一个实例，并提供一个该实例的全局访问点。重点在于如何实现线程安全的单例模式。</p><p><em><span id="more"></span></em></p><h3 id="1-经典单例模式"><a href="#1-经典单例模式" class="headerlink" title="1 经典单例模式"></a>1 经典单例模式</h3><p>许多时候，我们程序中的某些对象只需要一个或者只能存在一个，比如线程池、缓存、硬件的驱动等，如果存在多个实例就会造成逻辑错误或程序异常。因此作为类的设计者，就需要保证这个类在程序中只能存在一个实例对象。</p><p>显然，利用全局静态变量似乎就可以做到，但是全局静态变量并不完美。比如我们需要唯一的一个全局静态对象，那么这个全局对象在程序一开始就会被分配内存，如果后续并没有使用到这个全局对象，就造成了资源的浪费。而使用单例模式，可以随时在需要时才创建这个唯一的对象，并保证不会出现第二个对象。</p><p>经典的单例模式实现非常简单，在类中设定一个该类的静态对象成员，将构造函数设置为 private，然后提供一个静态的 <code>getInstance()</code>方法来获取全局唯一的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="comment">// 防止外部构造、析构、拷贝和移动</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="2-线程安全的单例模式"><a href="#2-线程安全的单例模式" class="headerlink" title="2 线程安全的单例模式"></a>2 线程安全的单例模式</h3><p>上面的经典实现在多线程的情况下会出现问题，有可能创建出两个实例对象，例如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230304162841491.png" alt="image-20230304162841491"></p><p>因此上述实现不是线程安全的。要实现线程安全的单例模式有多种方法。</p><h4 id="2-1-DCLP"><a href="#2-1-DCLP" class="headerlink" title="2.1 DCLP"></a>2.1 DCLP</h4><p>一种经典的方法是 Double-Checked Locking Pattern (DCLP)，在构造对象时使用互斥锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DCLP</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure><p>但 DCLP 也不是绝对安全的，问题出在<code>uniqueInstance = new Singleton()</code>这一句上，我们知道 C++ 中 <code>new</code> 一个对象实际上进行了三次操作：</p><ul><li>首先调用 <code>operator new</code> 申请一块内存</li><li>然后调用构造函数在该内存上构造对象</li><li>最后将该内存地址赋值给指针</li></ul><p>但由于编译器优化的原因，C++ 编译器可能会在构造函数不抛出异常的前提下调整语句的执行顺序，也就是上面的三步可能变成：</p><ul><li>首先调用 <code>operator new</code> 申请一块内存</li><li>然后将该内存地址赋值给指针</li><li>最后调用构造函数在该内存上构造对象</li></ul><p>在单线程的情况下，这样的顺序变化不会影响程序的结果，但在多线程情况下就不一定了，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230304164102931.png" alt="image-20230304164102931"></p><p>这种情况下，线程 A 恰好完成内存申请，并且将内存地址赋给指针，但是还没有调用构造函数，此时线程 B 执行到指针判断，判断指针不为空，于是返回该对象指针，然后调用该对象的函数，但是这时该对象还没有进行构造，就产生了错误。</p><p>DCLP 产生该问题的关键在于 <code>new</code> 的操作不是原子的，虽然使用互斥锁对指针的写操作<code>uniqueInstance = new Singleton()</code>加了锁，但没有对之前的读操作<code>if(uniqueInstance == nullptr) </code>加锁，从而产生了线程不安全问题。</p><p>因此一种解决方案是利用原子变量<code>std::atomic</code>将对象指针变为原子类型，并使用<code>std::memory_order_acquire</code>和<code>std::memory_order_release</code>强制对该指针的内存操作顺序不变，从而避免线程不安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;Singleton*&gt; uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证内存命令的顺序不会被重排</span></span><br><span class="line">        Singleton* ins = uniqueInstance.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            ins = uniqueInstance.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            <span class="keyword">if</span>(ins == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ins = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">                uniqueInstance.<span class="built_in">store</span>(ins, std::memory_order_release);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> std::atomic&lt;Singleton*&gt; Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure><h4 id="2-2-call-once"><a href="#2-2-call-once" class="headerlink" title="2.2 call_once"></a>2.2 call_once</h4><p>除了 DCLP 之外，还有一种更简单的实现线程安全的单例模式的方法，利用 C++ 的 <code>std::call_once()</code> 来实现，<code>std::call_once()</code> 可以保证函数只被线程安全的调用一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::once_flag m_flag;<span class="comment">// 函数调用标识</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(m_flag, createInstance);</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::once_flag Singleton::m_flag;</span><br></pre></td></tr></table></figure><h4 id="2-3-Meyers-单例模型"><a href="#2-3-Meyers-单例模型" class="headerlink" title="2.3 Meyers 单例模型"></a>2.3 Meyers 单例模型</h4><p>最后还有一种最为简单的实现，利用 C++ 的局部静态变量机制，C++ 的局部静态变量在第一次被调用时进行初始化，且保证只初始化一次，因此可以直接在 <code>getInstance()</code> 方法中初始化一个局部静态对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了单例模式及相关的面向对象设计原则。单例模式保证一个类仅有一个实例，并提供一个该实例的全局访问点。重点在于如何实现线程安全的单例模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】工厂模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-04T07:35:34.000Z</published>
    <updated>2023-03-05T06:08:10.623Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了工厂模式及相关的面向对象设计原则。工厂模式分为工厂方法（Factory Method）和抽象工厂（Abstract Factory）两类：</p><ul><li>工厂方法定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法使得一个类的实例化延迟到子类。</li><li>抽象工厂提供了一个接口，让该接口负责创建一系列相关或者相互依赖的对象，而无需在主程序中指定它们具体的类型。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>假设有一个披萨店，整个披萨店的工作流程可以表示为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza* pizza = <span class="keyword">new</span> <span class="built_in">Pizza</span>();</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要更多类型的披萨的时候，就需要加上一些判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">    Pizza* pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们之后想要去掉或加上某些类型的披萨时，就需要不断地删改上面的代码，因为我们违背了前面提到过的一些设计原则：应该把代码中需要变化的部分封装起来。</p><p>于是我们将创建披萨对象的代码提取出来，放到一个单独的对象中，这个对象称之为“工厂”，因为它只负责生成披萨对象，而<code>orderPizza()</code>方法就不需要再关注披萨对象的具体类型了，它只知道会从工厂拿到一个披萨，然后对披萨进行处理即可。于是工厂类的定义可能像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后<code>orderPizza()</code>方法就变得非常简洁，并且与具体的披萨类型解耦开来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">    PizzaFactory* factory = <span class="keyword">new</span> <span class="built_in">PizzaFactory</span>();</span><br><span class="line">    Pizza* pizza;</span><br><span class="line">    pizza = factory-&gt;<span class="built_in">createPizza</span>(type);</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种常见的代码优化思路，但还称不上是设计模式，因为这更像是一种好的编程习惯，这种方法被称为简单工厂。</p><p>当我们要在不同地区开连锁店时，虽然我们希望所有店都使用相同的流程，但是不同地区的披萨风味可能有所不同，因此不同店的披萨类型也有所不同，此时如果使用简单工厂，我们需要为不同地区编写各自的工厂类，然后在<code>orderPizza()</code>方法中判断当前所处哪一个地区，再实例化对应的工厂，生产对应的披萨。这样一来又回到了一开始的问题，因此简单工厂并不足够灵活。</p><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><p>解决上述问题的方法是我们可以设计一个披萨店的抽象类<code>PizzaStore</code>，那么<code>orderPizza()</code>自然是该类中的一个方法，同时该类“抽象”的地方在于拥有一个创建披萨的纯虚函数<code>createPizza(string&amp; type)</code>，所有不同地区的连锁店都是对该抽象类的一个具体实现，都拥有自己的创建披萨方法，也就是说，这个纯虚函数是一个<strong>工厂方法</strong>，负责生成不同类型的披萨对象，而所有类的<code>orderPizza()</code>方法都无需关注披萨对象的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        pizza = <span class="built_in">createPizza</span>(type);</span><br><span class="line">    </span><br><span class="line">        pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纽约的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 创建其它类型的披萨</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的好处在于，使用了工厂方法负责对象的创建，并且把具体的创建行为封装在子类中，只要顾客决定了到哪家分店吃披萨，就决定了将会创建哪些披萨对象，也就是把具体对象的创建延迟到了子类中去决定，而客户代码中统一调用披萨店的<code>orderPizza()</code>方法即可，这样一来无论是新开分店，还是某个分店改变了披萨类型，都不会对客户代码产生任何影响，这就是解耦。另一个潜在的好处是继承关系使得每一家分店还可以自己定义披萨的制作流程，而无需局限在基类<code>orderPizza()</code>方法所定义的流程框架中。</p><p>上面的披萨店是披萨的“创建者”，那么自然还需要有被创建的“产品”披萨，披萨类的设计很简单：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304141104864.png" alt="image-20230304141104864"></p><p>于是工厂方法模式的类图一目了然：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304141227114.png" alt="image-20230304141227114"></p><p>工厂方法模式定义了一个创建对象的接口，但由子类来实现该接口，从而决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类。需要注意的是，这里所说的“让子类决定”并不是指子类能够在运行时做决定，而是指在实际编写创建者类时，不需要知道实际创建的产品是哪一个，选择使用了哪个子类，就决定了创建的产品是哪些。另外，工厂方法模式中，基类不必须是抽象的，我们可以定义一些默认的对象创建行为，这样即使没有具体的子类，基类本身也可以创建对象。</p><p>回到一开始，如果不使用工厂方法，而是使用一种最直观的方式来实现，可能的代码会是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; area, string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        pizza = <span class="built_in">createPizza</span>(area, type);</span><br><span class="line">    </span><br><span class="line">        pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Pizza* <span class="title">createPizza</span><span class="params">(string&amp; area, string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(area == <span class="string">&quot;NewYork&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYCheesePizza</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYGreekPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYPepperoinPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(area == <span class="string">&quot;Chicago&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CCheesePizza</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CGreekPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CPepperoinPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样实现的披萨店的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304143043787.png" alt="image-20230304143043787"></p><p>显然披萨店这一个类，依赖于所有的具体披萨类，当任何一个披萨的具体实现改变了，都会影响到披萨店。这是因为这样的设计使得“高层”的组件披萨店依赖了“低层”的组件披萨，违背了<strong>依赖倒置原则</strong>。</p><blockquote><p><strong>设计原则：依赖倒置原则</strong></p><p>不能让高层组依赖低层组件，也就是要让类依赖于抽象，而不是依赖于具体的其他类。</p></blockquote><p>相比之下，上面的工厂方法模式所实现的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304143134405.png" alt="image-20230304143134405"></p><p>所有披萨店只依赖于披萨基类这一个类，而披萨基类正是一个抽象类，而所有的具体披萨类也只依赖于披萨基类这一个类，因此满足了依赖倒置原则。</p><p>工厂方法模式可以解决单个对象的需求变化，但是要求创建对象的工厂方法必须参数一致。但有些情况下，我们面对的可能是更复杂的情况，当一系列互相依赖或互相作用的多个对象发生变化时，工厂方法就不能很好地解决问题了。</p><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3 抽象工厂"></a>3 抽象工厂</h3><p>继续以披萨店为例，不同地区可能会制作同一类型的披萨，但是不同地区对同样的披萨使用的原料都不同，不过制作披萨所需要的原料都是同一组，比如都需要一种面团、一种酱料和一种芝士，只是不同地区对这些原料组件都有不同的实现方式。具体来说，在任何地方制作披萨都需要使用一个原料家族，不同地方的家族中，都包含同样的成员，但这些成员的具体实现不同，比如纽约使用一种芝士，而芝加哥使用另一种芝士。</p><p>于是我们需要创建一些原料工厂来负责生产不同的原料家族，但它们都需要继承自同一个抽象基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原料工厂抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IngredientFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纽约的原料工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkIngredientFactory</span> : <span class="keyword">public</span> IngredientFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYSauce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的原料工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoIngredientFactory</span> : <span class="keyword">public</span> IngredientFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CSauce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以在披萨类中加入这些原料：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dough* dough;</span><br><span class="line">    Sauce* sauce;</span><br><span class="line">    Cheese* cheese;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而所有的具体披萨类型都要和原料工厂绑定，从而使用该工厂的原料制作披萨：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CheesePizza</span> : <span class="keyword">public</span> Pizza &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IngredientFactory* ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CheesePizza</span>(IngredientFactory* <span class="keyword">if</span>) : <span class="built_in">ingredientFactory</span>(<span class="keyword">if</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dough = ingredientFactory-&gt;<span class="built_in">createDough</span>();</span><br><span class="line">        sauce = ingredientFactory-&gt;<span class="built_in">createSauce</span>();</span><br><span class="line">        cheese = ingredientFactory-&gt;<span class="built_in">createCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在披萨店中制作披萨的时候就需要选择一个原料工厂来创建披萨：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纽约的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 使用纽约原料工厂的原料</span></span><br><span class="line">        IngredientFactory* ingredientFactory = <span class="keyword">new</span> <span class="built_in">NewYorkIngredientFactory</span>();</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>(ingredientFactory);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>(ingredientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>(ingredientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 使用芝加哥原料工厂的原料</span></span><br><span class="line">        IngredientFactory* ingredientFactory = <span class="keyword">new</span> <span class="built_in">ChicagoIngredientFactory</span>();</span><br><span class="line">        <span class="comment">// 创建其它类型的披萨</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的整个过程我们创建了一个抽象的原料工厂，用来创造原料家族，而原料家族就是由一系列相互关联、相互依赖的对象构成的，这些对象都有可能发生变化，但通过抽象工厂，我们把这种变化约束在了具体的工厂当中，而不会影响代码的其他部分。此外，还可以通过替换不同的工厂使得同一类对象产生不同的行为，比如我们可以将披萨类中的原料工厂替换成其他的原料工厂，从而实现通过组合来创建不同的披萨对象的功能。</p><p>抽象工厂模式定义了一个接口，用于创建一系列相关或依赖的对象，而不需要明确指定他们的具体类型。抽象工厂允许客户代码使用一个抽象的接口来创建一系列产品，而不需要关注产生的具体产品是什么，这样一来客户和产品就被解耦开来。抽象工厂的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304151212414.png" alt="image-20230304151212414"></p><p>在上面的例子中，各种原料就是一系列相关的产品，原料工厂是负责生成这一系列产品的抽象工厂，而披萨店则是原料工厂的客户。在披萨店的代码中我们不需要关注原料具体是哪些，只负责制作披萨就可以了。</p><h3 id="4-总结与对比"><a href="#4-总结与对比" class="headerlink" title="4 总结与对比"></a>4 总结与对比</h3><p>两种工厂模式的异同总结如下：</p><ul><li>工厂方法用于应对“单个对象”的需求变化，而抽象工厂用于应对“一个系列”的需求变化。</li><li>工厂方法通过继承来实现，把对象创建委托给子类，子类实现工厂方法来创建对象；而抽象工厂通过对象组合来实现，对象的创建被实现在抽象工厂所声明的方法中。</li><li>所有工厂模式都是通过减少客户程序（主程序）和具体类之间的依赖来实现松耦合的。</li><li>所用工厂模式都遵循依赖倒置原则，指导我们要避免依赖具体类，而要尽量依赖抽象。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了工厂模式及相关的面向对象设计原则。工厂模式分为工厂方法（Factory Method）和抽象工厂（Abstract Factory）两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工厂方法定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法使得一个类的实例化延迟到子类。&lt;/li&gt;
&lt;li&gt;抽象工厂提供了一个接口，让该接口负责创建一系列相关或者相互依赖的对象，而无需在主程序中指定它们具体的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】装饰者模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-02T09:18:17.000Z</published>
    <updated>2023-03-02T09:19:42.691Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了装饰者模式及相关的面向对象设计原则。装饰者模式动态的将责任附加到对象身上，扩展功能时，装饰者模式相比于继承能为系统带来更好的弹性。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>一个咖啡饮料系统需要为所有类型的饮料定义各自的类，最原始的设计是这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302164118582.png" alt="image-20230302164118582"></p><p>在购买饮料时，顾客可以在某种饮料的基础上加入各种调料，比如奶泡、摩卡等，不同调料的价格也不同，组合而成的饮料价格也就不同，不同的调料搭配不同的饮料可能会出现无数种组合，如果一味的使用继承，将会使饮料子类的数量急剧膨胀，难以管理的同时还会出现大量的重复代码。因此我们希望能有一种设计模式来解决这种问题。</p><h3 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2 装饰者模式"></a>2 装饰者模式</h3><blockquote><p><strong>设计原则：开放-关闭原则，对扩展开放，对修改关闭。</strong></p></blockquote><p>开放-关闭原则是指当一个类设计好之后，尽可能不对他进行修改，但又能允许该类进行扩展，也就是在不修改现有代码的前提下，扩展新的行为。装饰者模式就实现了这一目的。</p><p>以一杯加了奶泡和摩卡的深焙咖啡为例，构建这样一种饮品的流程是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165122699.png" alt="image-20230302165122699"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165135782.png" alt="image-20230302165135782"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165152185.png" alt="image-20230302165152185"></p><p>这就是一个装饰者模式的流程，装饰者模式的类图结构如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165414471.png" alt="image-20230302165414471"></p><p>按着上面的类图，饮料就作为组件，具体的饮料类型对应于具体组件，而调料作为装饰器，具体的调料对应不同的具体装饰器，于是我们可以开始用装饰者模式实现上面的饮料系统。</p><p>首先是组件（饮料）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他内容...</span></span><br><span class="line">    </span><br><span class="line">    string discription = <span class="string">&quot;Unknow Beverage&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">getDiscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discription;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>装饰器（调料）要和组件是同一类，这样才能保证所有装饰器都能代替组件，调用同一个接口，因此需要继承于组件类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所有调料都要有自己的描述，这样才能输出完整的配料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDiscription</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来实现一个具体组件类，比如浓缩咖啡（Espresso）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Espresso</span>() &#123;</span><br><span class="line">        discription = <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个具体装饰器，比如摩卡（Mocha）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mocha</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Component* beverage;<span class="comment">//被装饰者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mocha</span>(Component* b) : <span class="built_in">beverage</span>(b) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDiscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDiscription</span>() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">cost</span>() + <span class="number">0.2</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的方法可以构建不同的饮料和调料，之后就可以随意组合了，在调用的时候也会变得无比方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Component* beverage = <span class="keyword">new</span> <span class="built_in">Espresso</span>();<span class="comment">// 一杯浓缩咖啡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Mocha</span>(beverage);<span class="comment">// 加入一份摩卡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Whip</span>(beverage);<span class="comment">// 加入一份奶泡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Sugar</span>(beverage);<span class="comment">// 加入一份糖</span></span><br><span class="line">    cout &lt;&lt; beverage.<span class="built_in">getDiscription</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; beverage.<span class="built_in">cost</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，装饰者类是一个组件类，也就是和被装饰者是 is-a 的关系，但同时装饰者类中又包含组件类，对组件类进行扩展，因此二者之间还存在 has-a 的关系。装饰者模式利用组合解决了继承带来的子类膨胀和灵活性差的问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了装饰者模式及相关的面向对象设计原则。装饰者模式动态的将责任附加到对象身上，扩展功能时，装饰者模式相比于继承能为系统带来更好的弹性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】观察者模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-02T07:53:14.000Z</published>
    <updated>2023-03-02T07:54:50.456Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了观察者模式及相关的面向对象设计原则。观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>有一个气象站系统需要构建，系统中包含三部分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302131902396.png" alt="image-20230302131902396"></p><p>其中气象站负责感应气象数据，WeatherData 对象从气象站获取数据并更新气象显示装置，气象显示装置有不同的显示界面，比如目前状况、气象统计、天气预报等等，未来还可能加入新的显示界面。</p><p>一种实现方式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span>&#123;</span><br><span class="line">    <span class="comment">//其他内容...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">float</span> temp = <span class="built_in">getTemperature</span>();</span><br><span class="line">        <span class="type">float</span> humidity = <span class="built_in">getHumidity</span>();</span><br><span class="line">        <span class="type">float</span> pressure = <span class="built_in">getPressure</span>();</span><br><span class="line">        <span class="comment">// 调用各显示面板的更新函数，以更新各显示界面</span></span><br><span class="line">        currentConditionsDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">        statisticsDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">        forecastDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然这样的实现方式违背了上一节提到的诸多设计原则，比如没有把不变和变化的代码分开，如果后续需要加入新的显示面板，就要更改 WeatherData 的代码，再比如调用面板的<code>update()</code>方法没有面向接口编程，而是一个一个的调用了具体面板的接口。因此这样的设计会为后续的系统维护带来巨大的成本。</p><h3 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2 观察者模式"></a>2 观察者模式</h3><p>观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302134222869.png" alt="image-20230302134222869"></p><p>观察者模式通常通过构建 Subject 接口 Observer 接口来实现：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302134606606.png" alt="image-20230302134606606"></p><p>观察者模式提供了一种对象设计，让主题对象和观察者对象之间<strong>松耦合</strong>。所谓松耦合是指两个对象之间依然可以交互，但彼此不清楚对方的细节。松耦合的好处在于，主题对象只知道观察者实现了 Observer 接口，而无需关注观察者具体是谁，做了什么或者任何其他细节。在代码运行的任何时候都可以增加或者删除观察者，主题不会受到任何影响，它只在状态改变时，遍历观察者列表并通知他们。当我们改变主题或者观察者任意一方时，另一方都不会受到任何影响，只要它们之间的接口依然被遵守。因此使用松耦合设计系统会更有的弹性，更容易应对变化，因为对象之间的互相依赖降到了最低。</p><blockquote><p><strong>设计原则：为了交互对象之间的松耦合而努力。</strong></p></blockquote><p>回顾上面的气象站项目，显然 WeatherData 对象就是主题，主题在实现的时候通常也被称为 Observable（可观察对象），也就是被观察者，而不同的显示面板就是观察者。</p><p>于是我们首先需要实现两个接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现 WeatherData 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> : <span class="keyword">public</span> Observable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    <span class="type">float</span> humidity;</span><br><span class="line">    <span class="type">float</span> pressure;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">remove</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::list&lt;Observer*&gt;::iterator it = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (it != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            (*it)-&gt;<span class="built_in">update</span>(temperature, humidity, pressure);</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>某个观察者显示面板的实现更为简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    <span class="type">float</span> humidity;</span><br><span class="line">    Observable* weatherData;<span class="comment">//绑定一个被观察者，用于注册或者取消观察</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CurrentConditionsDisplay</span>(Observable* o) : <span class="built_in">weatherData</span>(o) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 显示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个简单的观察者模式就是实现完毕了，这是经典的观察者模式实现，但存在一些缺陷：</p><ul><li>需要继承，继承是强对象关系，只能对特定的观察者才有效，即必须是Observer抽象类的派生类才行</li><li>观察者被通知的接口参数不支持变化，导致观察者不能应付接口的变化，并且这个观察者还不能带参数</li></ul><h3 id="3-改进的观察者模式"><a href="#3-改进的观察者模式" class="headerlink" title="3 改进的观察者模式"></a>3 改进的观察者模式</h3><p>C++11 提供的仿函数和模板等特性可以解决上述问题。C++11 实现的观察者模式，内部维护了一个泛型函数列表，观察者只需要将观察者函数注册进来即可，消除了继承导致的强耦合。通知接口还使用了可变参数模板，支持任意数量的参数，消除了接口变化的影响。</p><p>改进之后的观察者模式和 C# 中的 event 类似，通过定义观察者的模板类型来限定观察者，即不要求观察者必须为某个派生类，只要求所有观察者使用相同的函数模板即可，当需要和原来不同的观察者时，只需要定义一个新的 event 类型即可。</p><p>需要注意的是 event 对象不能拷贝和复制，这可以通过 delete 关键字来实现。</p><p>一个改进的观察者模式实现如下：</p><p><strong>observer.hpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _OBSERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OBSERVER_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//禁用复制构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp; n) = <span class="keyword">delete</span>; <span class="comment">// deleted</span></span><br><span class="line">    <span class="comment">//禁用赋值构造函数</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp; n) = <span class="keyword">delete</span>; <span class="comment">// deleted</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>; <span class="comment">// available</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Events</span> : <span class="keyword">public</span> NonCopyable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_observerId = <span class="number">0</span>; <span class="comment">//观察者对应编号</span></span><br><span class="line">    map&lt;<span class="type">int</span>, Func&gt; m_connections; <span class="comment">// 观察者列表</span></span><br><span class="line">    <span class="comment">// 保存观察者并分配观察者编号</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Assign</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = m_observerId++;</span><br><span class="line">        m_connections.<span class="built_in">emplace</span>(k, std::forward&lt;F&gt;(f));</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册观察者，支持右值引用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(Func&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Assign</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者，左值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> Func&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Assign</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Disconnect</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        m_connections.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : m_connections) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; func = it.second;</span><br><span class="line">            <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;observer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> ObserverFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Observer函数对象的事件2被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> res = a + b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">observerFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Observer2成员函数事件3被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> res = a + b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gobserverFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局的gobserverFunc事件4被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res = a + b;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Events&lt;ObserverFunc&gt; e;</span><br><span class="line">    <span class="comment">// 调用基于lambda表达式的观察者函数</span></span><br><span class="line">    <span class="type">int</span> lambdaID = e.<span class="built_in">Connect</span>([](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="type">int</span> res = a+b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lambda函数的事件1被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用仿函数的观察者函数</span></span><br><span class="line">    <span class="type">int</span> obsID = e.<span class="built_in">Connect</span>(<span class="built_in">Observer</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用成员函数的观察者函数</span></span><br><span class="line">    Observer2 o2;</span><br><span class="line">    <span class="type">int</span> obsID1 = e.<span class="built_in">Connect</span>(std::<span class="built_in">bind</span>(&amp;Observer2::observerFunc, o2, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用全局观察者函数</span></span><br><span class="line">    <span class="type">int</span> gID4 = e.<span class="built_in">Connect</span>(gobserverFunc);</span><br><span class="line"> </span><br><span class="line">    e.<span class="built_in">Notify</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了观察者模式及相关的面向对象设计原则。观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】策略模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-02-28T07:46:59.000Z</published>
    <updated>2023-02-28T07:49:42.551Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了策略模式及相关的面向对象设计原则。策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>鸭子模拟游戏中会出现各种鸭子，一边游泳，一边呱呱叫，此系统内部使用了标准的面向对象技术，设计了一个鸭子父类，并让各种鸭子继承此父类。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141328616.png" alt="image-20230228141328616"></p><p>此时如果希望鸭子能飞起来，最简单的方法就是在父类中加上一个<code>fly()</code>方法：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141532173.png" alt="image-20230228141532173"></p><p>但并不是所有鸭子都会飞，于是想到可以在子类中重写<code>fly()</code>方法，让其什么也不做，从而覆盖掉父类的<code>fly()</code>方法。同样，也是不所有鸭子都会嘎嘎叫，比如橡皮鸭子是吱吱叫，同样可以通过重写<code>quack()</code>方法覆盖掉父类的方法来实现。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141813782.png" alt="image-20230228141813782"></p><p>之后，如果我们想新加入一个木头假鸭类型，它既不会飞也不会叫，那么用同样的方式覆盖父类对应的方法就可以实现。但是当我们需要不断地新增不同类型的鸭子，或者不断地修改不同类型鸭子的行为时，就需要不停的新建子类，重写并覆盖原来的方法，显然这样的实现方式使得我们虽然利用了面向对象的“继承”这一特性，但却并没有实现代码的复用。</p><p>转变思路，我们可以将<code>fly()</code>方法从鸭子类中分离出来，放进一个<code>Flyable</code>的接口（抽象类）中，只有会飞的鸭子才继承此抽象类，并实现其中的<code>fly()</code>方法，<code>quack()</code>方法同样分离出来放在<code>Quackable</code>的抽象类中，只有会叫的鸭子才继承此抽象类并实现其中的<code>quack()</code>方法。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228142529567.png" alt="image-20230228142529567"></p><p>这样的设计看似更加巧妙，但重复的代码会变得更多，且代码依然无法复用，我们要为每一个会叫的鸭子写一套<code>quack()</code>代码，即使他们叫的方式是相同的。</p><p>对于上面这个例子，似乎继承和接口都不能很好的解决问题，而恰好有一个设计模式，可以适用于这种情况。</p><h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2 策略模式"></a>2 策略模式</h3><blockquote><p><strong>设计原则：将变化的部分单独封装起来</strong></p><p>找出程序中可能需要变化的地方，把他们独立出来并进行封装，使他们和那些不会变化的代码分开，以便之后可以轻易的修改或扩充这一部分代码，而不影响那些不需要变化的部分。</p></blockquote><p>对于上面的例子，显然<code>fly()</code>和<code>quack()</code>就是代码中需要变化的部分，因为他们会随着不同的鸭子类型或者不同的用户需求随时发生变化，所以我们可以将他们从鸭子类中独立出来，分别建立两个抽象类<code>FlyBehavior</code>和<code>QuackBehavior</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个抽象类代表飞和叫这两种行为，至于怎么飞，怎么叫，通过具体的行为类继承于这两个抽象类来实现，比如飞的行为可以分为用翅膀飞和不会飞这两种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWithWings</span> : <span class="keyword">public</span> FlyBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;用翅膀飞&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyNoWay</span> : <span class="keyword">public</span> FlyBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不会飞&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>叫的行为也类似，比如可以实现嘎嘎叫和不会叫：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quack</span> : <span class="keyword">public</span> QuackBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;嘎嘎叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MuteQuack</span> : <span class="keyword">public</span> QuackBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不会叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后我们在鸭子类中加入这两种行为类的对象，然后将原本的<code>fly()</code>和<code>quack()</code>方法改为<code>PerformFly()</code>和<code>PerformQuack()</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FlyBehavior* flyBehavior;</span><br><span class="line">    QuackBehavior* quackBehavior;</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior-&gt;<span class="built_in">fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quackBehavior-&gt;<span class="built_in">quack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要构造一个鸭子子类的时候，只需要继承鸭子父类，并在构造函数中指定该子类的具体行为对象，就可以控制鸭子子类的行为了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MallardDuck</span> : <span class="keyword">public</span> Duck&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MallardDuck</span>()&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> <span class="built_in">FlyWithWings</span>();<span class="comment">// 绿头鸭会用翅膀飞</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> <span class="built_in">Quack</span>();<span class="comment">// 绿头鸭会嘎嘎叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用上面的设计方法可以让我们在编程时不需要关注鸭子是什么具体类型，因为我们可以利用多态，比如有一个<code>getDuck()</code>函数会返回一个具体类型的鸭子，至于是什么类型，可能在程序运行时才能确定，那么我们的主函数就可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Duck* duck = <span class="built_in">getDuck</span>();</span><br><span class="line">    duck-&gt;<span class="built_in">PerformFly</span>();</span><br><span class="line">    duck-&gt;<span class="built_in">PerformQuack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的设计依然不够有弹性，因为每一个子类的鸭子具有什么行为是在构造函数中指定的，如果我们希望同一类鸭子也能自由的设定不同的行为，那么只需要在鸭子父类中加上一个设定行为的方法就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FlyBehavior* flyBehavior;</span><br><span class="line">    QuackBehavior* quackBehavior;</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior-&gt;<span class="built_in">fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quackBehavior-&gt;<span class="built_in">quack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态设定行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFlyBehavior</span><span class="params">(FlyBehavior* fb)</span></span>&#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetQuackBehavior</span><span class="params">(QuackBehavior* qb)</span></span>&#123;</span><br><span class="line">        quackBehavior = qb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们通过调用鸭子的<code>SetFlyBehavior()</code>和<code>SetQuackBehavior()</code>方法就可以随时改变鸭子的行为了。</p><p>纵观上面的设计过程，我们把鸭子类中经常变化的部分独立出来，封装成了单独的抽象类，也就是一个接口，然后用不同的代码去实现这个接口（抽象类的子类），这些不同的代码就是“一族算法”，而在鸭子类中，只要包含这一族算法的统一接口就可以灵活地使用他们当中的任何一个。</p><blockquote><p><strong>设计原则：面向接口编程，而不是面向实现编程。</strong></p></blockquote><p>能够实现这样灵活的效果的原因在于，所有鸭子的行为并不是从父类继承而来的，而是与不同的行为对象组合而来的，因此恰当的使用类的组合有时要比一味的使用类的继承灵活的多。而进行组合的类也不一定是行为，也可以是物品、属性等等，比如游戏中不同的角色有不同的武器，那么一个角色就可以由角色类和武器类组合而来。</p><blockquote><p><strong>设计原则：多用组合，少用继承。</strong></p></blockquote><p>利用组合构建系统具有很大的弹性，不仅可以将一族算法封装成类，还可以在运行时动态的改变类对象的行为或属性，只要组合的类符合接口标准即可。因此在面向对象程序设计中，简单的使用继承和多态不一定能降低代码量和代码维护成本，灵活使用类的组合也可以达到代码复用的目的。</p><p>上面的设计还有一个好处就是，每一族算法或者其中的每一个算法都可以有自己的成员，比如算法要用到的参数，状态和其他辅助函数等等，只要最终实现了接口就可以，这可以让算法的设计更加灵活。</p><p><strong>上面的设计模式就是策略模式，策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了策略模式及相关的面向对象设计原则。策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】遮挡剔除总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-07T01:51:11.000Z</published>
    <updated>2022-08-07T02:31:33.777Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对常见的遮挡剔除技术进行总结概括，主要包括：</p><ul><li>Precomputed Visibility</li><li>Portal-Culling</li><li>Software Occlusion</li><li>Occlusion Query</li><li>Hierarchical Z-Buffer</li></ul><p><em><span id="more"></span></em></p><h3 id="1-Precomputed-Visibility"><a href="#1-Precomputed-Visibility" class="headerlink" title="1 Precomputed Visibility"></a>1 Precomputed Visibility</h3><p>预计算可见性是比较简单的遮挡剔除方案，UE 中内置了这一方法。官方文档：<a href="https://docs.unrealengine.com/4.26/zh-CN/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/">预计算可视性体积 | 虚幻引擎文档 (unrealengine.com)</a></p><p>其基本思路是就是先将场景划分成一个个 Cell，让后对于每个 Cell 区域，预计算出摄影机在这个 Cell 范围内时，所有可能看到的物体，并将可见信息保存下来。这样在运行时就可以直接查表来得到所有静态物体的可见信息，运行时开销几乎为 0。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/PVis_VisualizationEnabled.png" alt="PVis_VisualizationEnabled"></p><p>当然这种方式的缺点也很明显，完全无法剔除动态物体，并且静态物体可见性全部都是不可变的。并且对于比较自由的大型场景，计算量和存储量都非常大，因此只适用于线性流程关卡等相机移动范围有限的场景中。</p><p>如果我们想要实现对动态物体的剔除，可以对该算法进行改进：在每个 Cell 中，同时保存其他 Cell 的可见性。对于小型的动态物体，我们先计算出动态物体所在的 Cell 坐标，然后根据 Cell 之间的可见性信息，判断可见性。这样做会额外消耗内存，如果动态的小型物体较多时，可以考虑配合使用。</p><h3 id="2-Portal-Culling"><a href="#2-Portal-Culling" class="headerlink" title="2 Portal-Culling"></a>2 Portal-Culling</h3><p>这种方式也是将场景划分成 Cell，不同的是，烘焙时保存的是每两个相邻 Cell 之间的连通性。这样，在运行时，根据摄影机所在的位置的 Cell 和观察方向，就可以根据 Cell 间的连通性信息，快速计算出目标物体是否处于可见范围内。</p><p>相对上面完全的预计算，这种方式的优点就是可以剔除动态物体，同时提供了些许的静态遮挡物体变化的灵活性。比如有扇可以开关的门，当门被打开后，就可以将门两侧的 Cell 的连通打开。Unity 自带的遮挡剔除使用这种方案。</p><h3 id="3-Software-Occlusion"><a href="#3-Software-Occlusion" class="headerlink" title="3 Software Occlusion"></a>3 Software Occlusion</h3><p>软光栅遮挡查询是 UE 中面向移动端的一种遮挡查询方案，官方文档：<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/VisibilityCulling/SoftwareOcclusionQueries/">面向移动平台的软件遮挡查询 | 虚幻引擎文档 (unrealengine.com)</a></p><p>这种方式需要手动标记好大型的用来遮挡的物体，在运行时，将遮挡物的包围盒（或最高 LOD 级别的模型）软光栅到 CPU 内存中的 z-buffer 上，然后根据 z-buffer 中的深度信息，根据需要剔除物体的包围盒，实时计算遮挡信息。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/soq_sceneOccludersHighlighted.png" alt="soq_sceneOccludersHighlighted"></p><p>这种方式缺点是对 CPU 端压力很大，优点是相对前面两种方案，软光栅剔除提供了非常大的灵活性，支持完全可变或任意大小的场景，适用于流式关卡或者大世界中的遮挡剔除。并且相对 GPU 实现的遮挡剔除，这种方案完全不用担心硬件兼容问题。但是由于 CPU 的软光栅计算压力非常大，因此我们需要注意，不能在光栅化时计算太多的物体，不能使用精细的模型计算。</p><h3 id="4-Occlusion-Query"><a href="#4-Occlusion-Query" class="headerlink" title="4 Occlusion Query"></a>4 Occlusion Query</h3><p>硬件遮挡查询利用 GPU 进行遮挡剔除，其思想也非常简单，首先使用一个简单的 depth-only 的 pass 将深度写入到 z-buffer 中，然后使用物体的包围盒传入到 GPU 进行遮挡测试，也就是判断深度，如果测试发现所有像素都被遮挡，说明这个物体是被遮挡的物体，否则的话认为是可见的。</p><p>由于从 GPU 回读数据到 CPU 通常很慢，因此通常会将得到的数据放在下一帧中作为剔除数据来使用，这样遮挡剔除其实是延迟一帧（移动端延迟两帧）生效的。不过一般来说，延迟一帧的剔除对实际的渲染影响并不大。</p><p>几乎所有的图形 API 都提供硬件遮挡查询，UE 默认也采用这种方式进行遮挡剔除。</p><p>当然硬件遮挡查询也存在一定的问题，比如：</p><ul><li>虽然基于 GPU 的判断效率高，但涉及数据传输，在大规模场景下会造成 CPU 一直等待 GPU 查询结果返回造成 GPU 性能饥饿的情况</li><li>虽然基于 GPU 判断效率高，不过在复杂场景下仍有大量渲染目标需要被测试，仍有提升空间</li></ul><p>因此有人提出了改进的 <strong>Coherent Occlusion Culling（CHC）</strong> 算法，其核心思想是：</p><ul><li>利用 BVH（Bounding Volume Hirachical）管理场景，并利用 Spatial Coherence（空间相关性）减少每一帧需要进行遮挡查询的次数。</li><li>重用上一帧的查询结果，利用 Time Coherence（时间相关性）进一步减少查询次数。</li><li>维护一个查询队列，延迟进行查询的时间，并利用渲染部分场景的时间来填充 CPU 等待 GPU 查询结果返回的时间，减少 GPU 的饥饿。</li></ul><p>具体可以查看<a href="https://zhuanlan.zhihu.com/p/35067260">Coherent Occlusion Culling(CHC)算法的原理与实现</a>一文。</p><h3 id="5-Hierarchical-Z-Buffer"><a href="#5-Hierarchical-Z-Buffer" class="headerlink" title="5 Hierarchical Z-Buffer"></a>5 Hierarchical Z-Buffer</h3><p>HZB 是多 Mip 层级的 z-buffer，每个更高级别 Mip 的 buffer 记录上一级别中周围四点中最远处的深度值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/image-20220807102055112.png" alt="image-20220807102055112"></p><p>将 HZB 生成后，就可以将待剔除物体的包围盒信息传入到 Computer Shader 中进行计算，计算时会选择最适合的 Mip 级别进行遮挡测试。在屏幕中占比更大的物体会选择更高级别 Mip 的深度进行测试，因为更大的物体更容易被看到，就可以用更高级别的 Mip 中的深度，而不必取过于精细的深度来判断。</p><p>具体来说，要测试对象是否被遮挡，可以将其包围体投射到屏幕空间，并估计在 z-pyramid 中的 Mip 级别。将对象的包围体投影到屏幕空间。使用最长的边（像素）计算 Mip 等级：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/image-20220807102419175.png" alt="image-20220807102419175"></p><p>然后根据选定的 Mip 测试遮挡。如果结果不明确，可以继续使用更细的 Mip 级别进行测试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对常见的遮挡剔除技术进行总结概括，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Precomputed Visibility&lt;/li&gt;
&lt;li&gt;Portal-Culling&lt;/li&gt;
&lt;li&gt;Software Occlusion&lt;/li&gt;
&lt;li&gt;Occlusion Query&lt;/li&gt;
&lt;li&gt;Hierarchical Z-Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【UE渲染体系】目录索引</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-UE%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB-%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-UE%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB-%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-07T01:22:40.000Z</published>
    <updated>2022-08-07T01:44:15.840Z</updated>
    
    <content type="html"><![CDATA[<p>本篇提供了博客园博主<a href="https://www.cnblogs.com/timlly/">0向往0 - 博客园 (cnblogs.com)</a>的《剖析虚幻渲染体系》系列文章的索引，便于查找学习。</p><p><em><span id="more"></span></em></p><ul><li><a href="https://www.cnblogs.com/timlly/p/13877623.html">剖析虚幻渲染体系（01）- 综述和基础 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14327537.html">剖析虚幻渲染体系（02）- 多线程渲染 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14588598.html">剖析虚幻渲染体系（03）- 渲染机制 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14732412.html">剖析虚幻渲染体系（04）- 延迟渲染管线 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14817455.html">剖析虚幻渲染体系（05）- 光源和阴影 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14927797.html">剖析虚幻渲染体系（06）- UE5特辑Part 1（特性和Nanite） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15007236.html">剖析虚幻渲染体系（06）- UE5特辑Part 2（Lumen和其它） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15092257.html">剖析虚幻渲染体系（08）- Shader体系 </a></li><li><a href="https://www.cnblogs.com/timlly/p/15109132.html">剖析虚幻渲染体系（09）- 材质体系 </a></li><li><a href="https://www.cnblogs.com/timlly/p/15156626.html">剖析虚幻渲染体系（10）- RHI </a></li><li><a href="https://www.cnblogs.com/timlly/p/15217090.html">剖析虚幻渲染体系（11）- RDG </a></li><li><a href="https://www.cnblogs.com/timlly/p/15511402.html">剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15546797.html">剖析虚幻渲染体系（12）- 移动端专题Part 2（GPU架构和机制） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15574911.html">剖析虚幻渲染体系（12）- 移动端专题Part 3（渲染优化） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15680064.html">剖析虚幻渲染体系（13）- RHI补充篇：现代图形API之奥义与指南 </a></li><li><a href="https://www.cnblogs.com/timlly/p/16097134.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 1（萌芽期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16147358.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 2（成长期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16216707.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 3（开花期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16268881.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 4（结果期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16357850.html">剖析虚幻渲染体系（15）- XR专题 </a></li><li><a href="https://www.cnblogs.com/timlly/p/16404963.html">剖析虚幻渲染体系（16）- 图形驱动的秘密 </a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇提供了博客园博主&lt;a href=&quot;https://www.cnblogs.com/timlly/&quot;&gt;0向往0 - 博客园 (cnblogs.com)&lt;/a&gt;的《剖析虚幻渲染体系》系列文章的索引，便于查找学习。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="虚幻引擎渲染体系" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="虚幻引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【Piccolo代码解读】渲染系统（三）帧调试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/</id>
    <published>2022-07-25T02:07:31.000Z</published>
    <updated>2022-07-25T03:10:04.060Z</updated>
    
    <content type="html"><![CDATA[<p>上一节了解了 Piccolo 中两种不同的渲染路径的具体实现，这一节我们使用 RenderDoc 帧调试工具来验证整个渲染流程。</p><p><em><span id="more"></span></em></p><h3 id="1-回顾渲染路径"><a href="#1-回顾渲染路径" class="headerlink" title="1 回顾渲染路径"></a>1 回顾渲染路径</h3><p>Piccolo 引擎默认的渲染路径是延迟渲染，因此我们再次回顾延迟渲染路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipeline::deferredRender</span><span class="params">(std::shared_ptr&lt;RHI&gt; rhi, std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VulkanRHI*      vulkan_rhi      = <span class="built_in">static_cast</span>&lt;VulkanRHI*&gt;(rhi.<span class="built_in">get</span>());</span><br><span class="line">    RenderResource* vulkan_resource = <span class="built_in">static_cast</span>&lt;RenderResource*&gt;(render_resource.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    vulkan_resource-&gt;<span class="built_in">resetRingBufferOffset</span>(vulkan_rhi-&gt;m_current_frame_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">waitForFences</span>();</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">resetCommandPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> recreate_swapchain =</span><br><span class="line">        vulkan_rhi-&gt;<span class="built_in">prepareBeforePass</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (recreate_swapchain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;DirectionalLightShadowPass*&gt;(m_directional_light_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;PointLightShadowPass*&gt;(m_point_light_shadow_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    ColorGradingPass&amp; color_grading_pass = *(<span class="built_in">static_cast</span>&lt;ColorGradingPass*&gt;(m_color_grading_pass.<span class="built_in">get</span>()));</span><br><span class="line">    FXAAPass&amp;         fxaa_pass          = *(<span class="built_in">static_cast</span>&lt;FXAAPass*&gt;(m_fxaa_pass.<span class="built_in">get</span>()));</span><br><span class="line">    ToneMappingPass&amp;  tone_mapping_pass  = *(<span class="built_in">static_cast</span>&lt;ToneMappingPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    UIPass&amp;           ui_pass            = *(<span class="built_in">static_cast</span>&lt;UIPass*&gt;(m_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line">    CombineUIPass&amp;    combine_ui_pass    = *(<span class="built_in">static_cast</span>&lt;CombineUIPass*&gt;(m_combine_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;MainCameraPass*&gt;(m_main_camera_pass.<span class="built_in">get</span>())</span><br><span class="line">        -&gt;<span class="built_in">draw</span>(color_grading_pass,</span><br><span class="line">               fxaa_pass,</span><br><span class="line">               tone_mapping_pass,</span><br><span class="line">               ui_pass,</span><br><span class="line">               combine_ui_pass,</span><br><span class="line">               vulkan_rhi-&gt;m_current_swapchain_image_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">submitRendering</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是平行光的 Shadow Pass，然后是点光源的 Shadow Pass，最后是相机的 Pass，其中相机的 Pass 又包含很多 Subpass，也就是 <code>draw()</code> 函数中的流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainCameraPass::draw</span><span class="params">(ColorGradingPass&amp; color_grading_pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                          FXAAPass&amp;         fxaa_pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ToneMappingPass&amp;  tone_mapping_pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                          UIPass&amp;           ui_pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CombineUIPass&amp;    combine_ui_pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">uint32_t</span>          current_swapchain_image_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        VkRenderPassBeginInfo renderpass_begin_info &#123;&#125;;</span><br><span class="line">        renderpass_begin_info.sType             = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line">        renderpass_begin_info.renderPass        = m_framebuffer.render_pass;</span><br><span class="line">        renderpass_begin_info.framebuffer       = m_swapchain_framebuffers[current_swapchain_image_index];</span><br><span class="line">        renderpass_begin_info.renderArea.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        renderpass_begin_info.renderArea.extent = m_vulkan_rhi-&gt;m_swapchain_extent;</span><br><span class="line"></span><br><span class="line">        VkClearValue clear_values[_main_camera_pass_attachment_count];</span><br><span class="line">        clear_values[_main_camera_pass_gbuffer_a].color                = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_gbuffer_b].color                = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_gbuffer_c].color                = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_backup_buffer_odd].color        = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_backup_buffer_even].color       = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_post_process_buffer_odd].color  = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_post_process_buffer_even].color = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_depth].depthStencil             = &#123;<span class="number">1.0f</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        clear_values[_main_camera_pass_swap_chain_image].color         = &#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        renderpass_begin_info.clearValueCount = (<span class="built_in">sizeof</span>(clear_values) / <span class="built_in">sizeof</span>(clear_values[<span class="number">0</span>]));</span><br><span class="line">        renderpass_begin_info.pClearValues    = clear_values;</span><br><span class="line"></span><br><span class="line">        m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_begin_render_pass</span>(</span><br><span class="line">            m_vulkan_rhi-&gt;m_current_command_buffer, &amp;renderpass_begin_info, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_vulkan_rhi-&gt;<span class="built_in">isDebugLabelEnabled</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        VkDebugUtilsLabelEXT label_info = &#123;</span><br><span class="line">            VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, <span class="literal">NULL</span>, <span class="string">&quot;BasePass&quot;</span>, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;;</span><br><span class="line">        m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_begin_debug_utils_label_ext</span>(m_vulkan_rhi-&gt;m_current_command_buffer, &amp;label_info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drawMeshGbuffer</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drawDeferredLighting</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drawBillboardParticle</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    tone_mapping_pass.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    color_grading_pass.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_enable_fxaa) fxaa_pass.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    VkClearAttachment clear_attachments[<span class="number">1</span>];</span><br><span class="line">    clear_attachments[<span class="number">0</span>].aspectMask                  = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    clear_attachments[<span class="number">0</span>].colorAttachment             = <span class="number">0</span>;</span><br><span class="line">    clear_attachments[<span class="number">0</span>].clearValue.color.float32[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">    clear_attachments[<span class="number">0</span>].clearValue.color.float32[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">    clear_attachments[<span class="number">0</span>].clearValue.color.float32[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line">    clear_attachments[<span class="number">0</span>].clearValue.color.float32[<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">    VkClearRect clear_rects[<span class="number">1</span>];</span><br><span class="line">    clear_rects[<span class="number">0</span>].baseArrayLayer     = <span class="number">0</span>;</span><br><span class="line">    clear_rects[<span class="number">0</span>].layerCount         = <span class="number">1</span>;</span><br><span class="line">    clear_rects[<span class="number">0</span>].rect.offset.x      = <span class="number">0</span>;</span><br><span class="line">    clear_rects[<span class="number">0</span>].rect.offset.y      = <span class="number">0</span>;</span><br><span class="line">    clear_rects[<span class="number">0</span>].rect.extent.width  = m_vulkan_rhi-&gt;m_swapchain_extent.width;</span><br><span class="line">    clear_rects[<span class="number">0</span>].rect.extent.height = m_vulkan_rhi-&gt;m_swapchain_extent.height;</span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_clear_attachments</span>(m_vulkan_rhi-&gt;m_current_command_buffer,</span><br><span class="line">                                             <span class="built_in">sizeof</span>(clear_attachments) / <span class="built_in">sizeof</span>(clear_attachments[<span class="number">0</span>]),</span><br><span class="line">                                             clear_attachments,</span><br><span class="line">                                             <span class="built_in">sizeof</span>(clear_rects) / <span class="built_in">sizeof</span>(clear_rects[<span class="number">0</span>]),</span><br><span class="line">                                             clear_rects);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drawAxis</span>();</span><br><span class="line"></span><br><span class="line">    ui_pass.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_next_subpass</span>(m_vulkan_rhi-&gt;m_current_command_buffer, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"></span><br><span class="line">    combine_ui_pass.<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    m_vulkan_rhi-&gt;<span class="built_in">m_vk_cmd_end_render_pass</span>(m_vulkan_rhi-&gt;m_current_command_buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这些 Subpass 按照顺序依次是：</p><ul><li><code>drawMeshGbuffer()</code></li><li><code>drawDeferredLighting()</code></li><li><code>drawBillboardParticle()</code></li><li><code>tone_mapping_pass.draw()</code></li><li><code>color_grading_pass.draw()</code></li><li><code>if (m_enable_fxaa) fxaa_pass.draw()</code></li><li><code>drawAxis()</code></li><li><code>ui_pass.draw()</code></li><li><code>combine_ui_pass.draw()</code></li></ul><h3 id="2-帧调试"><a href="#2-帧调试" class="headerlink" title="2 帧调试"></a>2 帧调试</h3><p>常用的图形调试工具有 Intel GPA、Nvidia Nsight 和 RenderDoc。他们大概有以下一些特点：</p><ul><li>Intel GPA 简单易用，用于 PC 调试</li><li>Nsight 功能强大复杂，用于 PC 调试</li><li>RenderDoc 兼容性强，用于PC、移动设备、主机等</li></ul><p>接下来我们使用 RenderDoc 来抓取引擎运行时的一帧并查看这一帧的渲染流程。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725102303105.png" alt="image-20220725102303105"></p><p>左侧 Event 列表即为当前帧的绘制流程。</p><p>我们知道 Vulkan 中进行渲染流程其实就是向 Command Buffer 中提交命令，Command Buffer 记录命令后最后统一提交给设备的 Queue 去执行，执行完毕后渲染就完成了，最后送显（Present）就将画面显示在了屏幕上。</p><p>因此每一帧的绘制都以 <code>vkBeginCommandBuffer</code> 开始，以<code>vkEndCommandBuffer</code> 结束，命令记录完之后调用 <code>vkQueueSubmit</code> 提交给设备执行，最后调用 <code>vkQueuePresentKHR</code> 送显。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104007201.png" alt="image-20220725104007201"></p><p>接下来就是一系列的渲染指令，首先是 Colour Pass #1 为平行光阴影绘制，如下图绘制了平行光的 Shadow Map：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104117496.png" alt="image-20220725104117496"></p><p>然后是 Colour Pass #2 点光源的 Shadow Map，但因为我们的场景目前还没有点光源，因此 Shadow Map 没有内容：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104259284.png" alt="image-20220725104259284"></p><p>接下来 Colour Pass #3 对应主相机 Pass 中的<code>drawMeshGbuffer()</code>，逐模型逐 Mesh 的绘制了 G-buffer：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104756924.png" alt="image-20220725104756924"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104804231.png" alt="image-20220725104804231"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104814678.png" alt="image-20220725104814678"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725104908630.png" alt="image-20220725104908630"></p><p>右侧的 output 列表可以看到 G-Buffer 中有哪些内容，包括法线 Buffer、颜色 Buffer、深度 Buffer 等：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105037213.png" alt="image-20220725105037213"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105051150.png" alt="image-20220725105051150"></p><p>接下来按照代码流程切换到了下一个 Subpass，因此先发送了命令 <code>vkCmdNextSubpass</code>，然后调用了 <code>drawDeferredLighting()</code> 进行延迟光照渲染：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105257799.png" alt="image-20220725105257799"></p><p>接下来继续切换下一个 Subpass，进行粒子特效及参与介质的渲染 <code>drawBillboardParticle()</code>，但该功目前还未实现，因此继续切换 Next Subpass 来到后处理的部分。</p><p>后处理首先进行了色调映射 <code>tone_mapping_pass.draw()</code> 得到了更加鲜明的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105510219.png" alt="image-20220725105510219"></p><p>然后是切换下一个 Subpass 来到 <code>color_grading_pass.draw()</code>，但目前的 LUT 颜色映射没有对颜色进行变换，因此没有进行操作：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105621484.png" alt="image-20220725105621484"></p><p>然后是 fxaa 抗锯齿，默认也没有开启，因此也没有进行操作，之后是绘制选中目标的坐标轴 <code>drawAxis()</code>：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105747376.png" alt="image-20220725105747376"></p><p>然后是绘制 UI 界面 <code>ui_pass.draw()</code>：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105838076.png" alt="image-20220725105838076"></p><p>最后是将 UI 界面和渲染的图像结合起来的 <code>combine_ui_pass.draw()</code>：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725105924846.png" alt="image-20220725105924846"></p><p>这样就得到了我们引擎的一帧画面。</p><p>RenderDoc 还可以查看每个渲染命令绑定的 Pipeline，以及 Pipeline 绑定的资源 DescriptorSets 等：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725110403129.png" alt="image-20220725110403129"></p><p>还可以看到每个 Pass 的输入纹理，纹理可以是我们准备的资源，也可以是上一个 Pass 的渲染结果，比如 color grading pass 的输入是色调映射的渲染结果和 LUT 颜色查找表：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/25/20220725-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%B8%A7%E8%B0%83%E8%AF%95/image-20220725110623171.png" alt="image-20220725110623171"></p><p>其他功能在之后用到的时候再继续深入探索。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节了解了 Piccolo 中两种不同的渲染路径的具体实现，这一节我们使用 RenderDoc 帧调试工具来验证整个渲染流程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Piccolo引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Piccolo%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】最终版说明文档</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</id>
    <published>2022-07-23T02:39:40.000Z</published>
    <updated>2022-07-23T02:54:00.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软光栅化渲染器说明文档"><a href="#软光栅化渲染器说明文档" class="headerlink" title="软光栅化渲染器说明文档"></a>软光栅化渲染器说明文档</h2><h3 id="1-环境及依赖"><a href="#1-环境及依赖" class="headerlink" title="1 环境及依赖"></a>1 环境及依赖</h3><p>开发环境：VS 2022 + QT 5.12.3</p><p>第三方库：glm 数学库</p><p>编译说明：需要在 VS 中安装 Qt Visual Studio Tools 插件并配置 QT 路径，之后正常编译即可</p><p><em><span id="more"></span></em></p><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h3><ul><li>基于 QT 的可交互界面</li><li>支持加载 .obj 模型和主纹理，支持模型、材质、环境等参数设置</li><li>完整模拟渲染管线基本流程</li><li>实现了基础的材质、纹理、光照、阴影、天空盒以及图元裁剪、光栅化等算法</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/image-20220720101828805.png" alt="image-20220720101828805"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/image-20220723102429237.png" alt="image-20220723102429237"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/image-20220723084335117.png" alt="image-20220723084335117"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/image-20220723084359800.png" alt="image-20220723084359800"></p><h3 id="3-实现思路"><a href="#3-实现思路" class="headerlink" title="3 实现思路"></a>3 实现思路</h3><h4 id="3-1-UI-框架及操作说明"><a href="#3-1-UI-框架及操作说明" class="headerlink" title="3.1 UI 框架及操作说明"></a>3.1 UI 框架及操作说明</h4><p>程序的入口为 <code>main.cpp</code> 中的主函数，其中调用了程序的主窗口，程序主窗口在 <code>RenderWidget</code> 类中实现，该类会开始渲染循环 <code>RenderLoop</code> 并处理鼠标、键盘和绘制等事件，其中：</p><ul><li><strong>鼠标点击</strong>事件处理定义在 <code>RenderWidget.cpp</code> 中的 <code>RenderWidget::mouseMoveEvent</code> 函数中，通过鼠标拖动可以改变相机的俯仰角和方向角，目前不支持滚转角变化；</li><li><strong>鼠标滚轮</strong>事件处理定义在 <code>RenderWidget.cpp</code> 中的 <code>RenderWidget::wheelEvent</code> 函数中，鼠标滚轮可以拉近或拉远视角，通过改变模型的缩放系数实现；</li><li><strong>键盘输入</strong>事件处理定义在 <code>RenderWidget.cpp</code> 中的 <code>RenderWidget::keyPressEvent</code>、<code>RenderWidget::keyReleaseEvent</code> 和 <code>RenderWidget::DealInput()</code> 三个函数中，每隔 100 ms 接收一次键盘输入，通过 W、A、S、D 可以改变相机水平位置，通过 Q、E 可以改变相机所在位置的垂直高度；</li><li><strong>绘制事件</strong>处理定义在 <code>RenderWidget.cpp</code> 中的 <code>RenderWidget::Vsync</code> 和 <code>RenderWidget::paintEvent</code> 函数中，每一帧绘制完成后，交换前后缓冲并向主窗口发出刷新信号，此时主窗口接收当前 FrameBuffer 中的颜色缓冲数据，并将其转化为 <code>QImage</code> 对象以绘制在界面的画布上。</li></ul><p>主窗口还包含模型设置和环境设置两个标签页，分别实现在 <code>ModelTab.cpp</code> 和 <code>EnvTab.cpp</code> 中，功能都是接收输入并改变渲染时的一些参数和状态。选中模型还可以打开材质编辑面板，实现在 <code>MaterialDialog.cpp</code> 中，具体可参见代码及注释。</p><h4 id="3-2-渲染流程"><a href="#3-2-渲染流程" class="headerlink" title="3.2 渲染流程"></a>3.2 渲染流程</h4><p>在主窗口 <code>RenderWidget</code> 类的构造函数中除了初始化 UI 外，还初始化了起始的渲染状态并调用了渲染主循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RenderWidget::<span class="built_in">RenderWidget</span>(QWidget* parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent), <span class="built_in">fps</span>(<span class="number">0</span>), <span class="built_in">firstMouseMove</span>(<span class="literal">true</span>), <span class="built_in">mdTab</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化状态机</span></span><br><span class="line">    sys = StateMachine::<span class="built_in">GetInstance</span>();</span><br><span class="line">    sys-&gt;<span class="built_in">Init</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    renderLoop = <span class="keyword">new</span> <span class="built_in">RenderLoop</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    renderThread = <span class="keyword">new</span> <span class="built_in">QThread</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染线程和函数绑定</span></span><br><span class="line">    renderLoop-&gt;<span class="built_in">moveToThread</span>(renderThread);</span><br><span class="line">    <span class="built_in">connect</span>(renderThread, &amp;QThread::finished, renderLoop, &amp;RenderLoop::deleteLater);</span><br><span class="line">    <span class="built_in">connect</span>(renderThread, &amp;QThread::started, renderLoop, &amp;RenderLoop::MainLoop);</span><br><span class="line">    <span class="built_in">connect</span>(renderLoop, &amp;RenderLoop::Vsync, <span class="keyword">this</span>, &amp;RenderWidget::Vsync);</span><br><span class="line"></span><br><span class="line">    renderThread-&gt;<span class="built_in">start</span>();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>StateMachine</code> 是一个全局对象，类似于 OpenGL 中的上下文（context），负责记录整个渲染系统的状态，这些状态包括帧缓冲、相机状态、灯光参数、场景及模型数据、渲染模式、剔除模式、深度写入开关、颜色写入开关等等，以及改变这些状态的相关方法，初始化状态机时会对视口大小、帧缓冲、相机、光源等以及负责绘制的类 <code>Graphics</code> 的对象进行初始化，并且会构造默认的地板平面。具体实现在 <code>StateMachine.cpp</code> 中。</p><p><code>RenderLoop</code> 类实现了渲染主循环，类似于 Vulkan 中的 Pipeline，负责设定每一个 Pass 渲染时的各种状态参数和渲染目标（Render Target），并按顺序调用不同的 Pass 对场景进行渲染，渲染主循环实现在 <code>RenderLoop.cpp</code> 中的 <code>RenderLoop::MainLoop()</code> 函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderLoop::MainLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始模型</span></span><br><span class="line">    Model* wBox = <span class="keyword">new</span> <span class="built_in">Model</span>(Mesh::<span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.5</span>));</span><br><span class="line">    Texture2D* mt = <span class="keyword">new</span> <span class="built_in">Texture2D</span>(<span class="string">&quot;../assets/Textures/container.jpg&quot;</span>);</span><br><span class="line">    wBox-&gt;meshes[<span class="number">0</span>]-&gt;material-&gt;<span class="built_in">SetTexture</span>(mt);</span><br><span class="line">    wBox-&gt;yaw = <span class="number">60</span>;</span><br><span class="line">    wBox-&gt;name = <span class="string">&quot;Box&quot;</span>;</span><br><span class="line">    wBox-&gt;meshes[<span class="number">0</span>]-&gt;name = <span class="string">&quot;Box&quot;</span>;</span><br><span class="line">    sys-&gt;<span class="built_in">AddModel</span>(wBox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!shouldClosed) &#123;</span><br><span class="line">        <span class="comment">/***** Shadow Pass *****/</span></span><br><span class="line">        <span class="keyword">if</span> (sys-&gt;drawShadow) &#123;</span><br><span class="line">            <span class="comment">// 参数设置，2048 ShadowMap 分辨率</span></span><br><span class="line">            sys-&gt;<span class="built_in">SetViewPortMatrix</span>(<span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">            sys-&gt;writeColor = <span class="literal">false</span>;</span><br><span class="line">            sys-&gt;writeDepth = <span class="literal">true</span>;</span><br><span class="line">            sys-&gt;faceCullMode = Front;</span><br><span class="line">            <span class="comment">// 逐光源生成 ShadowMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sys-&gt;dirLights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                sys-&gt;dirLights[i]-&gt;<span class="built_in">SetShadowMap</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="comment">// 设定 RT</span></span><br><span class="line">                FrameBuffer* SBO = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(<span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">                sys-&gt;graphics-&gt;<span class="built_in">SetRenderTarget</span>(SBO);</span><br><span class="line">                SBO-&gt;<span class="built_in">ClearDepth</span>(<span class="number">1.0f</span>);</span><br><span class="line">                <span class="comment">// 绘制 ShadowMap</span></span><br><span class="line">                sys-&gt;<span class="built_in">DrawShadow</span>(sys-&gt;dirLights[i]);</span><br><span class="line">                <span class="comment">// 存储 ShadowMap</span></span><br><span class="line">                sys-&gt;dirLights[i]-&gt;<span class="built_in">SetShadowMap</span>(<span class="keyword">new</span> <span class="built_in">Texture2D</span>(SBO-&gt;depthBuffer));</span><br><span class="line">                <span class="keyword">delete</span> SBO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sys-&gt;dirLights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                sys-&gt;dirLights[i]-&gt;<span class="built_in">SetShadowMap</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***** Forward Render Pass *****/</span></span><br><span class="line">        <span class="comment">// 参数设置</span></span><br><span class="line">        sys-&gt;<span class="built_in">SetViewPortMatrix</span>(sys-&gt;width, sys-&gt;height);</span><br><span class="line">        sys-&gt;writeColor = <span class="literal">true</span>;</span><br><span class="line">        sys-&gt;writeDepth = <span class="literal">true</span>;</span><br><span class="line">        sys-&gt;faceCullMode = Back;</span><br><span class="line">        <span class="comment">// 设定 RT</span></span><br><span class="line">        sys-&gt;graphics-&gt;<span class="built_in">SetRenderTarget</span>(sys-&gt;backBuffer);</span><br><span class="line">        sys-&gt;<span class="built_in">ClearColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sys-&gt;<span class="built_in">ClearDepth</span>(<span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 绘制场景</span></span><br><span class="line">        sys-&gt;<span class="built_in">DrawScene</span>();</span><br><span class="line">        <span class="comment">// 双重缓冲交换</span></span><br><span class="line">        sys-&gt;<span class="built_in">SwapBuffer</span>();</span><br><span class="line">        <span class="comment">// 发送屏幕刷新信号，在画布上显示当前帧</span></span><br><span class="line">        <span class="function">emit <span class="title">Vsync</span><span class="params">(sys-&gt;GetFrame(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        sys-&gt;fps++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说到 <code>StateMachine</code> 中会初始化负责绘制的类 <code>Graphics</code> 的对象，该类中实现了全部渲染算法，负责执行状态机发送的 “Drawcall”，这里的 Drawcall 即为上面代码中一系列以 Draw 开头的函数，这些函数内部都会调用 <code>Graphics</code> 中的方法进行绘制。</p><p>以 <code>sys-&gt;DrawScene()</code> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StateMachine::DrawScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 缩放系数矩阵</span></span><br><span class="line">    glm::mat4 globelScale = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(modelScale, modelScale, modelScale));</span><br><span class="line">    <span class="comment">// View矩阵</span></span><br><span class="line">    glm::mat4 viewMatrix = camera-&gt;<span class="built_in">GetViewMatrix</span>();</span><br><span class="line">    <span class="comment">// 投影矩阵</span></span><br><span class="line">    glm::mat4 projectionMatrix = camera-&gt;<span class="built_in">GetProjectionMatrix</span>();</span><br><span class="line">    <span class="comment">// 三角形数量，调试用</span></span><br><span class="line">    triangle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个模型逐光源绘制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; models.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dirLights.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="function">Uniform <span class="title">u</span><span class="params">(globelScale * models[i]-&gt;GetModelMatrix(), viewMatrix, projectionMatrix)</span></span>;</span><br><span class="line">            u.cameraPos = glm::<span class="built_in">vec4</span>(camera-&gt;position, <span class="number">1.0f</span>);</span><br><span class="line">            u.ambient = ambient;</span><br><span class="line">            u.dirLight = dirLights[j];</span><br><span class="line">            graphics-&gt;<span class="built_in">DrawModel</span>(*models[i], u, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绘制 sky box</span></span><br><span class="line">    <span class="keyword">if</span> (drawSkyBox) &#123;</span><br><span class="line">        faceCullMode = Front;</span><br><span class="line">        writeDepth = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">Uniform <span class="title">u</span><span class="params">(glm::mat4(<span class="number">1.0f</span>), viewMatrix, projectionMatrix)</span></span>;</span><br><span class="line">        u.cubemap = skyboxMap[currentSkybox];</span><br><span class="line">        graphics-&gt;<span class="built_in">DrawModel</span>(*skyBox, u, <span class="number">2</span>);</span><br><span class="line">        faceCullMode = Back;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中的工作就是获取 MVP 矩阵，并初始化一个 <code>Uniform</code> 对象，然后发送 Drawcall，<code>Uniform</code> 对象的功能类似于 Vulkan 中的 Pipeline Layout，其中存放了 Shader 中可以用到的所有资源及参数，包括各种全局变量和纹理等，<code>Uniform</code> 定义在 <code>ShaderBase.h</code> 中。</p><p><code>Graphics</code> 对象会从模型开始渲染，即 <code>Graphics::DrawModel</code> 函数，该函数接收三个参数：模型 <code>Model</code> 对象、<code>Uniform</code> 对象和 pass 索引，该函数会绘制给定的 Model，Model 由 Mesh 组成，因此会逐 Mesh 绘制，并将 Mesh 对应的材质参数填充到 <code>Uniform</code> 对象中，以便 Shader 访问，材质 <code>Material</code> 还绑定了 Shader，该函数会根据给定的 pass 索引找到对应的 Shader 进行此次绘制。</p><p>对于 Mesh，由顶点缓冲 VBO 和索引缓冲 EBO 组成，逐 Mesh 绘制即为从 Mesh 的顶点缓冲和索引缓冲中组装三角形图元，然后调用 <code>Graphics::DrawTriangle</code> 逐图元进行绘制。</p><p><code>Graphics::DrawTriangle</code> 函数接收三个顶点，首先对顶点执行 Vertex Shader，之后进行剔除以丢弃不需要渲染的图元，然后对部分在裁剪空间立方体内的图元进行裁剪生成新的顶点和图元，最后对所有顶点组成的图元调用 <code>Graphics::RasterizeTriangle</code> 函数进行光栅化，在光栅化函数中会进行 Early-Z 深度测试，并为通过测试的片段执行 Fragment Shader，最后根据是否开启颜色写入和深度写入来更新 FrameBuffer。</p><p>整个渲染流程中各对象的关系如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/%E6%B5%81%E7%A8%8B1.jpg" alt="流程1"></p><p>其中 <code>Graphics::DrawModel</code> 是渲染管线流程的入口，渲染管线流程如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/%E6%B5%81%E7%A8%8B2.jpg" alt="流程2"></p><h4 id="3-3-其他实现细节"><a href="#3-3-其他实现细节" class="headerlink" title="3.3 其他实现细节"></a>3.3 其他实现细节</h4><p>按照管线流程顺序，本节介绍其中一些关键算法的实现思路。</p><h5 id="3-3-1-图元裁剪算法"><a href="#3-3-1-图元裁剪算法" class="headerlink" title="3.3.1 图元裁剪算法"></a>3.3.1 图元裁剪算法</h5><p>图元裁剪算法在顶点变换到裁剪空间之后，透视除法之前执行，基本流程是：</p><ul><li>判断图元是否完全在裁剪立方体外部，对于完全在外部的图元直接丢弃</li><li>判断图元是否完全在裁剪立方体内部，对于完全在内部的图元无需裁剪</li><li>对部分在内部的图元执行裁剪算法，遍历六个裁剪平面，对两两顶点组成的直线进行裁剪</li><li>如果两顶点在裁剪平面两侧，则求直线和平面的交点（通过点到平面的距离插值得到）作为新的顶点加入结果顶点集</li><li>每一个平面的裁剪结果（顶点集）作为下一次裁剪的输入，直到遍历完六个裁剪平面</li></ul><p>具体实现在 <code>Clip.cpp</code> 的 <code>Clip::SutherlandHodgeman</code> 方法中。</p><h5 id="3-3-2-光栅化算法"><a href="#3-3-2-光栅化算法" class="headerlink" title="3.3.2 光栅化算法"></a>3.3.2 光栅化算法</h5><p>使用了边界函数光栅化算法，边界函数即根据向量叉乘判断点是否在三角形内部，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/23/20220723-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%9C%80%E7%BB%88%E7%89%88%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/image-20220723102429578.png" alt="v2-09c42968924c38ea0732073d31d81912_r"></p><p>则点 P 相对于边 AB 的边界函数可以表示为：<br>$$<br>F_{AB}(P) &#x3D; AB \times AP &#x3D; (B_x - A_x)(P_y - A_y) - (B_y - A_y)(P_x - A_x)<br>$$<br>其他两边同理，对于逆时针顶点顺序的三角形，三个边界函数都大于 0 即为点在三角形内部。上面的边界函数展开并整理可以改写为：<br>$$<br>F_{AB}(P) &#x3D; (A_y - B_y)P_x + (B_x  -A_x)P_y + (A_xB_y - A_yB_x)<br>$$<br>即边界函数对于 Px 和 Py 是完全线性的，也就是两个像素之间的边界函数差值是固定的：<br>$$<br>F_{AB}(P_{x + 1}, P_y) - F_{AB}(P_{x}, P_y) &#x3D; A_y - B_y<br>$$</p><p>$$<br>F_{AB}(P_x, P_{y+1}) - F_{AB}(P_{x}, P_y) &#x3D; B_x - A_x<br>$$</p><p>于是只需要计算出边界函数初值，之后遍历每个像素只需要加上固定的增量即可快速得到该点的边界函数，无需重新计算叉乘。</p><p>如果当前点在三角形内部，则使用重心坐标插值得到该点的属性，重心坐标就是面积比值，也可以通过叉乘得到，因此还可以通过边界函数快速得到该点的重心坐标。</p><p>综上，边界函数光栅化算法基本流程为：</p><ul><li>求三角形 Bounding Box</li><li>求三条边的边界函数初值</li><li>遍历 Bounding Box 中的每个像素，使用边界函数判断是否在三角形内部</li><li>对在内部的点，通过边界函数得到重心坐标，插值得到片段属性并执行 Fragment Shader，更新 Frame Buffer</li><li>使用增量更新边界函数继续遍历</li></ul><p>具体实现在 <code>Graphics.cpp</code> 的 <code>Graphics::RasterizeTriangle</code> 方法中。</p><h5 id="3-3-3-透视插值校正"><a href="#3-3-3-透视插值校正" class="headerlink" title="3.3.3 透视插值校正"></a>3.3.3 透视插值校正</h5><p>由于光栅化过程中的插值在屏幕空间进行，而屏幕空间的顶点位置和世界空间的顶点位置不具备线性对应关系，因此直接使用线性插值会导致顶点属性错误，比如纹理坐标错误会使纹理贴图显示异常，因此要在光栅化之前，透视除法的时候对顶点的所有属性进行插值校正（除以 Z 值），在光栅化算法插值后进行透视恢复（乘以原本的 Z 值）。</p><p>这部分具体实现在 <code>Graphics.cpp</code> 的 <code>Graphics::PerspectiveDivision</code> 和 <code>Graphics::PerspectiveRestore</code> 中。</p><h3 id="4-参考及资源"><a href="#4-参考及资源" class="headerlink" title="4 参考及资源"></a>4 参考及资源</h3><ul><li>UI 框架参考：<a href="https://www.zhihu.com/people/carcat/posts">Clawko - zhihu.com</a></li><li>Box 纹理：<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg">https://learnopengl-cn.github.io/img/01/06/container.jpg</a></li><li>Floor 纹理：<a href="https://www.textureking.com/dsc_3521/">DSC_3521 Textures from TextureKing</a></li><li>Wolf 模型及纹理：<a href="https://free3d.com/3d-model/wolf-rigged-and-game-ready-42808.html">Wolf Rigged and Game Ready - Free3D</a></li><li>Sky Box HDRI：<a href="https://polyhaven.com/hdris">HDRIs • Poly Haven</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;软光栅化渲染器说明文档&quot;&gt;&lt;a href=&quot;#软光栅化渲染器说明文档&quot; class=&quot;headerlink&quot; title=&quot;软光栅化渲染器说明文档&quot;&gt;&lt;/a&gt;软光栅化渲染器说明文档&lt;/h2&gt;&lt;h3 id=&quot;1-环境及依赖&quot;&gt;&lt;a href=&quot;#1-环境及依赖&quot; class=&quot;headerlink&quot; title=&quot;1 环境及依赖&quot;&gt;&lt;/a&gt;1 环境及依赖&lt;/h3&gt;&lt;p&gt;开发环境：VS 2022 + QT 5.12.3&lt;/p&gt;
&lt;p&gt;第三方库：glm 数学库&lt;/p&gt;
&lt;p&gt;编译说明：需要在 VS 中安装 Qt Visual Studio Tools 插件并配置 QT 路径，之后正常编译即可&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Vulkan】资源绑定和状态管理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</id>
    <published>2022-07-17T07:11:59.000Z</published>
    <updated>2022-07-24T07:22:48.041Z</updated>
    
    <content type="html"><![CDATA[<p>这一节讨论 Vulkan 的资源绑定和状态管理机制，过程中可以加深对 Pipeline、Pipeline layout、Descriptor、Descriptor Set、Descriptor set layout、Descriptor binding 等概念的理解。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717150433528.png" alt="image-20220717150433528"></p><p><em><span id="more"></span></em></p><h3 id="1-Pipeline-状态管理"><a href="#1-Pipeline-状态管理" class="headerlink" title="1 Pipeline 状态管理"></a>1 Pipeline 状态管理</h3><p>Vulkan中的管线分为两种：Compute Pipeline 和 Graphics Pipeline。这两种Pipeline的作用跟其他CG API并没有太大的差别。</p><ul><li>Compute Pipeline 用于异构并行计算，Vulkan 的 Compute Pipleline 比较简单，API 也比较少，基本上我们只需要关注 compute shader 本身就好。</li><li>Graphics Pipeline 用于绘制渲染，相比于 Compute Pipleline，Vulkan 的 Graphics Pipeline 更加复杂，包含了 Rasterzation(光栅化)、Shading(着色)、Geometry (几何着色)、Tessellation （细分）等可编程管线的重要环节。</li></ul><p>回忆一下 OpenGL 的设计，每一次的 API 调用你都需要知道将要设置的 OpenGL 状态，所有的状态都由 OpenGL 的 VM 进行管理，因此在使用 OpenGL 时需要时刻将 VM 的状态熟记于心，而 Vulkan 则完全相反，你需要将所有的渲染状态显式的设置到一个原始的 VkPipeline 对象上，该对象打包了所有可编程 (programable) 渲染状态以及所有的固定功能 (fixed-function) 状态。</p><p>VkPipeline 对象的创建在加载阶段，可以在运行游戏时动态创建，也可以直接从文件中读取预编译的对象，预先创建 Pipeline 对象可以减少游戏过程中的卡顿(hitch)现象，下面的代码片段是创建一个 Pipeline 对象所必须设置的状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkGraphicsPipelineCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                      pNext;</span><br><span class="line">    VkPipelineCreateFlags                            flags;</span><br><span class="line">    <span class="type">uint32_t</span>                                         stageCount;</span><br><span class="line">    <span class="type">const</span> VkPipelineShaderStageCreateInfo*           pStages;</span><br><span class="line">    <span class="type">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;</span><br><span class="line">    <span class="type">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;</span><br><span class="line">    <span class="type">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;</span><br><span class="line">    <span class="type">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;</span><br><span class="line">    <span class="type">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;</span><br><span class="line">    <span class="type">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;</span><br><span class="line">    <span class="type">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;</span><br><span class="line">    <span class="type">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;</span><br><span class="line">    <span class="type">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;</span><br><span class="line">    VkPipelineLayout                                 layout;</span><br><span class="line">    VkRenderPass                                     renderPass;</span><br><span class="line">    <span class="type">uint32_t</span>                                         subpass;</span><br><span class="line">    VkPipeline                                       basePipelineHandle;</span><br><span class="line">    <span class="type">int32_t</span>                                          basePipelineIndex;</span><br><span class="line">&#125; VkGraphicsPipelineCreateInfo;</span><br></pre></td></tr></table></figure><p>其中每一个 CreateInfo 又包含一大堆参数，可以说相当繁琐，我们需要设置 GPU 在当前管线下工作时的每个状态。</p><p>从早期开始，OpenGL 状态机就提供了更细颗粒度的状态控制，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>但精细颗粒度的控制对驱动程序带来了负担，驱动程序不得不对状态进行缓存和运行时编译，但是现在新的 API，几乎把整个 GPU state vector 封装到一个 object 中。比如，如果我们想切换状态，是通过切换 pipeline A 和 pipeline B。而不是像 OpenGL 中那样更改标志位。</p><p>这样粗颗粒度的状态对象的优势是方便驱动程序的编译和验证，有助于避免在状态改变时造成的暂停现象。Vulkan 的 Pipeline状态管理参考的是 Mantel，提供了 Pipeline State Object（PSO）进行状态管理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717144401753.png" alt="image-20220717144401753"></p><p>这些状态包括：</p><ul><li><p>Vertex input state：Vertex input state 用来管理 Vertex 数据的位置、索引、布局等信息</p></li><li><p>Input assembly state：Input assembly state 管理顶点数据的组装方式（点、线、三角形等）</p></li><li><p>Tessellation State：Tessellation State 管理 Tessellation control shader 和 Tessellation evaluation shader 的状态</p></li><li><p>Viewport state：Viewport state 用来管理 Viewport，Viewport 会将设备坐标（device coordinate）转换为窗口坐标（window coordinate），是进行光栅化之前最后一次坐标变换</p></li><li><p>Rasterization state：Rasterization state 用来管理光栅化的一些状态，包括多边形的填充模式（PolygonMode）、剔除模式（正面剔除、背面剔除）、深度信息的处理等</p></li><li><p>Color Blend state：Color Blend 是 Vulkan Graphics Pipeline 的最后阶段，这个阶段负责将片段写入 color attachments。在许多情况下，这是一个简单的操作，仅用 Fragment Shader 输出的值覆盖 attachments 中的值。除此之外，color blend 还可以将这些值与 FrameBuffer 中的值混合，并进行简单的逻辑运算。</p></li><li><p>Depth&#x2F;Stencil state：Depth&#x2F;Stencil state 控制着 Depth 和 Stencil 测试的方式</p></li><li><p>Multi-Sampling State：多重采样的目的是为了抗锯齿，Multi-Sampling State 管理多重采样</p></li></ul><p>Vulkan 还允许动态状态管理，因为 Graphics Pipeline 很复杂，包含很多状态，一些图形应用希望能以更高的频率更改某些状态。如果每种状态更改都要创建一个新的 Pipeline 对象，非常不利于管理。Dynamic state 可以管理 viewport、stencil、line widths（线宽）、blending constants、stencil comparison masks 等状态。应用无需重建 Pipeline 对象，只需要通过 Command Buffer 就可以实现状态更新。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717144735429.png" alt="image-20220717144735429"></p><p>接下来对一些状态进行进一步说明。</p><h4 id="1-1-ShaderMoudle"><a href="#1-1-ShaderMoudle" class="headerlink" title="1.1 ShaderMoudle"></a>1.1 ShaderMoudle</h4><p>Shader 是 Pipeline 状态中最为核心的一个，Vulkan 完全摒弃了固定渲染管线。Vulkan 中 shader 对象被称为 VkShaderMoudle，在图形渲染管线(VkGraphicPipeline)中必不可少的 Shader 有 Vertex shader 和 Fragment shader，当然在一些特殊应用中也可以有细分 shader 以及几何 shader。</p><p>Vulkan 并没有特定的 Shader语法，而是使用了一种编译后的中间格式——SPIRV，通常情况下一般使用第三方库将 GLSL 或 HLSL 离线或实时编译成 SPIRV 格式，例如对于 GLSL 可以使用 LunaG 中提供的工具离线将其编译成 SPIRV 格式，也可以使用第三方库 Glslang 将其实时编译成 SPIRV 格式(但这样会有一定的运行时开销，可以将编译后的 SPIRV 格式保存存文件，下次直接加载)。</p><h4 id="1-2-Input-Assembly-State"><a href="#1-2-Input-Assembly-State" class="headerlink" title="1.2 Input Assembly State"></a>1.2 Input Assembly State</h4><p>该状态一般也缩写为 IA，用来指定图元的拓扑方式(topology)，如 Point, Line, TriangleList 等，作用等同于 OpenGL 中 glDrawElements 中的 Mode 参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkPrimitiveTopology</span> &#123;</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = <span class="number">0</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = <span class="number">1</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = <span class="number">2</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = <span class="number">3</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = <span class="number">4</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = <span class="number">5</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = <span class="number">6</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = <span class="number">7</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = <span class="number">8</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = <span class="number">9</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = <span class="number">10</span>,</span><br><span class="line">    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkPrimitiveTopology;</span><br></pre></td></tr></table></figure><h4 id="1-3-Rasterization"><a href="#1-3-Rasterization" class="headerlink" title="1.3 Rasterization"></a>1.3 Rasterization</h4><p>Pipeline 对象中需要显式指定光栅化操作中需要的状态，Vulkan 不支持光栅化的可编程操作，但支持光栅化模块的参数配置，如 CullMode，FrontFace 的缠绕(winding)方式，depth 偏移(bias)，线宽等：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPipelineRasterizationStateCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                pNext;</span><br><span class="line">    VkPipelineRasterizationStateCreateFlags    flags;</span><br><span class="line">    VkBool32                                   depthClampEnable;</span><br><span class="line">    VkBool32                                   rasterizerDiscardEnable;</span><br><span class="line">    VkPolygonMode                              polygonMode;</span><br><span class="line">    VkCullModeFlags                            cullMode;</span><br><span class="line">    VkFrontFace                                frontFace;</span><br><span class="line">    VkBool32                                   depthBiasEnable;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasConstantFactor;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasClamp;</span><br><span class="line">    <span class="type">float</span>                                      depthBiasSlopeFactor;</span><br><span class="line">    <span class="type">float</span>                                      lineWidth;</span><br><span class="line">&#125; VkPipelineRasterizationStateCreateInfo;</span><br></pre></td></tr></table></figure><h4 id="1-4-Multisampling"><a href="#1-4-Multisampling" class="headerlink" title="1.4 Multisampling"></a>1.4 Multisampling</h4><p>Vulkan支持多重采样(Multisampling)，由于多重采样在是渲染管线之中，因此也也需要在 Pipeline 对象中指定多重采样状态，一般支持 1、4、8、16 个采样点，这依赖于硬件的支持情况，Vulkan 最多支持 64 个多重采样点。如果采样点数量不为 1 时，attchment 必须支持相应的多重采样，即创建 VkImage 时的 samples 参数必须与之相同。</p><h4 id="1-5-Blend"><a href="#1-5-Blend" class="headerlink" title="1.5 Blend"></a>1.5 Blend</h4><p>Blend 同样也是 fixed-function 阶段，可以使用不同的参数进行配置，混合只发生于 color attchment，因此需要为不同的颜色 attchement 指定相应的混合参数，典型的混合参数有 <code>VK_BLEND_FACTOR_ZERO</code>, <code>VK_BLEND_FACTOR_ONE</code> 等，典型的混合操作有如 <code>VK_BLEND_OP_ADD</code>， <code>VK_BLEND_OP_SUBTRACT</code> 等。</p><p>混合参数也可以指定常量 <code>VK_BLEND_FACTOR_CONSTANT_COLOR</code>，这时会使用创建 Pipeline 对象时指定的 <code>VkPipelineColorBlendStateCreateInfo</code> 中的 <code>blendConstants</code> 参数，也可以使用命令 <code>vkCmdSetBlendConstants</code> 设置的常量。</p><h4 id="1-6-RenderPass"><a href="#1-6-RenderPass" class="headerlink" title="1.6 RenderPass"></a>1.6 RenderPass</h4><p>RenderPass 是指一组 attachment，Subpass 以及 Subpass 之间的依赖，Pipeline 对象引用了一个 VkRenderPass 对象。对于 RenderPass 而言，最为核心的是 Attachment 上的操作，RenderPass 可以指定 Pass 开始时对 attachment 的操作，如是否需要 Clean，在某种情况下，RenderPass 中参数的合理选择可以显著提高游戏的渲染效率。</p><h4 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h4><p>总之，在 Vulkan 中，配置 Graphics Pipeline 需要三个步骤：</p><ul><li>提供 shader</li><li>绑定资源</li><li>管理状态</li></ul><p>接下来讨论资源的绑定。</p><h3 id="2-Vulkan-资源绑定"><a href="#2-Vulkan-资源绑定" class="headerlink" title="2 Vulkan 资源绑定"></a>2 Vulkan 资源绑定</h3><p>Vulkan 的资源绑定涉及到以下几个概念：</p><ul><li>Descriptor</li><li>Descriptor Set</li><li>Descriptor set layout</li><li>Descriptor binding</li><li>Pipeline layout</li><li>Push constant</li></ul><h4 id="2-1-Descriptor"><a href="#2-1-Descriptor" class="headerlink" title="2.1 Descriptor"></a>2.1 Descriptor</h4><p>Descriptor 是一个 GPU 特定编码格式的数据块。Descriptor 所指的内容不同，就可以表示不同的数据类型。比如指向纹理的 texture descriptor 可能包括指向纹理数据的指针，以及宽度&#x2F;高度，格式等信息。</p><p>Descriptor 的内存不可以分配和释放，只能 write，copy 和 move。</p><h4 id="2-2-Descriptor-Set"><a href="#2-2-Descriptor-Set" class="headerlink" title="2.2 Descriptor Set"></a>2.2 Descriptor Set</h4><p>Descriptor Set 是一个绑定在 Pipeline 上资源集合。多个 Descriptor Set 可以同时绑定到一个 Pipeline 上。</p><p>每个 Descriptor Set 都有一个 layout，Descriptor set Layout 会控制当前资源集当中的资源排布方式，给 shader 提供了读取资源的接口。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717145643661.png" alt="image-20220717145643661"></p><h4 id="2-3-Descriptor-set-layout"><a href="#2-3-Descriptor-set-layout" class="headerlink" title="2.3 Descriptor set layout"></a>2.3 Descriptor set layout</h4><p>Descriptor set layout 本质上是 Descriptor bindings 的集合。Descriptor binding 可以是一个 texture descriptor、buffer descriptor 或者 sampler descriptor 等。</p><p>正是通过 Descriptor binding，Descriptor Set 才实现了 shader 和资源的绑定，方便了 shader 对资源的读写操作。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717145816221.png" alt="image-20220717145816221"></p><h4 id="2-4-Pipeline-layout"><a href="#2-4-Pipeline-layout" class="headerlink" title="2.4 Pipeline layout"></a>2.4 Pipeline layout</h4><p>Pipeline layout 是由 Pipeline 可以访问的 descriptor set layouts 和 push constant ranges 组成，它表示 Pipeline 可以访问的完整资源集。其中，<strong>Push constant</strong> 提供了一个快速更新 shader 中常量的方法。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717145943704.png" alt="image-20220717145943704"></p><h4 id="2-5-Binding-model"><a href="#2-5-Binding-model" class="headerlink" title="2.5 Binding model"></a>2.5 Binding model</h4><p>我们把上述元素组织在一起，就是 Vulkan 的资源绑定模型。</p><p>Descriptor Set 包含一组 Descriptor 和 Descriptor Set layout：</p><ul><li>每个 Descriptor 都可以表示不同的数据类型</li><li>Descriptor Set Layout 由 Descriptor binding 组成，会控制每个 Descriptor 的排列方式</li><li>Descriptor binding 将 Descriptor 和 shader 进行绑定，给 shader 提供了对资源操作的接口。</li></ul><p>Constants register array（Root Table） 把多个Descriptor Set 和 push constant 组织在一起。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717150351889.png" alt="image-20220717150351889"></p><p>Pipeline layout 表示整个渲染管线的资源布局。最后看一下资源和状态管理的整体架构：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717150433528.png" alt="image-20220717150433528"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节讨论 Vulkan 的资源绑定和状态管理机制，过程中可以加深对 Pipeline、Pipeline layout、Descriptor、Descriptor Set、Descriptor set layout、Descriptor binding 等概念的理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E8%B5%84%E6%BA%90%E7%BB%91%E5%AE%9A%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/image-20220717150433528.png&quot; alt=&quot;image-20220717150433528&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Vulkan/"/>
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>【Vulkan】显示与绘制</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/</id>
    <published>2022-07-17T06:27:39.000Z</published>
    <updated>2022-07-20T02:59:48.029Z</updated>
    
    <content type="html"><![CDATA[<p>这一节来讨论 Vulkan 中的显示与绘制机制，过程中可以加深对 SwapChain、Renderpass、Subpass 和 FrameBuffer 的理解。</p><p><em><span id="more"></span></em></p><h3 id="1-SwapChains"><a href="#1-SwapChains" class="headerlink" title="1 SwapChains"></a>1 SwapChains</h3><p>因为支持 Vulkan 运行的平台有很多，有些以计算为目的应用也不需要把绘制的结果呈现给用户，所以显示相关的 API 并不是 Vulkan 核心 API 的一部分，而是通过扩展（extensions）的方式提供。</p><p>Vulkan 没有默认帧缓冲的概念，它需要一个能够缓冲渲染操作的组件。在 Vulkan 中，这一组件就是交换链。Vulkan 的交换链必须显式地创建，不存在默认的交换链。交换链本质是一个包含了若干等待呈现的图像的队列。我们的应用程序从交换链获取一张图像，然后在图像上进行渲染操作，完成后，将图像返回到交换链的队列中。交换链的队列的工作方式和它呈现图像到表面的条件依赖于交换链的设置。但通常来说，交换链被用来同步图像呈现和屏幕刷新。</p><p>每一个支持显示的平台都有自己的窗口系统 Windowing System Integration (WSI)。Vulkan提供了 Swap Chains 跟平台的窗口系统对接。Swap Chains 会向窗口系统申请一个或者多个可以用于显示的 image 对象。我们可以将这些 image 对象作为我们的绘制目标，绘制完成后通过 <code>vkQueuePresentKHR()</code> 函数送显。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/image-20220717142021432.png" alt="image-20220717142021432"></p><p>Presentation（送显）功能依赖于平台提供支持，不同平台的特性有所差异。我们在通过Swap Chains 获取用来显示的image object之后，还需要确认当前平台支持的显示模式。有些平台可能支持多种显示模式，我们需要根据自己的场景做出选择。</p><p>Vulkan API中定义了四种显示模式：</p><ul><li>IMMEDIATE：送显之后立刻显示，替换当前正在显示的图像，不会关心 vsync。显示引擎中也没有等待队列保存图像。这种方式不在消隐期间替换图像，很容易被用户看到撕裂现象。</li><li>FIFO：每个 Vulkan API 的实现都必须支持 FIFO 模式。这种模式下，送显的图像会先被保存在一个先进先出的队列中，当 vsync 触发时，队列里的图像才会替换当前显示的图像，被替换的图像可以重新被应用程序申请绘制。</li><li>FIFO RELAXED：在 FIFO 上做了修改，当图像的显示时长超过一个 vsync 周期时，下一个图像不会再等待下一次 vsync 的到来，而是立刻显示。如果这个操作在非消隐期间，用户可以看到撕裂现象。</li><li>MAILBOX：该模式下，图像仅仅在消隐期间显示，所以用户看不到撕裂现象。在显示引擎内部，只使用单个元素的队列，当有新的图像被生成时，等待队列的图像将被替换。所以这种模式下，显示的图像永远是最新的。</li></ul><h3 id="2-Renderpass-和-Framebuffer"><a href="#2-Renderpass-和-Framebuffer" class="headerlink" title="2 Renderpass 和 Framebuffer"></a>2 Renderpass 和 Framebuffer</h3><p>在 Vulkan 中，绘制命令被组织成 Render Pass。Renderpass 是一组 subpass 的集合，每个 subpass 描述的是如何使用 color attachments 等图像资源。Renderpass 管理着 subpass 之间的依赖关系和绘制顺序。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/image-20220717142347471.png" alt="image-20220717142347471"></p><p>FrameBuffer 是一系列 Image 对象的集合，它是所有绘制操作的最终目标。Swap Chains 从窗口系统申请来的 Image 对象跟 FrameBuffer 绑定以后，绘制操作才能绘制到这些 Image 上面。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/image-20220717142430005.png" alt="image-20220717142430005"></p><p>如果把绘制流程比作绘画：</p><ul><li><p>Swap Chains 从窗口系统申请来的 Image 是用来作画的纸张；</p></li><li><p>FrameBuffer 就是一个可以夹住多张纸的画板；</p></li><li><p>Renderpasses 则表示每张纸要画什么，他们之间的绘制顺序是什么样子的，绘制时是不是要参考前一张的绘制内容。</p></li></ul><p>当绘制完成后，我们就可以把 Image 传给平台的窗口系统进行显示了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E6%98%BE%E7%A4%BA%E4%B8%8E%E7%BB%98%E5%88%B6/image-20220717142650336.png" alt="image-20220717142650336"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节来讨论 Vulkan 中的显示与绘制机制，过程中可以加深对 SwapChain、Renderpass、Subpass 和 FrameBuffer 的理解。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Vulkan/"/>
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>【Vulkan】内存管理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-07-17T06:11:55.000Z</published>
    <updated>2022-07-20T02:58:30.704Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要讨论 Vulkan 中内存管理的相关内容，在这个过程中可以加深对 Heap， Memory，Buffer 和 Image 等概念的理解。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Image-20220717130808509.png" alt="Image-20220717130808509"></p><p><em><span id="more"></span></em></p><h3 id="1-Vulkan-内存管理"><a href="#1-Vulkan-内存管理" class="headerlink" title="1 Vulkan 内存管理"></a>1 Vulkan 内存管理</h3><p>Vulkan 将内存划分为两大类：<strong>Host  Memory</strong> 和 <strong>Device  Memory</strong>。</p><p>Host 是运行应用程序的处理器，在 PC 机上就是指 CPU。Device 是执行 Vulkan 命令的处理器，在 PC 机上就是指 GPU。</p><p>所以，Host  Memory 指的是对 Host 可见的内存，Device  Memory 指的是对 Device 可见的内存。</p><p>更详细的，Vulkan系统中的内存有四种类型：</p><ul><li>Host Local  Memory，只对 Host 可见的内存，通常称之为普通<strong>内存</strong></li><li>Device Local  Memory，只对 Device 可见的内存，通常称之为<strong>显存</strong></li><li>Host Local Device  Memory，由 Host 管理的，对 Device 看见的内存</li><li>Device Local Host  Memory，由 Device 管理的，对 Host 可见的内存</li></ul><p>但并不是所有设备都支持这四种类型。一些嵌入式系统、移动设备甚至是笔记本电脑的 GPU，可能与 CPU 共享内存控制器和内存子系统。这种情况它的内存只有一种类型，我们通常称之为 unified  Memory architecture（统一内存架构）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Image-20220717130155090.png" alt="Image-20220717130155090"></p><h4 id="1-1-Host-Memory"><a href="#1-1-Host-Memory" class="headerlink" title="1.1 Host  Memory"></a>1.1 Host  Memory</h4><p>Host  Memory 是 CPU 可以访问的常规内存，一般是通过调用 malloc 或 new 分配。</p><p>Vulkan API 创建的对象通常需要一定数量的 Host  Memory，用来储存对象和数据结构。Vulkan 对 Host  Memory 的要求就是内存地址是对齐的，这是因为某些高性能 CPU 指令在对齐的内存地址上效果最佳。通过假定存储 CPU 端数据结构的分配是对齐的，Vulkan 可以无条件使用这些高性能指令，从而提供显著的性能优势。</p><h4 id="1-2-Device-Memory"><a href="#1-2-Device-Memory" class="headerlink" title="1.2 Device  Memory"></a>1.2 Device  Memory</h4><p>任何可以由 Device 访问的内存，都被称为 Device  Memory（设备内存）。Device  Memory 距离 Device 更近，比 Host  Memory 更有性能优势。Image object、Buffer object、UBO（uniform Buffer objec）都由 Device  Memory 分配。Vulkan 中的所有资源都由 Device  Memory 支持。</p><h4 id="1-3-Pool"><a href="#1-3-Pool" class="headerlink" title="1.3 Pool"></a>1.3 Pool</h4><p>内存是一种昂贵的资源，分配操作通常会有间接的系统代价。Vulkan 中通过资源池来平摊成本，一些创建比较频繁的资源都由资源池统一管理：</p><ul><li>Command Buffer Pool</li><li>Descriptor Pool</li><li>Query Pool</li></ul><h3 id="2-Heap-和-Memory"><a href="#2-Heap-和-Memory" class="headerlink" title="2 Heap 和  Memory"></a>2 Heap 和  Memory</h3><h4 id="2-1-Heap"><a href="#2-1-Heap" class="headerlink" title="2.1 Heap"></a>2.1 Heap</h4><p>在 Vulkan 中，首先有一个叫做 Heap 的概念，可以认为就是一个有着不同属性的  Memory pool，app 显然可以根据它自己对资源的理解，将不同用途的资源申请分配到不同属性的 Heap 中去。但在之前的 API，如 OpenGL，D3D 11 等，资源的属性更多的时候是作为一个 hint，在资源创建的时候传递给 driver，由 driver 来最终决定将资源分配到何处。例如，在 D3D 11 中，创建资源的时候可以指定用途，从 default&#x2F;dynamic&#x2F;immutable&#x2F;staging 中选择一项，然后 driver 负责根据用途来挑选不同的  Memory 类型。</p><p>然而，在 Vulkan中，资源对象，例如 Buffer 和 Image，以及资源对象实际使用的  Memory，这两个概念已经剥离开来了。也就是说，在 Vulkan 中创建一个对象，并不会同时为这个对象分配相应的  Memory。 Memory 需要从 Heap 中分配出来，然后和对象来一次 association，对象才真正地有了  Memory 来存放其中的内容。</p><p>Heap 本身作为一个硬件支撑的对象，属于 Physical Device 的范畴，所以，可以用 <code>vkGetPhysicalDevice MemoryProperties</code> 来获取硬件可用的 Heap 资源的信息。这个 api 返回的数据结构是一个 <code>VkPhysicalDevice MemoryProperties</code> 的对象，其摘要如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDevice</span> MemoryProperties &#123;</span><br><span class="line">    <span class="type">uint32_t</span>         MemoryTypeCount;</span><br><span class="line">    Vk MemoryType     MemoryTypes[VK_MAX_ Memory_TYPES];</span><br><span class="line">    <span class="type">uint32_t</span>         MemoryHeapCount;</span><br><span class="line">    Vk MemoryHeap     MemoryHeaps[VK_MAX_ Memory_HEAPS];</span><br><span class="line">&#125; VkPhysicalDevice MemoryProperties;</span><br></pre></td></tr></table></figure><p>Heap 的信息以一种非常不直观的形式，由这种数据结构展示出来。其中，真正的 Heap 存放在 <code> MemoryHeaps</code> 数组中，这个数组本身的大小是固定的，但是其中有效的 Heap 个数由 <code> MemoryHeapCount</code> 指定。一个 <code>Vk MemoryHeap</code> 只包含两个信息，第一个是 Heap 的大小，第二个则是一个掩码数，目前只有一个选项可选：是否是 Device-Local 的。Vulkan 规定所有的 Heap中，至少有一个必须设置为 Device-Local。</p><h4 id="2-2-Memory"><a href="#2-2-Memory" class="headerlink" title="2.2  Memory"></a>2.2  Memory</h4><p>我们一般时候说的 Memory，都是指存储空间（不一定是 CPU 的内存，也可能是 GPU 的显存），而在 Vulkan 中， Memory 也特指  Memory 对象，即从一个 Heap 中分配出来的、可以为 Image&#x2F;Buffer 做容器的对象。当我们谈到 Memory 对象的时候，我们指的是 Vulkan 中的 Memory 概念，其他时候，我们谈 Memory，指的就是存储空间。</p><p>有了 Heap 之后，我们就可以从中分配 Memory 对象了，分配的方法很简单，使用 <code>vkAllocateMemory</code> 即可。分配主要需要的信息都在 <code>VkMemoryAllocateInfo</code> 数据结构中体现，其摘要如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    VkDeviceSize       allocationSize;</span><br><span class="line">    <span class="type">uint32_t</span>           MemoryTypeIndex;</span><br><span class="line">&#125; VkMemoryAllocateInfo;</span><br></pre></td></tr></table></figure><p>一个 Memory 对象在生命周期的尽头，由 <code>vkFreeMemory</code> 释放。当释放一个 Memory 对象的时候，app 应当保证此时 Device 不再引用此 Memory 对象上所关联的 Image&#x2F;Buffer。</p><h3 id="3-Buffer-和-Image"><a href="#3-Buffer-和-Image" class="headerlink" title="3 Buffer 和 Image"></a>3 Buffer 和 Image</h3><p>内存的作用是给资源做底层支持，不同的资源对内存的要求并不一样。Vulkan 有两种基本资源类型：Buffer 和 Image。</p><p><strong>Buffer</strong> 是最简单的资源类型，可以用来储存线性的结构化的数据，也可以储存内存中原始字节。</p><p><strong>Image</strong> 则相对比较复杂，具有特殊的布局（layout）和格式（format），可用来做 flitering，blending，depth 和 stencil testing 等。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220717133127448.png" alt="image-20220717133127448"></p><h4 id="3-1-Buffer"><a href="#3-1-Buffer" class="headerlink" title="3.1 Buffer"></a>3.1 Buffer</h4><p>从上图中我们可以看到，Vulkan 中使用的 Buffer 类型主要有：</p><ul><li>Indirect Buffer</li><li>Index Buffer</li><li>Vertex Buffer</li><li>Uniform texel Buffer</li><li>Uniform Buffer</li><li>Storage texel Buffer</li><li>Storage Buffer</li></ul><p>当使用 <code>vkCreateBuffer</code> 创建一个 Buffer 对象的时候，在创建信息 <code>VkBufferCreateInfo</code> 中，我们就要指定这个 Buffer 对象可能的使用场景。除了上述七种有着一一对应的使用掩码位之外，还有额外的两个，分别表示 Buffer 是否可以作为 Transfer 的 Src 或者 Dst。此外还可以设置是否创建 Sparse 的资源，以及其在 Queue Family 之间共享或者独享等信息。</p><p>当我们创建好了一个 Buffer 对象后，我们需要将它和一个 Memory 对象关联起来，这样才可以真正让这个 Buffer 对象拥有 Memory。关联是通过 <code>vkBindBufferMemory</code> 来完成的，然而，直接 binding 可能会失败，因为创建的 Buffer 可能会有一些额外的要求，例如对齐等，所以在此之前，我们需要使用 <code>vkGetBufferMemoryRequirements</code> 来获取这个 Buffer 对象对于 Memory 等要求。要求被填入一个 <code>VkMemoryRequirements</code> 的对象中，这个对象的摘要如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryRequirements</span> &#123;</span><br><span class="line">    VkDeviceSize    size;</span><br><span class="line">    VkDeviceSize    alignment;</span><br><span class="line">    <span class="type">uint32_t</span>        memoryTypeBits;</span><br><span class="line">&#125; VkMemoryRequirements;</span><br></pre></td></tr></table></figure><p>对于一个 Texel 的 Buffer，如 Uniform Texel Buffer 或者 Storage Texel Buffer，shader 如果需要使用的话，还需要用 <code>vkCreateBufferView</code> 为其创建一个 Buffer View，才可以绑定到 Descriptor Set 上，创建信息保存在 <code>VkBufferViewCreateInfo</code> 中，主要制定了 View 的 Format，以及 View 在 Buffer 中的 offset 和 range。</p><p>Buffer 和 Buffer View 分别使用 <code>vkDestroyBuffer</code> 以及 <code>vkDestroyBufferView</code> 进行销毁。</p><h4 id="3-2-Image"><a href="#3-2-Image" class="headerlink" title="3.2 Image"></a>3.2 Image</h4><p>从上图中可以看出，image 主要是作为 shader resource 的 sampled image（即传统意义上的 texture），storage image，以及 frame buffer 中的 input attachment, color attachment 和 depth&#x2F;stencil attachment。大概相当于 D3D 中的 texture, render target 等，表示的是具有 pixel array 和 mipmap 结构的数据。</p><p>创建一个 image，需要使用 <code>vkCreateImage</code>，主要核心在于数据结构 <code>VkImageCreateInfo</code>，其摘要如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    VkImageCreateFlags       flags;</span><br><span class="line">    VkImageType              imageType;</span><br><span class="line">    VkFormat                 format;</span><br><span class="line">    VkExtent3D               extent;</span><br><span class="line">    <span class="type">uint32_t</span>                 mipLevels;</span><br><span class="line">    <span class="type">uint32_t</span>                 arrayLayers;</span><br><span class="line">    VkSampleCountFlagBits    samples;</span><br><span class="line">    VkImageTiling            tiling;</span><br><span class="line">    VkImageUsageFlags        usage;</span><br><span class="line">    VkSharingMode            sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>                 queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pQueueFamilyIndices;</span><br><span class="line">    VkImageLayout            initialLayout;</span><br><span class="line">&#125; VkImageCreateInfo;</span><br></pre></td></tr></table></figure><p>首先解释几个比较简单的部分，例如，imageType 决定 image 是 1d&#x2F;2d&#x2F;3d，format 决定 image 的格式，extent 决定其大小，mipLevels 和 arrayLayers 则是其 mip 层数和数组维度，samples 给出了采样个数。如同 buffer 创建的时候一样，创建 image 的时候也需要指定共享模式，以及可用的 queue 的 family 索引。</p><p>tiling 则决定了 image 本身的 tile 方法，包括 linear 和 optimal 两个选项：</p><ul><li>linear - 其中的图像（Image）数据线性的排列在内存中。</li><li>optimal - 其中的图像（Image）数据以高度优化的模式进行布局，可以有效利用设备的内存子系统。</li></ul><p>线性布局（linear layout）适合连续的单行的读写，但是大多数图形操作都涉及到跨行读写纹理元素，如果图像的宽度非常宽，相邻行的访问在线性布局中会有非常大的跳转。这可能会导致性能问题。</p><p>优化布局（optimal layout）的好处是内存数据根据不同内存子系统进行优化，比如将所有的纹理像素都优化到一块连续的内存区域中，加快内存处理速度。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20220717134630792.png" alt="image-20220717134630792"></p><p>如果需要在 shader 中使用 image，必须通过 frame buffer 或者 descriptor set，通过 image view 的方式才可以。创建 image view 是通过 <code>vkCreateImageView</code> 来完成的，如同 buffer 和 memory 的 binding 一样，一个 image 首先需要使用 <code>vkGetImageMemoryRequirements</code> 来获取其对 memory 的要求，然后才可以用 <code>vkBindImageMemory</code> 来将 memory 和 image bind 起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要讨论 Vulkan 中内存管理的相关内容，在这个过程中可以加深对 Heap， Memory，Buffer 和 Image 等概念的理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Image-20220717130808509.png&quot; alt=&quot;Image-20220717130808509&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Vulkan/"/>
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>【Vulkan】多线程渲染</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/</id>
    <published>2022-07-17T03:24:16.000Z</published>
    <updated>2022-07-20T02:37:35.798Z</updated>
    
    <content type="html"><![CDATA[<p>这一节来学习 Vulkan 多线程渲染的设计理念和执行过程，学习过程中可以深入理解 Vulkan 中 Queue 和 Command Buffer 的关系与作用。</p><p><em><span id="more"></span></em></p><h3 id="1-Vulkan-多线程设计理念"><a href="#1-Vulkan-多线程设计理念" class="headerlink" title="1  Vulkan 多线程设计理念"></a>1  Vulkan 多线程设计理念</h3><p>Vulkan 不仅仅是图形 API，而是一个面向图形和计算的编程接口。支持 Vulkan 的设备可以是 GPU，也可以是 DSP 或者固定功能的硬件。</p><p>Vulkan 中的计算模型主要基于并行计算，因此支持多线程是 Vulkan 设计的核心理念之一。</p><p>为了减少 Vulkan 内部因为互斥同步等操作造成的卡顿问题，Vulkan 内部默认认为对任何资源的访问不存在多线程竞争，所有的资源同步操作由应用开发者去负责，因为对资源的访问和使用没有人比应用开发者自己更加清楚。Vulkan 称之为外部同步（external synchronization）。</p><p>因为这个原因，资源管理和线程同步工作成为编写 Vulkan 程序的最大难点之一。想要让 Vulkan 多线程正常运行，你需要做大量的工作。当然，换来的是 Vulkan 有了更加干净的线程模型以及比其它 CG API 高得多的性能。</p><h3 id="2-Instances、Devices-和-Queues"><a href="#2-Instances、Devices-和-Queues" class="headerlink" title="2 Instances、Devices 和 Queues"></a>2 Instances、Devices 和 Queues</h3><p>Vulkan 多线程模型与几个概念紧密相关，我们再次回顾这些概念：</p><ul><li><strong>Instances</strong> 可以看做是应用的子系统，从逻辑上把 Vulkan 与应用程序上下文中的其他逻辑隔开。Instances 可以看做是 Vulkan 的上下文，它会跟踪所有状态，从逻辑上把所有支持 Vulkan 的设备整合在一起。</li><li><strong>Physical devices</strong> 和 <strong>Logical device</strong> 都是 Devices，<strong>Physical devices</strong> 通常代表一个或者多个支持 Vulkan 的硬件设备，这些设备具有特定功能，可以提供一系列 Queues。图形显卡、加速器、DSP 等都可以是 Vulkan 的 Physical devices。<strong>Logical device</strong> 是 Physical devices 的软件抽象，用于预订一些硬件资源。</li><li><strong>Queues</strong> 可以理解为一个“GPU 线程”，它是实现 Vulkan 多线程的关键元素之一，用于响应应用的请求，大部分时间，应用都在与其进行交互。</li></ul><p>三者之间的层次关系如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717093523311.png" alt="image-20220717093523311"></p><h3 id="3-Queues-和-Command-Buffer"><a href="#3-Queues-和-Command-Buffer" class="headerlink" title="3 Queues 和 Command Buffer"></a>3 Queues 和 Command Buffer</h3><h4 id="3-1-Queues"><a href="#3-1-Queues" class="headerlink" title="3.1 Queues"></a>3.1 Queues</h4><p><strong>Queue</strong> 代表一个 GPU 线程，Vulkan 设备执行的就是提交到 Queues 中的工作。物理设备中 Queue 可能不止一个，每一个 Queue 都被包含在 Queue Families 中。</p><p><strong>Queue Families</strong> 是一个有相同功能的 Queues 的集合，它们的性能水平和对系统资源的访问是相同的，并且在它们之间数据传输工作没有任何成本（同步之外）。</p><p>一个物理设备中可以存在多个 Queue Families，不同的 Queue Families 有不同的特性。相同 Queue Families 中的 Queues 的功能相同，并且可以并行运行。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717093746797.png" alt="image-20220717093746797"></p><p>按照 Queue 的能力，可以将其划分为：</p><ul><li><p>Graphics（图形）：该系列中的 Queues 支持图形操作，例如绘制点，线和三角形。</p></li><li><p>Compute（计算）：该系列中的 Queues 支持诸如 computer shader 之类的计算操作。</p></li><li><p>Transfer（传输，拷贝）：该系列中的 Queues 支持传输操作，例如复制缓冲区和图像内容。</p></li><li><p>Sparse binding（稀疏绑定）：该系列中的 Queues 支持用于更新稀疏资源（sparse resource）的内存绑定操作。</p></li></ul><h4 id="3-2-Command-Buffer"><a href="#3-2-Command-Buffer" class="headerlink" title="3.2 Command Buffer"></a>3.2 Command Buffer</h4><p>传统 CG API 是单线程的，性能的提升只能依赖于 CPU 主频的提高。能有的优化方案也不外乎主线程和渲染线程分开，或者某些资源的异步加载、离线处理。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717094133278.png" alt="image-20220717094133278"></p><p>Vulkan 为了充分发挥 CPU 多核多线程的作用，引入了 command buffer 的概念。多个线程可以同时协作，每个 CPU 线程都可以往自己的 command buffer 中提交渲染命令，然后统一提交到对应的 Queue 中，大大提高了 CPU 的利用率。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717094701486.png" alt="image-20220717094701486"></p><p>应用在绘制时会提交一系列绘制命令给 GPU 驱动，但是这些绘制命令不会立刻被执行，而是被简单的添加到 Command Buffer 的末尾。</p><p>在其他 CG APIs 中，驱动程序在应用不感知的情况下，把 API 调用翻译成 GPU command 并储存在 command buffer 中，最终提交给 GPU 处理。command buffer 的创建和销毁都由驱动负责。</p><p>而在 Vulkan 中，你需要自己从 <strong>Command Buffer Pool</strong> 中申请 command buffer，将想要记录的命令放入 command buffer 中。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717094416108.png" alt="image-20220717094416108"></p><p>Command Buffer 可以记录（Record）很多命令，比如设置状态、绘制操作、数据拷贝等等，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717094500235.png" alt="image-20220717094500235"></p><p>理论上，一个线程可以把 Command 记录到多个 Command Buffer 中，多个线程也可以共享同一个 Command Buffer，但是一般不鼓励多个线程共享一个 Command Buffer。</p><p>Vulkan 的关键设计原则之一就是做到高效的多线程。想实现这一点，应用程序要注意因为资源竞争导致的多线程彼此阻塞。因此，每个线程最好有一个或者多个 Command Buffer，不要尝试共享一个。另外，Command Buffer 由 Command Buffer Pool 分配，应用可以为每一个线程创建一个 Command Buffer Pool，让各个工作线程从 Command Buffer Pool 中分配 Command Buffer，无需参与竞争。</p><h4 id="3-3-Command-Buffer-生命周期"><a href="#3-3-Command-Buffer-生命周期" class="headerlink" title="3.3 Command Buffer 生命周期"></a>3.3 Command Buffer 生命周期</h4><p>从 Command Buffer 创建开始，会经历不同的状态，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717105544433.png" alt="image-20220717105544433"></p><ul><li><strong>Initial 状态</strong>：在 <code>Command-Buffer</code> 刚刚创建时，它就是处于初始化的状态。从此状态，可以达到 <code>Recording</code> 状态，另外，如果重置之后，也会回到该状态。</li><li><strong>Recording 状态</strong>：调用 <code>vkBeginCommandBuffer</code> 方法从 <code>Initial</code> 状态进入到该状态。一旦进入该状态后，就可以调用 <code>vkCmd*</code> 等系列方法记录命令。</li><li><strong>Executable 状态</strong>：调用 <code>vkEndCommandBuffer</code> 方法从 <code>Recording</code> 状态进入到该状态，此状态下，<code>Command-Buffer</code> 可以提交或者重置。</li><li><strong>Pending 状态</strong>：把 <code>Command-Buffer</code> 提交到 <code>Queue</code> 之后，就会进入到该状态。此状态下，物理设备可能正在处理记录的命令，因此不要在此时更改 <code>Command-Buffer</code>，当处理结束后，<code>Command-Buffer</code> 可能会回到 <code>Executable</code> 状态或者 <code>Invalid</code> 状态。</li><li><strong>Invalid 状态</strong>：一些操作会使得 <code>Command-Buffer</code> 进入到此状态，该状态下，<code>Command-Buffer</code> 只能重置、或者释放。</li></ul><h3 id="4-Vulkan-同步机制"><a href="#4-Vulkan-同步机制" class="headerlink" title="4 Vulkan 同步机制"></a>4 Vulkan 同步机制</h3><h4 id="4-1-显式同步操作"><a href="#4-1-显式同步操作" class="headerlink" title="4.1 显式同步操作"></a>4.1 显式同步操作</h4><p>Vulkan 把同步的操作交给了我们的应用程序（external synchronization），绝大多数的 Vulkan 命令根本不提供同步，需要应用自己负责。Vulkan 给应用提供了同步原语，帮助应用进行同步操作。</p><p>Vulkan 中主要有四种同步原语（synchronization primitives）：</p><ul><li><p><strong>Fences</strong>：最大颗粒度的同步原语，用来保证物理设备和应用程序之间的同步，比如说向 <code>Queue</code> 中提交了 <code>Command-Buffer</code> 后，具体的执行交由物理设备去完成了，这是一个异步的过程，而应用程序如果要等待执行结束，就要使用 <code>Fence</code> 机制。因此 <code>Fences</code> 给 CPU 端提供了一种方法，可以使其知道 GPU 或者其他 Vulkan Device 什么时候把提交的工作全部做完。</p></li><li><p><strong>Semaphores</strong>：颗粒度比 Fences 更小一点，主要是用来向 <code>Queue</code> 中提交 <code>Command-Buffer</code> 时实现同步。比如说某个 <code>Command-Buffer-B</code> 在执行的某个阶段中需要等待另一个 <code>Command-Buffer-A</code> 执行成功后的结果，同时 <code>Command-Buffer-C</code> 在某阶段又要等待 <code>Command-Buffer-B</code> 的执行结果，那么就应该使用 <code>Semaphore</code> 机制实现同步；此时 <code>Command-Buffer-B</code> 提交到 <code>Queue</code> 时就需要两个 <code>VkSemaphor</code> ，一个表示它需要等待的 <code>Semaphore</code>，并且指定在哪个阶段等待；一个是它执行结束后发出通知的 <code>Semaphore</code>。</p></li><li><p><strong>Events</strong>：颗粒度更小，可以用于 Command Buffer 之间的同步工作</p></li><li><p><strong>Barriers</strong>：Vulkan 流水线（Pipeline）阶段内用于内存访问管理和资源状态移动的同步机制</p></li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717100401919.png" alt="image-20220717100401919"></p><h4 id="4-2-隐式执行顺序"><a href="#4-2-隐式执行顺序" class="headerlink" title="4.2 隐式执行顺序"></a>4.2 隐式执行顺序</h4><p>在没有同步原语的情况下，Vulkan 的执行顺序其实是有一定的潜规则的：</p><ul><li>Command Buffer 中的 Command，先记录的先执行</li><li>先提交的 Command Buffer 先执行</li><li>同一个 Queue 中，一起提交的 Command Buffer1 和 Command Buffer2 按照下标的顺序执行，即 Command Buffer1 先执行</li></ul><h4 id="4-3-Barriers"><a href="#4-3-Barriers" class="headerlink" title="4.3 Barriers"></a>4.3 Barriers</h4><p>Barriers 需要开发者了解渲染管线的各个阶段，能清晰的把握管线中每个步骤对资源的读写顺序。</p><p>Vulkan 中将 Pipeline 的各个阶段定义为：</p><ul><li>TOP_OF_PIPE_BIT</li><li>DRAW_INDIRECT_BIT</li><li>VERTEX_INPUT_BIT</li><li>VERTEX_SHADER_BIT</li><li>TESSELLATION_CONTROL_SHADER_BIT</li><li>TESSELLATION_EVALUATION_SHADER_BIT</li><li>GEOMETRY_SHADER_BIT</li><li>FRAGMENT_SHADER_BIT</li><li>EARLY_FRAGMENT_TESTS_BIT</li><li>LATE_FRAGMENT_TESTS_BIT</li><li>COLOR_ATTACHMENT_OUTPUT_BIT</li><li>TRANSFER_BIT</li><li>COMPUTE_SHADER_BIT</li><li>BOTTOM_OF_PIPE_BIT</li></ul><p>对应于管线流程图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717100954068.png" alt="image-20220717100954068"></p><p>假设我们有个两个渲染管线 P1 和 P2，P1 会通过 Vertex Shader 往 buffer 写入顶点数据，P2 需要在 Compute Shader 中使用这些数据。</p><p>如果使用 fence 去同步，我们的流程应该是这样：P1 的 Command 提交后，P2 通过 fence 确保 P1 的操作已经被全部执行完，再开始工作。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717101041745.png" alt="image-20220717101041745"></p><p>但是这种大颗粒度的同步操作无疑造成了耗时操作：P1 的数据在 Vertex Shader 阶段就已经准备好了，我们为什么要等到它所有操作执行完再开始？P2 平白多等待了很长时间，而且在这个期间 P2 的其他阶段并没有使用到 P1 的数据，也是可以同步执行的。</p><p>Barriers 的引入完全解决了这个问题，我们只需要告诉 Vulkan，我们在 P2 的 Compute Shader 阶段才会等待 P1 Vertex Shader 里面的数据，其他阶段并不关心，可以同步进行。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717101122332.png" alt="image-20220717101122332"></p><h3 id="5-具体用法"><a href="#5-具体用法" class="headerlink" title="5 具体用法"></a>5 具体用法</h3><p>接下来总结上述 4 种组件的具体用法。首先回顾 Vulkan 中重要的组件及其工作流程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/vulkan-instance-device-queue.png" alt="vulkan-instance-device-queue"></p><p>在 Vulkan 的 API 中有一些固定的调用套路 ：</p><ol><li>要创建某个对象，先提供一个包含创建信息的对象。</li><li>创建时通过传递引用的方式来传参。</li></ol><h4 id="5-1-Instance-组件"><a href="#5-1-Instance-组件" class="headerlink" title="5.1 Instance 组件"></a>5.1 Instance 组件</h4><p>在 <code>vkCreateInstance</code> 函数中有个名为 <code>VkInstanceCreateInfo</code> 类型的参数，这就是包含了 <code>VKInstance</code> 要创建的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkInstanceCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;  <span class="comment">// 一般为方法对应的类型</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext; <span class="comment">// 一般为 null 就好了</span></span><br><span class="line">    VkInstanceCreateFlags       flags;  <span class="comment">// 留着以后用的，设为 0 就好了</span></span><br><span class="line">    <span class="type">const</span> VkApplicationInfo*    pApplicationInfo; <span class="comment">// 对应新的一个结构体 VkApplicationInfo</span></span><br><span class="line">    <span class="type">uint32_t</span>                    enabledLayerCount; <span class="comment">// layer 和 extension 用于调试和拓展</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*          ppEnabledLayerNames;</span><br><span class="line">    <span class="type">uint32_t</span>                    enabledExtensionCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>*          ppEnabledExtensionNames;</span><br><span class="line">&#125; VkInstanceCreateInfo;</span><br></pre></td></tr></table></figure><p>除此之外还需要创建一个 <code>VkApplicationInfo</code> 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkApplicationInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*        pApplicationName;</span><br><span class="line">    <span class="type">uint32_t</span>           applicationVersion;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>*        pEngineName;</span><br><span class="line">    <span class="type">uint32_t</span>           engineVersion;</span><br><span class="line">    <span class="type">uint32_t</span>           apiVersion;</span><br><span class="line">&#125; VkApplicationInfo;</span><br></pre></td></tr></table></figure><p>下面是创建一个 instance 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VkApplicationInfo app_info = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">app_info.apiVersion = VK_API_VERSION_1_0;</span><br><span class="line">app_info.applicationVersion = <span class="number">1</span>;</span><br><span class="line">app_info.engineVersion = <span class="number">1</span>;</span><br><span class="line">app_info.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line">app_info.pEngineName = APPLICATION_NAME;</span><br><span class="line">app_info.pApplicationName = APPLICATION_NAME;</span><br><span class="line"></span><br><span class="line">VkInstanceCreateInfo instance_info = &#123;&#125;;</span><br><span class="line"><span class="comment">// type 就是结构体的类型</span></span><br><span class="line">instance_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">instance_info.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">instance_info.pApplicationInfo = &amp;app_info;</span><br><span class="line">instance_info.flags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Extension and Layer 暂时不用,可空</span></span><br><span class="line">instance_info.enabledExtensionCount = <span class="number">0</span>;</span><br><span class="line">instance_info.ppEnabledExtensionNames = <span class="literal">nullptr</span>;</span><br><span class="line">instance_info.ppEnabledLayerNames = <span class="literal">nullptr</span>;</span><br><span class="line">instance_info.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">VkResult result = <span class="built_in">vkCreateInstance</span>(&amp;instance_info, <span class="literal">nullptr</span>, &amp;instance);</span><br></pre></td></tr></table></figure><p>当每调用一个创建函数后，返回的类型都是 <code>VkResult</code> ，只要 VkResult 大于 0 ，那么执行就是成功的。</p><h4 id="5-2-Device-组件"><a href="#5-2-Device-组件" class="headerlink" title="5.2 Device 组件"></a>5.2 Device 组件</h4><p>有了 <code>Instance</code> 组件，就可以创建 <code>Device</code> 组件了，按照调用的套路，肯定还会有一个 <code>VkDeviceCreateInfo</code> 的结构体表示 <code>Device</code> 的创建信息。</p><p><code>Device</code> 具体指的是逻辑上的设备，可以说是对物理设备的一个逻辑上的封装，而物理设备就是 <code>VkPhysicalDevice</code> 对象。</p><p>在某些情况下，可能会具有多个物理设备，因此要先枚举一下所有的物理设备：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gpu_size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 第一次调用只为了获得个数</span></span><br><span class="line">VkResult res = <span class="built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;gpu_size, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在 <code>vkEnumeratePhysicalDevices</code> 方法中，传入的第二个参数为 GPU 的个数，第三个参数为 null，这样的一次调用会返回 GPU 的个数到 <code>gpu_size</code> 变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;VkPhysicalDevice&gt; gpus;</span><br><span class="line">gpus.<span class="built_in">resize</span>(gpu_size);</span><br><span class="line"><span class="comment">// 第二次调用获得所有的数据，vector.data() 方法转换成指针类型</span></span><br><span class="line">res = <span class="built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;gpu_size, gpus.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure><p>当再一次调用 <code>vkEnumeratePhysicalDevices</code> 函数时，第三个参数不为 null，而是相应的 <code>VkPhysicalDevice</code> 容器，那么 <code>gpus</code> 会填充 <code>gpu_size</code> 个的 <code>VkPhysicalDevice</code> 对象。</p><p>有了 <code>VkPhysicalDevice</code> 对象之后，可以查询 <code>VkPhysicalDevice</code> 上的一些属性，以下函数都可以查询相关信息：</p><ul><li>vkGetPhysicalDeviceQueueFamilyProperties</li><li>vkGetPhysicalDeviceMemoryProperties</li><li>vkGetPhysicalDeviceProperties</li><li>vkGetPhysicalDeviceImageFormatProperties</li><li>vkGetPhysicalDeviceFormatProperties</li></ul><p>以 <code>QueueFamilyProperties</code> 为例，获得该属性的方法调用方式和获得 <code>VkPhysicalDevice</code> 数据方式一样，也是一个两次调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次调用，获得个数</span></span><br><span class="line"><span class="type">uint32_t</span> queue_family_count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(gpus[<span class="number">0</span>], &amp;queue_family_count, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">assert</span>(queue_family_count != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次调用，获得实际数据</span></span><br><span class="line">vector&lt;VkQueueFamilyProperties&gt; queue_family_props;</span><br><span class="line">queue_family_props.<span class="built_in">resize</span>(queue_family_count);</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(gpus[<span class="number">0</span>], &amp;queue_family_count, queue_family_props.<span class="built_in">data</span>());</span><br><span class="line"><span class="built_in">assert</span>(queue_family_count != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>QueueFamilyProperties</code> 的结构体含义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkQueueFamilyProperties</span> &#123;</span><br><span class="line">    VkQueueFlags    queueFlags;      <span class="comment">// 标识位：表示 Queue 的功能</span></span><br><span class="line">    <span class="type">uint32_t</span>        queueCount;         </span><br><span class="line">    <span class="type">uint32_t</span>        timestampValidBits;</span><br><span class="line">    VkExtent3D      minImageTransferGranularity;</span><br><span class="line">&#125; VkQueueFamilyProperties;</span><br></pre></td></tr></table></figure><p>其中的 <code>queueFlags</code> 表示该 Queue 的能力，有的 Queue 是用来渲染图像的，还有的 Queue 是用来计算的，具体的 Flag 标识如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkQueueFlagBits</span> &#123;</span><br><span class="line">    VK_QUEUE_GRAPHICS_BIT = <span class="number">0x00000001</span>,         <span class="comment">// 图像相关</span></span><br><span class="line">    VK_QUEUE_COMPUTE_BIT = <span class="number">0x00000002</span>,          <span class="comment">// 计算相关</span></span><br><span class="line">    VK_QUEUE_TRANSFER_BIT = <span class="number">0x00000004</span>,         <span class="comment">// 传输，拷贝</span></span><br><span class="line">    VK_QUEUE_SPARSE_BINDING_BIT = <span class="number">0x00000008</span>,   <span class="comment">// 稀疏绑定</span></span><br><span class="line">    VK_QUEUE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkQueueFlagBits;</span><br><span class="line"><span class="keyword">typedef</span> VkFlags VkQueueFlags;</span><br></pre></td></tr></table></figure><p>接下来是创建一个 Device，在 <code>VkDeviceCreateInfo</code> 结构体中需要一个参数是 <code>VkDeviceQueueCreateInfo</code> ，因此要先创建 <code>VkDeviceQueueCreateInfo</code>，再创建 <code>VkDeviceCreateInfo</code>，最后调用 <code>vkCreateDevice</code> 创建一个 Device：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Queue 所需的相关信息</span></span><br><span class="line">VkDeviceQueueCreateInfo queue_info = &#123;&#125;;</span><br><span class="line"><span class="comment">// 找到属性为 VK_QUEUE_GRAPHICS_BIT 的索引</span></span><br><span class="line"><span class="type">bool</span> found = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; queue_family_count; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_family_props[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;</span><br><span class="line">        queue_info.queueFamilyIndex = i;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> queue_priorities[<span class="number">1</span>] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="comment">// 结构体的类型</span></span><br><span class="line">queue_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;</span><br><span class="line">queue_info.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">queue_info.queueCount = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Queue 的优先级</span></span><br><span class="line">queue_info.pQueuePriorities = queue_priorities;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Device 所需的相关信息类</span></span><br><span class="line">VkDeviceCreateInfo device_info = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;</span><br><span class="line">device_info.pNext = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// Device 所需的 Queue 相关信息</span></span><br><span class="line">device_info.queueCreateInfoCount = <span class="number">1</span>;   <span class="comment">// Queue 个数</span></span><br><span class="line">device_info.pQueueCreateInfos = &amp;queue_info;    <span class="comment">// Queue 相关信息</span></span><br><span class="line"><span class="comment">// Layer 和 Extension 暂时为空，不影响运行，后续再补上</span></span><br><span class="line">device_info.enabledExtensionCount = <span class="number">0</span>;</span><br><span class="line">device_info.ppEnabledExtensionNames = <span class="literal">NULL</span>;</span><br><span class="line">device_info.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">device_info.ppEnabledLayerNames = <span class="literal">NULL</span>;</span><br><span class="line">device_info.pEnabledFeatures = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">VkResult res = <span class="built_in">vkCreateDevice</span>(gpus[<span class="number">0</span>], &amp;device_info, <span class="literal">nullptr</span>, &amp;device);</span><br></pre></td></tr></table></figure><h4 id="5-3-Queue-组件"><a href="#5-3-Queue-组件" class="headerlink" title="5.3 Queue 组件"></a>5.3 Queue 组件</h4><p>完成了 <code>Device</code> 创建之后，<code>Queue</code> 的创建也简单多了，直接调用如下函数就好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(VKAPI_PTR *PFN_vkGetDeviceQueue)</span></span></span><br><span class="line"><span class="function"><span class="params">(VkDevice device,          <span class="comment">// 创建的 Device 对象</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">uint32_t</span> queueFamilyIndex, <span class="comment">// queueFlags 为 VK_QUEUE_GRAPHICS_BIT 的索引</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">uint32_t</span> queueIndex,        </span></span></span><br><span class="line"><span class="params"><span class="function">VkQueue* pQueue)</span></span>;          <span class="comment">// 要创建的 Queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="built_in">vkGetDeviceQueue</span>(info.device, info.graphics_queue_family_index, <span class="number">0</span>, &amp;info.queue);</span><br></pre></td></tr></table></figure><p>完成了 <code>Instance</code>、<code>Device</code>、<code>Queue</code> 组件的创建之后，还有一件要做的事情就是释放它们，销毁组件。</p><p>按照先进后出的方式进行销毁，<code>Instance</code> 最先创建因此最后销毁，和 <code>Device</code> 相关联的 <code>Queue</code> 在 <code>Device</code> 销毁时就随之销毁了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁 Device</span></span><br><span class="line"><span class="built_in">vkDestroyDevice</span>(info.device, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 销毁 Instance</span></span><br><span class="line"><span class="built_in">vkDestroyInstance</span>(info.instance, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h4 id="5-4-Command-Buffer-组件"><a href="#5-4-Command-Buffer-组件" class="headerlink" title="5.4 Command Buffer 组件"></a>5.4 Command Buffer 组件</h4><p>在前面的学习中，我们已经创建了 <code>Instance</code>、<code>Device</code>、<code>Queue</code> 三个组件，并且知道了 <code>Queue</code> 组件是用来和物理设备沟通的桥梁，而具体的沟通过程就需要 <code>Command-Buffer</code> 组件，它是若干命令的集合，我们向 <code>Queue</code> 提交 <code>Command-Buffer</code>，然后才交由物理设备 GPU 进行处理。</p><h5 id="5-4-1-创建-Command-Pool"><a href="#5-4-1-创建-Command-Pool" class="headerlink" title="5.4.1 创建 Command Pool"></a>5.4.1 创建 Command Pool</h5><p>在创建 <code>Command-Buffer</code> 之前，需要创建 <code>Command-Pool</code> 组件，从 <code>Command-Pool</code> 中去分配 <code>Command-Buffer</code> 。还是老套路，我们需要先创建一个 <code>VkCommandPoolCreateInfo</code> 的结构体，结构体每个参数的释义还是要多参考官方的文档。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Command-Pool 组件</span></span><br><span class="line">VkCommandPool command_pool;</span><br><span class="line">VkCommandPoolCreateInfo poolCreateInfo = &#123;&#125;;</span><br><span class="line">poolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line"><span class="comment">// 可以看到 Command-Pool 还和 Queue 相关联</span></span><br><span class="line">poolCreateInfo.queueFamilyIndex = info.graphics_queue_family_index;</span><br><span class="line"><span class="comment">// 标识命令缓冲区的一些行为</span></span><br><span class="line">poolCreateInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</span><br><span class="line"><span class="comment">// 具体创建函数的调用</span></span><br><span class="line"><span class="built_in">vkCreateCommandPool</span>(info.device, &amp;poolCreateInfo, <span class="literal">nullptr</span>, &amp;command_pool);</span><br></pre></td></tr></table></figure><p>有几个参数需要注意：</p><ol><li><code>queueFamilyIndex</code> 参数表示创建 <code>Queue</code> 时选择的那个 <code>queueFlags</code> 为 <code>VK_QUEUE_GRAPHICS_BIT</code> 的索引，从 <code>Command-Pool</code> 中分配的的 <code>Command-Buffer</code> 必须提交到同一个 <code>Queue</code> 中。</li><li><code>flags</code> 有如下的选项，分别指定了 <code>Command-Buffer</code> 的不同特性：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandPoolCreateFlagBits</span> &#123;</span><br><span class="line">    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandPoolCreateFlagBits;</span><br></pre></td></tr></table></figure><ul><li>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT：表示该 <code>Command-Buffer</code> 的寿命很短，可能在短时间内被重置或释放</li><li>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT：表示从 <code>Command-Pool</code> 中分配的 <code>Command-Buffer</code> 可以通过 <code>vkResetCommandBuffer</code> 或者 <code>vkBeginCommandBuffer</code> 方法进行重置，如果没有设置该标识位，就不能调用 <code>vkResetCommandBuffer</code> 方法进行重置。</li></ul><h5 id="5-4-2-创建-Command-Buffer"><a href="#5-4-2-创建-Command-Buffer" class="headerlink" title="5.4.2 创建 Command Buffer"></a>5.4.2 创建 Command Buffer</h5><p>接下来就是从 <code>Command-Pool</code> 中分配 <code>Command-Buffer</code>，通过 <code>VkCommandBufferAllocateInfo</code> 函数。首先需要一个 <code>VkCommandBufferAllocateInfo</code> 结构体表示分配所需要的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkCommandPool           commandPool;    <span class="comment">// 对应上面创建的 command-pool</span></span><br><span class="line">    VkCommandBufferLevel    level;</span><br><span class="line">    <span class="type">uint32_t</span>                commandBufferCount; <span class="comment">// 创建的个数</span></span><br><span class="line">&#125; VkCommandBufferAllocateInfo;</span><br></pre></td></tr></table></figure><p>这里有个参数也要注意：</p><ul><li><code>VkCommandBufferLevel</code> 指定 <code>Command-Buffer</code> 的级别。</li></ul><p>有如下级别可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandBufferLevel</span> &#123;</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_PRIMARY = <span class="number">0</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_SECONDARY = <span class="number">1</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + <span class="number">1</span>),</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandBufferLevel;</span><br></pre></td></tr></table></figure><p>一般来说，使用 <code>VK_COMMAND_BUFFER_LEVEL_PRIMARY</code> 就好了。</p><p>具体创建代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer commandBuffer[<span class="number">2</span>];</span><br><span class="line">VkCommandBufferAllocateInfo command_buffer_allocate_info&#123;&#125;;</span><br><span class="line">command_buffer_allocate_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">command_buffer_allocate_info.commandPool = command_pool;</span><br><span class="line">command_buffer_allocate_info.commandBufferCount = <span class="number">2</span>;</span><br><span class="line">command_buffer_allocate_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line"><span class="built_in">vkAllocateCommandBuffers</span>(info.device, &amp;command_buffer_allocate_info, commandBuffer);</span><br></pre></td></tr></table></figure><h5 id="5-4-3-Command-Buffer-记录与提交命令"><a href="#5-4-3-Command-Buffer-记录与提交命令" class="headerlink" title="5.4.3 Command Buffer 记录与提交命令"></a>5.4.3 Command Buffer 记录与提交命令</h5><p>回顾上面的 Command Buffer 记录命令流程图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/17/20220717-Vulkan-Vulkan%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B8%B2%E6%9F%93/image-20220717094500235.png" alt="image-20220717094500235"></p><p>在 <code>vkBeginCommandBuffer</code> 和 <code>vkEndCommandBuffer</code> 方法之间可以记录和渲染相关的命令，我们先不考虑中间的过程，直接创建提交。</p><p>首先，还是需要创建一个 <code>VkCommandBufferBeginInfo</code> 结构体用来表示 <code>Command-Buffer</code> 开始的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line"><span class="built_in">vkBeginCommandBuffer</span>(commandBuffer[<span class="number">0</span>], &amp;beginInfo);</span><br></pre></td></tr></table></figure><p>这里要注意的参数是 <code>flags</code> ，表示 <code>Command-Buffer</code> 的用途：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandBufferUsageFlagBits</span> &#123;</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandBufferUsageFlagBits;</span><br></pre></td></tr></table></figure><p>我们用的 <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> 表示该 Command-Buffer 只使用提交一次，用完之后就会被重置，并且每次提交时都需要重新记录。</p><p>直接调用 <code>vkEndCommandBuffer</code> 方法就可以结束记录，此时就可以提交了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkEndCommandBuffer</span>(commandBuffer[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>接下来通过 <code>vkQueueSubmit</code> 方法将 <code>Command-Buffer</code> 提交到 <code>Queue</code> 上。同样的还是需要创建一个 <code>VkSubmitInfo</code> 结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubmitInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                       waitSemaphoreCount;  <span class="comment">// 等待的 Semaphore 数量</span></span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pWaitSemaphores;     <span class="comment">// 等待的 Semaphore 数组指针</span></span><br><span class="line">    <span class="type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;   <span class="comment">// 在哪个阶段进行等待</span></span><br><span class="line">    <span class="type">uint32_t</span>                       commandBufferCount;  <span class="comment">// 提交的 Command-Buffer 数量</span></span><br><span class="line">    <span class="type">const</span> VkCommandBuffer*         pCommandBuffers;     <span class="comment">// 具体的 Command-Buffer 数组指针</span></span><br><span class="line">    <span class="type">uint32_t</span>                       signalSemaphoreCount;  <span class="comment">//执行结束后通知的 Semaphore 数量</span></span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pSignalSemaphores;     <span class="comment">//执行结束后通知的 Semaphore 数组指针</span></span><br><span class="line">&#125; VkSubmitInfo;</span><br></pre></td></tr></table></figure><p>它的参数比较多，并且涉及到 <code>Command-Buffer</code> 之间的同步关系了，上面已经提到过 Semaphore 和 Fence 的相关内容。</p><p>如果只是简单的提交 <code>Command-Buffer</code>，那就不需要考虑 <code>Semaphore</code> 这些同步机制了，把相应的参数都设置为 <code>nullptr</code>，或者直接不设置也行，最后提交就好了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的提交过程</span></span><br><span class="line"><span class="comment">// 开始记录</span></span><br><span class="line">VkCommandBufferBeginInfo beginInfo1 = &#123;&#125;;</span><br><span class="line">beginInfo1.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">beginInfo1.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line"><span class="built_in">vkBeginCommandBuffer</span>(commandBuffer[<span class="number">0</span>], &amp;beginInfo1);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 省略中间的 vkCmdXXXX 系列方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束记录</span></span><br><span class="line"><span class="built_in">vkEndCommandBuffer</span>(commandBuffer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">VkSubmitInfo submitInfo1 = &#123;&#125;;</span><br><span class="line">submitInfo1.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line"><span class="comment">// pWaitSemaphores 和 pSignalSemaphores 都不设置，只是提交</span></span><br><span class="line">submitInfo1.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">submitInfo1.pCommandBuffers = &amp;commandBuffer[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意最后的参数 临时设置为 VK_NULL_HANDLE，也可以设置为 Fence 来同步</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(info.queue, <span class="number">1</span>, &amp;submitInfo1, VK_NULL_HANDLE);</span><br></pre></td></tr></table></figure><p>以上就完成了 <code>Command-Buffer</code> 提交到 <code>Queue</code> 的过程，省略了 <code>Semaphores</code> 和 <code>Fences</code> 的同步机制，当然也可以把它们加上。</p><p>我们在 <code>vkQueueSubmit</code> 的最后一个参数设置为了 <code>VK_NULL_HANDLE</code> ，这是 Vulkan 中设置为 <code>NULL</code> 的一个方法（其实是设置了一个整数 0 ），也可以设置 <code>Fence</code> ，表示我们要等待该 <code>Command-Buffer</code> 在 <code>Queue</code> 执行结束，当 <code>vkQueueSubmit</code> 的最后参数传入 <code>Fence</code> 后，就可以通过 <code>Fence</code> 等待该 <code>Command-Buffer</code> 执行结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Fence</span></span><br><span class="line">VkFence drawFence;</span><br><span class="line">VkFenceCreateInfo fenceCreateInfo = &#123;&#125;;</span><br><span class="line">fenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line"><span class="comment">// 该参数表示 Fence 的状态，如果不设置或者为 0 表示 unsignaled state</span></span><br><span class="line">fence_info.flags = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">vkCreateFence</span>(info.device, &amp;fenceCreateInfo, <span class="literal">nullptr</span>, &amp;drawFence);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 最后的参数设置为 Fence 来同步</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(info.queue, <span class="number">1</span>, &amp;submitInfo1, &amp;drawFence);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 Command buffer 执行结束</span></span><br><span class="line">VkResult res;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    res = <span class="built_in">vkWaitForFences</span>(info.device, <span class="number">1</span>, &amp;drawFence, VK_TRUE, UINT64_MAX);</span><br><span class="line">&#125; <span class="keyword">while</span> (res == VK_TIMEOUT);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节来学习 Vulkan 多线程渲染的设计理念和执行过程，学习过程中可以深入理解 Vulkan 中 Queue 和 Command Buffer 的关系与作用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Vulkan/"/>
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>【Vulkan】常用组件总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/16/20220716-Vulkan-Vulkan%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/16/20220716-Vulkan-Vulkan%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-16T03:28:39.000Z</published>
    <updated>2022-07-17T02:20:48.040Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结 Vulkan 常用组件之间的关系，以便于后续关于 Vulkan 多线程渲染、内存管理、资源绑定、状态管理等部分的讨论。下图展示了 Vulkan 中重要的组件及其工作流程，我们在之后还会反复见到这张图。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/16/20220716-Vulkan-Vulkan%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/vulkan-instance-device-queue.png" alt="vulkan-instance-device-queue"></p><p><em><span id="more"></span></em></p><p> Vulkan 相比于 DX12 和 Metal，其接口包装的最全也最复杂，但基本能够覆盖 DX12 和 Metal 的功能并且具备非常好的跨平台能力。首先来总结 Vulkan 中各种对象之间的关系。</p><p>下图展示了 Vulkan 中大部分常用对象和它们之间的关系，下面从上到下具体来介绍一下，这里要注意，实际 API 会有个 Vk 前缀，比如图里 Instance，在代码中是 VkInstance，CommandBuffer 在代码中是 VkCommandBuffer：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/16/20220716-Vulkan-Vulkan%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/v2-adcf46b99591a0e498c0dd345042f3c8_r.jpg" alt="v2-adcf46b99591a0e498c0dd345042f3c8_r"></p><ul><li><strong>Instance</strong>：全局的 Vulkan 实例，有一些全局设置存在这个对象上，<strong>对应于 OpenGL 中的 context</strong>。正常情况一个游戏就创建一个。</li><li><strong>SurfaceKHR：</strong>窗口，这个应该不算 Vulkan 内部的，属于扩展，因为毕竟 Vulkan 要显示到实际的系统窗口里，这个对象主要处理和系统窗口之间的关系，各种设置之类。</li><li><strong>PhysicalDevice</strong>：物理设备，这个就是实际的硬件，比如显卡，集成显卡就算两个设备，可以通过全局函数枚举出来所有设备，<strong>所以 VkPhysicalDevice 只是对 GPU 的抽象</strong>。这里 Queue Family，Memory Heap 就是物理上提供的队列或者显存之类。</li><li><strong>Device</strong>：这个是逻辑设备的封装，一个物理设备可能有多种功能，可以把一种功能归为一个逻辑设备。一个物理设备可以对应多个逻辑设备。因此 VkDevice 是 VkPhysicalDevice 的子功能集抽象；由于 GPU 中有Queue的概念，这一点被 OpenGL 屏蔽了；但是 Vulkan 暴露了出来；GPU 不一定整个使用；可以使用其中部分的 queue，通常图形引擎只用两个：present 和 graphics，因此，用户可以自己选择 queue “打包”为 1 个 Device（逻辑设备）构造出来。Device 是一个基础概念，几乎绝大部分函数都需要 Device 作为输入参数，由于 Vulkan 是 C，没有类的概念，<strong>从 C++ 角度来看，Vulkan 大部分函数都是 Device 的成员函数</strong>。</li><li><strong>Queue</strong>：这个是设备提供的队列，一般来说，提交给硬件的命令，硬件设备也不是马上执行的，而是放在自己队列里再慢慢执行，当然有的设备也提供多个队列。</li><li><strong>CommandBuffer</strong>：<strong>这个就是具体业务提交的命令缓冲区，drawcall 就是先交到这里</strong>。CommandPool 是创建 CommandBuffer 的对象池，因为 CommandBuffer 创建销毁都比较耗，所以有个池子可以重用以提高性能，另外池子本身是绑定 DeviceFamily 的，所以多个设备的命令没法混一起交。CommandBuffer 是先收集一大堆命令，然后用 vkQueueSubmit 提交给设备的 Queue。</li><li><strong>Buffer&#x2F;Image</strong>：<strong>Buffer 可以理解为一段一维的内存数据</strong>，就像我们平常代码里写的 char* 指针加一个大小表示的区域，也可以说是一维数组，<strong>Image 可以理解为一段多维的内存数据</strong>，也可以说是多维数组，贴图一般都是二维的，所以要用这个表示，当然也能表示一维的，最高三维，这里都是纯数据。Vulkan 本身没有 VertexBuffer 或 IndexBuffer 这样的概念，他们都是Buffer。</li><li><strong>BufferView&#x2F;ImageView</strong>：这两个就是对应 Buffer 和 Image 的视图，本身没存数据，相当于是 Buffer 和 Image 的解读说明书，让 Vulkan 知道具体怎么解释一段内存，要和 Buffer 或者 Image 绑定使用。</li><li><strong>Sampler</strong>：采样器，就是个数据的壳，也是告诉 Vulkan 具体怎么解读数据的。但和 ImageView 不一样，他<strong>不需要绑定到 Image 上</strong>。</li><li><strong>DescriptorSet</strong>：描述符集，shader 没法直接访问资源，要通过 DescriptorSet 来访问，<strong>DescriptorSet  其实就是个内存到 shader 的映射器</strong>。DX12 里叫描述符堆 DescriptorHeap。为什么要搞一个这东西呢？<strong>主要是为了让 shader 复用资源，把需要的资源接口定义好，当贴图或 Buffer 什么的发生了变化，只要还符合接口格式要求，那么就还是能复用相同 shader</strong>。假如没有这一层，直接让 shader 绑死资源，那么换一个贴图就要一个新的 shader，这样就太不灵活了。DescriptorSet 也是通过池来创建的，需要先指定布局 DescriptorSetLayout，相当于是个模板。多个 DescriptorSet 可以通过 PipelineLayout 绑定到 CommandBuffer 上。</li><li><strong>FrameBuffer</strong>：<strong>就是最后要画到屏幕的那个 RT</strong>。BeginRenderPass 的时候，就要带上 FrameBuffer 这个参数，这样 Vulkan 才知道往哪画。每个 RenderPass 都对应一个 FrameBuffer，也就是说可以创建多个 FrameBuffer，然后多个线程同时画，除了上面说的在 CommandBuffer 上能多线程，这里也能多线程。vkCmdBeginRenderPass 和 vkCmdEndRenderPass 之间的代码，就是真正绘制的代码。默认 RenderPass 只有一个 Subpass，创建 RenderPass 时候的参数里可以设多个 Subpass，绘制时候通过 vkCmdNextSubpass 切换。</li><li><strong>Pipeline</strong>：就是最外层的一个大壳，<strong>要设置整个渲染管线每一步的流程的参数</strong>。分两种，一个图形管线，一个计算管线。计算管线就一个阶段，而图形管线有很多个阶段，是从上到下执行的。VkPipeline 其实对应的是 OpenGL 的 ShaderProgram，但是 shaderProgram 的创建只需要几个 shader 就行了。而创建一个 VkPipeline 要复杂的多得多，因为 VkPipeline 几乎把所有渲染的配置都包含进去了，比如 OpenGL 的 glViewport() 这个函数可以随时运行，但是在 Vulkan 就不行，Pipeline 创建时必须指定视口变换的参数（当然开放了接口可以修改），还有什么多重采样，面剔除，光栅化等等。<strong>概括来说，OpenGL 那些配置参数的函数被 Vulkan 分类打包为若干个结构体，这些结构在创建 VkPipeline 时必须事先准备好</strong>。</li><li><strong>Pass 和 Subpass</strong>：一个 Pass 可以包含多个 Subpass，<strong>一个 Subpass 才是一套渲染管线状态下的一次渲染</strong>，因此在创建管线 Pipeline 的时候要绑定 RenderPass 和对应的 Subpass 索引，那么 Subpass 的意义是什么呢？使用 Subpass 可以不用把渲染结果回写回内存，就可以在 Subpass 之间传递数据，这样就能很快。尤其是移动端，一般都是分 Tile 绘制的，比如 3 个 pass，如果不用 Subpass 绘制，可能就要先画每个 Tile 的 pass1，再画每个 Tile 的 pass2，再画每个 Tile 的 pass3。如果 pass2 要利用 pass1 的绘制结果，pass1 会先把结果拷回内存，pass2 要再从内存上拷到显存里，这样两次来回读写就有额外的带宽开销。而如果使用 Subpass，会先把第一个 tile 的Subpass1 ~ Subpass3执行完，再执行第二个 tile 的Subpass1 ~ Subpass3，直到所有 tile 执行完，如果 Subpass2 要复用 Subpass1 的结果，不需要拷回内存，直接 fetch 就可以了，这样就不会有额外的开销，就像是有了免费的 G-Buffer 一样，但缺点就是只能复用 Tile 内的结果。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结 Vulkan 常用组件之间的关系，以便于后续关于 Vulkan 多线程渲染、内存管理、资源绑定、状态管理等部分的讨论。下图展示了 Vulkan 中重要的组件及其工作流程，我们在之后还会反复见到这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lz328.github.io/LycTechStack.github.io/2022/07/16/20220716-Vulkan-Vulkan%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/vulkan-instance-device-queue.png&quot; alt=&quot;vulkan-instance-device-queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Vulkan/"/>
    
    
    <category term="Vulkan" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>【Piccolo代码解读】渲染系统（二）渲染路径的实现</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/13/20220713-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/13/20220713-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-07-13T06:19:05.000Z</published>
    <updated>2022-07-13T06:20:18.938Z</updated>
    
    <content type="html"><![CDATA[<p>上一次我们了解了 Piccolo 引擎中渲染的基本流程，包括 Logic Tick 和 Render Tick 的数据交换和 RenderTick 的大致过程，这一节我们来详细看这些过程都是如何实现的，在此基础上下一节尝试为整个渲染流程加入一个 Color Grading Pass。</p><p><em><span id="more"></span></em></p><h3 id="1-Render-Tick-整体流程"><a href="#1-Render-Tick-整体流程" class="headerlink" title="1 Render Tick 整体流程"></a>1 Render Tick 整体流程</h3><p>首先回顾上一节中看过的 Render Tick 整体流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process swap data between logic and render contexts</span></span><br><span class="line">    <span class="built_in">processSwapData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare render command context</span></span><br><span class="line">    m_rhi-&gt;<span class="built_in">prepareContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame buffer</span></span><br><span class="line">    m_render_resource-&gt;<span class="built_in">updatePerFrameBuffer</span>(m_render_scene, m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame visible objects</span></span><br><span class="line">    m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                         m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare pipeline&#x27;s render passes data</span></span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">preparePassData</span>(m_render_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render one frame</span></span><br><span class="line">    <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>processSwapData()</code> 上一节中已经学习过， <code>m_rhi-&gt;prepareContext()</code> 用来准备渲染命令，其内部就是初始化 command buffer：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanRHI::prepareContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_p_current_frame_index  = &amp;m_current_frame_index;</span><br><span class="line">    m_current_command_buffer = m_command_buffers[m_current_frame_index];</span><br><span class="line">    m_p_command_buffers      = m_command_buffers;</span><br><span class="line">    m_p_command_pools        = m_command_pools;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一些需要具体看的操作，我们一一探究。</p><h3 id="2-updatePerFrameBuffer"><a href="#2-updatePerFrameBuffer" class="headerlink" title="2 updatePerFrameBuffer"></a>2 updatePerFrameBuffer</h3><p><code>m_render_resource-&gt;updatePerFrameBuffer(m_render_scene, m_render_camera)</code> 负责准备每一帧渲染中的场景数据，包括 VP 矩阵，相机位置，环境光，点光源数量，每个点光源的强度、位置、半径衰减以及平行光属性，把这些数据存到 <code>RenderResource</code> 类的对应成员中用于之后渲染使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderResource::updatePerFrameBuffer</span><span class="params">(std::shared_ptr&lt;RenderScene&gt;  render_scene,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          std::shared_ptr&lt;RenderCamera&gt; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix4x4 view_matrix      = camera-&gt;<span class="built_in">getViewMatrix</span>();</span><br><span class="line">    Matrix4x4 proj_matrix      = camera-&gt;<span class="built_in">getPersProjMatrix</span>();</span><br><span class="line">    Vector3   camera_position  = camera-&gt;<span class="built_in">position</span>();</span><br><span class="line">    glm::mat4 proj_view_matrix = GLMUtil::<span class="built_in">fromMat4x4</span>(proj_matrix * view_matrix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ambient light</span></span><br><span class="line">    Vector3  ambient_light   = render_scene-&gt;m_ambient_light.m_irradiance;</span><br><span class="line">    <span class="type">uint32_t</span> point_light_num = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(render_scene-&gt;m_point_light_list.m_lights.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ubo data</span></span><br><span class="line">    m_mesh_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.camera_position  = GLMUtil::<span class="built_in">fromVec3</span>(camera_position);</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.ambient_light    = ambient_light;</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.point_light_num  = point_light_num;</span><br><span class="line"></span><br><span class="line">    m_mesh_point_light_shadow_perframe_storage_buffer_object.point_light_num = point_light_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// point lights</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; point_light_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point_light_position = render_scene-&gt;m_point_light_list.m_lights[i].m_position;</span><br><span class="line">        Vector3 point_light_intensity =</span><br><span class="line">            render_scene-&gt;m_point_light_list.m_lights[i].m_flux / (<span class="number">4.0f</span> * glm::<span class="built_in">pi</span>&lt;<span class="type">float</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> radius = render_scene-&gt;m_point_light_list.m_lights[i].<span class="built_in">calculateRadius</span>();</span><br><span class="line"></span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].position  = point_light_position;</span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].radius    = radius;</span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].intensity = point_light_intensity;</span><br><span class="line"></span><br><span class="line">        m_mesh_point_light_shadow_perframe_storage_buffer_object.point_lights_position_and_radius[i] =</span><br><span class="line">            <span class="built_in">Vector4</span>(point_light_position, radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// directional light</span></span><br><span class="line">    m_mesh_perframe_storage_buffer_object.scene_directional_light.direction =</span><br><span class="line">        render_scene-&gt;m_directional_light.m_direction.<span class="built_in">normalisedCopy</span>();</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.scene_directional_light.color = render_scene-&gt;m_directional_light.m_color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pick pass view projection matrix</span></span><br><span class="line">    m_mesh_inefficient_pick_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line"></span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.eye_position     = GLMUtil::<span class="built_in">fromVec3</span>(camera_position);</span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.up_direction     = GLMUtil::<span class="built_in">fromVec3</span>(camera-&gt;<span class="built_in">up</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-updateVisibleObjects"><a href="#3-updateVisibleObjects" class="headerlink" title="3 updateVisibleObjects"></a>3 updateVisibleObjects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                             m_render_camera);</span><br></pre></td></tr></table></figure><p>这个函数负责预先计算可见的物体，将完全不可见的物体剔除掉，不送入之后的渲染流程中，将可见物体的属性设置好便于之后使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderScene::updateVisibleObjects</span><span class="params">(std::shared_ptr&lt;RenderResource&gt; render_resource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       std::shared_ptr&lt;RenderCamera&gt;   camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">updateVisibleObjectsDirectionalLight</span>(render_resource, camera);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsPointLight</span>(render_resource);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsMainCamera</span>(render_resource, camera);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsAxis</span>(render_resource);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsParticle</span>(render_resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中调用了各种可见性检测函数，包括对平行光的物体可见性、对点光源的物体可见性，对相机的物体可见性以及坐标轴可见性，坐标轴可见性是为了我们在编辑模式选中物体的时候显示坐标轴，所以也要绘制，而最后一个 <code>updateVisibleObjectsParticle</code> 还没有实现， 我们以 <code>updateVisibleObjectsMainCamera</code> 为例来看可见性检测具体干了什么，其他的也是大同小异，最后会提到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void RenderScene::updateVisibleObjectsMainCamera(std::shared_ptr&lt;RenderResource&gt; render_resource,</span><br><span class="line">                                                     std::shared_ptr&lt;RenderCamera&gt;   camera)</span><br><span class="line">&#123;</span><br><span class="line">    m_main_camera_visible_mesh_nodes.clear();</span><br><span class="line"></span><br><span class="line">    Matrix4x4 view_matrix      = camera-&gt;getViewMatrix();</span><br><span class="line">    Matrix4x4 proj_matrix      = camera-&gt;getPersProjMatrix();</span><br><span class="line">    Matrix4x4 proj_view_matrix = proj_matrix * view_matrix;</span><br><span class="line"></span><br><span class="line">    ClusterFrustum f = CreateClusterFrustumFromMatrix(GLMUtil::fromMat4x4(proj_view_matrix), -1.0, 1.0, -1.0, 1.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">    for (const RenderEntity&amp; entity : m_render_entities)</span><br><span class="line">    &#123;</span><br><span class="line">        BoundingBox mesh_asset_bounding_box &#123;entity.m_bounding_box.getMinCorner(),</span><br><span class="line">                                                 entity.m_bounding_box.getMaxCorner()&#125;;</span><br><span class="line"></span><br><span class="line">        if (TiledFrustumIntersectBox(f, BoundingBoxTransform(mesh_asset_bounding_box, GLMUtil::fromMat4x4(entity.m_model_matrix))))</span><br><span class="line">        &#123;</span><br><span class="line">            m_main_camera_visible_mesh_nodes.emplace_back();</span><br><span class="line">            RenderMeshNode&amp; temp_node = m_main_camera_visible_mesh_nodes.back();</span><br><span class="line"></span><br><span class="line">            temp_node.model_matrix = GLMUtil::fromMat4x4(entity.m_model_matrix);</span><br><span class="line"></span><br><span class="line">            assert(entity.m_joint_matrices.size() &lt;= m_mesh_vertex_blending_max_joint_count);</span><br><span class="line">            for (size_t joint_index = 0; joint_index &lt; entity.m_joint_matrices.size(); joint_index++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node.joint_matrices[joint_index] = GLMUtil::fromMat4x4(entity.m_joint_matrices[joint_index]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp_node.node_id = entity.m_instance_id;</span><br><span class="line"></span><br><span class="line">            VulkanMesh&amp; mesh_asset           = render_resource-&gt;getEntityMesh(entity);</span><br><span class="line">            temp_node.ref_mesh               = &amp;mesh_asset;</span><br><span class="line">            temp_node.enable_vertex_blending = entity.m_enable_vertex_blending;</span><br><span class="line"></span><br><span class="line">            VulkanPBRMaterial&amp; material_asset = render_resource-&gt;getEntityMaterial(entity);</span><br><span class="line">            temp_node.ref_material            = &amp;material_asset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取相机的 PV 矩阵，然后根据矩阵构建世界空间下的视锥体，这部分内容我们在之前学过，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/">【光栅化渲染器】（六）剔除与裁剪</a>第 2 部分，有了视锥体就可以利用视锥体和 bounding box 求交来判断是否可见了，如果可见就将该物体的模型矩阵，骨骼矩阵、材质等属性记录下来。</p><p>对于平行光的可见性检测，需要先计算平行光覆盖的范围的 Bounding Box，然后后后续的操作都一样；对于点光源，需要分别计算每一个点光源覆盖的球体范围，计算一个 Bounding Sphere，然后逐点光源进行上述步骤即可。</p><p>至于求交函数，分为视锥体与 Bounding Box 求交以及 Bounding Box 与 Bounding Sphere 求交，前者我们学习过，利用点和视锥体六个平面的关系判断，后者利用球心到 Bounding Box 六个面的距离和球的半径判断即可，具体函数实现可以自行查看工程中的代码。</p><h3 id="4-preparePassData"><a href="#4-preparePassData" class="headerlink" title="4 preparePassData"></a>4 preparePassData</h3><p><code>m_render_pipeline-&gt;preparePassData(m_render_resource)</code> 负责准备渲染所需的 pass 数据，包括相机的 pass，编辑模式下选中物体时的显示 pass（主要是绘制坐标轴），平行光的 shadow pass，点光源的 shadow pass 等：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipelineBase::preparePassData</span><span class="params">(std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_main_camera_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_pick_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_directional_light_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_point_light_shadow_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-forwardRender"><a href="#5-forwardRender" class="headerlink" title="5 forwardRender"></a>5 forwardRender</h3><p>经过上面的场景光源信息、相机信息、物体信息和渲染的 pass 的准备，我们就可以进行渲染了，于是接下来根据渲染路径选择不同的渲染 pipeline：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render one frame</span></span><br><span class="line"><span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">&#123;</span><br><span class="line">    m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">&#123;</span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看前向渲染 <code>forwardRender</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipeline::forwardRender</span><span class="params">(std::shared_ptr&lt;RHI&gt; rhi, std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VulkanRHI*      vulkan_rhi      = <span class="built_in">static_cast</span>&lt;VulkanRHI*&gt;(rhi.<span class="built_in">get</span>());</span><br><span class="line">    RenderResource* vulkan_resource = <span class="built_in">static_cast</span>&lt;RenderResource*&gt;(render_resource.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    vulkan_resource-&gt;<span class="built_in">resetRingBufferOffset</span>(vulkan_rhi-&gt;m_current_frame_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">waitForFences</span>();</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">resetCommandPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> recreate_swapchain =</span><br><span class="line">        vulkan_rhi-&gt;<span class="built_in">prepareBeforePass</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (recreate_swapchain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;DirectionalLightShadowPass*&gt;(m_directional_light_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;PointLightShadowPass*&gt;(m_point_light_shadow_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    ColorGradingPass&amp; color_grading_pass = *(<span class="built_in">static_cast</span>&lt;ColorGradingPass*&gt;(m_color_grading_pass.<span class="built_in">get</span>()));</span><br><span class="line">    FXAAPass&amp;         fxaa_pass          = *(<span class="built_in">static_cast</span>&lt;FXAAPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    ToneMappingPass&amp;  tone_mapping_pass  = *(<span class="built_in">static_cast</span>&lt;ToneMappingPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    UIPass&amp;           ui_pass            = *(<span class="built_in">static_cast</span>&lt;UIPass*&gt;(m_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line">    CombineUIPass&amp;    combine_ui_pass    = *(<span class="built_in">static_cast</span>&lt;CombineUIPass*&gt;(m_combine_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;MainCameraPass*&gt;(m_main_camera_pass.<span class="built_in">get</span>())</span><br><span class="line">        -&gt;<span class="built_in">drawForward</span>(color_grading_pass,</span><br><span class="line">                      fxaa_pass,</span><br><span class="line">                      tone_mapping_pass,</span><br><span class="line">                      ui_pass,</span><br><span class="line">                      combine_ui_pass,</span><br><span class="line">                      vulkan_rhi-&gt;m_current_swapchain_image_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">submitRendering</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在一切准备工作完成之后，首先进行了平行光的 shadow pass 和点光源的 shadow pass 生成光照阴影，然后是主相机的 pass，在主相机 pass 的 <code>drawForward(...)</code> 函数中依次执行了：</p><ul><li><code>drawMeshLighting()</code></li><li><code>drawSkybox()</code></li><li><code>drawBillboardParticle()</code>（未实现）</li><li><code>tone_mapping_pass.draw()</code></li><li><code>color_grading_pass.draw()</code> </li><li><code>if (m_enable_fxaa) fxaa_pass.draw()</code></li><li><code>drawAxis()</code></li><li><code>ui_pass.draw()</code>（未实现）</li><li><code>combine_ui_pass.draw()</code>（未实现）</li></ul><h3 id="6-deferredRender"><a href="#6-deferredRender" class="headerlink" title="6 deferredRender"></a>6 deferredRender</h3><p>延迟渲染的代码和前向渲染基本一致，只是最后调用的是主相机 pass 中的 <code>draw(...)</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipeline::deferredRender</span><span class="params">(std::shared_ptr&lt;RHI&gt; rhi, std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VulkanRHI*      vulkan_rhi      = <span class="built_in">static_cast</span>&lt;VulkanRHI*&gt;(rhi.<span class="built_in">get</span>());</span><br><span class="line">    RenderResource* vulkan_resource = <span class="built_in">static_cast</span>&lt;RenderResource*&gt;(render_resource.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    vulkan_resource-&gt;<span class="built_in">resetRingBufferOffset</span>(vulkan_rhi-&gt;m_current_frame_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">waitForFences</span>();</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">resetCommandPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> recreate_swapchain =</span><br><span class="line">        vulkan_rhi-&gt;<span class="built_in">prepareBeforePass</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (recreate_swapchain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;DirectionalLightShadowPass*&gt;(m_directional_light_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;PointLightShadowPass*&gt;(m_point_light_shadow_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    ColorGradingPass&amp; color_grading_pass = *(<span class="built_in">static_cast</span>&lt;ColorGradingPass*&gt;(m_color_grading_pass.<span class="built_in">get</span>()));</span><br><span class="line">    FXAAPass&amp;         fxaa_pass          = *(<span class="built_in">static_cast</span>&lt;FXAAPass*&gt;(m_fxaa_pass.<span class="built_in">get</span>()));</span><br><span class="line">    ToneMappingPass&amp;  tone_mapping_pass  = *(<span class="built_in">static_cast</span>&lt;ToneMappingPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    UIPass&amp;           ui_pass            = *(<span class="built_in">static_cast</span>&lt;UIPass*&gt;(m_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line">    CombineUIPass&amp;    combine_ui_pass    = *(<span class="built_in">static_cast</span>&lt;CombineUIPass*&gt;(m_combine_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;MainCameraPass*&gt;(m_main_camera_pass.<span class="built_in">get</span>())</span><br><span class="line">        -&gt;<span class="built_in">draw</span>(color_grading_pass,</span><br><span class="line">               fxaa_pass,</span><br><span class="line">               tone_mapping_pass,</span><br><span class="line">               ui_pass,</span><br><span class="line">               combine_ui_pass,</span><br><span class="line">               vulkan_rhi-&gt;m_current_swapchain_image_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">submitRendering</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主相机 pass 的 <code>draw(...)</code> 函数中依次执行了：</p><ul><li><code>drawMeshGbuffer()</code></li><li><code>drawDeferredLighting()</code></li><li><code>drawBillboardParticle()</code>（未实现）</li><li><code>tone_mapping_pass.draw()</code></li><li><code>color_grading_pass.draw()</code> </li><li><code>if (m_enable_fxaa) fxaa_pass.draw()</code></li><li><code>drawAxis()</code></li><li><code>ui_pass.draw()</code>（未实现）</li><li><code>combine_ui_pass.draw()</code>（未实现）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次我们了解了 Piccolo 引擎中渲染的基本流程，包括 Logic Tick 和 Render Tick 的数据交换和 RenderTick 的大致过程，这一节我们来详细看这些过程都是如何实现的，在此基础上下一节尝试为整个渲染流程加入一个 Color Grading Pass。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Piccolo引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Piccolo%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
