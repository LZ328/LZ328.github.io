<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-05-15T07:25:56.380Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Real-Time Rendering】程序噪声总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T07:24:30.000Z</published>
    <updated>2022-05-15T07:25:56.380Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇提到过，程序纹理基本上都是通过噪声纹理来实现的，不同的噪声纹理适合制作不同的效果，如云雾、水波、大理石、能量波等。这一节对常见的程序噪声算法进行总结，主要包括：</p><ul><li>Value Noise</li><li>Gradient Noise（Perlin Noise、Simplex Noise）</li><li>Voronoi Noise 和 Worley Noise</li><li>Fractal Brownian Motion</li><li>Curl Noise</li><li>White Noise</li></ul><p><em><span id="more"></span></em></p><h3 id="1-噪声概述"><a href="#1-噪声概述" class="headerlink" title="1 噪声概述"></a>1 噪声概述</h3><p>对于图形学而言，噪声通常会用作程序化效果生成（如地形、水面、云层等），其最开始在图形学中引进，是为了代替贴图给物件添加纹理以解决电脑内存不足的问题（不过噪声的计算通常比贴图采样要慢一点，因此现在通常是直接使用噪声贴图来代替 shader 的随机数计算），但是并不是所有的噪声都是有用的，只有那些数据具有一定的连贯性的噪声才算是有用的噪声，而如果噪声不连贯的话，在进行贴图采样后，得到的结果就会呈现一种混乱的状态，这种对于程序化生成而言并没有什么作用，因此图形学中的一个理想的噪声应该具备如下几个特性：</p><ul><li>伪随机（不变性）：所谓的噪声只是看起来随机而已，实际上，需要保证在同样的输入下，肯定能够得到同样的输出，否则可能出现渲染的结果随着时间或者观察位置而变化，这就不够物理了，而且结果不可控也跟实际需要不符合。</li><li>只返回一个 float 值，不管输入是几维的，只返回一个 float。</li><li>噪声通常是带限的（band-limited），噪声频率过高通常会导致锯齿（镜头旋转等情况下常见），因此通常其频率范围都是有限的，不过对于一些平缓（大尺寸）变化的情形需要一些低频噪声，而对于一些细节变化则需要一些高频噪声。</li><li>噪声需要具有一定的连续性，比如某些情况下需要计算噪声的导数，甚至需要计算高阶微分，因此对于噪声的连续性有一定的要求。</li><li>四方连续，为了保证 tiling 时不会出现肉眼可辩的缝隙，需要保证上下左右四个方向都是连续的（如果使用了大量 tiling 可能会导致重复纹样，而解决重复的做法就是将 tiling 尺寸设得足够大，虽然可能会引入其他问题，但是这个问题可以通过其他方式来规避）。</li></ul><h3 id="2-Value-Noise"><a href="#2-Value-Noise" class="headerlink" title="2 Value Noise"></a>2 Value Noise</h3><p>Value Noise 是最简单的一类噪声，其实现算法非常简单，以 2D 为例，我们在一个规整的 2D 网格上的每个顶点（如下图中的每个红色小圆点）放置一个随机数（通常范围在 [0, 1] 之间），之后使用线性插值填充每个小方格，得到的结果就是 Value Noise。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-442ada94477d7682.png" alt="19200103-442ada94477d7682"></p><h3 id="3-Gradient-Noise"><a href="#3-Gradient-Noise" class="headerlink" title="3 Gradient Noise"></a>3 Gradient Noise</h3><p>Value Noise 是通过对周边顶点的随机 Value 进行插值来得到噪声贴图的，而 Gradient Noise 的实现原理与 Value Noise 类似，不同的是，这里是通过对周边顶点的 Gradient（梯度，可以理解为某个点的速度，常用向量来表示）进行插值来输出噪声贴图。</p><p>对梯度进行插值，这里有一个问题需要解决，那就是对向量的插值，得到的结果肯定还是向量，而前面说过，噪声的输出结果应该是一个浮点数，那么要怎么实现这二者的转换呢？这里的做法是将当前像素点到对应顶点的连线作为一个向量，与这个顶点的梯度进行点乘，就得到了对应的浮点数，之后再对这个浮点数应用与 Value Noise 一样的插值算法，就能得到对应的噪声结果了。</p><p>根据插值顶点选取算法的不同，这里又有不同的细分，Perlin Noise 与前面的 Value Noise 类似，都是选取周边四个顶点（如果是 3D 的，就是周边 8 个顶点，以此类推）的数据进行插值，而 Simplex Noise 则不同，选取的是等边三个顶点的数据（如果是 3D，选取的就是正四面体的四个顶点进行插值），下面来看这两种噪声的实现细节。</p><h4 id="3-1-Perlin-Noise"><a href="#3-1-Perlin-Noise" class="headerlink" title="3.1 Perlin Noise"></a>3.1 Perlin Noise</h4><p>Perlin Noise 非常常见，关于 Perlin  Noise 可以查看之前在光线追踪中的实现：<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>。</p><h4 id="3-2-Simplex-Noise"><a href="#3-2-Simplex-Noise" class="headerlink" title="3.2 Simplex Noise"></a>3.2 Simplex Noise</h4><p>实际上，Simplex 噪声跟 Perlin 噪声都是 Ken Perlin 发明的，后者是对前者的优化替代，Simplex 实际上是一种算法，既可以用于实现 Value Noise，同样也可以用于实现 Gradient Noise，不过由于 Gradient Noise 的应用范围更广，因此这里我们就直接跳过 Value Noise 部分，只介绍用于实现 Gradient Noise 的部分。</p><p>Simplex Noise 与 Perlin Noise 的区别在于其插值时所选取的周边顶点的算法不同，具体而言，是选取此像素所从属的 grid 中的正三角形（等边三角形）的三个顶点（即将 Perlin Noise 中的插值正方形沿着对角线一分为二，选取当前像素所在的那个正三角形的三个顶点，对应到 3D 空间，Perlin 使用的是立方体的 8 个顶点，而 Simplex 使用的则是连接相邻三个面的对角线组成的四面体转换后的正立方体的四个顶点）作为插值的数据源。</p><p>相对 Perlin Noise，Simplex 的实现更为简洁，其成本也更低。与前面计算某个像素对应的噪声值需要通过对周边顶点数据进行插值不同，Simplex 采用的是衰减函数，比如根据某个顶点到此像素的距离来计算此顶点数据对于此像素的贡献，之后将周边顶点的贡献进行累加就得到了最终的输出结果。</p><p>前面说到，Simplex 噪声来自于正三角形（正四面体）的数据衰减，那么这个正三角形是怎么来的呢？我们知道，一个 2D 平面，既可以使用正方形进行无缝平铺，这种 tiling 方式对应的就是前面 Value &#x2F; Perlin Noise 的计算基础，同时也可以使用正三角形进行平铺，而这对应的则是 Simplex 噪声的实现基础，这里的一个问题就是这二者是如何转换的，毕竟我们平常使用的基本上都是 grid，也就是正方形的平铺方式。这个转换过程可以参考：</p><ul><li><a href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a>中的 2.2 节</li><li><a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise - Wikipedia</a></li></ul><h3 id="4-Voronoi-Noise-和-Worley-Noise"><a href="#4-Voronoi-Noise-和-Worley-Noise" class="headerlink" title="4 Voronoi Noise 和 Worley Noise"></a>4 Voronoi Noise 和 Worley Noise</h3><p>Voronoi Noise 与 Worley Noise 在形态上十分相似，在图形学中的应用也基本一致，比如同样用于进行云层创建，水底焦散现象模拟等，那同样的噪声为什么会有两个名字呢？实际上图形学中最开始使用的是 Voronoi 噪声，只是这种噪声的实现算法消耗比较高，后面 Steven Worley 对齐进行了改进，提出了以其名字命名的 Worley 噪声。下面我们一起来看一下这两种噪声的实现算法。</p><p>Voronoi 噪声是通过在空间中生成随机分布的多个特征点，之后对于每个需要计算的像素，对所有的特征点进行遍历，找到距离其最近的特征点，以其对应的特征值作为此像素的值进行输出。下图展示了 Voronoi 噪声的生成过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-6ee079fe186022e5.gif" alt="19200103-6ee079fe186022e5"></p><p>Voronoi 噪声的思路很简单，但是由于需要对每个特征点进行遍历，整个算法的复杂度就变得很高了，为了降低计算的消耗，Worley 噪声就应运而生了。</p><p>Worley 噪声是通过将空间（2D &#x2F; 3D）划分成一个个的 cell（正方形 &#x2F; 立方体），在每个 cell 中的随机位置随机生成一个特征点，之后对于每个待计算的像素，搜寻周边的 cell，找到距离其最近的噪点，之后以距离此噪点的距离作为当前像素的噪声结果，就得到了对应的 Worley 噪声。相对于 Voronoi 噪声，Worley 算法的改进点在于将搜寻范围从所有特征点限定在了周边的若干个 cell 之中，理论上最正确的搜索范围是周边 25 个 cell，但实际上如果噪声函数选取得当，使用九宫格进行搜索也能得到正确的结果。下图展示了 Worley 噪声的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-e8fe35196eb9ddd9.png" alt="19200103-e8fe35196eb9ddd9"></p><p>如果将搜索范围换成 9 个 cell，会发现结果会存在异常，这是因为在某些随机函数作用下，九宫格搜索会漏掉一些正确解导致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-bdec0bdd9617cdd0.png" alt="19200103-bdec0bdd9617cdd0"></p><h3 id="5-Fractal-Brownian-Motion"><a href="#5-Fractal-Brownian-Motion" class="headerlink" title="5 Fractal Brownian Motion"></a>5 Fractal Brownian Motion</h3><p>有时候单一频率的噪声不足以满足需求，会需要使用多级噪声累加的结果来实现程序化生成，这种方式我们称之为分形布朗运动（Fractal Brownian Motion，简称 FBM），也称为 Turbulence，简单来说就是将多个不同频率的噪声按照不同的振幅进行混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>中有 Turbulence 应用于 Perlin Noise 的代码实现。还可以将 FBM 应用于 Worley 噪声，得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a89ea620cfe2aad9.png" alt="19200103-a89ea620cfe2aad9"></p><h3 id="6-Curl-Noise"><a href="#6-Curl-Noise" class="headerlink" title="6 Curl Noise"></a>6 Curl Noise</h3><p>Curl 噪声在图形学中有着广泛的应用，比如可以用于对粒子位置进行调制，使之产生卷曲的效果；比如可以对烟雾水流效果进行调制，生成湍流扰动效果等。相对于其他的流体模拟算法，Curl Noise 的生成算法算是十分简单的，但是应用起来效果却并没有减色多少。</p><p>Curl 噪声中的 Curl 可以看成是跟加减乘除号同等的一种运算符号，其输入数据是一个向量，经过 curl 运算之后，就得到了一个 divergence free（无散度）的向量场，这里先介绍下什么是向量的 divergence，即散度：<br>$$<br>div\ \vec a &#x3D; \nabla · \vec a &#x3D; \frac{\partial a_x}{\partial x} + \frac{\partial a_y}{\partial y} + \frac{\partial a_z}{\partial z}<br>$$<br>散度指的是向量三个分量在对应坐标轴方向上的偏微分之和，从物理上来说，指的是一个向量场在某个给定的位置散开或者说收敛的程度，日常生活中常见的流体比如水流，空气，烟雾等都是 divergence-free（无散）的。curl 噪声从物理上来说，可以用来表征用于对向量进行转向的力的大小。</p><p>下面我们来介绍一下 Curl 噪声的实现算法，对一个潜在的 3D 向量场 $\Psi$ 而言，令：<br>$$<br>\vec \Psi &#x3D; (\Psi_1, \Psi_2, \Psi_3)<br>$$<br>由此我们可以计算出其 Curl Velocity 算子：<br>$$<br>\vec v(x,y,z) &#x3D; (\frac{\partial \Psi_3}{\partial y} - \frac{\partial \Psi_2}{\partial z},<br>\frac{\partial \Psi_1}{\partial z} - \frac{\partial \Psi_3}{\partial x},<br>\frac{\partial \Psi_2}{\partial x} - \frac{\partial \Psi_1}{\partial y})<br>$$<br>2D 情况较为简单：<br>$$<br>\vec v(x,y) &#x3D; (\frac{\partial \Psi}{\partial y},-\frac{\partial \Psi}{\partial x})<br>$$<br>根据流体力学可知，上述速度场都是无散的，即：<br>$$<br>\nabla·\vec v &#x3D; 0<br>$$<br>具体来说，假设我们以二维 Perlin 噪声作为向量场，那么最终的 Curl 噪声就可以用如下公式表示：<br>$$<br>\vec v(x,y) &#x3D; (\frac{PerlinNoise(x,y)}{\partial y},-\frac{PerlinNoise(x,y)}{\partial x})<br>$$<br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">curlNoise</span><span class="params">(vec2 uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> eps = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="type">float</span> x = uv.x;</span><br><span class="line">    <span class="type">float</span> y = uv.y;</span><br><span class="line">    <span class="comment">//Find rate of change in X direction</span></span><br><span class="line">    <span class="type">int</span> firstOctave = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> accumOctaves = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> revertPerlin = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> n1 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y + eps), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n2 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y - eps), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> a = (n1 - n2)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find rate of change in Y direction</span></span><br><span class="line">    <span class="type">float</span> n3 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x + eps, y), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n4 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x - eps, y), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> b = (n3 - n4)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Curl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec2</span>(a, -b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-d8bc4eb896a6a039.png" alt="19200103-d8bc4eb896a6a039"></p><p>将之用速度向量来表示，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a5f536670231116e.png" alt="19200103-a5f536670231116e"></p><p>其中灰色部分表示的是原始的 Perlin 噪声，而白色箭头表示的则是 Curl 噪声向量的方向与大小。</p><p>提高噪声频率得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-ef43d7f381fca207.png" alt="19200103-ef43d7f381fca207"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-7b5e9e3939c7b8ce.png" alt="19200103-7b5e9e3939c7b8ce"></p><h3 id="7-White-Noise"><a href="#7-White-Noise" class="headerlink" title="7 White Noise"></a>7 White Noise</h3><p>白噪声（White Noise）是一种在各个频率上的强度都十分均匀的噪声，这种噪声并不平滑，而自然界的各种纹理实际上都是连续的，因此通常不适合用于贴图生成。</p><p>实际上，所谓的白噪声并不是特指的某一种噪声，而是一种信号的统计模型。在离散采样中，白噪声具有如下特点：</p><ul><li>各个采样点之间完全没有数值上的联系</li><li>信号的均值为0，方差有限。</li></ul><p>实现白噪声最简单的算法就是直接使用一个随机数作为返回值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-c17c41b69b51b075.png" alt="19200103-c17c41b69b51b075"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇提到过，程序纹理基本上都是通过噪声纹理来实现的，不同的噪声纹理适合制作不同的效果，如云雾、水波、大理石、能量波等。这一节对常见的程序噪声算法进行总结，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value Noise&lt;/li&gt;
&lt;li&gt;Gradient Noise（Perlin Noise、Simplex Noise）&lt;/li&gt;
&lt;li&gt;Voronoi Noise 和 Worley Noise&lt;/li&gt;
&lt;li&gt;Fractal Brownian Motion&lt;/li&gt;
&lt;li&gt;Curl Noise&lt;/li&gt;
&lt;li&gt;White Noise&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】纹理总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T03:09:44.000Z</published>
    <updated>2022-05-15T09:35:29.304Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中纹理相关知识进行概括总结。主要内容包括：</p><ul><li><p>纹理管线（Texture Pipeline）</p></li><li><p>纹理缓存（Texture Caching）</p></li><li><p>纹理压缩（Texture Compression）</p></li><li><p>体纹理（Volume Texture）</p></li><li><p>立方体贴图（Cube Map）</p></li><li><p>程序纹理（Procedural Texturing）</p></li><li><p>凹凸贴图（Bump Mapping）及其改进</p></li></ul><p><em><span id="more"></span></em></p><h3 id="1-纹理管线"><a href="#1-纹理管线" class="headerlink" title="1 纹理管线"></a>1 纹理管线</h3><p>简单来说，纹理（Texturing）是一种针对物体表面属性进行“建模”的高效技术。图像纹理中的像素通常被称为纹素（Texels），以区别于屏幕上的像素。根据 Kershaw 的术语，通过将投影方程（projector function）运用于空间中的点 ，从而得到一组称为参数空间值（parameter-spacevalues）的关于纹理的数值。这个过程就称为贴图（Mapping，也称映射 ）,也就是纹理贴图（Texture Mapping，也称纹理映射 ）这个词的由来。纹理贴图可以用一个通用的纹理管线来进行描述。<strong>纹理贴图过程的初始点是空间中的一个位置。这个位置可以基于世界空间，但是更常见的是基于模型空间。因为若此位置是基于模型空间的，当模型移动时，其纹理才会随之移动。</strong></p><p>下图展示了单个纹理的通用管线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515094736104.png" alt="image-20220515094736104"></p><ul><li>第一步。通过将投影方程（projector function）运用于空间中的点   ，从而得到一组称为参数空间值（parameter-space values）的关于纹理的数值，即 uv 坐标，在（0, 1）范围内。</li><li>第二步。在使用这些新值访问纹理之前，可以使用一个或者多个映射函数（corresponder function）将参数空间值（parameter-space values  ）转换到纹理空间，即对 uv坐标进行平移和缩放以映射到纹理空间中。</li><li>第三步。使用这些纹理空间值（texture-space locations）从纹理中获取相应的值（obtain value）。例如，可以使用图像纹理的数组索引来检索像素值。</li><li>第四步。再使用值变换函数（value transform function）对检索结果进行值变换，最后使用得到的新值来改变表面属性，如材质或者着色法线等等。</li></ul><p>下图通过一个例子描述了上述过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095022930.png" alt="image-20220515095022930"></p><h4 id="1-1-投影函数"><a href="#1-1-投影函数" class="headerlink" title="1.1 投影函数"></a>1.1 投影函数</h4><p>作为纹理管线的第一步，<strong>投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。</strong></p><p>在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数计算得到投影结果，而是直接使用在美术建模过程中，已经存储在模型顶点数据中的投影结果。</p><h4 id="1-2-映射函数"><a href="#1-2-映射函数" class="headerlink" title="1.2 映射函数"></a>1.2 映射函数</h4><p><strong>映射函数（The Corresponder Function）的作用是将参数空间坐标（parameter-space coordinates）转换为纹理空间位置（texture space locations）。</strong>我们知道图像会出现在物体表面的 (u,v) 位置上，且  uv 值的正常范围在 [0, 1) 范围内。超出这个值域的纹理，其显示方式便可以由映射函数（The Corresponder Function）来决定。</p><p>在  OpenGL 中，这类映射函数称为“封装模式（Warapping Mode）”，在 Direct3D 中，这类函数叫做“寻址模式（Texture Addressing Mode）”。最常见的映射函数有以下几种：</p><ul><li>重复寻址模式，wrap (DirectX)，repeat (OpenGL)。图像在表面上重复出现。</li><li>镜像寻址模式，mirror。图像在物体表面上不断重复，但每次重复时对图像进行镜像或者反转。</li><li>夹取寻址模式，clamp (DirectX)，clamp to edge (OpenGL)。夹取纹理寻址模式将纹理坐标夹取在 [0.0, 1.0] 之间，也就是说，在[0.0, 1.0] 之间就是把纹理复制一遍，然后对于 [0.0, 1.0] 之外的内容，将边缘的内容沿着 u 轴和 v 轴进行延伸。</li><li>边框颜色寻址模式，border (DirectX)，clamp to border (OpenGL)。边框颜色寻址模式就是在 [0.0, 1.0] 之间绘制纹理，然后 [0.0, 1.0] 之外的内容就用边框颜色填充。</li></ul><p>下图展示了上述四种寻址模式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095836855.png" alt="image-20220515095836855"></p><p>另外，每个纹理轴可以使用不同的映射函数。例如在 u 轴使用重复寻址模式，在 v 轴使用取寻址模式。</p><h3 id="2-纹理缓存"><a href="#2-纹理缓存" class="headerlink" title="2 纹理缓存"></a>2 纹理缓存</h3><p>一个复杂的应用程序可能需要相当数量的纹理。快速纹理存储器的数量因系统而异，但你会发现它们永远不够用。于是有了各种各样的纹理缓存（texture caching）技术，但我们一直在上传纹理到内存的开销和纹理单次消耗的内存量之间寻求一个好的平衡点。比如，一个由纹理贴图的多边形对象，初始化在离相机很远的位置，程序也许会只加载 mipmap 中更小的子纹理，就可以很完美的完成这个对象的显示了。</p><p>一些基本的建议是——<strong>保持纹理在不需要放大再用的前提下尽可能小，并尝试基于多边形将纹理分组。</strong>即便所有纹理都一直存储在内存中，这种预防措施也可能会提高处理器的缓存性能。</p><p>常见的缓存策略有以下几种，许多都和操作系统中的缓存策略一致：</p><ul><li><strong>最近最少使用策略（Least Recently Used ,LRU）</strong>。LRU 是纹理缓存方案中常用的一种策略，其原理为：加载到图形加速器的内存中的每个纹理都被给出一个时间戳，记录最后一次访问以渲染图像的时间。当需要空间来加载新的纹理时，首先卸载最旧时间戳的纹理。一些 API 还允许为每个纹理设置一个优先级：如果两个纹理的时间戳相同，则优先级较低的纹理首先被卸载。 设置优先级可以帮助避免不必要的纹理交换。</li><li><strong>最近最常使用策略（Most Recently Used，MRU）</strong>。MRU 如其名称一样，总是替换掉使用的最少的纹理缓存。鉴于如果在当前帧中载入纹理，会发生抖动（Thrashing）的情况。所谓抖动就是纹理数据集远大于缓存空间，这样就会出现频繁替换纹理缓存的现象，就称为抖动。这时，LRU 策略是一种非常不好的策略，因为在每帧画面中会对每张纹理图像进行交换。在这种情况下，可以采用 MRU 策略，直到在画面中没有纹理交换时为止，再然后切换回 LRU。</li><li><strong>预取策略（Prefetching）</strong>。加载纹理花费显着的时间，特别是在需将纹理转换为硬件原生格式时。 纹理加载在每个框架可以有很大的不同。在单个帧中加载大量纹理使得难以保持恒定的帧速率。一种解决方案是使用预取（prefetching），在将来需要预期的情况下，预计未来的需求然后加载纹理，将加载过程分摊在多帧中。</li><li><strong>裁剪图策略（Clipmap）</strong>。对于飞行模拟和地型模拟系统，图像数据集可能会非常巨大。传统的方法是将这些图像分解成更小的硬件可以处理的瓦片地图（tiles）。Tanner 等人提出了一种一种称为裁剪图（clipmap）的改进数据结构。其思想是，将整个数据集视为一个 mipmap，但是对于任何特定视图，只需要 mipmap 的较低级别的一小部分即可。支持  DirectX 10 的  GPU 就能够实现 clipmap 技术。</li></ul><h3 id="3-纹理压缩"><a href="#3-纹理压缩" class="headerlink" title="3 纹理压缩"></a>3 纹理压缩</h3><p>直接解决内存和带宽问题和缓存问题的一个解决方案是固定速率纹理压缩（Fixed-rate Texture Compression）。通过硬件解码压缩纹理，纹理可以需要更少的纹理内存，从而增加有效的高速缓存大小。至少这样的纹理使用起来更高效，因为他们在访问时消耗更少的内存带宽。</p><p>纹理压缩算法种类繁多，但基本的共同点是：把纹理按 4x4 个单元（纹素）大小划分为块。每个块对应一张四色查找表，表中存有两个标准 RGB565 格式表示的 16 位颜色，另外使用标准插入算法在插入两个新的颜色值，由此构成四色查找表。4x4 大小的纹理块中每个单元（像素点）用两个 bit 表示，每一个都代表四色查找表中的一种颜色。<strong>可以看出，实质上是利用每个单元（像素点）中的两个 bit 来索引四色查找表中的颜色值。</strong></p><p>这些压缩技术可以应用于立方体或体积图，以及二维纹理。<strong>而其主要缺点是它们是有损的压缩。</strong> 也就是说，原始图像通常不能从压缩版本检索。 仅使用四个或八个内插值来表示 16 个像素。 如果一个瓦片贴图有更大的数值，相较压缩前就会有一些损失。 在实践中，如果正常使用这些压缩方案，一般需给出可接受的图像保真度。</p><h3 id="4-体纹理"><a href="#4-体纹理" class="headerlink" title="4 体纹理"></a>4 体纹理</h3><p>体纹理（volume texture），也称为三维纹理（3D texture），是传统二维纹理（2D texture）在逻辑上的扩展。二维纹理是一张简单的位图图片，用于为三维模型提供表面点的颜色值；而<strong>一个三维纹理，可以被认为由很多张 2D 纹理组成，用于描述三维空间数据的图片。</strong>三维纹理通过三维纹理坐标进行访问。</p><p>虽然体纹理具有更高的储存要求，并且滤波成本更高，但它们具有一些独特的优势：</p><ul><li>使用体纹理，可以跳过为三维网格确定良好二维参数的复杂过程，因为三维位置可以直接用作纹理坐标，从而避免了二维参数化中通常会发生的变形和接缝问题。</li><li>体纹理也可用于表示诸如木材或大理石的材料的体积结构。使用三维纹理实现出的这些模型，看起来会很逼真，浑然天成。</li></ul><p>体纹理的缺点也很明显：</p><ul><li>使用体纹理作为表面纹理会非常低效，因为三维纹理中的绝大多数样本都没起到作用。</li></ul><h3 id="5-立方体贴图"><a href="#5-立方体贴图" class="headerlink" title="5 立方体贴图"></a>5 立方体贴图</h3><p>立方体贴图（cube map）也称立方体纹理（cube texture），是一种特殊的纹理技术，它用 6 幅二维纹理图像构成一个以原点为中心的纹理立方体，这每个 2D 纹理是一个立方体（cube）的一个面。对于每个片段，<strong>纹理坐标 (s, t, r) 被当作方向向量看待，每个纹素(texel)都表示从原点所看到的纹理立方体上的图像。</strong></p><p>下图以两种方式展示了立方体贴图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100701571.png" alt="image-20220515100701571"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100722640.png" alt="image-20220515100722640"></p><p><strong>可以使用三分量纹理坐标向量来访问立方体贴图中的数据，该矢量指定了从立方体中心向外指向的光线的方向。</strong>选择具有最大绝对值的纹理坐标对应的相应的面。例如给定矢量（-3.2, 5.1, -8.4），选择绝对值最大的 -8.4 所在的 -Z 面，然后将其他两维除以最大的绝对值，就映射到了（-1, 1），然后再映射到（0, 1）范围就可以在 -Z 面上得到一个纹理坐标了。</p><h3 id="6-程序纹理"><a href="#6-程序纹理" class="headerlink" title="6 程序纹理"></a>6 程序纹理</h3><p>给定纹理空间位置，进行图像查找是生成纹理值的一种方法。另一种方法是对函数进行求值，从而得到一个程序贴图纹理（procedural texture）。</p><p>程序贴图纹理也称为过程纹理，是用计算机算法生成的，旨在创建用于纹理映射的自然元素（例如木材，大理石，花岗岩，金属，石头等）的真实表面或三维物体而创建的纹理图像。通常，会使用分形噪声（fractal noise）和湍流扰动函数（turbulence functions）这类“随机性”的函数来生成程序贴图纹理。</p><p>程序纹理通常用于离线渲染应用程序，而图像纹理在实时渲染中更为常见。这是由于在现代 GPU 中的图像纹理硬件有着极高效率，其可以在一秒钟内执行数十亿个纹理访问。然而，GPU 架构正在朝着更便宜的计算能力和（相对）更昂贵的存储器访问而发展。这将使程序纹理在实时应用程序中更常见，尽管它们不可能完全替代图像纹理。</p><p>关于程序纹理中常见的噪声，之后有专门的文章总结。</p><h3 id="7-凹凸贴图及其改进"><a href="#7-凹凸贴图及其改进" class="headerlink" title="7 凹凸贴图及其改进"></a>7 凹凸贴图及其改进</h3><p>与凹凸贴图相关的改进技术包括：位移贴图、法线贴图、视差贴图、浮雕贴图等，除了位移贴图方法以外，其他的几种改进一般都是通过修改每像素着色方程来实现，关键思想是访问纹理来修改表面的法线，而不是改变光照方程中的颜色分量。物体表面的几何法线保持不变，我们修改的只是着色方程中使用的法线值。他们比单独的纹理有更好的三维感官，但是显然还是比不上实际的三维几何体。下面将分别说明这几种方法。</p><h4 id="7-1-凹凸贴图"><a href="#7-1-凹凸贴图" class="headerlink" title="7.1 凹凸贴图"></a>7.1 凹凸贴图</h4><p><strong>凹凸贴图是通过改变表面光照方程的法线，而不是表面的几何法线，或对每个待渲染的像素在计算照明之前都要加上一个从高度图中找到的扰动，来模拟凹凸不平的视觉特征</strong>，如褶皱、波浪等等。<br>Blinn 于 1978 年提出了凹凸贴图方法。使用凹凸贴图，是为了给光滑的平面，在不增加顶点的情况下，增加一些凹凸的变化。他的原理是通过法向量的变化，来产生光影的变化，从而产生凹凸感。<strong>实际上并没有几何顶点上的变化。</strong>所以下图中球体边缘还是光滑的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515104558734.png" alt="image-20220515104558734"></p><h4 id="7-2-位移贴图"><a href="#7-2-位移贴图" class="headerlink" title="7.2 位移贴图"></a>7.2 位移贴图</h4><p>移位贴图（Displacement Mapping）也有人称为置换贴图，或称高度纹理贴图（Heightfield Texturing）。这种方法类似于法线贴图，<strong>移位贴图的每一个纹素中存储了一个向量，这个向量代表了对应顶点的位移。</strong>注意，此处的纹素并不是与像素一一对应，而是与顶点一一对应，因此，纹理的纹素个数与网格的顶点个数是相等的。在 Vertex Shader 阶段，获取每个顶点对应的纹素中的位移向量，施加到局部坐标系下的顶点上，然后进行世界视点投影变换即可。<strong>位移贴图真正改变了顶点位置。</strong></p><h4 id="7-3-法线贴图"><a href="#7-3-法线贴图" class="headerlink" title="7.3 法线贴图"></a>7.3 法线贴图</h4><p>法线贴图（Normal mapping）是凸凹贴图（Bump mapping）技术的一种应用。简单来说，<strong>Normal Map 直接将正确的 Normal 值保存到一张纹理中去，那么在使用的时候直接从贴图中取即可。</strong>为了使法线贴图能应用于不同的物体，所以法线贴图中存储的法线值一般是表面顶点切线空间下的法线值，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，相比于存储模型空间下的法线值，切线空间下的法线值是一个相对值，可以应用到不同的模型上而不至于出错。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105351266.png" alt="image-20220515105351266"></p><p>上图展示了基于法线贴图的凹凸映射，左侧为法线贴图，每个颜色通道实际上是表面法线坐标。红色通道是 x 偏差; 红色越多，正常点越多。 绿色是 y 偏差，蓝色是 z。 右边是使用法线贴图生成的图像。 请注意立方体顶部的扁平外观，<strong>法线贴图显然没有改变几何形状。</strong></p><h4 id="7-4-视差贴图"><a href="#7-4-视差贴图" class="headerlink" title="7.4 视差贴图"></a>7.4 视差贴图</h4><p>视差贴图（Parallax Mapping），又称为 Offset Mapping，或 virtual displacement mapping，视差贴图是一种改进的 Bump Mappin 技术，相较于普通的凹凸贴图，视差贴图技术得到凹凸效果得会更具真实感（如石墙的纹理将有更明显的深度）。<strong>视差贴图是通过替换渲染多边形上的顶点处的纹理坐标来实现的</strong>，而这个替换依赖于一个关于切线空间中的视角（相对于表面法线的角度）和在该点上的高度图的方程。简单来说，Parallax Mapping 利用  Height Map 进行了近似的  Texture Offset。如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105943878.png" alt="image-20220515105943878"></p><h4 id="7-5-浮雕贴图"><a href="#7-5-浮雕贴图" class="headerlink" title="7.5 浮雕贴图"></a>7.5 浮雕贴图</h4><p>浮雕贴图（Relief Mapping），有人把它誉为凹凸贴图的极致。我们知道，Parallax Mapping 是针对  Normal Mapping 的改进，利用  HeightMap 进行了近似的 Texture Offset。而 Relief Mapping 是精确的 Texture Offset，所以在表现力上比较完美。</p><p>Parallax Mapping 能够提供比 Bump Mapping 更多的深度，尤其相比于小视角下，但是如果想提供更深的深度，Parallax Mapping 就无能为力了，Relief Mapping 则可以很好的胜任。相较于 Parallax Mapping，浮雕贴图可以实现更深的凹凸深度，并且还可以做出自阴影和闭塞效果。当然算法也稍稍有点复杂，具体细节可以参考这篇中文文献：<a href="https://www.ixueshu.com/document/3dc4369a761ca0d6318947a18e7f9386.html">Relief mapping：凹凸贴图的极致</a>，而如果要用一句话概括  Relief Mapping，将会是：“在 Shader 里做光线追踪”。</p><p>下图是法线贴图和浮雕贴图的对比，浮雕贴图可以实现自阴影：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110338598.png" alt="image-20220515110338598"></p><p>下图是视差贴图和浮雕贴图的对比，浮雕贴图可以实现更深的凹凸深度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110121700.png" alt="image-20220515110121700"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中纹理相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;纹理管线（Texture Pipeline）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纹理缓存（Texture Caching）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纹理压缩（Texture Compression）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;体纹理（Volume Texture）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;立方体贴图（Cube Map）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序纹理（Procedural Texturing）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;凹凸贴图（Bump Mapping）及其改进&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】模板测试和深度测试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-14T03:34:55.000Z</published>
    <updated>2022-05-14T03:36:33.273Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习渲染管线的时候，没有对混合阶段的各种测试展开细说，本篇将详细介绍模板测试和深度测试有关的知识，主要内容包括：</p><ul><li>渲染管线终极版</li><li>模板测试</li><li>深度测试</li><li>Early-Z 和 Z-Prepass</li></ul><p><em><span id="more"></span></em></p><h3 id="1-渲染管线终极版"><a href="#1-渲染管线终极版" class="headerlink" title="1 渲染管线终极版"></a>1 渲染管线终极版</h3><p>之前的学习中我们已经对渲染管线有了一个整体流程上的认识，但具体细节和阶段内部的顺序并没有过多关注，在学习模板测试和深度测试有关的内容之前，有必要为之前的渲染管线加上一些“细节”，以便于后续的理解。</p><p>下图展示了整个渲染管线的流程，包含了各阶段内部和操作内部的顺序以及流程细节，可以作为最终版放在脑中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/RenderPipeline.png" alt="RenderPipeline"></p><p>图中：</p><ul><li>绿色的阶段都是完全可编程的</li><li>蓝色的阶段可配置，但不可编程</li><li>黄色的阶段完全固定</li><li>虚线为可选阶段</li></ul><h3 id="2-模板测试（Stencil-Test）"><a href="#2-模板测试（Stencil-Test）" class="headerlink" title="2 模板测试（Stencil Test）"></a>2 模板测试（Stencil Test）</h3><p>模板测试简单来说就是根据模板缓冲区的数值决定该像素的颜色值，最简单的比如只有模板缓冲为 1 的像素才显示，为 0 则不显示，类似于一个 mask 操作，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/X911U-WnXlnLJg_9klfTcg.png" alt="X911U-WnXlnLJg_9klfTcg"></p><p>模板缓冲区与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值（通常是 8 位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。模板测试发生在透明度测试（alpha test）之后，深度测试（depth test）之前。如果模板测试通过，则相应的像素点更新，否则不更新。</p><p>模板测试可以定义不同的比较方式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160835251.png" alt="image-20220513160835251"></p><p>还可以定义更新缓冲值的方式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160947277.png" alt="image-20220513160947277"></p><p>总的来说模板测试就是对当前模板缓冲值（stencil Buffer Value）和模板参考值（reference Value）使用特定的比较操作进行比较来决定是否渲染该像素，模板测试后可以根据测试结果，按照特定方式更新模板缓冲区的值。</p><p>模板测试可以与其他测试或图形算法结合实现许多效果，比如：描边、多边形填充、反射区域控制等。</p><h3 id="3-深度测试（Z-Test）"><a href="#3-深度测试（Z-Test）" class="headerlink" title="3 深度测试（Z Test）"></a>3 深度测试（Z Test）</h3><p>深度测试发生在模板测试之后，透明度混合之前。所谓深度测试，就是针对当前对象在屏幕上（更准确的说是frame buffer）对应的像素点，将对象自身的深度值与当前该像素点缓存的深度值进行比较，如果通过了，本对象在该像素点才会将颜色写入颜色缓冲区，否则否则不会写入颜色缓冲。</p><p><strong>深度缓冲（Z-Buffer）</strong>就像颜色缓冲（储存所有的片段颜色）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24 或 32 位 float 的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。一般来说，深度缓冲区中存储的深度值为 0 到 1 范围的浮点值，且为非线性。深度值在各个空间的变化如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513171312423.png" alt="image-20220513171312423"></p><p><strong>深度写入（Z-Write）</strong>包括两种状态：ZWrite On 与 ZWrite Off。当我们开启深度写入的时候，通过深度测试则将新的深度值写入深度缓存；反之，如果关闭深度写入，那么深度就不会写入深度缓冲区。</p><p>深度测试对深度缓冲区和颜色缓冲区的写入情况有以下四种：</p><ul><li>深度测试通过，深度写入开启：写入深度缓冲区，写入颜色缓冲区；</li><li>深度测试通过，深度写入关闭：不写深度缓冲区，写入颜色缓冲区；</li><li>深度测试失败，深度写入开启：不写深度缓冲区，不写颜色缓冲区；</li><li>深度测试失败，深度写入关闭：不写深度缓冲区，不写颜色缓冲区；</li></ul><p>一般来说，深度测试可以自定义比较方式，默认为小于等于，即深度小于等于缓冲区中的深度时则通过测试，并且深度写入默认开启。深度测试的流程图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/f9z_wixRyJvq5jVawaFuPA.png" alt="f9z_wixRyJvq5jVawaFuPA"></p><p>深度测试不仅可以解决遮挡问题，还可以应用于很多效果，比如：阴影贴图、透明渲染、粒子渲染、切边效果、X光等。</p><h3 id="4-Early-Z-和-Z-Prepass"><a href="#4-Early-Z-和-Z-Prepass" class="headerlink" title="4 Early-Z 和 Z-Prepass"></a>4 Early-Z 和 Z-Prepass</h3><h4 id="4-1-Early-Z"><a href="#4-1-Early-Z" class="headerlink" title="4.1 Early-Z"></a>4.1 Early-Z</h4><p>在正常的渲染管线中，深度测试在所有测试完成后才进行，片元着色器计算的所有片元经过深度测试后会有一大部分被舍弃，这相当于进行了很多无用的计算，而实际上在进入片元着色器之前我们就已经知道了所有顶点的深度，因此完全可以提前进行深度测试，将深度大的片元提前舍弃，不去计算，这样就可以节省很多的计算量，这就是 Early-Z 的思想。上面的渲染管线图中给出了 Early-Z 在整个管线中的位置。</p><p>但是有一些情况下，Early-Z 会失效或使用 Early-Z 会造成错误：</p><ul><li>开启了透明度测试（Alpha Test ），这时如果提前进行深度测试，可能导致透明物体后的片元没有通过深度测试而渲染不出来</li><li>进行手动剔除（discard）操作，这时提前通过深度测试筛选出来的片元也可能会被手动剔除而造成错误</li><li>片元着色器中手动修改 GPU 插值得到的深度，这时提前通过深度剔除片元很大可能会造成错误</li><li>开启了透明度混合（Alpha Blend），开启透明度混合一般会关闭深度写入，所以 Early-Z 不生效</li><li>关闭深度测试时 Early-Z 自然也不生效</li></ul><p>Early-Z 进行的操作和原本逐像素处理阶段的 Z-Test（为了 Early-Z 区别，这个阶段也会被称为 Late-Z）操作完全一样，现代的 GPU 已经都开始包含这样的硬件设计。但是 Early-Z 有以下两个主要的缺点：</p><ul><li>一旦进行了手动写入深度值、开启 alpha test 或者丢弃像素等上述操作，那么 GPU 就会关闭 Early-Z 直到下次清空 Z-Buffer 后才会重新开启（不过现在的 GPU 也在逐渐优化，使其更智能的开关 Early-Z）。之所以 GPU  会选择关闭 Early-Z 是因为上述那些操作可能会在片元着色器与 Late-Z 阶段之间修改深度缓存中的深度值，导致提前的 Early-Z 结果不正确。我们也可以在 fragment shader 中使用 <code>layout(early_fragment_tests)</code> 来强制打开 Early-Z。</li><li>Early-Z 的优化效果并不稳定，最理想条件下所有绘制顺序都是由近及远，那么 Early-Z 可以完全避免过度绘制。但是相反的状态下，由远及近绘制物体， Early-Z 则会起不到任何效果。所以有些时候为了完全发挥 Early-Z 的功效，我们会在每帧绘制时对场景的物体按照到摄像机的距离由远及近进行排序。这个操作会在 CPU 端进行，当场景复杂到一定程度，频繁的排序将会占用 CPU 的大量计算资源。</li></ul><h4 id="4-2-Z-Prepass"><a href="#4-2-Z-Prepass" class="headerlink" title="4.2 Z-Prepass"></a>4.2 Z-Prepass</h4><p>Z-Prepass 是一种软件技术。它主要是配合 Early-Z 使用，来减少上面提到的 Early-Z 的第二个缺点——效果不稳定。Z-Prepass 的做法是将场景做两个 pass 的绘制。第一个 pass 仅写入深度，不做任何复杂的片元计算，不输出任何颜色。第二个 pass <strong>关闭深度写入</strong>，并将<strong>深度比较函数设为“相等”</strong>。</p><p>本节一开始就提到， Early-Z 的出现是因为经过大量运算的片元，很大概率会在之后被丢弃掉。那么对于第一个 pass 由于只写入深度，不在片元做任何计算，所以即便之后会被丢弃，也并不可惜。也就是说无论场景中的物体以怎样的顺序绘制，我们都可以以很小的代价提前绘制好当前场景的深度缓存。那么在第二个 pass 时，Early-Z 就可以用这个深度缓存中的值和当前深度值进行比较，只绘制深度相等的片元，任何其他的片元都可以直接丢弃，因此第二个 pass 要把深度比较函数设为“相等”。同时当前的深度缓存已经是完全正确的结果了，因此第二个 pass 也不需要对深度缓存做任何更新，便可以关闭深度写入。</p><p>Z-Prepass 必须配合 Early-Z 才能发挥效果，如果没有 Early-Z 的话，第二个 pass 的深度测试依旧在片元着色器之后，因此所有片元都会在片元阶段进行复杂计算。Z-Prepass 的思想和延迟渲染管线（defered render pipeline，之后会专门总结）有些相似，差别在于：</p><ul><li>第一，Z-Prepass 的第一个 pass 只计算深度，并且结果直接存储在深度缓存。而延迟渲染会同时计算更多其他的屏幕空间数据，并将这些数据存储在额外的 frame buffer 中，需要更大的缓存（也就是G-Buffer）。</li><li>第二，Z-Prepass 的第二个 pass 依旧需要对全场景的各个物体进行绘制（至少顶点阶段是如此），而延迟渲染的第二个 pass 类似于后处理，本质上只绘制了一个屏幕大小的矩形。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前学习渲染管线的时候，没有对混合阶段的各种测试展开细说，本篇将详细介绍模板测试和深度测试有关的知识，主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渲染管线终极版&lt;/li&gt;
&lt;li&gt;模板测试&lt;/li&gt;
&lt;li&gt;深度测试&lt;/li&gt;
&lt;li&gt;Early-Z 和 Z-Prepass&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】图形渲染和视觉处理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/</id>
    <published>2022-05-13T07:42:45.000Z</published>
    <updated>2022-05-13T07:44:49.674Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中与图形渲染基础和视觉处理相关的知识进行概括总结。主要内容包括：</p><ul><li>光照与材质</li><li>着色</li><li>抗锯齿总结</li><li>透明渲染</li><li>伽马校正</li></ul><p><em><span id="more"></span></em></p><h3 id="1-光照与材质"><a href="#1-光照与材质" class="headerlink" title="1 光照与材质"></a>1 光照与材质</h3><h4 id="1-1-光源特性"><a href="#1-1-光源特性" class="headerlink" title="1.1 光源特性"></a>1.1 光源特性</h4><p>光被不同地模拟为几何光线，电磁波或光子（具有一些波特性的量子粒子）。无论如何处理，光都是电磁辐射能，即通过空间传播的电磁能。光源发光，而不是散射或吸收光。根据渲染目的，光源可以以许多不同的方式来表示。光源可以分为三种不同类型：<strong>平行光源、点光源和聚光灯。</strong></p><h4 id="1-2-光的散射与吸收"><a href="#1-2-光的散射与吸收" class="headerlink" title="1.2 光的散射与吸收"></a>1.2 光的散射与吸收</h4><p><strong>从根本上来说，所有的光物质相互作用都是两种现象的结果：散射（scattering）和吸收（absorption）。</strong></p><p>散射（scattering）发生在当光线遇到任何种类的光学不连续性（optical discontinuity）时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。散射不会改变光量，它只是使其改变方向。光的散射（scattering）一般又分为反射（reflection）和折射（refraction）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110002009.png" alt="image-20220513110002009"></p><p>吸收（absorption）发生在物质内部，其会导致一些光转变成另一种能量并消失。吸收会减少光量，但不会影响其方向。</p><h4 id="1-3-镜面反射和漫反射"><a href="#1-3-镜面反射和漫反射" class="headerlink" title="1.3 镜面反射和漫反射"></a>1.3 镜面反射和漫反射</h4><p><strong>镜面反射光表示在表面反射的光。而漫反射光表示经历透射（transmission），吸收（absorption）和散射（scattering）的光。</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110116016.png" alt="image-20220513110116016"></p><h4 id="1-4-颜色"><a href="#1-4-颜色" class="headerlink" title="1.4 颜色"></a>1.4 颜色</h4><p>入射光（Incoming illumination）通过表面辉度（irradiance）来度量。而出射光（outgoing light）通过出射率（exitance）来度量。<strong>出射率除以辉度可以作为材质的衡量特性。对于不发光的表面，该比率为 0 到 1 之间。出射率和辉度的比率对于不同的光颜色是不同的，所以其表示为 RGB 矢量，也就是我们通常说的颜色。</strong></p><h4 id="1-5-表面与散射分布"><a href="#1-5-表面与散射分布" class="headerlink" title="1.5 表面与散射分布"></a>1.5 表面与散射分布</h4><p>镜面反射项的方向分布取决于表面粗糙度（roughness，其反义词是 smoothness，光滑度）。反射光线对于更平滑的表面更加紧密，并且对于较粗糙的表面更加分散。我们可以看到下图中的这种依赖关系，它显示了不同粗糙度的两个表面的反射效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110421641.png" alt="image-20220513110421641"></p><h3 id="2-着色"><a href="#2-着色" class="headerlink" title="2 着色"></a>2 着色</h3><p>可以查看以前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a></p><h3 id="3-抗锯齿方法总结"><a href="#3-抗锯齿方法总结" class="headerlink" title="3 抗锯齿方法总结"></a>3 抗锯齿方法总结</h3><p>抗锯齿，也称反走样。它是一种消除显示器输出的画面中图物边缘出现凹凸锯齿的技术，那些凹凸的锯齿通常因为高分辨率的信号以低分辨率表示或无法准确运算出 3D 图形坐标定位时所导致的走样（aliasing）而产生的，抗锯齿技术能有效地解决这些问题。</p><p>关于抗锯齿的原理可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/">【计算机图形学】（四）反走样</a>，下面将常见的抗锯齿类型进行总结介绍，也包括  RTR 中没有讲到的，最近几年新提出的常见抗锯齿类型。</p><h4 id="3-1-超级采样抗锯齿（SSAA）"><a href="#3-1-超级采样抗锯齿（SSAA）" class="headerlink" title="3.1 超级采样抗锯齿（SSAA）"></a>3.1 超级采样抗锯齿（SSAA）</h4><p>超级采样抗锯齿（Super-Sampling Anti-Aliasing，简称  SSAA）是比较早期的抗锯齿方法，比较消耗资源，但简单直接。这种抗锯齿方法先把图像映射到缓存并把它放大，再用超级采样把放大后的图像像素进行采样，一般选取 2 个或 4 个邻近像素，把这些采样混合起来后，生成的最终像素，这样每个像素拥有邻近像素的特征，像素与像素之间的过渡色彩，就变得近似，使得图形的边缘色彩过渡趋于平滑。再把最终像素还原回原来大小的图像，并保存到帧缓存也就是显存中，替代原图像存储起来，最后输出到显示器，显示出一帧画面。这样就等于把一幅模糊的大图，通过细腻化后再缩小成清晰的小图。比如在 1024x768 分辨率上开启 2xSSAA，GPU 会先渲染 2048x1536 图像，再“塞进”1024x768 的屏幕中，将画面精细度提升一倍，毫无疑问会改善边缘锯齿情况。超级采样抗锯齿中使用的采样法一般有两种：</p><ul><li>OGSS，顺序栅格超级采样（Ordered Grid Super-Sampling，简称  OGSS），采样时选取  2 个邻近像素</li><li>RGSS，旋转栅格超级采样（Rotated Grid Super-Sampling，简称  RGSS），采样时选取  4 个邻近像素</li></ul><p>另外，作为概念上最简单的一种超采样方法，全场景抗锯齿（Full-Scene Antialiasing, FSAA）以较高的分辨率对场景进行绘制，然后对相邻的采样样本进行平均，从而生成一幅新的图像。</p><h4 id="3-2-多重采样抗锯齿（MSAA）"><a href="#3-2-多重采样抗锯齿（MSAA）" class="headerlink" title="3.2 多重采样抗锯齿（MSAA）"></a>3.2 多重采样抗锯齿（MSAA）</h4><p>多重采样抗锯齿（Multi Sampling Anti-Aliasing，简称  MSAA），是一种特殊的 SSAA，MSAA 首先来自于 OpenGL。具体是 MSAA 只对  Z 缓存（Z-Buffer）和模板缓存 (Stencil Buffer) 中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。这样的话，相比  SSAA 对画面中所有数据进行处理，MSAA 对资源的消耗需求大大减弱，不过在画质上可能稍有不如  SSAA。</p><h4 id="3-3-高分辨率抗锯齿（HRAA）"><a href="#3-3-高分辨率抗锯齿（HRAA）" class="headerlink" title="3.3 高分辨率抗锯齿（HRAA）"></a>3.3 高分辨率抗锯齿（HRAA）</h4><p>高分辨率抗锯齿方法(High Resolution Anti-Aliasing，简称 HRAA)，也称 Quincunx 方法，出自 NVIDIA 公司。“Quincunx”意思是 5 个物体的排列方式，其中 4 个在正方形角上，第五个在正方形中心，也就是梅花形。此方法中，采样模式是五点梅花状，其中四个样本在像素单元的角上，最后一个在中心。</p><h4 id="3-4-可编程过滤抗锯齿（CFAA）"><a href="#3-4-可编程过滤抗锯齿（CFAA）" class="headerlink" title="3.4 可编程过滤抗锯齿（CFAA）"></a>3.4 可编程过滤抗锯齿（CFAA）</h4><p>可编程过滤抗锯齿（Custom Filter Anti-Aliasing，简称 CFAA）简单地说就是扩大取样面积的 MSAA，比方说之前的 MSAA 是严格选取物体边缘像素进行缩放的，而 CFAA 则可以通过驱动和谐灵活地选择对影响锯齿效果较大的像素进行缩放，以较少的性能牺牲换取平滑效果。显卡资源占用也比较小。</p><h4 id="3-5-形态抗锯齿（MLAA）"><a href="#3-5-形态抗锯齿（MLAA）" class="headerlink" title="3.5 形态抗锯齿（MLAA）"></a>3.5 形态抗锯齿（MLAA）</h4><p>形态抗锯齿（Morphological Anti-Aliasing，简称 MLAA），是 AMD 推出的完全基于 CPU 处理的抗锯齿解决方案。与 MSAA 不同， MLAA 将跨越边缘像素的前景和背景色进行混合，用第 2 种颜色来填充该像素，从而更有效地改进图像边缘的变现效果。</p><h4 id="3-6-快速近似抗锯齿（FXAA）"><a href="#3-6-快速近似抗锯齿（FXAA）" class="headerlink" title="3.6 快速近似抗锯齿（FXAA）"></a>3.6 快速近似抗锯齿（FXAA）</h4><p>快速近似抗锯齿 (Fast Approximate Anti-Aliasing，简称 FXAA)  ，是传统 MSAA (多重采样抗锯齿) 效果的一种高性能近似。是最简单的、高效率的抗锯齿方式，FXAA 对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p><h4 id="3-7-时间性抗锯齿（TAA）"><a href="#3-7-时间性抗锯齿（TAA）" class="headerlink" title="3.7 时间性抗锯齿（TAA）"></a>3.7 时间性抗锯齿（TAA）</h4><p>时间性抗锯齿（Temporal Anti-Aliasing，简称 TAA），将 MSAA、时间滤波以及后期处理相结合，用于呈现更高的视觉保真度。与 CG 电影中所采用的技术类似，TXAA 集 MSAA 的强大功能与复杂的解析滤镜于一身，可呈现出更加平滑的图像效果。此外，TXAA 还能够对帧之间的整个场景进行抖动采样，以减少闪烁情形，闪烁情形在技术上又称作时间性锯齿。</p><p>Temporal AA 严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p><p>简单来说，Temporal AA 是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p><h4 id="3-8-多帧采样抗锯齿（MFAA）"><a href="#3-8-多帧采样抗锯齿（MFAA）" class="headerlink" title="3.8 多帧采样抗锯齿（MFAA）"></a>3.8 多帧采样抗锯齿（MFAA）</h4><p>多帧采样抗锯齿（Multi-Frame Sampled Anti-Aliasing，MFAA）是 NVIDIA 公司根据 MSAA 改进出的一种抗锯齿技术。可以将 MFAA 理解为 MSAA 的优化版，能够在得到几乎相同效果的同时提升性能上的表现。MFAA 与 MSAA 最大的差别就在于在同样开启 4 倍效果的时候 MSAA 是真正的针对每个边缘像素周围的 4 个像素进行采样，MFAA 则是仅仅只是采用交错的方式采样边缘某个像素周围的两个像素。</p><h4 id="3-9-深度学习超采样（DLSS）"><a href="#3-9-深度学习超采样（DLSS）" class="headerlink" title="3.9 深度学习超采样（DLSS）"></a>3.9 深度学习超采样（DLSS）</h4><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p><h4 id="3-10-图示抗锯齿"><a href="#3-10-图示抗锯齿" class="headerlink" title="3.10 图示抗锯齿"></a>3.10 图示抗锯齿</h4><p>下图展示了不同采样方法的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513113600088.png" alt="image-20220513113600088"></p><h3 id="4-透明渲染"><a href="#4-透明渲染" class="headerlink" title="4 透明渲染"></a>4 透明渲染</h3><h4 id="4-1-透明渲染算法"><a href="#4-1-透明渲染算法" class="headerlink" title="4.1 透明渲染算法"></a>4.1 透明渲染算法</h4><p>透明渲染是是图形学里面的常见问题之一，可以从《Real-Time Rendering》中总结出如下两个算法：</p><ul><li>Screen-Door Transparency 方法。基本思想是用棋盘格填充模式来绘制透明多边形，也就是说，以每隔一个像素绘制一点方式的来绘制一个多边形，这样会使在其后面的物体部分可见，通常情况下，屏幕上的像素比较紧凑，以至于棋盘格的这种绘制方式并不会露馅。同样的想法也用于剪切纹理的抗锯齿边缘，但是在子像素级别中的，这是一种称为 alpha 覆盖（alpha to coverage）的特征。screen-door transparency 方法的优点就是简单，可以在任何时间任何顺序绘制透明物体，并不需要特殊的硬件支持（只要支持填充模式）。缺点是透明度效果仅在 50% 时最好，且屏幕的每个区域中只能绘制一个透明物体。</li><li>Alpha 混合（Alpha Blending）方法。这个方法比较常见，其实就是按照 Alpha 混合向量的值来混合源像素和目标像素。当在屏幕上绘制某个物体时，与每个像素相关联的值有 RGB 颜色和 Z 缓冲深度值，以及另外一个成分 alpha 分量，这个 alpha 值也可以根据需要生成并存储，它描述的是给定像素的对象片段的不透明度的值。alpha 为 1.0 表示对象不透明，完全覆盖像素所在区域; 0.0 表示像素完全透明。为了使对象透明，在现有场景的上方，以小于 1 的透明度进行绘制即可。每个像素将从渲染管线接收到一个  RGBA 结果，并将这个值和原始像素颜色相混合。</li></ul><h4 id="4-2-透明排序"><a href="#4-2-透明排序" class="headerlink" title="4.2 透明排序"></a>4.2 透明排序</h4><p>要将透明对象正确地渲染到场景中，通常需要对物体进行排序。下面分别介绍两种比较基本的透明排序方法（画家算法和深度缓冲）和两种高级别的透明排序算法（加权平均值算法和深度剥离）。</p><h5 id="4-2-1-画家算法和深度缓冲"><a href="#4-2-1-画家算法和深度缓冲" class="headerlink" title="4.2.1  画家算法和深度缓冲"></a>4.2.1  画家算法和深度缓冲</h5><p>可查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">【计算机图形学】（五）深度缓冲</a></p><h5 id="4-2-2-加权平均值算法（Weighted-Average）"><a href="#4-2-2-加权平均值算法（Weighted-Average）" class="headerlink" title="4.2.2 加权平均值算法（Weighted Average）"></a>4.2.2 加权平均值算法（Weighted Average）</h5><p>使用简单的透明混合公式来实现无序透明渲染的算法，它通过扩展透明混合公式，来实现无序透明物件的渲染，从而得到一定程度上逼真的结果。</p><p>NVIDIA 公司的 Louis Bavoil 在此基础上提出了新的算法，使用物体的不透明度作为加权值的加权平均值算法。此算法的主要思想如下：</p><p>对于某个位置的像素点，如果所有的不透明物件是相同的颜色，那么渲染的结果与它们的渲染顺序无关。那么，对于不相同颜色值的情况，如果我们用某一个颜色来替换这些颜色，比如这些颜色的平均值。对于这种情况，我们使用各个颜色的不透明度作为权重来计算出它们的加权平均值作为最终颜色替换这些颜色，这样渲染就与顺序无关。</p><p>此算法的优点很明显，效率高，速度快，只需要对物体进行一次的渲染，然后加上一次全屏的后处理。但是缺点也是同样的明显，透明结果只是一个近似值，而不是确切的正确结果。然而，它的效果仍然远远好过不做任何处理的简单透明混合，而且高效性也使得它有一定的应用空间。</p><h5 id="4-2-3-深度剥离算法（Depth-Peeling）"><a href="#4-2-3-深度剥离算法（Depth-Peeling）" class="headerlink" title="4.2.3 深度剥离算法（Depth Peeling）"></a>4.2.3 深度剥离算法（Depth Peeling）</h5><p>深度剥离是一种对深度值进行排序的技术。它的原理比较直观，标准的深度检测使场景中的 Z 值最小的点输出到屏幕上，就是离我们最近的顶点。但还有离我们第二近的顶点，第三近的顶点存在。要想显示它们，可以用多遍渲染的方法。深度剥离的每次渲染都需要一个深度缓冲，一个 Shadow Map 纹理和一个颜色缓冲，算法流程如下：</p><ul><li>首先使用深度缓冲正常渲染，就可以得到离我们最近的顶点及其深度值，同时将所有深度值拷贝到 Shadow Map 纹理中</li><li>第二次渲染打开深度纹理的比较功能，使得深度值比较大的颜色通过测试，这样就把所有深度值小于前一次渲染的顶点全部剥离掉，剩下的顶点都是比上一次渲染离我们更远的顶点，再加上深度缓冲本身的取最小深度的功能，就可以得到比上一次渲染离我们更远的顶点中离我们最近的顶点的颜色</li><li>重复第二步操作，就把所有顶点颜色按照深度一层一层剥离出来，最后按照从后往前的顺序进行渲染，这样就可以得到正确的结果了。</li></ul><p>这种方法与渲染物体的顺序无关，并且得到的结果保证正确，但缺点也很明显，需要剥离 N 次才能完成，就需要 N 个 Pass，N 是深度复杂度，因此性能是严重的瓶颈，另外如何确定 N 也是个问题。</p><h3 id="5-伽马校正"><a href="#5-伽马校正" class="headerlink" title="5 伽马校正"></a>5 伽马校正</h3><p>查看之前笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/">【RayTracer】（四）漫反射材质</a>中的第三部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中与图形渲染基础和视觉处理相关的知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光照与材质&lt;/li&gt;
&lt;li&gt;着色&lt;/li&gt;
&lt;li&gt;抗锯齿总结&lt;/li&gt;
&lt;li&gt;透明渲染&lt;/li&gt;
&lt;li&gt;伽马校正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】GPU管线</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-05-13T02:46:21.000Z</published>
    <updated>2022-05-13T02:47:22.923Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中 GPU 渲染管线和可编程着色器的相关知识进行概括总结。主要内容包括：</p><ul><li>GPU 管线概述</li><li>可编程着色模型</li><li>思维导图</li></ul><p><em><span id="more"></span></em></p><h3 id="1-GPU-管线"><a href="#1-GPU-管线" class="headerlink" title="1 GPU 管线"></a>1 GPU 管线</h3><p>GPU 管线和上一节概念上的图形渲染管线不完全相同，现代 GPU 实现了图形渲染管线中的几何和光栅化阶段。其被分为一些不同程度的可配置性和可编程性的硬件阶段，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513100149647.png" alt="image-20220513100149647"></p><p>其中，不同颜色代表了不同程度的自定义属性：</p><ul><li>绿色的阶段都是完全可编程的</li><li>黄色的阶段可配置，但不可编程</li><li>蓝色的阶段完全固定</li></ul><p>GPU 实现的渲染管线和概念上的图形渲染管线的功能阶段在结构上略有不同。以下是对  GPU 渲染管线的一个流程概览：</p><ul><li><strong>顶点着色器（The Vertex Shader）</strong>是完全可编程的阶段，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改、创建、忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置等。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。</li><li><strong>几何着色器（The Geometry Shader）</strong>位于顶点着色器之后，允许 GPU 高效地创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片元着色器。</li><li><strong>裁剪（Clipping）</strong>属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。</li><li><strong>屏幕映射（Screen Mapping）</strong>、<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段是固定功能阶段。</li><li><strong>像素着色器（Pixel Shader，Direct3D 中的叫法）</strong>常常又称为片段着色器，<strong>片元着色器（Fragment Shader，OpenGL 中的叫法）</strong>，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。</li><li><strong>合并阶段（The Merger Stage）</strong>处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改（Color Modifying），Z 缓冲（Z-buffer），混合（Blend），模板（Stencil）和相关缓存的处理。</li></ul><h3 id="2-可编程着色模型"><a href="#2-可编程着色模型" class="headerlink" title="2 可编程着色模型"></a>2 可编程着色模型</h3><p>早期的着色模型可以用汇编语言直接编程，但 DX10 之后，汇编就只在调试输出阶段可见，改用高级着色语言。目前的着色语言都是 C-like 的着色语言，比如 HLSL，CG 和 GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言。这样的安排可以兼容不同的硬件实现。这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机。这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。<strong>着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。</strong></p><p>Shader 程序可以在程序加载或运行时离线编译。和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。一个编译过的  Shader 作为字符串或者文本来存储，并通过驱动程序传递给  GPU。</p><h4 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h4><p>顶点着色器是完全可编程的阶段，是专门处理传入的顶点信息的着色器，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作。顶点着色器一般不处理附加信息，也就是说，顶点着色器提供了修改，创建，或者忽略与每个多边形顶点相关的值的方式，例如其颜色，法线，纹理坐标和位置。通常，<strong>顶点着色器程序将顶点从模型空间（Model Space）变换到齐次裁剪空间（Homogeneous Clip Space）</strong>，并且，一个顶点着色器至少且必须输出此变换位置。</p><p>顶点着色器既不能创建也不能消除顶点，并且由一个顶点生成的结果不能传递到另一个顶点。由于每个顶点都被独立处理，所以  GPU 上的任何数量的着色器处理器都可以并行地应用到传入的顶点流上。</p><p>顶点着色器的输出可以以许多不同的方式来使用，通常是随后用于每个实例三角形的生成和光栅化，然后各个像素片段被发送到像素着色器，以便继续处理。而在 Shader Model 4.0 中，数据也可以发送到几何着色器（Geometry Shader）或输出流（Streamed Output）或同时发动到像素着色器和几何着色器两者中。</p><h4 id="2-2-几何着色器"><a href="#2-2-几何着色器" class="headerlink" title="2.2 几何着色器"></a>2.2 几何着色器</h4><p>几何着色器的输入是单个对象及对象相关的顶点，而对象通常是网格中的三角形，线段或简单的点。另外，扩展的图元可以由几何着色器定义和处理。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513102855674.png" alt="image-20220513102855674"></p><p>上图所示，几何着色器程序的输入是一个单独的类型：点，线段，三角形。两个最右边的图元，包括与线和三角形对象相邻的顶点也可被使用。</p><p>几何着色器需要图元作为输入，在处理过程中他可以将这个图元整个丢弃或者输出一个或更多的图元（也就是说它可以产生比它得到的更多或更少的顶点），这个能力被叫做几何增长（growing geometry）。几何着色器可以改变新传递进来的图元的拓扑结构，且几何着色器可以接收任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p><p>当我们未添加几何着色器时，默认的行为是将输入的三角形直接输出。我们添加了几何着色器之后，可以在几何着色器中修改输出的图形，我们可以输出我们想要输出的任何图形。</p><blockquote><p>GPU 管线的标准使用方式是发送数据到顶点着色器，然后对所得到的三角形进行光栅化处理，并在像素着色器中处理它们。数据总是通过管线传递，无法访问中间结果。流输出的想法在  Shader Model 4.0 中被引入。在顶点着色器（以及可选的几何着色器中）处理顶点之后，除了将数据发送到光栅化阶段之外，也可以输出到流，也就是一个有序数组中进行处理。事实上，可以完全关掉光栅化，然后管线纯粹作为非图形流处理器来使用。以这种方式处理的数据可以通过管线回传，从而允许迭代处理。这种操作特别适用于模拟流动的水或其他粒子特效。</p></blockquote><h4 id="2-3-像素着色器"><a href="#2-3-像素着色器" class="headerlink" title="2.3 像素着色器"></a>2.3 像素着色器</h4><p>像素着色器(Pixel Shader，Direct3D 中的叫法)，常常又称为片元着色器(Fragment Shader, OpenGL 中的叫法)，用于进行逐像素计算颜色的操作，让复杂的着色方程在每一个像素上执行。像素着色器是光栅化阶段的主要步骤之一。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。</p><p>像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片元着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片元着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。</p><p>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在 Shader Model 4.0 中，共有 16 个向量（每个向量含 4 个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出 32 个向量到像素着色器中。</p><h4 id="2-4-合并阶段"><a href="#2-4-合并阶段" class="headerlink" title="2.4 合并阶段"></a>2.4 合并阶段</h4><p>作为光栅化阶段名义上的最后一个阶段，合并阶段（The Merging Stage）是将像素着色器中生成的各个片段的深度和颜色与帧缓冲结合在一起的地方。这个阶段也就是进行模板缓冲（Stencil-Buffer）和 Z 缓冲（Z-buffer）操作的地方。最常用于透明处理（Transparency）和合成操作（Compositing）的颜色混合（Color Blending）操作也是在这个阶段进行的。虽然合并阶段不可编程，但却是高度可配置的。在合并阶段可以设置颜色混合来执行大量不同的操作。最常见的是涉及颜色和 Alpha 值的乘法，加法，和减法的组合。其他操作也是可能的，比如最大值，最小值以及按位逻辑运算。</p><h4 id="2-5-特效"><a href="#2-5-特效" class="headerlink" title="2.5 特效"></a>2.5 特效</h4><p>GPU 渲染管线中的可编程阶段有顶点、几何和像素着色器三个部分，他们需要相互结合在一起使用。正因如此，不同的团队研发出了不同的特效语言，例如 HLSL FX，CgFX，以及 COLLADA FX，来将他们更好的结合在一起。</p><p>一个效果文件通常会包含所有执行一种特定图形算法的所有相关信息，而且通常定义一些可被应用程序赋值的全局参数。例如，一个单独的  effect file 可能定义渲染塑料材质需要的  vs（顶点着色器）和  ps（像素着色器），它可能暴露一些参数例如塑料颜色和粗糙度，这样渲染每个模型的时候可以改变效果而仅仅使用同一个特效文件。一个效果文件中能存储很多 techniques。这些 techniques 通常是一个<br>相同特效的变体。</p><p>下图展示了一些特效文件带来的材质和后处理效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104314983.png" alt="image-20220513104314983"></p><h3 id="3-思维导图"><a href="#3-思维导图" class="headerlink" title="3 思维导图"></a>3 思维导图</h3><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104353817.png" alt="image-20220513104353817"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中 GPU 渲染管线和可编程着色器的相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU 管线概述&lt;/li&gt;
&lt;li&gt;可编程着色模型&lt;/li&gt;
&lt;li&gt;思维导图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】图形渲染管线</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-05-12T09:41:09.000Z</published>
    <updated>2022-05-12T09:43:20.381Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中图形渲染管线的相关知识进行概括总结。主要内容包括：</p><ul><li>图形渲染管线整体架构</li><li>图形渲染管线各阶段工作</li><li>思维导图</li></ul><p><em><span id="more"></span></em></p><h2 id="1-知识总结"><a href="#1-知识总结" class="headerlink" title="1 知识总结"></a>1 知识总结</h2><h3 id="1-1-图形渲染管线架构"><a href="#1-1-图形渲染管线架构" class="headerlink" title="1.1 图形渲染管线架构"></a>1.1 图形渲染管线架构</h3><p>在概念上可以将图形渲染管线分为三个阶段：</p><ul><li>应用程序阶段（The Application Stage）</li><li>几何阶段（The Geometry Stage）</li><li>光栅化阶段（The Rasterizer Stage）</li></ul><p>如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152034788.png" alt="image-20220512152034788"></p><p>图形渲染管线的每个阶段也可能是一条管线，比如上图中几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</p><h3 id="1-2-应用程序阶段"><a href="#1-2-应用程序阶段" class="headerlink" title="1.2 应用程序阶段"></a>1.2 应用程序阶段</h3><p>应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。</p><p>正因应用程序阶段是软件方式实现，因此不能像几何和光栅化阶段那样继续分为若干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在 CPU 设计上，称这种形式为超标量体系（superscalar）结构，因为它可以在同一阶段同一时间做不同的几件事情。</p><p><strong>应用程序阶段通常实现的方法</strong>有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p><p><strong>应用程序阶段的主要任务</strong>：在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元，rendering primitives，如点、线、矩形等）输入到绘制管线的下一个阶段。</p><p>对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段——几何阶段。</p><h3 id="1-3-几何阶段"><a href="#1-3-几何阶段" class="headerlink" title="1.3 几何阶段"></a>1.3 几何阶段</h3><p>几何阶段主要负责大部分多边形操作和顶点操作。可以将这个阶段进一步划分成如下几个功能阶段：</p><ul><li>模型视点变换 Model &amp; View Transform</li><li>顶点着色 Vertex Shading</li><li>投影 Projection</li><li>裁剪 Clipping</li><li>屏幕映射 Screen Mapping</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152716026.png" alt="image-20220512152716026"></p><p>几个注意点：</p><ul><li>根据具体实现，这些阶段可以和管线阶段等同，也可以不等同。在一些情况下，一系列连续的功能阶段可以形成单个管线阶段（和其他管线阶段并行运行）。在另外情况下，一个功能阶段可以划分成其他更细小的管线阶段。</li><li>几何阶段执行的是计算量非常高的任务，在只有一个光源的情况下，每个顶点大约需要 100 次左右的精确的浮点运算操作。</li></ul><h4 id="1-3-1-模型和视图变换"><a href="#1-3-1-模型和视图变换" class="headerlink" title="1.3.1 模型和视图变换"></a>1.3.1 模型和视图变换</h4><p>在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中。<strong>模型变换的变换对象一般是模型的顶点和法线</strong>。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p><p>为了便于投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向 Z 轴负方向，y 轴指向上方,x 轴指向右边。在视点变换后，实际位置和方向就依赖于当前的 API。我们称上述空间为相机空间或者观察空间。</p><p>下图显示了模型和视图变换的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512153245093.png" alt="image-20220512153245093"></p><p>在左图中，摄像机根据用户指定的位置进行放置和定位。在右图中，视点变换从 原点沿着 Z 轴负方向对相机重新定位，这样可以使裁剪和投影操作更简单、更快速。可视范围是一个平截椎体，因此可以认为它是透视模式。</p><p><strong>【总结】</strong>模型和视图变换阶段分为模型变换和视图变换。模型变换的目的是将模型变换到适合渲染的空间当中，而视图变换的目的是将摄像机放置于坐标原点，方便后续步骤的操作。</p><h4 id="1-3-2-顶点着色"><a href="#1-3-2-顶点着色" class="headerlink" title="1.3.2 顶点着色"></a>1.3.2 顶点着色</h4><p>为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些描述。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p><p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shading equation）。通常，这些计算中的一部分在几何阶段期间在模型的顶点上执行（vertex shading），而其他计算可以在逐像素光栅化（per-pixel rasterization）期间执行。可以在每个顶点处存储各种属性数据，诸如顶点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。<strong>顶点着色的结果（可以是颜色，向量，纹理坐标或任何其他种类的着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</strong></p><p>着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型空间、观察空间、法线空间等）并在那里执行计算，也可以得到正确的结果。这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p><p><strong>【总结】</strong>顶点着色阶段的目的在于确定模型上顶点处材质的光照效果。</p><h4 id="1-3-3-投影"><a href="#1-3-3-投影" class="headerlink" title="1.3.3 投影"></a>1.3.3 投影</h4><p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是 (-1,- 1,-1) 和 (1,1,1) 的单位立方体（unit cube）内，这个单位立方体通常也被称为规范立方体（Canonical View Volume，CVV）。</p><p>目前，主要有两种投影方法，即：</p><ul><li>正交投影（orthographic projection，或称  parallel projection）</li><li>透视投影（perspective projection）</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512154019834.png" alt="image-20220512154019834"></p><p>正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。而在透视投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</p><p>正交投影和透视投影都可以通过 4 x 4 的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。</p><p><strong>【总结】</strong>投影的目的在于将模型顶点变换到归一化的设备坐标系中，便于后续处理。</p><h4 id="1-3-4-裁剪"><a href="#1-3-4-裁剪" class="headerlink" title="1.3.4 裁剪"></a>1.3.4 裁剪</h4><p>只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。</p><p>不难理解，一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p><ul><li>当图元完全位于视体内部，那么它可以直接进行下一个阶段</li><li>当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染</li><li>当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理</li></ul><p>裁剪的过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512160053289.png" alt="image-20220512160053289"></p><p>投影变换后，只对单位立方体内的图元（相应的是视锥内可见图元）继续进行处理，因此，将单位立方体之外的图元剔除掉，保留单位立方体内部的图元，同时沿着单位立方体将与单位立方体相交的图元裁剪掉，于是就会产生新的图元，同时舍弃旧的图元。</p><p><strong>【总结】</strong>裁剪阶段的目的，就是对部分位于视体内部的图元进行裁剪操作以只保留在视体内的部分。</p><h4 id="1-3-5-屏幕映射"><a href="#1-3-5-屏幕映射" class="headerlink" title="1.3.5 屏幕映射"></a>1.3.5 屏幕映射</h4><p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的 x 和 y 坐标变换到了屏幕坐标系中，屏幕坐标系连同 z 坐标一起称为窗口<br>坐标系。<br>假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2， y2），其中  x1 &lt; x2，y1 &lt; y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中 z 坐标不受影响。新的 x 和 y 坐标称为屏幕坐标系，与 z 坐标一起（-1 ≦ z ≦ 1）进入光栅化阶段。<br>屏幕映射过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163021922.png" alt="image-20220512163021922"></p><p><strong>【总结】</strong>屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p><h3 id="1-4-光栅化阶段"><a href="#1-4-光栅化阶段" class="headerlink" title="1.4 光栅化阶段"></a>1.4 光栅化阶段</h3><p>给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。这个过个过程叫光珊化（rasterization）或扫描变换（scan conversion），即从二维顶点所处的屏幕空间（所有顶点都包含 Z 值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。</p><p>与几何阶段相似，该阶段细分为几个功能阶段：</p><ul><li>三角形设定（Triangle Setup）阶段</li><li>三角形遍历（Triangle Traversal）阶段</li><li>像素着色（Pixel Shading）阶段</li><li>融合（Merging）阶段</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163755234.png" alt="image-20220512163755234"></p><h4 id="1-4-1-三角形设定"><a href="#1-4-1-三角形设定" class="headerlink" title="1.4.1 三角形设定"></a>1.4.1 三角形设定</h4><p>三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。<strong>该过程在专门为其设计的硬件上执行</strong>。</p><h4 id="1-4-2-三角形遍历"><a href="#1-4-2-三角形遍历" class="headerlink" title="1.4.2 三角形遍历"></a>1.4.2 三角形遍历</h4><p>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成<strong>片元（fragment）</strong>。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。<strong>每个片元的属性均由三个三角形顶点的数据插值而生成，这些属性包括片元的深度，以及来自几何阶段的着色数据等。</strong><br><strong>【总结】</strong>找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。</p><h4 id="1-4-3-像素着色"><a href="#1-4-3-像素着色" class="headerlink" title="1.4.3 像素着色"></a>1.4.3 像素着色</h4><p><strong>所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。</strong>纹理贴图操作就是在这阶段进行的。像素着色阶段是在可编程 GPU 内执行的，在这一阶段有大量的技术可以使用，其中最常见，<br>最重要的技术之一就是纹理贴图（Texturing），将会在之后进行总结。</p><p><strong>【总结】</strong>像素着色阶段的主要目的是计算所有需逐像素操作的过程。</p><h4 id="1-4-4-融合"><a href="#1-4-4-融合" class="headerlink" title="1.4.4 融合"></a>1.4.4 融合</h4><p>每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。<strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。</strong>不像其它着色阶段，通常运行该阶段的 GPU 子单元并非完全可编程的，但其高度可配置，可支持多种特效。</p><p>此外，这个阶段还负责可见性问题的处理。对于大多数图形硬件来说，这个过程是通过 <strong>Z 缓冲（Z-Buffer）</strong>算法来实现的。Z 缓冲算法非常简单，具有 O(n) 复杂度（n 是需要绘制的像素数量），只要对每个图元计算出相应的像素 z 值，就可以使用这种方法，大概内容是：Z 缓冲器和颜色缓冲器形状大小一样，每个像素都存储着一个 z 值，这个 z 值是从相机到最近图元之间的距离。每次将一个图元绘制为相应像素时，需要计算像素位置处图元的 z 值，并与同一像素处的 z 缓冲器内容进行比较。如果新计算出的 z 值，远远小于 z 缓冲器中的 z 值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近。这样，像素的 z 值和颜色就由当前图元对应的值和颜色进行更新。反之，若计算出的 z 值远远大于 z 缓冲器中的 z 值，那么 z 缓冲器和颜色缓冲器中的值就无需改变。</p><p>除了颜色缓冲器用来存储颜色，z 缓冲器用来存储每个像素的  z 值，还有其他缓冲器可以用来过滤和捕获片段信息：</p><ul><li><strong>alpha 通道（alpha channel）</strong>和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值。 可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片断未能通过测试，它将不再进行进一步的处理。alpha 测试经常用于不影响深度缓存的全透明片段的处理。</li><li><strong>模板缓冲器（stencil buffer）</strong>是用于记录所呈现图元位置的离屏缓存。每个像素通常与占用 8 个位。图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和 Z 缓存的渲染。举个例子，假设在模板缓冲器中绘制出了一个实心圆形，那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个 mask 的操作。模板缓冲器是制作特效的强大工具。而在管线末端的所有这些功能都叫做光栅操作（raster operations ，ROP）或混合操作（blend operations）。</li><li><strong>帧缓冲器（frame buffer）</strong>通常包含一个系统所具有的所有缓冲器，但有时也可以认为是颜色缓冲器和 z 缓冲器的组合。</li><li><strong>累计缓冲器（accumulation buffer）</strong>，是 1990 年，Haeberli 和 Akeley 提出的一种缓冲器，是对帧缓冲器的补充。这个缓冲器可以用一组操作符对图像进行累积。例如，为了产生运动模糊（motion blur），可以对一系列物体运动的图像进行累积和平均。此外，其他的一些可产生的效果包括景深（e depth of field），反走样（antialiasing）和软阴影（soft shadows）等。</li></ul><p>而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了<strong>双缓冲（double buffering）</strong>机制，这意味着屏幕绘制是在一个后置缓冲器（backbuffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换。注意，只有当不影响显示的时候，才进行交换。</p><p><strong>【总结】</strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。此外，融合阶段还负责可见性问题（Z 缓冲相关）的处理。</p><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>图形渲染管线的主要功能就是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。在概念上可以将图形渲染管线分为三个阶段：应用程序阶段、几何阶段、光栅化阶段。</p><p><strong>应用程序阶段</strong>的主要任务，是将需要绘制图元输入到绘制管线的下一个阶段，以及实现一些软件方式来实现的方法。主要方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法。对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段，即几何阶段。</p><p><strong>几何阶段</strong>首先对模型的顶点和法线进行矩阵变换，并将模型置于观察空间中（模型和视图变换），然后根据材质、纹理、以及光源属性进行顶点光照的计算（顶点着色阶段），接着将该模型投影变换到一个单位立方体内，并舍弃所有立方体之外的图元（投影阶段），而为了得到所有位于立方体内部的图元，接下来对与单位立方体相交的图元进行裁剪（裁剪阶段），然后将顶点映射到屏幕上的窗口中（屏幕映射阶段）。在对每个多边形执行完这些操作后，将最终数据传递到光栅，这样就来到了管线中的最后一个阶段，光栅化阶段。</p><p><strong>光栅化阶段</strong>中，所有图元会被光栅化，进而转换为屏幕上的像素。首先，计算三角形表面的差异和三角形表面的其他相关数据（三角形设定阶段），然后，找到哪些采样点或像素在三角形中（三角形遍历阶段），接着计算所有需逐像素计算操作（像素着色阶段），然后，合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，可见性问题可通过 Z 缓存算法解决，随同的还有可选的 alpha 测试和模版测试（融合阶段）。所有对象依次处理，而最后的图像显示在屏幕上。</p><h2 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2 思维导图"></a>2 思维导图</h2><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg" alt="图形渲染管线思维导图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中图形渲染管线的相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形渲染管线整体架构&lt;/li&gt;
&lt;li&gt;图形渲染管线各阶段工作&lt;/li&gt;
&lt;li&gt;思维导图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（七）模板和RTTI</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/</id>
    <published>2022-05-11T08:08:23.000Z</published>
    <updated>2022-05-11T08:12:51.045Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第七章重点梳理。主要内容包括：</p><ul><li>模板（Template）</li><li>执行期类型识别（Runtime Type Identification，RTTI）</li></ul><p><em><span id="more"></span></em></p><h3 id="1-模板（Template）"><a href="#1-模板（Template）" class="headerlink" title="1 模板（Template）"></a>1 模板（Template）</h3><h4 id="1-1-模板的实例化"><a href="#1-1-模板的实例化" class="headerlink" title="1.1 模板的实例化"></a>1.1 模板的实例化</h4><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++ 标准才要求实例化他们。其原因，有两点：</p><ul><li>空间和时间效率的考虑，如果模板类中有 100 个成员函数，对某个特定类型只有 2 个函数会被使用，针对另一个特定类型只会使用 3 个，那么如果将剩余的 195 个函数实例化将浪费大量的时间和空间。</li><li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li></ul><h4 id="1-2-模板的名称决议"><a href="#1-2-模板的名称决议" class="headerlink" title="1.2 模板的名称决议"></a>1.2 模板的名称决议</h4><p>对于一个模板类来说，需要明确两个范围：一个是定义模板的范围（scope of the template definition），另一个是实例化模板的范围（scope of the template instantiation）。</p><p>下面来举例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeRules</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        _member = <span class="built_in">foo</span>( _val );  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>( _member );  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _val;  </span><br><span class="line">    type _member;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope of the template instantiation  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;  </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ScopeRules&lt; <span class="type">int</span> &gt; sr0;  </span><br><span class="line"><span class="comment">/*(1)*/</span>sr0.<span class="built_in">invariant</span>();</span><br><span class="line"><span class="comment">/*(2)*/</span>sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></table></figure><p>对于上面的语句（1），将会调用哪一个 <code>foo()</code> 函数呢？答案是 <code>double foo ( double )</code>，这是一个完全反直觉的答案，原因在于 <code>invariant()</code> 函数调用了一个外部函数 <code>foo()</code> ，但传入的参数是模板类中固定类型的成员 <code>_val</code>，无论模板被实例化为什么类型，其中的 <code>_val</code> 都是 int 型，也就是说它完全与实例化模板的参数的类型无关，此时对于外部函数名称的决议会在定义模板的范围内进行，在上面的例子中，定义模板的范围内只有一个 <code>foo()</code> 函数的声明，所以即使 <code>_val</code> 是 int 型，也会调用 double 作为参数的 <code>foo()</code> 函数。</p><p>而对于语句（2），会调用 <code>int foo( int )</code>，因为 <code>type_dependent()</code> 函数将与实例化模板的参数类型有关的成员作为参数传给了外部函数，此时就无法在定义模板类的范围内决议使用哪个 <code>foo()</code> 函数，所以要推迟到模板被实例化之后再决议，因此会在实例化模板的范围内寻找合适的函数，上面的例子中，实例化模板的范围中有两个声明的 <code>foo()</code> 函数，所以会选择和模板类型匹配的 <code>foo(int)</code> 函数进行调用。</p><p>总结一下，在模板中，一个非成员名称的决议在于它适不适合在当前决议，当它完全与实例化模板的参数类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，于是将被推迟到实例化这个模板的时候才决议。</p><h3 id="2-执行期类型识别（Runtime-Type-Identification）"><a href="#2-执行期类型识别（Runtime-Type-Identification）" class="headerlink" title="2 执行期类型识别（Runtime Type Identification）"></a>2 执行期类型识别（Runtime Type Identification）</h3><p>在一开始学习多态的时候就已经了解过 RTTI，这里最后进行总结：</p><ol><li>RTTI  只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI 的，这是因为 RTTI 的实现是通过 vptr 来获取存储在虚函数表中的 <code>type_info*</code> ，事实上为非多态类提供 RTTI 也没有多大意义</li><li>对指针进行 <code>dynamic_cast</code> 失败会返回 NULL，而对引用的话，失败会抛出 <code>bad_cast exception</code>，这是由于指针可以被赋值为 0，以表示 no object，但是引用不行</li><li><code>typeid</code> 可以返回 <code>const type_info&amp;</code>，用以获取类型信息。虽然第一点指出 RTTI 只支持多态类，但 <code>typeid</code> 和 <code>type_info</code> 同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的 <code>type_info</code> 对象是静态取得（所以不能叫“执行期类型识别”），而多态类的是在执行期获得。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第七章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板（Template）&lt;/li&gt;
&lt;li&gt;执行期类型识别（Runtime Type Identification，RTTI）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（六）关于执行期</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/</id>
    <published>2022-05-11T07:17:16.000Z</published>
    <updated>2022-05-11T07:19:14.225Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第六章重点梳理。主要内容包括：</p><ul><li>执行期对象的构造与析构</li><li>详解 new 和 delete</li></ul><p><em><span id="more"></span></em></p><h3 id="1-对象的构造与析构"><a href="#1-对象的构造与析构" class="headerlink" title="1 对象的构造与析构"></a>1 对象的构造与析构</h3><p>一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    Point point; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// point.Point::Point() 一般被安插在这儿      </span></span><br><span class="line">    </span><br><span class="line">    ...      </span><br><span class="line">             </span><br><span class="line">    <span class="comment">// point.Point::~Point() 一般被安插在这儿 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方</strong>，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。</p><h4 id="1-1-全局对象（Global-Objects）"><a href="#1-1-全局对象（Global-Objects）" class="headerlink" title="1.1 全局对象（Global Objects）"></a>1.1 全局对象（Global Objects）</h4><p>一个全局对象，C++ 保证它在 <code>main()</code> 第一次使用它之前将其构造，而在 <code>main()</code> 结束之前，将之析构掉。C++ 程序中所有的 global objects 都被放置在程序的 data segment (数据段) 中，如果明确指定给它一个值， object 将以该值为初值。否则 object 所配置到的内存内容为 0.</p><p>虽然全局对象在编译期被即被置为 0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是静态初始化。所谓静态初始化，是因为全局变量被放在 data segment，data segment 是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为 0，存储在数据段，而等到程序激活时，就可以通过构造函数对在数据段的全局对象进行初始化了.</p><blockquote><p>以下引用自原书：</p><p>静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置于 try 块中，我们知道一个没有得到 catch 的异常默认的调用 <code>terminate()</code> 函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…</p><p>Lippman 甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。</p></blockquote><h4 id="1-2-局部静态对象（Local-Static-Objects）"><a href="#1-2-局部静态对象（Local-Static-Objects）" class="headerlink" title="1.2 局部静态对象（Local Static Objects）"></a>1.2 局部静态对象（Local Static Objects）</h4><p>下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Matrix&amp;  <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> Matrix mat_identity;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>static</code> 语意保证了 mat_identity 对象在整个程序周期都存在，而不会在函数 <code>identity()</code>退出时被析构，所以：</p><ul><li>mat_identity 的构造函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li><li>mat_identity 的析构函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li></ul><p>那么 mat_identity 的构造函数和析构函数到底在什么时候被调用？答案是：mat_identity 的构造函数只有在  <code>identity()</code> 第一次被调用时才被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。</p><h4 id="1-3-对象数组（Array-of-Objects）"><a href="#1-3-对象数组（Array-of-Objects）" class="headerlink" title="1.3 对象数组（Array of Objects）"></a>1.3 对象数组（Array of Objects）</h4><p>对于定义的一个对象数组，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际上背后做的工作是：</p><ol><li>分配充足的内存以存储 10 个 Point 对象；</li><li>为每个 Point 对象调用它们的默认构造函数（如果有的话，且不论是合成的还是显式定义的）。编译器一般以一个或多个函数来完成这个任务。当数组的生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。而关于具体细节，不必要死扣了，每个编译器肯定都有些许差别。</li></ol><h3 id="2-new-和-delete"><a href="#2-new-和-delete" class="headerlink" title="2 new 和 delete"></a>2 new 和 delete</h3><p>C++ 中一个经常容易混淆的问题是关于：operator new、new expression 和 placement operator new。这一节来详细讨论这三者的区别和联系。</p><h4 id="2-1-operator-new-和-new-expression"><a href="#2-1-operator-new-和-new-expression" class="headerlink" title="2.1 operator new 和 new expression"></a>2.1 operator new 和 new expression</h4><p>首先要明确，operator new 是一个运算符，和 +、-、*、% 等一样，是可以被重载的，而 new expression 不可以被重载，new expression 是对 operator new 的又一层封装。</p><p>C 语言中 <code>malloc</code> 函数我们非常熟悉，函数原型为 <code>void* malloc(size_t size)</code> ，参数 size 为要分配的字节数，返回值是 void*，通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址，失败会返回 NULL，但是申请成功后并不进行初始化，每个数据都是随机值。</p><p>operator new 是对 malloc 的封装，因此功能和 malloc 完全一样，只有一点细微的不同，operator new 在内存申请失败时会抛出异常，除此之外完全相同，也就是说，operator new 只用于分配内存。</p><p>而当我们使用非常熟悉的 new expression，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>实际上包含了两个步骤：</p><ul><li>调用 operator new 分配内存</li><li>调用合适的构造函数初始化这块内存，如果不是自定义的类，那么初始化就是简单的赋值操作</li></ul><p>由此可见， new expression 是对 operator new 的又一层封装。</p><p>我们当然也可以直接使用 operator new，比如只想分配内存的时候，完全可以替代 C 语言中的 <code>malloc</code> 操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T* newelements = <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line"><span class="comment">// 等同于T* pa = (T*)malloc(sizeof(T));</span></span><br><span class="line"><span class="comment">// static_cast表示明确的显式转换，可以告诉编译器和阅读程序的人这样的转换是故意为之</span></span><br></pre></td></tr></table></figure><p>STL 中重载有两个版本的 operator new，分别为单个对象和数组对象服务，单个对象版本提供给分配单个对象的 <code>new</code> 表达式调用，数组版提供给分配数组的 <code>new[]</code> 表达式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;     <span class="comment">// allocate an object</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// allocate an array</span></span><br></pre></td></tr></table></figure><p>我们可以分别重载这两个版本，来自定义单个对象或对象数组的内存分配方式。当我们自己在重载 operator new 时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个 <code>void*</code> 类型和第一个参数的类型必须为 <code>size_t</code>。</p><p>同样的，operator delete 和 delete expression 的关系和上述 operator new 和 new expression 的关系完全一样，delete expression 会先调用析构函数，再调用 operator delete 释放内存。operator delete 的功能和 C 中的 <code>free</code> 完全一样，是对 <code>free</code> 的封装。</p><p>需要注意的是，在类中重载的 operator new 和 operator delete 必须是静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个 this 指针来存取对象成员。另外，new expression 默认调用的是单参数的 operator new，即上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p><h4 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h4><p>有下面两种关于 delete expression 的情况，第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// p为什么能delete两次，而程序运行的时候还不报错。</span></span><br></pre></td></tr></table></figure><p>第二种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> ;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">5</span>;     <span class="comment">//delete后为什么还可以对*p进行再赋值？</span></span><br></pre></td></tr></table></figure><p>在回答这两个问题之前，我们先想想 <code>delete p</code>  这一语句意味着什么？p 指向一个地址，以该地址为起始地址保存有一个 <code>int</code> 变量（虽然该变量并没有进行初始化，因此默认为 0），<code>delete p </code> 之后 p 所指向的地址空间被释放，也就是说这个 int 变量的生命结束，但是 p 仍是一个合法的指针，它仍指向原来的地址，而且该地址仍代表着一个合法的程序空间。与 <code>delete</code> 之前唯一不同的是，你已经丧失了那块程序空间的所有权。但你依然可以通过指针对这块空间进行操作，因为你还保留有这块空间的“钥匙” p。</p><p>此时通过指针 p 对这块空间进行操作虽然从语法上来说是合法的，但是暗藏着很大的逻辑错误。不论是对一块已经释放的内存再度 <code>delete</code>，还是再度给它赋值，都暗含着很大的危险，因为当你 <code>delete</code> 后，就代表着将这块内存归还，而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度 <code>delete</code> 还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，完全取决于编译器够不够“聪明”。</p><p>上述情况下的指针 p 被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。避免野指针的一个好方法是，当一个指针变为野指针的时候，马上赋值为 <code>NULL</code>，其缘由在于，你可以很容易的判断一个指针是否为 <code>NULL</code>，却难以抉择其是否为野指针。而且，<code>delete </code> 一个空指针，不会做任何操作，因此总是安全的。</p><h4 id="2-3-placement-operator-new-和-placement-new-expression"><a href="#2-3-placement-operator-new-和-placement-new-expression" class="headerlink" title="2.3 placement operator new 和 placement new expression"></a>2.3 placement operator new 和 placement new expression</h4><p>placement new expression 的功能是对已经存在的空间进行初始化，即用来在指定地址上构造对象，因此它并不分配内存，仅仅是对指定地址调用构造函数。</p><p>而 placement operator new 是对 operator new 的重载，它的功能就是返回给定的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 p 指针指向的内存已经存在，不需要再分配内存，因此只要返回这个指针即可。</p><p>placement new expression 先调用 placement operator new 返回指针 p，然后调用构造函数初始化这个指针指向的内存，这样也就完成了对已经存在的空间进行初始化的工作。</p><p>需要注意的是，通过 placement new expression 构建的一个对象，如果你使用 delete 来删除对象，那么其内存也会被回收，如果想保留内存而只析构对象，好的办法是显式调用其析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* pa = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="comment">// 使用 placement new expression 初始化内存</span></span><br><span class="line"><span class="built_in">new</span>(pa) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 显式调用析构函数析构对象</span></span><br><span class="line">pa-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// 此时内存还在，手动使用delete释放内存，如果直接使用delete则其自动先调用析构，再释放内存</span></span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上并没有 placement new expression 这么一说，上面的说法只是为了便于理解，从头到尾都只有一个 new expression，并且 new expression 永远都只进行以下两个步骤：</p><ul><li>调用一个合适参数的 operator new 来分配内存，可以是普通的 operator new，也可以是 operator new[]，还可以是 placement  operator new</li><li>调用一个合适参数的构造函数初始化 operator new 分配的内存</li></ul><h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><p>operator new、new expression 和 placement operator new 三者的关系现在非常明了，总结如下：</p><ul><li>operator new 相当于 malloc 分配内存，区别在于申请失败时抛出异常而不是返回空指针</li><li>placement operator new 将给定的指针直接返回，相当于返回一块已经存在的内存</li><li>new expression 首先调用合适的 operator new 分配内存（可能是新分配的，也可能是已经存在的），然后调用构造函数初始化这块内存</li><li>operator delete 相当于 free 释放内存</li><li>delete expression 首先调用析构函数，然后调用 operator delete 释放内存</li></ul><h4 id="2-5-内存池"><a href="#2-5-内存池" class="headerlink" title="2.5 内存池"></a>2.5 内存池</h4><p>关于内存池技术有必要的话可以再做深入学习，这里只做简单了解即可。</p><p>利用默认的内存管理操作符 new 和 delete 在堆上分配和释放内存会有一些额外的开销。</p><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。</p><p>可见，如果程序频繁地使用 new 和 delete 在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。</p><p>C++ 引入了内存池（Memory Pool）来提高内存管理和运行效率。内存池是一种高效的内存分配方式，其工作原理是先向系统一次性申请比较大的空间，当我们每次去申请空间时就直接使用内存池里的空间，而省略了申请和释放的两个动作开销，也减少了系统内存碎片，从而提高了系统效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第六章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行期对象的构造与析构&lt;/li&gt;
&lt;li&gt;详解 new 和 delete&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（五）对象复制和析构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/</id>
    <published>2022-05-09T08:37:15.000Z</published>
    <updated>2022-05-11T07:16:51.387Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第五章重点梳理。主要内容包括：</p><ul><li>关于对象复制操作（Copy Assignment Operator）</li><li>关于对象析构（Destruction）</li><li>几点类的设计原则</li></ul><p><em><span id="more"></span></em></p><h3 id="1-关于-Copy-Assignment-Operator"><a href="#1-关于-Copy-Assignment-Operator" class="headerlink" title="1 关于 Copy Assignment Operator"></a>1 关于 Copy Assignment Operator</h3><p>Copy Assignment Operator 是指类中对 <code>operator=</code> 的重载，用来将一个对象指定给另一个对象。如果我们希望不允许将该类的对象指定给另一个对象，只需要将 <code>operator=</code> 设定为 private，并且不提供函数体即可。</p><p>当然大部分情况下，类的设计者可以选择不显式提供 copy assignment operator，使用默认的逐成员复制（类似于拷贝构造函数），因为这样既方便，效率又高。copy assignment operator 和拷贝构造函数一样，只在有用（nontrivial）的时候会真正被编译器产生或合成出来，而其他情况下由于保持有 bitwise copy semantics，不需要以函数调用的形式进行复制，也就无须合成。在四种情况下 copy assignment operator 会被视为 nontrivial 而被合成出来：</p><ul><li>当 class 中包含一个对象成员而后者的类声明有一个 copy assignment operator 时，因为需要调用对象成员的 copy assignment operator</li><li>当 class 继承自一个 base class 而后者存在有一个 copy assignment operator 时，因为需要调用基类的 copy assignment operator</li><li>当 class 声明了一个或多个 virtual functions 时，因为我们一定不能直接拷贝等号右边对象的 vptr，因为等号左边可能是基类对象，而右边是派生类对象</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时（不论虚基类有没有 copy assignment operator）</li></ul><h3 id="2-关于析构（Destruction）"><a href="#2-关于析构（Destruction）" class="headerlink" title="2 关于析构（Destruction）"></a>2 关于析构（Destruction）</h3><p>如果 class 没有显式定义析构函数，那么只有在 class 内包含的 member object（或是 class 自己的 base class）拥有析构函数时，编译器才会自动合成一个析构函数，否则，析构函数会被视为不需要，也就不需被合成（当然更不需要被调用）。析构函数的扩展和执行顺序类似于之前构造函数的执行顺序，并且与构造函数的顺序完全相反：</p><ol><li>构造函数本身首先被执行</li><li>如果有对象成员，且其有析构函数，按照它们声明顺序的相反顺序调用它们的析构函数</li><li>如果有 vptr，则重设 vptr，指向适当的基类的虚函数表</li><li>如果有任何直接的（上一层） nonvirtual base classes 拥有 destructor，它们会以其声明顺序的相反顺序被调用</li><li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个类是继承链最尾端 (most-derived) 的类，那么它们会以其原来的构造顺序的相反顺序被调用</li></ol><p>对于如下类继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/image-20220509161840825.png" alt="image-20220509161840825"></p><p>那么一个 PVertex 对象的构造过程是：首先构造一个 Point 对象，然后变成一个 Vertex 和一个 Point3d 对象，然后变成一个 Vertex3d 对象，最后变成一个 PVertex 对象；而一个 PVertex 对象的析构过程正相反：依次变成一个 Vertex3d 对象、一个 Vertex 对象、 一个 Point3d 对象，最后成为一个 Point 对象。</p><p>所以对象的构造是一个逐步进化的过程，从构建一个最基础的对象开始，一步步构建成一个目标对象，而对象的析构则是相反的逐步退化的过程。</p><h3 id="3-几点类的设计原则"><a href="#3-几点类的设计原则" class="headerlink" title="3 几点类的设计原则"></a>3 几点类的设计原则</h3><ul><li><p><strong>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。</strong>或许你可以通过其派生类来初始化它的数据成员（假如 non-static data member 为 publish 或 protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的 data member 应当被初始化，且只在其构造函数或其 member function 中初始化。</p></li><li><p><strong>只在有必要的时候才使用虚函数，不要滥用虚函数</strong>。虚函数意味着不小的成本，编译器很可能给你的类带来一连串的膨胀效应：</p><ul><li>每一个对象要多负担一个 vptr</li><li>给每一个构造函数（不论是显式的还是编译器合成的），插入一些代码来初始化 vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前</li><li>生成或合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对 vptr 的初始化代码</li><li>如果类原本具有 bitwise copy 语意，将失去该语义，然后是上面所述，更大的对象、没有那么高效的构造函数、没有那么高效的复制操作</li></ul></li><li><p><strong>不能决定一个虚函数是否需要 const ，那么就不要 const。</strong></p></li><li><p><strong>不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义，但还是必须实现该纯虚析构函数，否则所有的派生类都将遇到链接错误。这是因为，每一个派生类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显式的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义，所以当编译器看到一个其基类的析构函数声明，就去调用它的实体，而不管它有没有被定义。</p></li><li><p><strong>决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个基类的构造函数含有对虚函数的调用，当其派生类的构造函数调用基类的构造函数时，其中调用的虚函数是基类中的实体，而不是派生类中的实体。这是由 vptr 初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因为构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象，析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第五章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于对象复制操作（Copy Assignment Operator）&lt;/li&gt;
&lt;li&gt;关于对象析构（Destruction）&lt;/li&gt;
&lt;li&gt;几点类的设计原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（四）关于函数成员</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/</id>
    <published>2022-05-09T07:22:16.000Z</published>
    <updated>2022-05-11T07:16:45.856Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第四章重点梳理。主要内容包括：</p><ul><li>调用不同成员函数的背后工作</li><li>虚函数详解</li><li>内联函数的背后工作</li></ul><p><em><span id="more"></span></em></p><h3 id="1-调用不同成员函数的背后工作"><a href="#1-调用不同成员函数的背后工作" class="headerlink" title="1 调用不同成员函数的背后工作"></a>1 调用不同成员函数的背后工作</h3><p>C++ 类中包括三种成员函数：非静态成员函数、静态成员函数和虚函数。这三种成员函数被调用时，编译器会进行不同的背后工作。</p><h4 id="1-1-非静态成员函数"><a href="#1-1-非静态成员函数" class="headerlink" title="1.1 非静态成员函数"></a>1.1 非静态成员函数</h4><p>C+＋的设计准则之一就是：非静态成员函数必须至少和一般的非成员函数有相同的效率。所以 C++ 的做法就是在非静态成员函数被调用时，编译器将其转化为一般的非成员函数，并传入一个对象的指针。</p><p>假设有一个成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x * _x + _y * _y +  _z * _z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是转化步骤：</p><ol><li>改写函数的 signature（函数原型）以安插一个额外的参数到成员函数中，作为对对象成员的存取管道，该额外参数即为 this 指针，如果成员函数是 const，则传入参数也为 const</li><li>将对每一个成员变量的存取操作改为经由 this 指针的存取操作</li><li>将成员函数重写为一个外部非成员函数，并对函数名进行编码，使其有一个独一无二的内部名称</li></ol><p>转化后的的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">(<span class="type">const</span> Point3d* <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">        <span class="keyword">this</span>-&gt;_x * <span class="keyword">this</span>-&gt;_x + </span><br><span class="line">        <span class="keyword">this</span>-&gt;_y * <span class="keyword">this</span>-&gt;_y +  </span><br><span class="line">        <span class="keyword">this</span>-&gt;_z * <span class="keyword">this</span>-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对函数的调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">magnitude</span>();</span><br></pre></td></tr></table></figure><p>也被转化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magnitude_7Point3dFv</span>(ptr);</span><br></pre></td></tr></table></figure><h4 id="1-2-静态成员函数"><a href="#1-2-静态成员函数" class="headerlink" title="1.2 静态成员函数"></a>1.2 静态成员函数</h4><p>静态成员函数类似于非静态成员函数，编译器同样将其转化为一般的外部非成员函数，唯一的区别在于，传入的参数不是 this 指针，而是一个被强制转化后的指针，编译器将 0 强制转化为对象指针传入函数，所以一个静态成员函数转化后是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">((Point3d*) <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也正因为这样的转化，决定了我们所熟悉的静态成员函数的特性：</p><ul><li>无需经由类对象调用，通过类名即可调用，因为无需传入具体的对象指针，0 指针只作为一个执行静态成员函数的绑定对象指针，除此之外没有任何功能</li><li>不能够直接存取类中的非静态成员，因为指针是 0，实际不指向任何对象实体</li><li>不能声明为 const，virtual 等</li></ul><h4 id="1-3-虚拟成员函数"><a href="#1-3-虚拟成员函数" class="headerlink" title="1.3 虚拟成员函数"></a>1.3 虚拟成员函数</h4><p>虚成员函数在调用时被转化为经由 vptr 指向的虚函数表中的索引值调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>]) (ptr);</span><br></pre></td></tr></table></figure><p>其中传入的 ptr 也是 this 指针，1 是该函数在虚函数表中的索引。</p><h3 id="2-虚函数详解"><a href="#2-虚函数详解" class="headerlink" title="2 虚函数详解"></a>2 虚函数详解</h3><p>之前我们已经了解了虚函数的一般模型：每一个类有一个虚函数表，其中存放该类中所有有作用的虚函数地址，然后每个对象内含一个成员变量 vptr，指向虚函数表。这一节中我们根据不同继承情况，深入了解该模型内部原理。</p><h4 id="2-1-单一继承"><a href="#2-1-单一继承" class="headerlink" title="2.1 单一继承"></a>2.1 单一继承</h4><p>任何情况下，一个 class 只会有一个 virtual table 。每一个 table 内含其对应的 class object 中所有 active virtual functions 函数实体的地址。这些 active virtual functions 包括：</p><ul><li>这个 class 所定义的函数实体。它会改写 (overriding) 一个可能存在的 base class virtual function 实体</li><li>继承自 base class 的函数实体。这是在 derived class 决定不改写 base class virtual function 时才会出现的情况</li><li>一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序</li></ul><p>单一继承情况下的虚函数表布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509102615749.png" alt="image-20220509102615749"></p><p>可以看到 Point2d 继承自 Point 类，重写的函数会覆盖基类虚函数，比如析构函数，以及在 Point2d 中实现的纯虚函数等，而没有重写的函数则直接复制基类虚函数表中该函数的地址，比如 Point::z() 函数。</p><p>回顾上一节提到的虚函数在编译时的转化，假设现在有如下调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure><p>则会被编译器转化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>]) (ptr);</span><br></pre></td></tr></table></figure><p>于是这样的形式就可以提供给程序足够的信息，使其在执行期知道调用哪一个函数实体，因为：</p><ul><li>虽然不知道 ptr 指向的具体对象类型，但是我们知道经由 ptr 可以访问到该对象的 vptr，从而访问到类的虚函数表</li><li>虽然不知道哪一个函数实体 z() 会被调用，但是所有类的 z() 函数实体地址都放在虚函数表中下标为 4 的地方</li></ul><p>这正是指针和虚函数所支持的多态的内部原理之一。在一个单一继承体系中，这样的机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，就没有这么简单了。</p><h4 id="2-2-多重继承"><a href="#2-2-多重继承" class="headerlink" title="2.2 多重继承"></a>2.2 多重继承</h4><p>在多重继承之下，一个 derived class 内含 n 个虚函数表，n 表示上一层基类数目，其中第一个基类子对象指向的表为主要表格，其他的为次要表格，第一个基类的虚函数和派生类自己的虚函数都放在主要表格中。针对每一个虚函数表，派生类对象中都有对应的 vptr，当我们将一个派生类对象指定给第一个基类或者派生类的指针时，处理的是主要表格，其他情况处理的是次要表格。</p><p>多重继承情况下，虚函数表布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509105025788.png" alt="image-20220509105025788"></p><p>上图中的 * 表示需要调整 this 指针，当我们将派生类对象指定给第二个或之后的基类指针时，会存在一些需要调整 this 指针以支持正确的虚函数的情况，一般来说有以下三种情况（对应上面三个星号）：</p><ol><li>第一种情况：通过指向第二个基类的指针调用派生类的虚函数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure><p>上面的代码中 ptr 首先会被编译器调整至指向基类对象中的第二个基类子对象，编译器的调整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *ptr = temp ? temp + <span class="built_in">sizeof</span>(Base1) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这样才能保证后续正确地访问或调用与第二个基类有关的成员和方法。但接下来的 <code>delete ptr</code> 需要调用析构函数，此时需要将 ptr 再向后调整至指向派生类对象起始地址，才能正确执行析构函数删除整个派生类对象。</p><ol start="2"><li>第二种情况：通过一个指向派生类的指针，调用第二个基类中一个继承而来的虚函数，在这种情况派生类指针需要调整至指向第二个基类子对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line">pder-&gt;<span class="built_in">mumble</span>();</span><br><span class="line"><span class="comment">//pedr必须向前调整sizeof(Base1)个字节以指向第二个基类子对象</span></span><br></pre></td></tr></table></figure><ol start="3"><li>第三种情况发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化，可能是 base type，也可能是 publicly derived type。这一点可以通过上图中的 clone() 函数说明，clone() 函数的派生版本返回一个派生类对象，默默地改写了两个基类函数实体，当我们通过第二个基类指针调用 clone() 函数时，需要调整 this 指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">// 返回值必须调整以指向第二个基类子对象</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure><p>当进行 <code>pb1-&gt;clone()</code> 时，pb1 会被调整指向派生类对象的起始地址，于是会调用 clone() 函数的派生版本，它会传回一个新的派生类对象，当该对象被指定给第二个基类的指针时，需要调整以指向第二个基类子对象。</p><h4 id="2-3-虚拟继承"><a href="#2-3-虚拟继承" class="headerlink" title="2.3 虚拟继承"></a>2.3 虚拟继承</h4><p>虚拟继承的情况非常复杂，即使只有唯一的一个虚基类，他们的关系也不会像单一继承情况那样简单，因为虚基类和派生类不再相符，两者之间同样需要进行 this 指针转化。</p><p>当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual functions 和 nonstatic data members 时，编译器对于 virtual base class 的支持简直就像进了迷宫一样。总之一个建议是，<strong>不要在虚基类中声明非静态成员变量</strong>。</p><h3 id="3-内联函数的背后工作"><a href="#3-内联函数的背后工作" class="headerlink" title="3 内联函数的背后工作"></a>3 内联函数的背后工作</h3><p>下表对比了不同类型成员函数的执行效率：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509112026194.png" alt="image-20220509112026194"></p><p>可以看到内联函数的效率占据绝对优势。在以往的学习中我们被告知，inline 函数将会在被调用的时候在调用处产生函数实体，这个操作称为扩展，即把内联函数代码扩展到调用处替换函数调用代码。</p><p>但实际上不是所有声明为 inline 的函数都能成为内联函数，inline 只是一种请求，只有这个请求被接受才会在函数调用处扩展 inline 代码。那么编译器如何决定是否接受这个请求呢？</p><p>编译器有一套复杂的算法来决定是否将函数认定为 inline，通常是计算 assignments、function calls、virtual function calls 等操作的次数。每个操作（表达式）种类有一个权值，而 inline 函数的复杂度就以这些操作的总和来决定。当其执行成本比一般的函数调用及返回机制所带来的负荷低，就被认定为 inline。</p><p>一般而言，处理一个 inline 函数包括以下两个阶段：</p><ul><li>分析函数定义，以决定是否认定为 inline，如果函数因其复杂度，或因其建构问题，被判断为不可成为 inline，则它会被转为一个 static 函数，并在被编译模块内产生对应的函数定义。</li><li>真正的 inline 函数扩展操作是在调用的那个地方进行，这会带来参数的求值操作以及临时性对象的管理问题，接下来具体讨论。</li></ul><h4 id="3-1-有副作用的参数"><a href="#3-1-有副作用的参数" class="headerlink" title="3.1 有副作用的参数"></a>3.1 有副作用的参数</h4><p>inline 函数是如何被扩展的？下面一个例子可以说明问题，假设有如下内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是三个调用操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**（1）**/</span>minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line"><span class="comment">/**（3）**/</span>minval = <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">bar</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>以上三个调用会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**（1）**/</span>minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**（3）**/</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">bar</span>() + <span class="number">1</span>;</span><br><span class="line">minval = t1 &lt; t2 ? t1 : t2;</span><br></pre></td></tr></table></figure><p>第（3）个调用把函数调用作为参数传入 inline 函数，这可能导致实际参数的多次求值操作，因此被认为是有副作用的参数，所以在扩展时使用了临时变量。而传入常量则会直接执行表达式，并将内联函数扩展为赋值操作。</p><h4 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h4><p>如果我们修改 inline 函数，引入局部变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> minval = i &lt; j ? i : j</span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">minval = <span class="built_in">min</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>则会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min_lv_minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">minval = min_lv_minval</span><br></pre></td></tr></table></figure><p>inline 函数中的局部变量会被保留，并产生一个拥有唯一编码名字的临时变量。如果 inline 函数在同一个 scope 中被调用多次，那么每次都会产生一组名字不同的临时变量。</p><p>inline 函数中的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生。特别是它被调用多次的时候，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minval = <span class="built_in">min</span>(val1, val2) + <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">foo</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为局部变量产生的临时变量</span></span><br><span class="line"><span class="type">int</span> min_lv_minval_00;</span><br><span class="line"><span class="type">int</span> min_lv_minval_01;</span><br><span class="line"><span class="comment">// 为副作用参数产生的临时变量</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">foo</span>() + <span class="number">1</span>;</span><br><span class="line">min_lv_minval_00 = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">min_lv_minval_01 = t1 &lt; t2 ? t1 : t2;</span><br><span class="line">minval = min_lv_minval_00 + min_lv_minval_01;</span><br></pre></td></tr></table></figure><p>内联函数对于封装提供了一种必要的支持，可以有效存取封装于 class 中的 nonpublic 数据。它同时也是 C 程序中大量使用的<code>#define</code> （前置处理宏）的一个安全代替品，特别是如果宏中的参数有副作用的话。然而一个 inline 函数如果被调用太多次的话，会产生大量的扩展码，使程序的大小暴涨，并且由于参数带有副作用或者 inline 函数中有局部变量，会产生大量临时对象，编译器无法将它们移除。此外，inline 中再有 inline，可能会使一个表面上看起来简单的 inline 因其连锁复杂度而没办法扩展开来。对于既要安全又要效率的程序， inline 函数提供了一个强而有力的工具。然而，与 non-inline 函数比起来，它们需要更加小心地处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第四章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用不同成员函数的背后工作&lt;/li&gt;
&lt;li&gt;虚函数详解&lt;/li&gt;
&lt;li&gt;内联函数的背后工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（三）关于数据成员</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</id>
    <published>2022-05-07T08:49:49.000Z</published>
    <updated>2022-05-11T07:16:25.586Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第三章重点梳理。主要内容包括：</p><ul><li>C++ 字节对齐和类大小计算</li><li>数据成员的布局、虚函数表和虚基类表的布局</li></ul><p><em><span id="more"></span></em></p><h3 id="1-C-字节对齐"><a href="#1-C-字节对齐" class="headerlink" title="1 C++ 字节对齐"></a>1 C++ 字节对齐</h3><p>关于 C++ 字节对齐这篇文章讲得非常细致：<a href="https://blog.csdn.net/sweetfather/article/details/78487563">C++ 字节对齐的总结(原因和作用)</a></p><p>这里只做简要总结：</p><ul><li><p>字节对齐的原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是，如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个 int 型数据存放在偶地址开始的地方，那么一个读周期就可以读出这 32 位数据，而如果存放在奇地址开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32 位数据，显然在读取效率上下降很多</p></li><li><p>可以使用 <code>pragma pack(n)</code> 指定以 n 字节方式对齐，不指定则按默认方式对齐</p></li><li><p>字节对齐是要看变量所在偏移地址是否为变量字节数（或指定对齐字节数 n，取二者较小值）的整数倍</p></li><li><p>对于结构成员，要按照结构成员中对齐长度最大的一个对齐</p></li><li><p>对齐后还要看结构或类的总大小是否为其中最长变量（或指定对齐字节数 n，取二者较小值）的整数倍</p></li></ul><p>按照以上规则可以保证对齐后整个结构或类对象所占空间最小，并保证读取效率。</p><h3 id="2-C-类大小计算"><a href="#2-C-类大小计算" class="headerlink" title="2 C++ 类大小计算"></a>2 C++ 类大小计算</h3><p>关于 C++ 类的大小计算这篇文章讲的非常全面：<a href="https://www.cnblogs.com/fengyaoyao/p/10262312.html">C++类的大小计算汇总</a></p><p>这里只做简要总结：</p><p>C++ 中的类由于涉及虚函数、静态成员、虚拟继承、多继承、空类等情况，类对象的大小较为复杂，但总结起来遵循以下几个原则：</p><ul><li>类的大小是指类对象实体的大小，类大小的计算遵循字节对齐原则</li><li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员，均对类的大小无影响；静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区</li><li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响</li><li>空类的大小为 1，因为 C++ 要为某一个实体分配内存就要求这个实体必须有大小，不能为大小为 0 的实体分配内存，所以 C++ 会为空类指定 1 个字节作为其大小，防止 sizeof 为 0，含有虚函数，虚继承，多继承是特殊情况</li></ul><h4 id="2-1-关于空类"><a href="#2-1-关于空类" class="headerlink" title="2.1 关于空类"></a>2.1 关于空类</h4><p>C++ 空类大小为 1，这之中有两种情况需要注意：</p><ul><li>如果一个派生类继承自空类，且派生类有自己的数据成员，则基类子对象的一个字节不会加入到派生类中，因为派生类有自己的数据成员意味着有大小，可以分配内存，所以不需要空类的 1 个字节</li><li>一个类包含一个空类对象成员，这时空类的一个字节是要被计算进去的，因为空类对象必须有自己大小</li></ul><h4 id="2-2-关于虚函数"><a href="#2-2-关于虚函数" class="headerlink" title="2.2 关于虚函数"></a>2.2 关于虚函数</h4><p>虚函数是通过一张虚函数表来实现的。编译器必需要<strong>保证虚函数表的指针存在于对象实例中最前面的位置</strong>（这是为了保证正确取到虚函数的偏移量）。</p><p>每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就会为这个类创建一个虚函数表保存该类所有虚函数的地址，其实这个虚函数表的作用就是保存自己类中所有虚函数的地址，可以把虚函数表形象地看成一个函数指针数组，这个数组的每个元素存放的就是虚函数的地址。在每个带有虚函数的类中，编译器秘密地置入一指针，称为 vptr，指向这个对象的虚函数表。 当构造该派生类对象时，其成员 vptr 被初始化指向该派生类的虚函数表。所以可以认为<strong>虚函数表是该类的所有对象共有的</strong>，在定义该类时被初始化；而 <strong>vptr 则是每个类对象都有独立一份的</strong>，且在该类对象被构造时被初始化。</p><p>含有虚函数的时候，类的大小计算要注意以下几点：</p><ul><li>由于指针大小为 8 字节，因此含有虚函数的任何类的大小都是原本大小加上 8 字节</li><li>当继承的基类含有虚函数时，在派生类中不对基类的虚函数进行覆盖，同时派生类中还拥有自己的虚函数。此时派生类的虚函数表中首先存放基类虚函数地址，再存放派生类虚函数地址，所有虚函数地址顺序与声明顺序一致。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102541174.png" alt="image-20220507102541174"></p><ul><li>如果派生类中对基类的虚函数进行了覆盖，同时派生类中还拥有自己的虚函数。此时虚函数表中原本存放基类虚函数的位置会被覆盖为派生类重写的虚函数地址，其他顺序不变。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102558864.png" alt="image-20220507102558864"></p><ul><li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数无重载，此时派生类虚函数被放在第一个积累虚函数表后面，派生类的大小就是原本大小加上基类数量 * 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102738036.png" alt="image-20220507102738036"></p><ul><li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数有重载，情况和上述一致，这时任意一个基类指针指向派生类对象都可以调用派生类重载的基类虚函数</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102832628.png" alt="image-20220507102832628"></p><p>上面文章中的一个例子，在 Visual C++ 中的运行结果和文章中不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>    </span><br><span class="line">&#123;    </span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>    </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch1; </span><br><span class="line">    <span class="type">char</span> ch2; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> d;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> e;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;    <span class="comment">//result=1 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;    <span class="comment">//result=16     </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;C=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl;    <span class="comment">//result=16 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(D)&lt;&lt;endl;    <span class="comment">//result=24 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;E=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(E)&lt;&lt;endl;    <span class="comment">//result=40 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关于类 E 的大小，有必要再详细分析一下：类 E 包含一个类 B 子对象 16字节，一个类 C 子对象 16 字节，以及自身的 int 4 字节，现在一共是 36字节，但因为要跟成员中最大变量虚函数表指针 8 字节对齐，最终补齐到 40 字节。</p><blockquote><p>可以在 VS 中输出类的布局，打开 vs项目属性-&gt;配置属性-&gt; c&#x2F;c++ -&gt;命令行，在其它选项中添加如下命令：</p><ul><li><code>/d1 reportAllClassLayout</code> 是查看所有类的布局</li><li><code>/d1 reportSingleClassLayoutXX</code> 是查看名为XX的类的布局</li></ul><p>配置之后重新编译项目，会在编译输出中打印类布局。</p></blockquote><p>上面例子中，类 E 的布局打印出来如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507113905627.png" alt="image-20220507113905627"></p><p>和我们的分析一致，同时还可以看到类 E 的两个虚函数表的布局：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507113943452.png" alt="image-20220507113943452"></p><p>其中 <code>E::$vftable@B@</code> 是基类 B 的虚函数表，存放的是被 E 重载后的函数 func0 的指针， <code>E::$vftable@C@</code> 是基类 C 的虚函数表，存放的是 C 的函数 func 和被 E 重载的函数 func1 的指针。</p><h4 id="2-3-关于虚继承"><a href="#2-3-关于虚继承" class="headerlink" title="2.3 关于虚继承"></a>2.3 关于虚继承</h4><p>Visual C++ 中虚继承的情况比较简单，只是多了一个指向虚基类表的指针 vbptr，而真正的指向虚基类的指针存放在虚基类表中。</p><h3 id="3-数据成员的布局"><a href="#3-数据成员的布局" class="headerlink" title="3 数据成员的布局"></a>3 数据成员的布局</h3><p>最后通过一个例子总结 C++ 数据成员布局，通过下面这个例子可以清晰的认识 C++ 类数据成员布局、虚函数表和虚基类表的布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class X is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Y is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Y) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Z is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Z) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class A is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中包含了虚继承、多重继承、虚函数的情况，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size of class X is 4</span><br><span class="line">size of class Y is 24</span><br><span class="line">size of class Z is 32</span><br><span class="line">size of class A is 56</span><br></pre></td></tr></table></figure><p>我们打印类 A 的布局：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507115635356.png" alt="image-20220507115635356"></p><p>可以看到类 A 的布局：</p><ul><li>首先是基类 Y 的子对象，Y 包含一个虚函数，同时有一个虚基类，所以 Y 的内存中就是两个指针，一个是虚函数表指针 vfptr，一个是虚基类表指针 vbptr，共 16 字节；</li><li>然后是基类 Z 的子对象，Z 同样包含 vfptr 和 vbptr，以及一个 int 成员，字节对齐后一共是 24 字节，此时类 A 总共偏移 40 字节</li><li>然后是类 A 自己的数据成员，char 类型一个字节，类 A 总共偏移 41 字节，最终要和类中最长成员 8 字节对齐，因此对齐到 48 字节</li><li>类 A 的全部成员都存放完后，最后存放虚基类成员，int 占 4 字节，此时类 A 总共 52 字节，但输出是 56 字节，实际又做了一次 8 字节对齐，因为打印出的内存布局把类 A 和虚基类子对象作为两个独立的部分，所以打印 48 + 4 &#x3D; 52 字节，但实际还要做一次 8 字节对齐，所以 sizeof 输出 56 字节</li></ul><p>然后是类 A 的虚函数表：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507120353989.png" alt="image-20220507120353989"></p><p>虚函数表的第一项表示派生类对象指针相对于虚函数表指针的偏移，这里派生类 A 相对于基类 Y 的虚函数表指针的偏移是 0 字节，相对于基类 Z 的虚函数表指针的偏移是 -16 字节。</p><p>最后是类 A 的虚基类表：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507120419152.png" alt="image-20220507120419152"></p><p>虚基类表原理与虚函数表类似，表的第一项表示派生类对象指针相对于虚基类表指针的偏移，这里是 -8 字节，因为虚基类表指针前面还有一个虚函数表指针占用了 8 个字节，所以派生类 Y 对象的指针相对于其虚基类表指针的偏移量是 -8，派生类 Z 对象的指针相对于其虚基类表指针的偏移也是 -8，注意这里的派生类不再是指 A 了，而是指虚基类的派生类，所以就是 Y 和 Z；虚基类表从第二项开始，表示各个虚基类地址相对于虚基类表指针的偏移。这里虚基类 X 相对于 Y 的虚基类表指针偏移了 40 个字节，因此虚基类 X 相对于派生类 Y 的地址总共偏移了 48 字节，对于派生类 Z 也同样如此，总共偏移了 24 + 8 &#x3D; 32 个字节，从上面的内存布局可以清晰地看出这一点。</p><p>可以看到，Y 和 Z 的虚基类表都指向同一个虚基类 X 的子对象，正如之前所说的，虚基类无论在继承链中被继承多少次，都只产生一个实体，即虚基类子对象，但是“不同的派生类中虚基类子对象的位置不同”这句话，一方面是指虚基类子对象相对于派生类的起始地址偏移量不同，并不是存在多个虚基类子对象；另一方面，随着类的派生，虚基类子对象的位置确实可能变化，但所有派生类的虚基类表中都指向那同一个虚基类子对象。</p><p>最后总结一下，C++ 中数据成员布局与编译器有关，但总体原理一致，Visual C++ 中数据成员布局顺序为：</p><ul><li>基类子对象<ul><li>虚函数表指针 vfptr</li><li>虚基类表指针 vbptr</li><li>基类成员</li></ul></li><li>数据成员</li><li>虚基类成员</li></ul><blockquote><p>注：有的编译器不存在虚基类表指针 vbptr，而是把虚基类的偏移放在虚函数表中，这样只需要一个虚函数表指针</p></blockquote><p>最最后附上一个简单的问题：为什么不把派生类的成员填到基类子对象由于字节对齐而填充的空白内存中，而是要保留基类子对象的空白内存？</p><p>直接借用书中的图解释：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507164044837.png" alt="image-20220507164044837"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第三章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 字节对齐和类大小计算&lt;/li&gt;
&lt;li&gt;数据成员的布局、虚函数表和虚基类表的布局&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（二）关于构造函数</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2022-05-06T07:48:21.000Z</published>
    <updated>2022-05-11T07:16:12.268Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第二章重点梳理。主要内容包括：</p><ul><li>默认构造函数的构建操作</li><li>拷贝构造函数的构建操作</li><li>使用列表进行初始化的背后工作</li></ul><p><em><span id="more"></span></em></p><h2 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1 默认构造函数"></a>1 默认构造函数</h2><p>有一种常见的说法是，如果定义一个类的时候没有显式的为其声明构造函数，那么编译器将会自动生成默认的构造函数，但一般来说编译器生成的默认构造函数对于程序而言是没有任何用处的，编译器生成默认构造函数完全是为了满足编译器的需要，而不是我们所编写的程序的需要。但在一些情况下，编译器生成的默认构造函数是有用的，下面将讨论这些情况。</p><h3 id="1-1-带有默认构造函数的类对象成员"><a href="#1-1-带有默认构造函数的类对象成员" class="headerlink" title="1.1 带有默认构造函数的类对象成员"></a>1.1 带有默认构造函数的类对象成员</h3><p>如果一个类没有显式声明构造函数，但包含一个声明了构造函数的类对象成员，那么这个类的默认构造函数就是有用的。编译器会为这个类生成一个默认构造函数，但这个生成操作只在构造函数真正需要被调用的时候才进行。</p><p>例如，有下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>)... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">if</span>(str) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 Bar 中包含一个对象成员 foo，该对象有显式声明的构造函数，因此编译器会为 Bar 生成默认构造函数，这个默认构造函数会调用 Foo 的构造函数来初始化对象成员 foo，但不会初始化 Bar 的 str 成员，因为初始化对象成员是编译器需要的，编译器必须为每个对象分配内存，而初始化一个字符指针对于编译器来说不需要。所以编译器生成的默认构造函数看起来就是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器自动生成的构造函数、析构函数、拷贝构造、assignment 等都被指定为内联函数，如果函数太复杂不适合做成内联，就会生成一个显式的非内联静态（explicit non-inline static）函数实体。</p><p>为了让程序正确运行，我们需要把 str 成员也初始化，但这不能指望编译器来生成，需要手动实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;str = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>这时，虽然显式声明了构造函数，但这个构造函数没有初始化对象成员 foo，所以也还是没有满足编译器的需求，因此编译器还是会自动生成构造函数，但这时编译器不会单独生成一个函数了，而是会在用户定义的构造函数上进行扩展，加入编译器需要的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();   <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    str = <span class="number">0</span>;          <span class="comment">// 用户定义的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类中有多个对象成员，这些成员都有显式定义的构造函数，那么编译器自动生成构造函数时会按照对象成员的声明顺序调用他们的构造函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: <span class="built_in">Dopey</span>(); ...);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ...); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ...) ;</span><br><span class="line">               </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy; </span><br><span class="line">    Bashful bashful;</span><br><span class="line">    <span class="comment">// 显式定义的构造函数</span></span><br><span class="line">    <span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mumble = <span class="number">2048</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mumble; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时编译器自动扩展后的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    dopey.Dopey::<span class="built_in">dopey</span>();</span><br><span class="line">    sneezy.Sneezy::<span class="built_in">sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::<span class="built_in">bashful</span>();</span><br><span class="line">    <span class="comment">// 用户定义的代码</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-带有默认构造函数的基类"><a href="#1-2-带有默认构造函数的基类" class="headerlink" title="1.2 带有默认构造函数的基类"></a>1.2 带有默认构造函数的基类</h3><p>如果一个没有显式定义构造函数的类派生于一个有显式构造函数的基类，那么这个派生类的默认构造函数是有用的。派生类自动生成的默认构造函数将调用上一层基类的默认构造函数（根据声明次序）。</p><p>如果程序员为这个派生类声明了多个构造函数，但就是没有默认构造函数，那么编译器会扩展程序员声明的所有构造函数，将调用所有必要的默认构造函数的代码加入这些构造函数中，这些必要的默认构造函数就包括其父类的默认构造函数，以及其对象成员的默认构造函数。</p><h3 id="1-3-带有虚函数的类"><a href="#1-3-带有虚函数的类" class="headerlink" title="1.3 带有虚函数的类"></a>1.3 带有虚函数的类</h3><p>对于以下两种情况，默认构造函数也是有用的：</p><ul><li>带有虚函数的类</li><li>该类派生自一个继承链，这个继承链中有一个或多个带有虚函数的基类</li></ul><p>这两种情况下编译器将会在默认构造函数中加入对虚函数表的操作，因此是有用的。</p><p>例如有下图的继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505163329344.png" alt="image-20220505163329344"></p><p>执行下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.<span class="built_in">flip</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译期间，编译器会进行如下两个扩展操作：</p><ol><li>编译器会产生一张虚函数表 vtbl，其中存放类的虚函数地址</li><li>每一个类对象中，编译器会生成一个额外的指针成员 vptr，指向类的虚函数表</li></ol><p>此外，<code>widget.flip()</code> 的虚拟引发（virtual invocation）操作会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip() 条目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*widget.vptr[<span class="number">1</span>]) (&amp;widget)</span><br></pre></td></tr></table></figure><p>其中 1 表示 flip() 在虚函数表中的索引，<code>&amp;widget</code> 表示要交给被调用的某个 flip() 函数实体的 this 指针。</p><p>为了让这个机制发挥功效，编译器必须为每一个 Widget （或其派生类）的对象的 vptr 设定初值，放置适当的 virtual table 地址。对于 class 所定义的每一个构造函数，编译器会安插一些代码来做这样的事情。对于那些未声明任何构造函数的类，编译器会为它们生成一个默认构造函数，以便正确地初始化每一个 class object 的 vptr。</p><h3 id="1-4-继承于虚拟基类的类"><a href="#1-4-继承于虚拟基类的类" class="headerlink" title="1.4 继承于虚拟基类的类"></a>1.4 继承于虚拟基类的类</h3><p>虚拟继承的实现方法在不同的编译器之间有极大的差异，但是每一种实现方法都必须保证虚拟基类（virtual base class）子对象（subobject）在其每一个派生类对象中的位置能够在执行期准备妥当。例如有如下继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505165553286.png" alt="image-20220505165553286"></p><p>有下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> i;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">int</span> j;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">double</span> d;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;<span class="keyword">public</span>: <span class="type">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译期间编译器无法确定函数 foo 中 <code>pa-&gt;X::i</code> 的实际位置，因为 pa 的类型可以改变，其中包含的基类子对象的位置并不确定，因此编译器必须改变<strong>对虚拟基类成员进行存取操作的代码</strong>（例如上面的 <code>pa-&gt;i = 1024</code> 就是在对虚拟基类的成员进行存取操作），使得 <code>pa-&gt;X::i</code> 可以延迟到执行期才确定下来。</p><p>编译器通过在派生类对象中添加一个指向虚拟基类的指针来完成上述操作，任何对虚拟基类成员的存取操作都可以通过该指针完成，比如上面的代码会被编译器改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>__vbcX</code> 是编译器为派生类对象生成的指向 virtual base class X 的指针。 <code>__vbcX</code> 是在对象构造期间产生的，对于类中声明的每一个构造函数，编译器都会加入构建 <code>__vbcX</code> 的代码，如果类中没有声明任何构造函数，那么编译器会生成一个默认构造函数来完成这件事。</p><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>以上四种情况，会导致 C++ 编译器必须为没有显式声明构造函数的类生成（合成）一个默认构造函数。C++ 将这些默认构造函数称为 implicit nontrivial default constructors。</p><p>被生成（合成）出来的 constructor 只能满足编译器（而非程序）的需要，这样的构造函数之所以被称为 nontrivial ，是因为他们完成了一些对编译器来说必要的工作：</p><ul><li>调用对象成员的构造函数</li><li>调用基类的构造函数</li><li>为对象初始化指向虚函数表的指针</li><li>为对象初始化其 virtual base class 的指针</li></ul><p>至于不存在这四种情况而又没有显式声明构造函数的类，我们说它拥有的是 implicit trivial default constructors，这样的构造函数没有任何用处，实际上也不会被生成出来。</p><p>在生成（合成）的构造函数中，只有基类子对象和对象成员会被初始化，其他所有的非静态成员变量，如 int，*int，int[] 等，都不会被初始化，因为这些初始化或许对程序而言有用，但对编译器来说并不必要。</p><p><strong>因此，以下两种常见说法是完全错误的：</strong></p><ul><li>任何没有显式声明默认构造函数的类都会由编译器产生一个默认构造函数</li><li>编译器生成的默认构造函数会将类中所有成员明确初始化</li></ul><h2 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2 拷贝构造函数"></a>2 拷贝构造函数</h2><p>有三种情况，会以一个对象的内容作为另一个对象的初值：</p><ul><li>使用一个对象对另一个对象进行初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;...&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// 明确以一个对象对另一个对象初始化</span></span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure><ul><li>对象作为函数参数传递：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(X x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 以对象作为函数参数</span></span><br><span class="line">    <span class="built_in">foo</span>(xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象作为函数返回值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序员在类中明确定义了一个拷贝构造函数（copy constructor），即以本类型作为参数的构造函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>(<span class="type">const</span> X&amp; X);</span><br><span class="line">Y::<span class="built_in">Y</span>(<span class="type">const</span> Y&amp; y, <span class="type">int</span> = <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>那么在上述情况下，拷贝构造函数将被调用。但如果类中没有用户显式定义的拷贝构造函数，编译器将如何完成拷贝操作呢？</p><h3 id="2-1-Default-Memberwise（逐成员的）-Initialization"><a href="#2-1-Default-Memberwise（逐成员的）-Initialization" class="headerlink" title="2.1 Default Memberwise（逐成员的） Initialization"></a>2.1 Default Memberwise（逐成员的） Initialization</h3><p>当用户没有显式定义拷贝构造函数时，编译器内部是以 Default Memberwise Initialization（默认逐成员初始化） 方法完成该操作的。也就是把每一个内建的或派生的成员变量（指针或其他变量）的值，从某个对象拷贝到另一个对象身上，但它并不会拷贝其中的类对象成员（member class object），而是以递归的方式进行 Memberwise Initialization。</p><p>例如，有一个字符串类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们把一个字符串对象作为另一个对象的初值时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure><p>Default Memberwise Initialization 将会像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure><p>如果一个 String 对象作为另一个类的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    String _word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 word 对象的 Default Memberwise Initialization 将会直接拷贝成员 <code>_occurs</code>，然后在 <code>_word</code> 身上递归的进行 Memberwise Initialization，即递归的调用 String 对象的 Default Memberwise Initialization。</p><p>一个类对象可以从两种方式复制得到，一种是被初始化（即我们现在讨论的），另一种是被指定（assignment），将会之后的章节讨论。这两个操作分别是以 copy constructor 和 copy assignment operator 完成的。拷贝构造函数和上一节的默认构造函数一样，只在必要的时候才由编译器产生出来，因此“如果一个 class 未定义出 copy constructor，编译器就自动为它自动生成一个”这句话是不对的。并且拷贝构造函数也被分为有用的（nontrivial）和无用的（trivial），只有 nontrivial 的拷贝构造函数才会被生成或者合成到现有代码中，而决定一个拷贝构造函数是否是 nontrivial 的标准在于这个类是否展现出所谓的 “bitwise copy semantics”。</p><h3 id="2-2-bitwise-copy-semantics（逐位次拷贝语义）"><a href="#2-2-bitwise-copy-semantics（逐位次拷贝语义）" class="headerlink" title="2.2 bitwise copy semantics（逐位次拷贝语义）"></a>2.2 bitwise copy semantics（逐位次拷贝语义）</h3><p>现有下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;word.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    word verb = noun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然 verb 是根据 noun 来初始化的，但是在没有看过 word 类的声明之前，我们无法预测这个初始化操作的程序行为，如果 word 类的设计者定义了一个拷贝构造函数，verb 的初始化就会调用它，但如果没有显式定义的拷贝构造函数，编译器是否会为 word 类生成一个拷贝构造函数呢？这就得视 word 类是否展现出 “bitwise copy semantics” 而定。</p><p>举例说明，比如 word 类有如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    ~<span class="built_in">word</span>() &#123;<span class="keyword">delete</span> [] str;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种情况下并不需要合成出一个拷贝构造函数，因为上面的声明展现出了 default copy semantics，于是 verb 的初始化也就不需要以一个函数调用进行。但如果 word 类的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明没有展现 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">word</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 String 类显式声明了拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);    <span class="comment">//显式声明了拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个情况下，编译器必须合成出一个拷贝构造函数，以便调用对象成员的拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">word::word</span><span class="params">(<span class="type">const</span> word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成出来的拷贝构造函数也会将非对象成员进行复制。</p><p>一个类在四种情况下不会展现出 bitwise copy semantics，即会由编译器生成拷贝构造函数：</p><ul><li>当 class 中包含一个对象成员而后者的类声明有一个拷贝构造函数时（这个拷贝构造函数可以是被用户显式声明的，就像前面的 String 那样，也可以是被编译器合成的，像 word 那样）</li><li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（同样可以是用户定义的，也可以是编译器生成的）</li><li>当 class 声明了一个或多个 virtual functions 时</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时</li></ul><p>前两种情况中，编译器必须将对象成员或基类的拷贝构造函数调用代码安插到生成的拷贝构造函数中，而后两种情况较为复杂，下面具体讨论。</p><h3 id="2-3-重新设定-Virtual-Table-指针"><a href="#2-3-重新设定-Virtual-Table-指针" class="headerlink" title="2.3 重新设定 Virtual Table 指针"></a>2.3 重新设定 Virtual Table 指针</h3><p>首先是第三种情况。当类中声明了虚函数时，编译器会为类生成一个虚函数表，并在每一个类对象中增加一个指向虚函数表的指针 vptr，因此在拷贝构造函数中必须要对对象的 vptr 进行正确的赋值，否则后果不堪设想，所以这种情况下编译器必须生成拷贝构造函数。</p><p>假设有下面的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ZooAnimal 对象以另一个 ZooAnimal 对象作为初值，或者 Bear 对象以另一个 Bear 对象作为初值都可以直接靠 bitwise copy semantics 来完成，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure><p>yogi 会被 Bear 的默认构造函数初始化，在构造函数中，yogi 的 vptr 被设定指向 Bear 类的虚函数表（靠编译器安插代码完成），因此直接把 yogi 的 vptr 值复制给 winnie 是完全没问题的，二者的关系如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506105047329.png" alt="image-20220506105047329"></p><p>但是当一个基类对象以一个派生类对象作为初值进行初始化时，其 vptr 复制操作就不是这么简单了，如果直接把派生类对象的 vptr 复制给基类对象，就会发生严重错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal franny = yogi;</span><br><span class="line">franny.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure><p>如果 franny 的 vptr 被复制为 yogi 的 vptr，那么相当于一个 ZooAnimal 类的对象会调用 Bear 派生类的函数实体，这就会发生严重错误。因此编译器必须保证在拷贝构造函数中为基类对象设定正确的 vptr 值。</p><p>事实上，上述代码执行的会是 ZooAnimal 的 draw 方法，因为 franny 是一个 ZooAnimal 对象，yogi 中的 Bear 部分已经在 franny 初始化时被切割（sliced）掉了，如果 franny 被声明为一个指针或者引用，那么 <code>franny.draw()</code> 才会调用 Bear 的 draw 方法。</p><p>也就是说，编译器自动生成的拷贝构造函数会明确设定基类对象的 vptr 指向基类的虚函数表，而不是直接从派生类中复制 vptr 的值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110202874.png" alt="image-20220506110202874"></p><h3 id="2-4-处理-Virtual-Base-Class-Subobject"><a href="#2-4-处理-Virtual-Base-Class-Subobject" class="headerlink" title="2.4 处理 Virtual Base Class Subobject"></a>2.4 处理 Virtual Base Class Subobject</h3><p>接下来讨论第四种情况。一个类对象以另一个对象作为初值，而后者有一个 virtual base class subobject，那么也会使 bitwise copy semantics 失效，从而编译器必须生成拷贝构造函数。</p><p>之前学习过，编译器必须保证 virtual base class subobject 在其每一个派生类对象中的位置能够在执行期准备妥当，但 bitwise copy semantics 可能会破坏这个位置，所以编译器必须生成一个拷贝构造函数来处理这一事件。</p><p>比如有下面的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Raccoon</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">Raccoon</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类之间的继承关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110945550.png" alt="image-20220506110945550"></p><p>显然，编译器首先会安插一些代码在 Raccoon 的构造函数中，包括：调用基类 ZooAnimal 的默认构造函数，设定 Raccoon 的 vptr 值，定位出 Raccoon 中 ZooAnimal 子对象的位置等。</p><p>虽然 Raccoon 类中含有一个虚拟基类子对象，但当我们用 Raccoon 对象初始化另一个 Raccoon 对象时，也不会出现额外的问题，只依靠 bitwise copy 即可。问题在于“用派生类对象初始化一个基类对象”，比如现在有一个 RedPanda 类继承于 Raccoon 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedPanda</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">RedPanda</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506111610997.png" alt="image-20220506111610997"></p><p>使用一个 RedPanda 对象初始化 Raccoon 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure><p>这时，只依靠 bitwise copy 就不够了，编译器必须明确的将 little_critter 的 virtual base class subobject 指针初始化，以指出 virtual base class subobject 在哪。</p><p>这种情况下，为了正确完成 little_critter 的初值设定，编译器必须生成一个拷贝构造函数，安插一些代码以设定 virtual base class subobject 指针的初值，对每一个成员执行必要的逐成员初始化，以及其他内存相关工作。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506112328821.png" alt="image-20220506112328821"></p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>我们已经讨论过所有四种情况，这四种情况实际上和上一节默认构造函数的四种情况一致。在这些情况下，类不再保持 bitwise copy semantics，并且默认拷贝构造函数未被声明的话，会被视为 nontrivial，于是编译器为了正确处理“以一个对象作为另一个对象初值”的情况，必须生成或合成一个拷贝构造函数。</p><h2 id="3-使用列表初始化成员"><a href="#3-使用列表初始化成员" class="headerlink" title="3 使用列表初始化成员"></a>3 使用列表初始化成员</h2><p>C++ 中书写构造函数有一种特殊的写法，就是使用列表对类成员进行初始化，这一节来了解使用列表对成员进行初始化的背后发生了什么。</p><p>首先来看这样的一个类的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line">    <span class="comment">//不声明访问权限默认为private</span></span><br><span class="line">    String _name;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>() &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写构造函数自然没有问题，但效率很低，编译器会先产生一个临时的 String 对象，然后将它初始化，再以一个 assigment 运算符将临时的对象指定给 <code>_name</code> 成员，最后再摧毁临时对象。所以经过编译器扩展后的代码看起来就是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用String的默认构造函数</span></span><br><span class="line">    _name.String::<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//产生临时对象</span></span><br><span class="line">    String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//降临时对象指定给_name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    <span class="comment">//摧毁临时对象</span></span><br><span class="line">    temp.String::~<span class="built_in">String</span>();</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果我们把构造函数写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将会将代码扩展成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用列表是较好的方式，因此最好坚持列表初始化的代码习惯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>但有时我们不得不在函数体中指定成员初始值，比如要用一个成员初始化另一个成员，这时我们需要了解列表初始化背后到底发生了什么。</p><p>编译器会逐个操作初始化列表，以适当的次序将代码安插在构造函数体内，并且安插的代码会在用户定义的代码之前。这里的“适当的次序”是指成员变量在类中声明的次序，而不是初始化列表中书写的顺序。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里看起来是用 val 初始化 j，再用 j 初始化 i，但实际上列表初始化会按照成员声明次序扩展代码，因此会先为 i 赋值，但此时 j 还没有被赋值，因此会得到错误的结果。这时我们可以将构造函数写成这样，来避免问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为编译器扩展的代码会在用户定义代码之前，所以会先为 j 赋值，再为 i 赋值。</p><p>总结一下，当存在以下情况时，尽量选择使用列表队成员进行初始化：</p><ul><li>初始化一个 reference 成员时</li><li>初始化一个 const 成员时</li><li>当调用一个基类的构造函数，而它拥有一组参数时</li><li>当调用一个对象成员的构造函数，而它拥有一组参数时</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>最后总结构造函数的执行过程：</p><ol><li>在派生类构造函数中，所有虚基类和上一层基类的构造函数首先会按顺序被调用，以生成基类子对象</li><li>上述完成后，对象的 vptr 会被初始化，指向正确的虚函数表</li><li>如果有成员初始化列表的话，将在 vptr 被设定后扩展开来，以免其中调用了虚函数</li><li>如果有对象成员且其有构造函数，调用对象成员的构造函数</li><li>最后执行程序员提供的初始化代码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第二章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认构造函数的构建操作&lt;/li&gt;
&lt;li&gt;拷贝构造函数的构建操作&lt;/li&gt;
&lt;li&gt;使用列表进行初始化的背后工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（一）关于对象</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-05-05T07:33:58.000Z</published>
    <updated>2022-05-11T07:15:59.208Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索 C++ 对象模型》第一章重点梳理。主要内容包括：</p><ul><li>C++ 封装对象的布局成本</li><li>C++ 对象模型，详述 C++ 如何组织类对象及其成员</li><li>C++ 继承简述，简述 C++ 三种继承关系和三种继承方式，关于继承布局模型会在之后的章节详述</li><li>C++ 支持多态的三种方式</li><li>指针类型和多态的实现原理</li></ul><p><em><span id="more"></span></em></p><h3 id="1-C-封装对象的布局成本"><a href="#1-C-封装对象的布局成本" class="headerlink" title="1 C++ 封装对象的布局成本"></a>1 C++ 封装对象的布局成本</h3><p>C++ 将数据和对数据的操作封装为一个类，相比于 C 语言不封装，<strong>并没有增加成本</strong>。因为类的数据成员直接内含在每一个实例化的对象中，而方法成员虽然含在类的声明中，但却不出现在每一个对象中，每一个非内联（non-inline）的成员函数只产生一个函数实体，而内联函数自然在使用的地方产生函数实体，因此不会有任何空间或执行的不良效应。</p><p>C++ 在布局以及存取时间上的主要额外负担是由 virtual 引起的，包括：</p><ul><li>virtual function 机制：用以支持一个高效的“执行期绑定”（runtime binding）</li><li>virtual base class：用以实现“多次出现在继承体系中的 base class，只存在一个被共享的实体”</li></ul><p>后面将会对这两种情况进行解释。</p><h3 id="2-C-对象模型"><a href="#2-C-对象模型" class="headerlink" title="2 C++ 对象模型"></a>2 C++ 对象模型</h3><p>C++ 对象模型按照以下方式组织类对象及其成员：</p><ul><li>非静态成员变量（non-static data member）存放于类对象内部</li><li>静态成员变量（static data member）存放于所有类对象之外</li><li>静态和非静态的成员函数（member function）存放于所有类对象之外</li><li>虚函数（virtual function）通过<strong>虚函数表（virtual table）</strong>管理：每一个类产生出一堆指向虚函数的指针，放在表格之中构成虚函数表，接下来每一个类对象拥有一个指向虚函数表的指针，称为 <strong>vptr</strong>，vptr 的设定（set）和重置（reset）都由类的构造函数、析构函数、拷贝构造等完成。并且每一个类所关联的 type_info 对象（用来支持 runtime type identification，简称 RTTI）也经由虚函数表指出，通常放在虚函数表的第一位。</li></ul><blockquote><p><strong>什么是 RTTI ？</strong></p><p>RTTI 即运行阶段类型识别（Runtime Type Identification），旨在为程序在运行阶段确定对象类型提供一种标准方式。</p><p>RTTI 可以在只有一个指向基类的指针或引用时，确定所指对象的准确类型。C++ 有两种支持 RTTI 的运算：</p><ul><li>dynamic_cast 运算符，如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则该运算符返回空指针。</li><li>typeid 运算符，返回一个指出对象类型的 type_info 对象的引用，其中存储了有关对象类型的信息，比如类名等。</li></ul><p>需要注意的是，只能将 RTTI 用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才会将派生类对象的地址赋给基类指针（多态），即 <strong>RTTI 只适用于包含虚函数的类（实现多态）</strong>。</p></blockquote><p>以下面的类为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其对象模型如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505095707450.png" alt="image-20220505095707450"></p><p>C++ 这样构建对象模型的主要优点在于空间和存取时间效率高，但缺点在于如果程序代码本身没有更改，但所用到的类对象的非静态成员变量有所修改，那么代码就需要重新编译。</p><p>另一种没有应用在 C++ 中的对象模型——双表格模型可以解决这个问题，双表格模型把所有成员变量放在数据表格中，把所有指向函数的指针放在函数表格中，每一个类对象只包含指向这两个表格的指针。这样虽然更灵活，但也因此付出了空间和执行效率两方面的代价。</p><h3 id="3-C-继承简述"><a href="#3-C-继承简述" class="headerlink" title="3 C++ 继承简述"></a>3 C++ 继承简述</h3><p>C++ 支持单一继承、多重继承和虚拟继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单一继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library_Materials</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Library_Materials &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rental_Book</span> : <span class="keyword">public</span> Book &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span> : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么需要虚拟继承？</strong></p><p>虚拟继承是为了防止多重继承中，一个派生类继承自两个相同的基类的情况。</p><p>如上面的例子，类 iostream 继承自类 istream 和类 ostream，这两个类都继承自基类 ios，如果不使用虚拟继承，则类 iostream 中会出现两个基类 ios 的对象，而在虚拟继承中，无论基类在继承链中被派生多少次，都只产生一个实体（称为子对象，subobject），即在类 iostream 中，istream 对象和 ostream 对象共享一个 ios 基类对象，从而避免了重复继承的情况。</p></blockquote><p>之后的章节中我们会具体讨论这些继承情况分别对应的继承模型，即派生对象和基类对象的组织关系和内存管理。</p><p>顺便讨论一下类成员的三种访问级别和三种继承方式。众所周知 C++ 类成员可以拥有三种访问级别：</p><ul><li>public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问</li><li>protected：可以被该类中的函数、子类的函数、其友元函数访问，但不能被该类的对象访问</li><li>private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问</li></ul><p>在类继承中，也包含三种继承方式，不同的继承方式会导致类中成员的访问级别变化：</p><ul><li>public 继承：父类中的成员属性不发生改变</li><li>protected 继承：父类的 protected 和 public 成员在子类中变为 protected，private 成员不变</li><li>private 继承：父类的所有成员在子类中变为 private</li></ul><h3 id="4-C-支持多态的三种方式"><a href="#4-C-支持多态的三种方式" class="headerlink" title="4 C++ 支持多态的三种方式"></a>4 C++ 支持多态的三种方式</h3><p>C++ 通过以下三种方式支持多态：</p><ul><li>隐式转换：将派生类指针转化为一个指向其基类的指针：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure><ul><li>虚函数机制：基类中定义虚函数（纯虚函数），派生类进行重载，在运行时决定调用哪个函数对象：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure><ul><li>dynamic_cast 和 type_id 运算符，在上面的虚拟继承提到过，用来将指向基类的指针转化为指向派生类对象的指针，或者获取对象的 type_info</li></ul><h3 id="5-指针类型和多态原理"><a href="#5-指针类型和多态原理" class="headerlink" title="5 指针类型和多态原理"></a>5 指针类型和多态原理</h3><p>指向类的指针和指向其他变量类型（比如 int, string）的指针有什么不同？</p><p>以内存需求的观点来说，没有什么不同，它们都需要有足够的内存来放置一个机器地址，指向不同类型的指针之间的差异既不在其声明方法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的 object 类型不同。也就是说，”指针类型”会告诉编译器如何解释某个特定地址中的内存内容及其大小。</p><p>例如下面的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么指向类 ZooAnimal 的对象的指针将会包含：</p><ul><li>指向 int 类型的指针，在 32 位计算机上，int 占 4 字节</li><li>指向 string 类型的指针，占 8 字节（4 字节的字符指针和 4 字节的表示字符串长度的整数）</li><li>指向虚函数表的指针，占 4 字节</li></ul><p>因此类 ZooAnimal 的对象一共占用 16 字节，如果 ZooAnimal 对象存放在内存地址 1000，那么一个指向 ZooAnimal 对象的指针将会知道它需要涵盖内存的内存范围是 1000~1015.</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505112402307.png" alt="image-20220505112402307"></p><p>如果不告诉编译器这个指针指向什么类型，比如泛型指针 void*，那么编译器将不知道指针涵盖的地址范围，也就不能通过指针访问到正确的内存内容。</p><p>现在我们定义一个 Bear 类继承自 ZooAnimal 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Dances</span> &#123; ... &#125;;<span class="comment">//枚举类型默认使用int方式存储，占用4字节</span></span><br><span class="line">    </span><br><span class="line">    Dances dances_known;</span><br><span class="line">    <span class="type">int</span> cell_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么指向 Bear 对象的指针覆盖的内存大小是其基类子对象的大小（16字节）加上该对象成员变量的大小（4 + 4 字节）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505112658895.png" alt="image-20220505112658895"></p><p>假设 Bear 对象存放在内存地址 1000 处，那么指向基类 ZooAnimal 的指针 pz 和指向派生类 Bear 的指针 pb 都指向内存地址 1000，区别在于 pz 指针涵盖的内存范围只包含基类成员的 16 字节，而 pb 指针涵盖的内存范围包含整个 Bear 对象。</p><p>除了 ZooAnimal 对象中出现的成员，我们不能使用 pz 来处理 Bear 对象的任何成员，除非使用 virtual 机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以，虽然 pz 指向一个 bear 对象的地址</span></span><br><span class="line">pz-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以，经过显式转换</span></span><br><span class="line">((Bear*)pz)-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的方式是使用 RTTI，dynamic_cast返回一个指定派生类的指针，如果无法转换则返回空指针</span></span><br><span class="line"><span class="keyword">if</span>(Bear* pb2 = <span class="built_in">dynamic_cast</span>&lt;Bear*&gt;(pz))</span><br><span class="line">    pb2-&gt;cell_block;</span><br></pre></td></tr></table></figure><p>现在来看这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal za = b;</span><br><span class="line"><span class="comment">// 这将会调用 ZooAnimal 的 rotate 方法而不是 Bear 的</span></span><br><span class="line">za.<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure><p>为什么 za 调用的是 ZooAnimal 的 rotate 方法？这是由于当一个基类对象直接被初始化为一个派生类对象时，会发生切割（sliced），以塞入较小的基类内存中，而无法体现出任何派生类的痕迹。这时多态就“失效”了，实际上这是由于多态不能够发挥在“直接存取对象”这件事情上，<strong>因为多态机制是依靠指针（pointer）或引用（reference）完成的</strong>。</p><p>举例来说明，比如有下面的类继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505150626835.png" alt="image-20220505150626835"></p><p>然后我们使用下面一组定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ZooAnimal za;</span><br><span class="line">    ZooAnimal *pza;</span><br><span class="line">    </span><br><span class="line">    Bear b;</span><br><span class="line">    Panda *pp = <span class="keyword">new</span> Panda;</span><br><span class="line">    </span><br><span class="line">    pza = &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组定义可能的内存布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505150739142.png" alt="image-20220505150739142"></p><p>将对象 za 或者 b 的地址，或者指针 pp 的内容（也是个地址）赋给指针 pza，是完全没有问题的，后续还可以通过各种转换得到想要的不同派生类的对象，也就实现了多态。一个指针或者引用之所以支持多态，就是因为他们并不会引发内存配置的资源量的改变，会受到改变的只是它们所指向的内存的“大小和解释方式”而已。</p><p>但如果直接对对象进行操作，就会改变内存中的资源需求量，比如之前的例子，把整个 Bear 对象指定给 za，就会溢出它所配置得到的内存，自然也就无法得到正确的结果。</p><p>总之，多态是一种强大的机制，允许你继一个抽象的 public 接口之后，封装相关的类型。需要付出的代价就是额外的间接性——不论是在“内存的获得”或是在“类型的决断”上。C++ 通过 class 的 pointers 和 references 来支待多态，这种程序设计风格就称为“面向对象”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索 C++ 对象模型》第一章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 封装对象的布局成本&lt;/li&gt;
&lt;li&gt;C++ 对象模型，详述 C++ 如何组织类对象及其成员&lt;/li&gt;
&lt;li&gt;C++ 继承简述，简述 C++ 三种继承关系和三种继承方式，关于继承布局模型会在之后的章节详述&lt;/li&gt;
&lt;li&gt;C++ 支持多态的三种方式&lt;/li&gt;
&lt;li&gt;指针类型和多态的实现原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【STL】关联式容器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-05-03T07:32:18.000Z</published>
    <updated>2022-05-06T07:51:00.702Z</updated>
    
    <content type="html"><![CDATA[<p>标准的 STL 关联式容器分为 set(集合) &#x2F; map(映射表)两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree（红黑树）或hash table（哈希表）完成。</p><p><em><span id="more"></span></em></p><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h3><p>红黑树是 C++ STL 唯一实现的树状结构，是所有关联式容器的底层容器，关于红黑树的理论知识可以查看<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/">【数据结构】二叉树</a>第三部分。</p><h4 id="1-1-红黑树节点"><a href="#1-1-红黑树节点" class="headerlink" title="1.1 红黑树节点"></a>1.1 红黑树节点</h4><p>STL 中红黑树的的节点设计采用了结构和数值分离的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line"></span><br><span class="line">    _Color_type _M_color;    <span class="comment">//颜色</span></span><br><span class="line">    _Base_ptr _M_parent;     <span class="comment">//父节点，红黑树很多操作都需要知道父节点</span></span><br><span class="line">    _Base_ptr _M_left;       <span class="comment">//左孩子</span></span><br><span class="line">    _Base_ptr _M_right;      <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉搜索树获取最大值最小值</span></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_minimum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_left != <span class="number">0</span>) __x = __x-&gt;_M_left;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_maximum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_right != <span class="number">0</span>) __x = __x-&gt;_M_right;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树节点，包括结构和节点值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node</span> : <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">    _Value _M_value_field;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-2-红黑树迭代器"><a href="#1-2-红黑树迭代器" class="headerlink" title="1.2 红黑树迭代器"></a>1.2 红黑树迭代器</h4><p>为了更大的弹性， SGI 将 RB-tree 迭代器也实现为两层，下图所示的便是双层节点结构和双层迭代器结构之间的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220503111534187.png" alt="image-20220503111534187"></p><p>RB-tree 迭代器属于双向迭代器，不具备随机定位能力，其提领操作和成员访间操作与 list 十分近似，较为特殊的是其前进和后退操作。参见源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">  _Base_ptr _M_node;</span><br><span class="line">  <span class="comment">// 迭代器前进操作</span></span><br><span class="line">  <span class="type">void</span> _M_increment()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_right != <span class="number">0</span>) &#123;</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">      <span class="keyword">while</span> (_M_node-&gt;_M_left != <span class="number">0</span>)</span><br><span class="line">        _M_node = _M_node-&gt;_M_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_right) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_M_node-&gt;_M_right != __y)</span><br><span class="line">        _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//迭代器后退操作</span></span><br><span class="line">  <span class="type">void</span> _M_decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;</span><br><span class="line">        _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_M_node-&gt;_M_left != <span class="number">0</span>) &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_left;</span><br><span class="line">      <span class="keyword">while</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">        __y = __y-&gt;_M_right;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_left) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级迭代器，继承于一级</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>, <span class="keyword">class</span> <span class="title class_">_Ref</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_iterator</span> : <span class="keyword">public</span> _Rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Value&amp;, _Value*&gt;             </span><br><span class="line">    iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, <span class="type">const</span> _Value&amp;, <span class="type">const</span> _Value*&gt; </span><br><span class="line">    const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Ref, _Ptr&gt;                   </span><br><span class="line">    _Self;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  _Rb_tree_iterator() &#123;&#125;</span><br><span class="line">  _Rb_tree_iterator(_Link_type __x) &#123; _M_node = __x; &#125;</span><br><span class="line">  _Rb_tree_iterator(<span class="type">const</span> iterator&amp; __it) &#123; _M_node = __it._M_node; &#125;</span><br><span class="line">  <span class="comment">//迭代器解引用，返回指向值</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> _Link_type(_M_node)-&gt;_M_value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  <span class="comment">//返回迭代器数值域指针</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器++操作，调用底层迭代器_M_increment()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; _M_increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_increment();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//迭代器--操作，调用底层迭代器_M_decrement()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; _M_decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_decrement();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他双目运算定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node == __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node != __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//RB树迭代器是双向迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> _Rb_tree_base_iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-set-amp-map"><a href="#2-set-amp-map" class="headerlink" title="2 set &amp; map"></a>2 set &amp; map</h3><p>set 的所有元素都会根据元素的键值自动排序。set 的元素不像 map 那样可以同时拥有 key 和 value，set 元素的 key 就是 value，value 就是 key，set不允许有两个相同的元素。</p><p>map 的所有元素都会根据元素的键值自动排序。map 的所有元素都是 pair，同时拥有 key 和 value。pair 的第一元素为 key，第二元素为 value。map不允许有两个相同的键值。如果通过map的迭代器改变元素的键值，这样是不行的，因为 map 元素的键值关系到 map 元素的排列规则。任意改变 map 元素键值都会破坏 map 组织。如果修改元素的实值，这是可以的，因为 map 元素的实值不影响 map 元素的排列规则。</p><h3 id="3-multiset-amp-multimap"><a href="#3-multiset-amp-multimap" class="headerlink" title="3 multiset &amp; multimap"></a>3 multiset &amp; multimap</h3><p>multiset 和 multimap 的特性以及用法和 set 与 map 完全相同，唯一的差别在于它们允许键值重复，因此它的插入操作采用的是底层机制 RB-tree 的<code>insert_equal()</code> 而非 <code>insert_unique()</code>。</p><h3 id="4-hash-table"><a href="#4-hash-table" class="headerlink" title="4 hash table"></a>4 hash table</h3><p>hash table 是 STL 实现的另一种底层数据结构。之前的二叉搜索树具有对数平均时间表现，但这样的表现构造在一个假设上：输入数据有足够的随机性。hashtable 这种结构在插入、删除、查找具有“常数平均时间”，而且这种表现是以统计为基础，不需依赖元素的随机性。</p><p>hash table 底层数据结构为分离连接法的 hash 表，如下所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/772134-20160714231649779-234679385.png" alt="772134-20160714231649779-234679385"></p><p>hash table 中的 buckets 使用的是vector数据结构，当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射（常见的为取模），找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就返回；否则的话就将该元素插入到该链表的头部。当然，如果是 multi 版本的话，是可以插入重复元素的，此时插入过程为：当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射，找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就将新节点插入到该相同元素的后面；如果没有相同的元素，产生新节点，插入到链表头部。</p><p>对应的查询过程也是同理。此外，当调用成员函数 clear() 后，buckets vector 并未释放空间，仍保留原来大小，只是删除了 buckets 所连接的链表。</p><h3 id="5-hash-set-amp-hash-map"><a href="#5-hash-set-amp-hash-map" class="headerlink" title="5 hash_set &amp; hash_map"></a>5 hash_set &amp; hash_map</h3><p>hash_set 和 hash_map 以 hashtable 为底层结构，由于 RB-tree 有自动排序功能而 hash table 没有，反映出来的结果就是，set 和 map的元素有自动排序功能而hash_set 和 hash_map 没有。</p><h3 id="6-hash-multiset-amp-hash-multimap"><a href="#6-hash-multiset-amp-hash-multimap" class="headerlink" title="6 hash_multiset &amp; hash_multimap"></a>6 hash_multiset &amp; hash_multimap</h3><p>hash_multiset 和 hash_multimap 的特性与 multiset 和 multimap 完全相同，唯一的差别在于它们的底层机制是 hash table，因此，hash_multiset 和 hash_multimap 的元素是不会自动排序的。</p><h3 id="7-unordered-set-amp-unordered-map"><a href="#7-unordered-set-amp-unordered-map" class="headerlink" title="7 unordered_set &amp; unordered_map"></a>7 unordered_set &amp; unordered_map</h3><p>unordered_set 和 unordered_map 是 C++11 标准新增的容器，底层同样使用 hash table 实现，但一般来说效率比 hash_set 和 hash_map 更高，原因在于二者 rehash 实现不同。因此 hash_set 和 hash_map 基本已弃用。</p><h3 id="8-红黑树和-hash-table-对比"><a href="#8-红黑树和-hash-table-对比" class="headerlink" title="8 红黑树和 hash table 对比"></a>8 红黑树和 hash table 对比</h3><p>虽然大多数情况下 hash table 实现的 map 都会比红黑树实现的 map 查找快，但不是绝对的，因为冲突过多的话，可能耗费时间比 map 还要多。</p><p>另外，hash table 的实现决定了其使用的空间会比实际数据空间大。红黑树初始化时，节点只需要一个，后续的插入只是插入新的节点，但是哈希表初始化时就不是那么简单了，哈希表初始化时需要申请一个数组，数组的每个元素都指向一条链表，所以初始化时需要申请很多内存，相比于红黑树，的确更耗时。</p><p>相对于红黑树，hash table的优点很明显：插入，查找，删除复杂度为常数时间，大规模查询时，性能差距更为明显。</p><p>但相比于hash table，平衡树也是有优点的:</p><ul><li>首先，尽管我们都说 hash 查找插入删除复杂度是常数时间，但这仅仅是个统计上的概念，最差情况下，也是会达到 O(n)，而红黑树最差的情况下也是 O(logn)；</li><li>其次，hash table 实际上是空间换时间的做法，空间越小，操作的时间复杂度越大，操作时间越不稳定，而平衡树则稳定很多；</li><li>还有一个就是序，红黑树是查找树，因此中序遍历的结果就是排好序的。这就使得其在范围查找方面性能优秀，而 hash 却需要遍历全部数据，之后统计才能得出范围查找的结果。另外，如果你知道一个元素在树中的位置，和它大小相近的元素也在它周围，这就使得获取相近元素的时间很少。另外，我们知道，中序遍历的时间复杂度也只是 O(n)，这个性质非常有用。</li></ul><p>map 和 unordered_map 的使用场景基本上就是根据上述各自的特性决定了：</p><ul><li>map 一般就是用在数据量小于1000或者对内存使用要求比较高的情况下。因为 hash table 需要申请的空间比较大，而红黑树则是新增一个节点就申请一个节点的空间。</li><li>如果数据量大的话并且需要频繁查找的话，就可以使用 hash table 实现的 map 了。这个时候内存已经不是主要的问题所在，而是查找时间了，这种情况下 hash table 的查找速度是常数而红黑树是 O(logN)，对于后者，1024个数据最坏情况下要10次比较，在频繁查找的情况下这种时间耗费是很大的。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;标准的 STL 关联式容器分为 set(集合) &amp;#x2F; map(映射表)两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree（红黑树）或hash table（哈希表）完成。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【STL】序列式容器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-30T08:44:36.000Z</published>
    <updated>2022-05-06T07:51:21.803Z</updated>
    
    <content type="html"><![CDATA[<p>容器（Containers）是 STL 六大组件中最被人熟知和常用的一个神器，根据组织方式大概分为序列式容器和关联式容器两大类。</p><p><em><span id="more"></span></em></p><h3 id="1-STL-容器概览"><a href="#1-STL-容器概览" class="headerlink" title="1 STL 容器概览"></a>1 STL 容器概览</h3><p>STL 提供的容器如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430153405060.png" alt="image-20220430153405060"></p><p>其中内缩表达基层与衍生层的关系，这里所谓的衍生，并非派生 (inheritance) 关系，而是内含 (containment) 关系。例如 heap 内含一个 vector，priority_queue 内含一个 heap 、stack 和 queue 都含一个 deque，set&#x2F;map&#x2F;multiset&#x2F;multimap 都内含一个 RB-tree，hast_x 都内含一个 hashtable。</p><h3 id="2-序列式容器"><a href="#2-序列式容器" class="headerlink" title="2 序列式容器"></a>2 序列式容器</h3><p>所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted），C++ 本身内建了一个序列式容器array，STL 另外提供了vector、list、deque、stack、queue、priority-queue 等序列式容器。其中 stack 和 queue 由于只是 deque 改头换面而来，技术上被归为一种配接器 (adapter)。接下来了解各序列式容器的具体实现。</p><h3 id="3-vector"><a href="#3-vector" class="headerlink" title="3 vector"></a>3 vector</h3><p>vector 采用的数据结构非常简单：线性连续空间。它以两个迭代器 start 和 finish 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 end_of_storage 指向整块连续空间（含备用空间）的尾端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;             <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">    iterator finish;            <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">    iterator end_of_storage;    <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了降低空间配置时的速度成本， vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量 (capacity) 的观念。换句话说，一个 vector 的容量永远大于或等于其大小。一旦容量等于大小，下次再有新增元素，整个 vector 就得进行动态增加容量。</p><p>所谓动态增加容量，并不是在原来空间之后接续新空间（因为无法保证原空间之后尚有可供分配的空间），而是以原来大小的的两倍另外分配一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430154445332.png" alt="image-20220430154445332"></p><p>当我们以 <code>push_back()</code> 将新元素插入于 vector 尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新配置、移动数据、释放原空间）。</p><h3 id="4-list"><a href="#4-list" class="headerlink" title="4 list"></a>4 list</h3><p>相对于 vector 的连续线性空间，list 就显得复杂许多，它的好处就是插入或删除一个元素，就配置或删除一个元素空间。对于任何位置的元素的插入或删除，list 永远是常数时间。</p><p>List 不仅是一个双向链表，而且是一个双向循环链表，只需一个指针就可遍历整个链表。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430155828333.png" alt="image-20220430155828333"></p><p>对于迭代器，只能通过 <code>++</code> 或 <code>--</code> 操作将迭代器移动到后继&#x2F;前驱节点元素处，而不能对迭代器进行 +n 或 -n 的操作。因此 List 的迭代器是双向迭代器。在 List 中增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p><h3 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h3><p>vector 是单向开口的连续线性空间，deque 则是一种双向开口的线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，虽然 vector 也支持从头端插入元素，不过效率奇差。deque 容器类与 vector 类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。</p><p>deque 与 vector 最大差异：</p><ul><li>deque 允许常数时间内对头部进行元素的插入或移除操作。</li><li>deque 没有所谓的容量观念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并拼接起来。</li></ul><p>deque 由一段一段连续空间组成，一旦有必要在 deque 的前端或尾端增加新空间，便配置一段连续空间，串接在整个 deque 的前端或尾端。deque 的最大任务，便是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价是复杂的迭代器结构。</p><p>deque 采用一块所谓的 map（不是 STL 的 map 容器）作为主控。这里所谓 map 是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是 deque 的储存空间主体。 SGI STL 允许我们指定缓冲区大小，默认值 0 表示将使用 512 bytes 缓冲区。deque 最初状态（无任何元素）保有一个缓冲区，因此，clear() 完成之后回到初始状态，也一样会保留一个缓冲区。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430160922218.png" alt="image-20220430160922218"></p><p>由于以上结构，deque 的迭代器实现也较为复杂，deque 的迭代器首先必须指出分段连续空间在哪里，其次它必须能够判断自己是否已经处在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃下一个缓冲区，为了能够正常跳跃，deque 必须随时掌握管控中心（map）。下图展示了 deque 的中控器、迭代器和缓冲区的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430161351783.png" alt="image-20220430161351783"></p><p>假设一个 deque 存储 20 个元素，每个缓冲区可以存储 8 个元素，则它的迭代器关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430161627317.png" alt="image-20220430161627317"></p><p>迭代器 start 内的 cur 指针指向第一块缓冲区的第一个元素，迭代器 finish 内的 cur 指针指向最后一块缓冲区的最后一个元素（的下一位置）。</p><p>下面来分析 deque 常用操作对迭代器的影响：</p><ul><li>在队前或队后插入元素时（push_back()和push_front()），由于可能缓冲区的空间不够，需要增加 map 中控器，而中控器的个数如果也不够，就需要新开辟更大的空间来容纳中控器，所以可能会使迭代器失效；但指针、引用仍有效，因为缓冲区已有的元素没有重新分配内存。</li><li>在队列其他位置插入元素时，由于会造成缓冲区的一些元素的移动，所以肯定会造成迭代器的失效；并且指针、引用都会失效。</li><li>删除队头或队尾的元素时，由于只是对当前的元素进行操作，所以其他元素的迭代器不会受到影响，所以一定不会失效，而且指针和引用也都不会失效。</li><li>删除其他位置的元素时，也会造成元素的移动，所以其他元素的迭代器、指针和引用都会失效。</li></ul><h3 id="5-stack"><a href="#5-stack" class="headerlink" title="5 stack"></a>5 stack</h3><p>stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口。stack 允许增加元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其他方法可以存取 stack 的其他元素，换言之，stack 不允许有遍历行为，因此 stack 没有迭代器。stack 默认以 deque 为底层容器。stack 是对 deque 的又一层封装，因此 stack 并不是容器，而被称作配接器。</p><p>除了 deque 外，stack 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p><h3 id="6-queue"><a href="#6-queue" class="headerlink" title="6 queue"></a>6 queue</h3><p>queue 是一种先进先出（First In First Out，FIFO）的数据结构，它有两个出口，允许增加元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其他方法可以存取 queue 的其他元素，换言之，queue不允许有遍历行为，因此 queue 没有迭代器。queue 默认以 deque 为底层容器。</p><p>除了 deque 外，queue 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p><h3 id="7-heap"><a href="#7-heap" class="headerlink" title="7 heap"></a>7 heap</h3><p>heap 使用 vector 作为底层容器，关于 heap 的算法可在专题<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/">【数据结构】优先队列和堆</a>中找到。STL 默认建立大顶堆。</p><h3 id="8-priority-queue"><a href="#8-priority-queue" class="headerlink" title="8 priority_queue"></a>8 priority_queue</h3><p>priority_queue 底层使用 heap 实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;容器（Containers）是 STL 六大组件中最被人熟知和常用的一个神器，根据组织方式大概分为序列式容器和关联式容器两大类。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【STL】迭代器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-30T07:26:19.000Z</published>
    <updated>2022-05-06T07:51:38.932Z</updated>
    
    <content type="html"><![CDATA[<p>STL的中心思想是：将数据容器和算法分隔开，彼此独立设计，最后再用黏合剂将它们撮合在一起。容器和算法的泛型化，可以用 C++ 的 class template 和 function template 来实现，而迭代器（Iterator）就是二者的黏合剂了。</p><p><em><span id="more"></span></em></p><h3 id="1-迭代器的实现"><a href="#1-迭代器的实现" class="headerlink" title="1 迭代器的实现"></a>1 迭代器的实现</h3><p>迭代器是一种智能指针，它将指针进行了一层封装，既包含了原生指针的灵活和强大，也加上很多重要的特性，使其能发挥更大的作用以及能更好的使用。指针最常见也最为重要的行为就是内容提领 (dereference) 和成员访问 (member access)，迭代器对指针的一些基本操作如*、-&gt;、++、&#x3D;&#x3D;、!&#x3D;、&#x3D;进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构。</p><p>迭代器的“智能”体现在，针对不同的数据容器能够使用统一的方法、函数进行操作，以达到相同的目的。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++();  </span><br><span class="line"></span><br><span class="line">    ...  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    T *m_ptr;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>对于不同的数据容器，以上 Iterator 类中的成员函数 operator++ 的实现会各不相同，例如，对于数组的可能实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于数组的实现  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;   </span><br><span class="line">   ++m_ptr;   </span><br><span class="line">   retrun *<span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于链表，它会有一个类似于 next 的成员函数用于获取下一个结点，其可能实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;  </span><br><span class="line">   m_ptr = m_ptr-&gt;<span class="built_in">next</span>();<span class="comment">//next()用于获取链表的下一个节点   </span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>iterator 的实现首先要对其所指向的对象的实现细节有非常丰富的了解，所以 iterator 为了不暴露所指向对象的信息，干脆就将 iterator 的实现由各个容器的设计者来实现好了。STL 将迭代器的实现交给了容器，每种容器都会以嵌套的方式在内部定义专属的迭代器。各种迭代器的接口相同，内部实现却不相同，这也直接体现了泛型编程的概念。</p><h3 id="2-迭代器的类别"><a href="#2-迭代器的类别" class="headerlink" title="2 迭代器的类别"></a>2 迭代器的类别</h3><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为：</p><ul><li>输入迭代器：只读</li><li>输出迭代器：只写</li><li>正向迭代器：正向遍历迭代器，假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</li><li>双向迭代器：双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code> 都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</li><li>随机访问迭代器：随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：<ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul></li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><p>下表是不同容器的迭代器功能类型：</p><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set &#x2F; multiset</td><td>双向</td></tr><tr><td>map &#x2F; multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table><p>在以上功能的基础上，迭代器根据定义方式还分为：</p><ul><li>正向迭代器：容器类名::iterator </li><li>常量正向迭代器：容器类名::const_iterator</li><li>反向迭代器：容器类名::reverse_iterator</li><li>常量反向迭代器：容器类名::const_reverse_iterator</li></ul><p>反向迭代器和正向迭代器的区别在于：对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</p><h3 id="3-迭代器辅助函数"><a href="#3-迭代器辅助函数" class="headerlink" title="3 迭代器辅助函数"></a>3 迭代器辅助函数</h3><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p><ul><li><code>advance(p, n)</code>：使迭代器 p 向前或向后移动 n 个元素。</li><li><code>distance(p, q)</code>：计算两个迭代器之间的距离，即迭代器 p 经过多少次 <code>++</code> 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li><li><code>iter_swap(p, q)</code>：用于交换两个迭代器 p、q 指向的值。</li></ul><p>要使用上述模板，需要包含头文件 <code>&lt;algorithm&gt;</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;STL的中心思想是：将数据容器和算法分隔开，彼此独立设计，最后再用黏合剂将它们撮合在一起。容器和算法的泛型化，可以用 C++ 的 class template 和 function template 来实现，而迭代器（Iterator）就是二者的黏合剂了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【C++】基础知识汇总</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2022-04-30T02:59:06.000Z</published>
    <updated>2022-05-06T07:53:59.102Z</updated>
    
    <content type="html"><![CDATA[<p>C++中琐碎的基础知识，原理，用法汇总，用于快速查询知识点。持续更新。</p><p><em><span id="more"></span></em></p><h3 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1 智能指针"></a>1 智能指针</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/150555165">现代 C++：一文读懂智能指针</a></li><li><a href="https://blog.csdn.net/K346K346/article/details/81478223">C++ STL 四种智能指针</a></li><li><a href="https://blog.csdn.net/u012442719/article/details/55045583">C++ weak ptr解除指针循环引用</a></li></ul><h3 id="2-auto-和-decltype"><a href="#2-auto-和-decltype" class="headerlink" title="2 auto 和 decltype"></a>2 auto 和 decltype</h3><ul><li><p><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></p></li><li><p><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></p></li><li><p><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.2&utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></p></li></ul><h3 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3 Lambda表达式"></a>3 Lambda表达式</h3><ul><li><p><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C++ Lambda表达式原理及应用</a></p></li><li><p><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></p></li><li><p><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></p></li></ul><h3 id="4-仿函数"><a href="#4-仿函数" class="headerlink" title="4 仿函数"></a>4 仿函数</h3><ul><li><a href="https://blog.csdn.net/JMW1407/article/details/107130600">仿函数(functors)</a></li><li><a href="https://blog.csdn.net/toby54king/article/details/105103111">C++中的仿函数有点难，这篇文章却讲的通俗易懂</a></li><li><a href="https://zhuanlan.zhihu.com/p/362323211">C++ 仿函数为何而生</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中琐碎的基础知识，原理，用法汇总，用于快速查询知识点。持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（一）游戏引擎架构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2022-04-28T08:47:37.000Z</published>
    <updated>2022-04-28T08:58:22.544Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。</p><p><em><span id="more"></span></em></p><h3 id="1-游戏引擎分层架构"><a href="#1-游戏引擎分层架构" class="headerlink" title="1 游戏引擎分层架构"></a>1 游戏引擎分层架构</h3><p>现代游戏引擎的架构极为复杂，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155123811.png" alt="image-20220428155123811"></p><p>但大致可分为以下几个层次：</p><ul><li>工具层：工具层是面向游戏开发者，能够让游戏开发者使用引擎制作游戏的接口，包括一些系列可视化的编辑器，比如角色编辑器、纹理编辑器、动画编辑器等等。</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155356486.png" alt="image-20220428155356486"></p><ul><li>功能层：功能层包含一个游戏需要的各种功能，包括物理碰撞、动画、渲染、音效、逻辑脚本等等，是能够让一款游戏充满可玩性的核心驱动。</li><li>资源层：资源层负责管理游戏引擎中的各种资源，比如纹理、模型、音频、视频、脚本等，资源层需要将这些资源合理的、有层次的组织起来，并管理他们的生命周期，在合适的时间加载某些资源，在另外一些时候释放某些资源。</li><li>核心层：核心层包含上面几层在实现的过程中需要频繁使用的一些工具函数，比如数学、数据结构、常用的算法等，核心层是游戏引擎中所有上层结构的支撑，由于游戏引擎对效率的要求很高，所以有时并不能直接使用 C++ STL 提供的一些容器或者算法，而需要根据需求编写更高效的数据结构实现和算法函数供上层调用，因此核心层也是对代码质量要求最高的一层。</li><li>平台层：平台层是最容易被忽略的一层，但也是非常重要的一层，平台层负责处理不同平台的差异，包括软件平台和硬件平台，比如不同的操作系统、不同的 CPU&#x2F;GPU 架构、不同的游戏输入设备等等，保证游戏能够在所有平台完美运行。</li><li>第三方库：第三方库一方面用于实现一些基本功能，比如 GUI、图像处理等，另外也可以将功能层中某些模块直接用第三方库来实现，比如一些专门做物理、动画的第三方插件，直接集成到引擎中既方便开发，得到的效果也更好。</li></ul><p>游戏引擎架构当然没有这么简单，但是大致总结起来可以认为就是由这几部分组成的，分层架构的设计要求必须由上层调用下层功能，这样既便于开发，也便于管理。接下来我们对其中的重要模块稍作深入了解。</p><h3 id="2-资源层"><a href="#2-资源层" class="headerlink" title="2 资源层"></a>2 资源层</h3><p>游戏开发中需要利用各种资源来达到目的，而各类资源有不同的格式，即使是同一类资源，它们的格式也不尽相同，比如不同的 3D 建模软件导出的模型就存在各种各样的格式差异，资源层需要将这些不同的资源，统一转化为游戏引擎使用的格式，转换后的资源被称为 Asset，从资源到 Asset 的过程可以认为是对资源文件的提纯过程，这个过程会去掉那些游戏引擎不需要的信息，比如 3D 模型中的编辑信息，而只保留游戏引擎中需要的信息，并组织成统一的格式。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428161522013.png" alt="image-20220428161522013"></p><p>除此之外，资源层还要对海量的资源进行合理的管理，包括每个资源的唯一标识（GUID）、不同资源之间的关系、资源的生命周期等等。高效的管理资源是一个游戏稳定运行的基础，比如在游戏场景切换的时候就需要卸载大量资源再加载大量资源，如果资源管理做的不好，轻则加载时间长，影响游戏体验，重则出现卡顿，甚至崩溃。</p><h3 id="3-功能层"><a href="#3-功能层" class="headerlink" title="3 功能层"></a>3 功能层</h3><p>从某种程度上说，功能层是游戏引擎最核心的部分，因为它实现了一个游戏之所以能称之为游戏的全部重要功能，包括渲染、物理、动画、音效、网络、游戏性等等。因此功能层也是构建游戏世界的核心。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162147284.png" alt="image-20220428162147284"></p><p>游戏世界是依靠 Tick 来驱动的，类似于秒针走动一下，我们的世界就会发生一次改变。在游戏世界中，“秒针”每次走动，我们的计算机就会将所有的功能全部运行一遍，来计算这一秒游戏世界中发生的事情，因此在游戏引擎的代码中，入口就是 Tick：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162301962.png" alt="image-20220428162301962"></p><p>Tick 一般分为逻辑 Tick 和渲染 Tick，逻辑 Tick 负责计算相机、运动、动画、物理等功能，相当于在构建整个游戏世界；渲染 Tick 则负责将游戏在世界呈现在玩家面前，包括剔除、渲染、后处理等等。因此在每一个 Tick 中，都是先计算逻辑 Tick，再计算渲染 Tick。</p><p>功能层的许多功能可以在游戏中实现，也可以在游戏引擎中实现，这完全取决于需求，对于一些通用的商业引擎，它们可能会用于制作各种类型的游戏，因此功能层提供的功能要尽可能的丰富，而对于一些专用的引擎，比如寒霜、RED ENGINE等，它们被用于制作特定类型的游戏，因此就会在功能层对特定的功能进行实现，而抛弃一些不需要的功能。</p><h3 id="4-核心层"><a href="#4-核心层" class="headerlink" title="4 核心层"></a>4 核心层</h3><p>核心层为上层实现提供核心驱动，在核心层会实现包括数学计算、数据结构、内存管理、线程管理在内的基本代码，这部分要保证绝对的安全、稳定、高效。因此对编码要求也极高，一般核心层的代码不会轻易修改。</p><p>数学计算包括一些基本运算、向量、矩阵、四元数、随机数等的实现，游戏中许多计算可能并不要求结果的绝对精确，而是更需要计算的高效性，结果允许存在一定误差，因此在实现上就和 C++ 提供的数学库完全不同了。</p><p>数据结构也是同样，STL 提供的各种数据结构和容器实现有时候可能在内存、效率上达不到游戏中的要求，比如 C++11 中的 vector 在扩容时就可能造成大量的空间碎片，因此我们需要实现更高效、内存管理更严格的数据结构和容器供上层使用。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428163516740.png" alt="image-20220428163516740"></p><h3 id="5-平台层"><a href="#5-平台层" class="headerlink" title="5 平台层"></a>5 平台层</h3><p>平台层需要处理不同软硬件平台的差异，使得游戏和引擎能够在不同平台上运行。平台之间的差异说起来简单，但是实际情况却非常复杂，比如图形 API 之间的差异，DirectX 11、OpenGL、Vulkan 等图形接口就有相当大的差异，即便是同为微软的 DirectX 11 和 DirectX 12 也有着完全不同的实现框架，并且不同的显卡架构也完全不同，因此需要一个统一的渲染接口将这些差异统一起来，使得上层使用者只需要关注功能实现，而不需要关注底层接口和硬件之间的差异。</p><p>除此之外，平台差异还包括核心处理器架构的差异，PS、XBox、PC 等平台的核心处理架构设计是完全不同的，需要对这样的差异进行处理；另外还有游戏输入设备之间的差异，键鼠、手柄、方向盘、感应器等等，需要一个统一的接口处理这些设备的输入，使它们能得到相同的响应效果。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>总而言之，游戏引擎架构极为复杂，但概括来说就是由分层架构搭建而成，并且只允许上层功能调用下层功能，不允许下层功能调用上层功能。越底层的功能越稳定，越上层的功能越灵活。</p><p>游戏世界依靠 Tick 驱动，每一个 Tick 都计算一次逻辑功能和渲染功能，这样整个游戏世界就能够构建起来、运行起来并且呈现在玩家面前了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二十二）最后一步</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/</id>
    <published>2022-04-27T12:37:47.000Z</published>
    <updated>2022-04-27T12:39:32.494Z</updated>
    
    <content type="html"><![CDATA[<p>到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。</p><p><em><span id="more"></span></em></p><h3 id="1-统一管理散射光线"><a href="#1-统一管理散射光线" class="headerlink" title="1 统一管理散射光线"></a>1 统一管理散射光线</h3><p>对于镜面反射和折射，如果用新的渲染方程会出现 pdf 值为 0 的情况，因此我们使用之前隐式的渲染方程，也就是采样 pdf 和光线散射 pdf 一致。为此我们首先需要新增一个结构体来统一管理散射光线，然后根据散射光线的类型选择对应的渲染方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一管理散射光线</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> &#123;</span><br><span class="line">    ray specular_ray;           <span class="comment">// 散射光线</span></span><br><span class="line">    <span class="type">bool</span> is_specular;           <span class="comment">// 是否是镜面反射，金属或者电介质为true</span></span><br><span class="line">    color attenuation;          <span class="comment">// 反射率</span></span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;    <span class="comment">// 散射光线pdf，如果是金属或者电介质就是空指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改材质抽象类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自发光，可选</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来用新的结构体和方法改写之前实现的 Lambertian 材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样散射光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 材质本身散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> lights = <span class="built_in">make_shared</span>&lt;hittable_list&gt;();</span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line"><span class="comment">// 对透光的玻璃也进行额外采样</span></span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-金属和电介质"><a href="#2-金属和电介质" class="headerlink" title="2 金属和电介质"></a>2 金属和电介质</h3><p>有了统一管理散射光线的方法，我们可以修改之前的金属材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        srec.attenuation = albedo;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时修改电介质材质类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        srec.attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line">        </span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pdf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> color&amp; background, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> depth, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> RR)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, srec))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是高光反射或折射，采用之前的渲染方程，隐式的使采样pdf和散射pdf保持一致</span></span><br><span class="line">    <span class="keyword">if</span> (srec.is_specular) &#123;</span><br><span class="line">        <span class="keyword">return</span> srec.attenuation</span><br><span class="line">            * <span class="built_in">ray_color</span>(srec.specular_ray, background, world, lights, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对光源采样的pdf</span></span><br><span class="line">    <span class="keyword">auto</span> light_ptr = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="comment">// 混合pdf</span></span><br><span class="line">    <span class="function">mixture_pdf <span class="title">p</span><span class="params">(light_ptr, srec.pdf_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样光线</span></span><br><span class="line">    ray scattered = <span class="built_in">ray</span>(rec.p, p.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 采样光线的pdf值</span></span><br><span class="line">    <span class="keyword">auto</span> pdf_val = p.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + srec.attenuation * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;material&gt; aluminum = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.88</span>), <span class="number">0.0</span>);</span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), aluminum);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> glass = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, glass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-对球体和物体列表采样"><a href="#3-对球体和物体列表采样" class="headerlink" title="3 对球体和物体列表采样"></a>3 对球体和物体列表采样</h3><p>上面的主函数中我们对透明玻璃球也进行了额外采样，因此类似于之前光源所在的 zx 平面，现在我们需要实现球体和物体列表的 <code>pdf_value</code> 函数和 <code>random</code> 函数，对球体采样的具体推导过程可以查看《RayTracingTheRestOfYourLife》第 12.3 节，这里直接给出代码，首先修改球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / (center0 - o).<span class="built_in">length_squared</span>());</span><br><span class="line">        <span class="keyword">auto</span> solid_angle = <span class="number">2</span> * pi * (<span class="number">1</span> - cos_theta_max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        vec3 direction = center0 - o;</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>工具函数新增：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在球体外对球体随机采样</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2 * (<span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是物体列表 <code>hittable_list</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> weight = <span class="number">1.0</span> / objects.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">            sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size - <span class="number">1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-最后一步"><a href="#4-最后一步" class="headerlink" title="4 最后一步"></a>4 最后一步</h3><p>最后一步我们来处理掉之前图片中有时会出现的黑点或者异常像素，这是因为一些不好的采样计算出了很大的或者 NaN 的颜色，使得整个像素受损，因此我们可以在写颜色的时候处理这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常像素值</span></span><br><span class="line">    <span class="keyword">if</span> (r != r) r = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g != g) g = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != b) b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看一下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/CornellBoxConv.png" alt="CornellBoxConv"></p><h3 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二十一）混合概率密度</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/</id>
    <published>2022-04-26T03:29:53.000Z</published>
    <updated>2022-04-26T09:59:13.537Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。</p><p><em><span id="more"></span></em></p><p>因为我们要混和多种 pdf，最好的方法就是新建一个类去管理他们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 概率密度函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PDF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后我们将之前的随机散射的 pdf 作为派生类实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法线周围随机散射的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) &#123; uvw.<span class="built_in">build_from_w</span>(w); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">normalize</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个向场景中某个物体的方向采样光线的 pdf 类，这样我们可以不只向光源方向采样，还可以支持场景中的其他物体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向场景中某个物体方向采样的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> point3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们新调用了 <code>hittable</code> 类中的两个方法 <code>value</code> 和 <code>random</code>，因此要在抽象类中声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="comment">// 计算光线与物体的交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚函数，不要求所有派生类都实现</span></span><br><span class="line">    <span class="comment">// 计算对该物体方向采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成对该物体方向采样的随机光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 xz 平面物体类中实现这两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********作为光源平面用到的方法*********/</span></span><br><span class="line">    <span class="comment">// 计算随机采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 光源平面面积</span></span><br><span class="line">        <span class="keyword">auto</span> area = (x1 - x0) * (z1 - z0);</span><br><span class="line">        <span class="comment">// 光源采样点到着色点的距离平方</span></span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="comment">// 光线和光源平面法线cos</span></span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 概率密度</span></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机采样一点，作为随机采样的方向</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(x0, x1), k, <span class="built_in">random_double</span>(z0, z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后开始实现混合 pdf 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) &#123;</span><br><span class="line">        p[<span class="number">0</span>] = p0;</span><br><span class="line">        p[<span class="number">1</span>] = p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> * p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们这里只是简单的把两个 pdf 平均起来。</p><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合 pdf</span></span><br><span class="line">    <span class="keyword">auto</span> p0 = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">    <span class="function">mixture_pdf <span class="title">mixed_pdf</span><span class="params">(p0, p1)</span></span>;</span><br><span class="line">    <span class="comment">// 使用混合pdf采样光线</span></span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, mixed_pdf.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    pdf_val = mixed_pdf.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line">shared_ptr&lt;hittable&gt; lights;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">        world = <span class="built_in">cornell_box</span>();</span><br><span class="line">        lights = <span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;());</span><br><span class="line">        aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">        image_width = <span class="number">600</span>;</span><br><span class="line">        samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">        min_bounce = <span class="number">95</span>;</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">40.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/CornellBoxFinal.png" alt="CornellBoxFinal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
</feed>
