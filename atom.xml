<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2023-03-16T09:10:22.666Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++与Lua交互总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-16T08:56:42.000Z</published>
    <updated>2023-03-16T09:10:22.666Z</updated>
    
    <content type="html"><![CDATA[<p>本篇全面总结了 C++ 与 Lua 脚本交互的相关内容。内容目录：</p><p>1 编译并配置 Lua 库</p><p>2 Lua 与 C++ 交互原理</p><p>3 C++ 调用 Lua 脚本</p><p>4 Lua 调用 C++ 函数</p><p>5 Lua 调用 C++ 函数模块</p><p>6 Lua 以模块形式使用 C++ 类</p><p>7 Lua 以面向对象形式使用 C++ 类</p><p>8 Lua 与 C++ 全局数组交互</p><p>9 常用 API 总结</p><p>10 参考资料</p><p><em><span id="more"></span></em></p><h3 id="1-编译并配置-Lua-库"><a href="#1-编译并配置-Lua-库" class="headerlink" title="1 编译并配置 Lua 库"></a>1 编译并配置 Lua 库</h3><p>想要 Build 源码并直接使用 Lua 环境可以查看官网的详细步骤：<a href="http://lua-users.org/wiki/BuildingLuaInWindowsForNewbies">lua-users wiki: Building Lua In Windows For Newbies</a></p><p>为了与 C++ 程序交互，这里我们使用 VS 来将 Lua 编译成动态库，供 C++ 程序调用。</p><p>首先在 VS 中新建一个 DLL 项目：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316131921785.png" alt="image-20230316131921785"></p><p>切换到 Release 模式，然后将 Lua 源码的 src 文件夹复制到工程目录下，并将其中除 lua.c 和 luac.c 之外的所有 .c 和 .h 文件添加到工程中（因为这两个文件中有 main 函数，编译时会出错，也可以把 main 改个名字）。</p><p>修改工程属性，C&#x2F;C++ -&gt; 预编译头 -&gt; 不使用预编译头：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316132518494.png" alt="image-20230316132518494"></p><p>再修改：C&#x2F;C++ -&gt; 预处理器 -&gt; 预处理器定义，加上 <code>LUA_BUILD_AS_DLL</code> 宏定义：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316132641674.png" alt="image-20230316132641674"></p><p>之后进行生成，就可以得到编译后的库文件了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316132858537.png" alt="image-20230316132858537"></p><p>接下来为了方便后续使用，我们在合适的位置新建一个文件夹来放置 Lua 库和头文件：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316133226992.png" alt="image-20230316133226992"></p><p>然后将 Lua 源码中的 src 文件夹下的文件复制到 include 文件夹下，将生成的 .lib 文件复制到 lib 文件夹下。</p><p>接下来新建一个 C++ 工程，然后在配置项中加入包含目录：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316133551991.png" alt="image-20230316133551991"></p><p>在链接器配置中添加 Lua 库目录和库文件：<br><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316133830947.png" alt="image-20230316133830947"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316133852242.png" alt="image-20230316133852242"></p><p>之后生成项目的 Debug&#x2F;Release 目录，并将 Lua 动态库 .dll 文件放到该文件夹下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316134056677.png" alt="image-20230316134056677"></p><p>然后写一个测试程序测试是否配置成功：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span>  </span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line">&#125;<span class="comment">// 也可直接 #include lua.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 1.创建一个 Lua state  </span></span><br><span class="line">    lua_State *L = <span class="built_in">luaL_newstate</span>();  </span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 2.入栈操作  </span></span><br><span class="line">    <span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;I am so cool~&quot;</span>);   </span><br><span class="line">    <span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 3.取值操作  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lua_isstring</span>(L, <span class="number">1</span>)) &#123;             <span class="comment">//判断是否可以转为string  </span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">lua_tostring</span>(L,<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//转为string并返回  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lua_isnumber</span>(L, <span class="number">2</span>)) &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="built_in">lua_tonumber</span>(L, <span class="number">2</span>) &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 4.关闭 Lua state  </span></span><br><span class="line">    <span class="built_in">lua_close</span>(L);  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316134356516.png" alt="image-20230316134356516"></p><p>就表明配置完成了。</p><h3 id="2-Lua-与-C-交互原理"><a href="#2-Lua-与-C-交互原理" class="headerlink" title="2 Lua 与 C++ 交互原理"></a>2 Lua 与 C++ 交互原理</h3><p>Lua 与 C&#x2F;C++ 交互是通过一个虚拟栈来实现的，这个虚拟栈实际上就是一个 struct，具体实现可以从 Lua 源码中 lstate.c 文件中的 <code>static void stack_init (lua_State *L1, lua_State *L)</code> 函数看起。</p><p>与常规栈不同的是 Lua 虚拟栈不仅有正向索引（正数），还有反向索引（负数），其中正数索引 1 表示栈底，负数索引 -1 表示栈顶：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/1409576-20180729200454279-2026335911.png" alt="1409576-20180729200454279-2026335911"></p><p>于是 Lua 和 C++ 程序交互时，如果要传递值，基本原理就是：</p><ul><li><p>当 C++ 要调用 Lua 数据时，Lua 把值压入栈中，C++ 再从栈中取值</p></li><li><p>当 Lua 调用 C++ 数据时，C++ 要将数据压入栈中，让 Lua 从栈中取值</p></li></ul><p>而如果要发生函数交互，过程会稍微复杂一点：</p><ul><li>当 C++ 要调用 Lua 函数时，Lua 先将 Lua 函数压入栈中，C++ 再将数据（作为参数）继续压入栈中，然后用 API 调用栈上的 Lua 函数 + 参数，调用完后，Lua 函数和参数都会出栈，而函数计算后的值会压入栈中：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/1409576-20180729220537910-10080220.png" alt="1409576-20180729220537910-10080220"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/1409576-20180729220541857-857059720.png" alt="1409576-20180729220541857-857059720"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/1409576-20180729220545960-2028243880.png" alt="1409576-20180729220545960-2028243880"></p><ul><li>当 Lua 要调用 C++ 函数时，需要通过 API 注册符合 Lua 规范的 C++ 函数，来让 Lua 知道该 C++ 函数的定义。</li></ul><p>存入栈中的数据可以是 Lua 中的任何数据类型，包括数值, 字符串, 指针, talbe, 闭包等等，因为 Lua 的虚拟栈在源码中是这样定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lobject.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">StackValue</span> &#123;</span><br><span class="line">  TValue val;</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> delta;</span><br><span class="line">  &#125; tbclist;</span><br><span class="line">&#125; StackValue;</span><br></pre></td></tr></table></figure><p>其中的数据都是用一个名为 <code>TValue</code> 的结构体来存储的，这个结构体中就包含了 Lua 中的所有数据类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">GCObject</span> *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefieldsValue value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TValue</span> &#123;</span><br><span class="line">TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure><p>更多的实现可以查看源码中的 lobject.h 文件。</p><p>Lua 和 C++ 通信时有一个符合设计原则的约定：所有的 Lua 中的值由 Lua 来管理，C&#x2F;C++ 中产生的值 Lua 不知道, 类似表达了这样一种意思：”<strong>如果你（C&#x2F;C++）想要什么，你告诉我（Lua），我来产生，然后放到栈上，你只能通过 api 来操作这个值，而我负责管好我的世界</strong>“。这样的解耦很有必要，因为这可以保证只要是 Lua 中的变量，Lua 就要负责这些变量的生命周期和垃圾回收，而 C&#x2F;C++ 程序就无需多虑。所以，必须由 Lua 来创建这些值。</p><h3 id="3-C-调用-Lua-脚本"><a href="#3-C-调用-Lua-脚本" class="headerlink" title="3 C++ 调用 Lua 脚本"></a>3 C++ 调用 Lua 脚本</h3><p>根据以上原理，C++ 调用 Lua 脚本时一般步骤是：</p><ul><li>使用 <code>luaL_newstate()</code> 创建 Lua 状态机，返回指向虚拟栈的指针</li><li>使用 <code>luaL_loadfile()</code> 加载 Lua 脚本文件</li><li>使用 <code>lua_pcall()</code> 运行 Lua 脚本文件</li><li>需要获取 Lua 中的值时：<ul><li>使用 <code>lua_getglobal</code> 获取值</li><li>使用 <code>lua_toXXX</code> 将值转化为对应的 C++ 数据类型</li><li>如果获取的值为 table 的话，可以使用 <code>lua_getfield</code> 和 <code>lua_setfield</code> 来获取和修改 table 中的元素</li></ul></li><li>需要获取 Lua 中的函数时：<ul><li>使用 <code>lua_getglobal</code> 获取函数</li><li>如果函数有参数的话，使用 <code>lua_pushXXX</code> 将参数依次入栈</li><li>使用 <code>lua_pcall()</code> 调用函数，然后从栈顶取出函数返回值即可</li></ul></li></ul><p>接下来我们创建一个简单的 Lua 脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;Test Lua script.&quot;</span></span><br><span class="line">tbl = &#123;name = <span class="string">&quot;LYC&quot;</span>, id = <span class="number">2020262914</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后使用 C++ 程序来调用脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建 Lua 状态，返回一个指向堆栈的指针</span></span><br><span class="line">lua_State* L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"><span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 Lua 文件</span></span><br><span class="line"><span class="type">int</span> bRet = <span class="built_in">luaL_loadfile</span>(L, <span class="string">&quot;test.lua&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;load file error&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 Lua 文件</span></span><br><span class="line">bRet = <span class="built_in">lua_pcall</span>(L, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pcall error&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 读取 Lua 全局变量，内部实现过程为：</span></span><br><span class="line"><span class="comment">* 1.把 str 压栈</span></span><br><span class="line"><span class="comment">* 2.由 Lua 去寻找全局变量 str 的值，并将 str 的值返回栈顶（替换 str）</span></span><br><span class="line"><span class="comment">* 如果存在相同命名的其他变量、table 或函数，就会报错（读取位置发生访问冲突）</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;str&quot;</span>);</span><br><span class="line"><span class="comment">// 通过索引 -1 取出栈顶元素，转化为 C++ 的 string 类型</span></span><br><span class="line">string str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 table</span></span><br><span class="line"><span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;tbl&quot;</span>);</span><br><span class="line"><span class="comment">// 使用栈顶（-1）的 table 获取 table 中键为 name 的值，将其返回栈顶，替换掉 name</span></span><br><span class="line"><span class="built_in">lua_getfield</span>(L, <span class="number">-1</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 也可以使用下面的写法，先把 name 压入栈中，然后此时 table 元素在 -2 位置，使用 lua_gettable 获取对应值</span></span><br><span class="line"><span class="comment">//lua_pushstring(L, &quot;name&quot;);</span></span><br><span class="line"><span class="comment">//lua_gettable(L, -2);</span></span><br><span class="line"><span class="comment">// 获取栈顶的 name 值</span></span><br><span class="line">str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 因为此时 table 在栈顶的下面，所以取 -2，把 id 压栈，由 Lua 找到 table 中 id 键的值，并返回栈顶（替换id）</span></span><br><span class="line"><span class="built_in">lua_getfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">// 获取 id 的值，此时 id 在栈顶，所以取 -1</span></span><br><span class="line"><span class="type">int</span> id = <span class="built_in">lua_tonumber</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;tbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;tbl:id = &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取函数</span></span><br><span class="line"><span class="comment">// 将函数 add 放入栈中，由 Lua 去寻找名为 add 的函数，并将该函数返回栈顶（替换add）</span></span><br><span class="line"><span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"><span class="comment">// 分别将函数参数压入栈中</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 调用函数，调用完成以后，会将返回值压入栈中，2 表示参数个数，1 表示返回结果个数</span></span><br><span class="line"><span class="comment">// 栈中的过程：参数出栈-&gt;保存参数-&gt;参数出栈-&gt;保存参数-&gt;函数出栈-&gt;调用函数-&gt;返回结果入栈</span></span><br><span class="line"><span class="type">int</span> iRet = <span class="built_in">lua_pcall</span>(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iRet)<span class="comment">// 返回值为 0 表示调用成功</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 取出错误信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pErrorMsg = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; pErrorMsg &lt;&lt; endl;</span><br><span class="line"><span class="built_in">lua_close</span>(L);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">lua_isnumber</span>(L, <span class="number">-1</span>))<span class="comment">// 取值输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fValue = <span class="built_in">lua_tonumber</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Result is &quot;</span> &lt;&lt; fValue &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//至此，栈中的情况是：</span></span><br><span class="line"><span class="comment">//=================== 栈顶 =================== </span></span><br><span class="line"><span class="comment">// 索引    类型       值</span></span><br><span class="line"><span class="comment">// 5或-1   int       30 </span></span><br><span class="line"><span class="comment">// 4或-2   int       2020262914</span></span><br><span class="line"><span class="comment">// 3或-3   string    LYC </span></span><br><span class="line"><span class="comment">// 2或-4   table     tbl</span></span><br><span class="line"><span class="comment">// 1或-5   string Test Lua script.</span></span><br><span class="line"><span class="comment">//=================== 栈底 =================== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push 一个 string</span></span><br><span class="line"><span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;Master&quot;</span>);</span><br><span class="line"><span class="comment">// 修改 table 中的键值，注意索引值的使用，此时使用正向索引，因为 1 永远表示栈底元素</span></span><br><span class="line"><span class="comment">// 会将&quot;Master&quot;值出栈，保存值，找到到 table 的 name 键，如果键存在，存储到 name 键中</span></span><br><span class="line"><span class="built_in">lua_setfield</span>(L, <span class="number">2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="built_in">lua_getfield</span>(L, <span class="number">2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;tbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的 table</span></span><br><span class="line"><span class="built_in">lua_newtable</span>(L);</span><br><span class="line"><span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;A New Table&quot;</span>);</span><br><span class="line"><span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="built_in">lua_getfield</span>(L, <span class="number">-1</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">str = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;newtbl:name = &quot;</span> &lt;&lt; str.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭state，会销毁指定 Lua 状态机中的所有对象， 并且释放状态机中使用的所有动态内存。</span></span><br><span class="line"><span class="built_in">lua_close</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316151109087.png" alt="image-20230316151109087"></p><p>当我们修改 Lua 脚本的内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;A new Lua script.&quot;</span></span><br><span class="line">tbl = &#123;name = <span class="string">&quot;New&quot;</span>, id = <span class="number">6666666</span>&#125;</span><br><span class="line">function <span class="built_in">add</span>(a, b)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">10</span>, <span class="number">1</span>, <span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">a = a + b</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>重新运行的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316151410612.png" alt="image-20230316151410612"></p><h3 id="4-Lua-调用-C-函数"><a href="#4-Lua-调用-C-函数" class="headerlink" title="4 Lua 调用 C++ 函数"></a>4 Lua 调用 C++ 函数</h3><p>Lua 中使用 C++ 函数的一般步骤是：</p><ul><li>将 C++ 函数包装成 Lua 环境认可的 Lua_CFunction 格式</li><li>将包装好的函数注册到 Lua 环境中 </li><li>像使用普通 Lua 函数那样使用注册函数</li></ul><p>Lua_CFunction 的基本格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">xxxxx</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">　　 <span class="comment">// 函数功能</span></span><br><span class="line">    <span class="keyword">return</span> 一个数字;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的返回值代表函数返回结果的个数，而要获取参数则是通过将栈中某个位置的元素转换成 C++ 数据类型来实现，比如一个 3 个输入参数，2 个返回值的函数实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 得到参数个数 */</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 循环求参数之和 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">/* 求和 */</span></span><br><span class="line">sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 压入平均值 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line"><span class="comment">/* 压入和 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line"><span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将其注册到 Lua 环境中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数为 Lua 中的函数名称，第三个参数为 C++ 中的函数指针</span></span><br><span class="line"><span class="built_in">lua_register</span>(L, <span class="string">&quot;func&quot;</span>, average);</span><br></pre></td></tr></table></figure><p>之后我们编写一个 Lua 脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--全局变量，在C++中赋值，Lua中直接使用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;age&quot;</span>, age)</span><br><span class="line"></span><br><span class="line"><span class="comment">--新表，在C++中赋值，Lua中直接使用</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(newTable) <span class="keyword">do</span> </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;k = &quot;</span>,k,<span class="string">&quot; v = &quot;</span>,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name&quot;</span>, newTable.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">--直接调用C++中的函数</span></span><br><span class="line">avg, sum = func(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The average is &quot;</span>, avg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is &quot;</span>, sum)</span><br></pre></td></tr></table></figure><p>接下来是 C++ 部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 得到参数个数 */</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环求参数之和 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="comment">/* 求和 */</span></span><br><span class="line">sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 压入平均值 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line"><span class="comment">/* 压入和 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line"><span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_State* L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 载入Lua基本库 */</span></span><br><span class="line"><span class="built_in">luaL_openlibs</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册函数 */</span></span><br><span class="line"><span class="built_in">lua_register</span>(L, <span class="string">&quot;func&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Lua 中的全局变量</span></span><br><span class="line"><span class="built_in">lua_pushinteger</span>(L, <span class="number">18</span>);   <span class="comment">// 入栈</span></span><br><span class="line"><span class="built_in">lua_setglobal</span>(L, <span class="string">&quot;age&quot;</span>);  <span class="comment">// 1.先将18值出栈，保存值，2.在Lua中，把值存储到全局变量age中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Lua 中的 table</span></span><br><span class="line"><span class="built_in">lua_newtable</span>(L); <span class="comment">//创建一张空表，并将其压栈</span></span><br><span class="line"><span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;lili&quot;</span>);<span class="comment">// 入栈</span></span><br><span class="line"><span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;name&quot;</span>);<span class="comment">//栈顶是lili，新创建的table在lili下，所以是-2，赋值后lili出栈</span></span><br><span class="line"><span class="comment">// table出栈，保存到Lua中的newTable变量中</span></span><br><span class="line"><span class="built_in">lua_setglobal</span>(L, <span class="string">&quot;newTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行脚本 */</span></span><br><span class="line"><span class="built_in">luaL_dofile</span>(L, <span class="string">&quot;test.lua&quot;</span>);</span><br><span class="line"><span class="comment">/* 清除Lua */</span></span><br><span class="line"><span class="built_in">lua_close</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316154903000.png" alt="image-20230316154903000"></p><h3 id="5-Lua-调用-C-函数模块"><a href="#5-Lua-调用-C-函数模块" class="headerlink" title="5 Lua 调用 C++ 函数模块"></a>5 Lua 调用 C++ 函数模块</h3><p>当 Lua 中需要调用多个 C++ 函数时，可以将这些函数封装成一个模块，模块实际上是一个 table，然后使用 <code>luaL_newlib</code> 就可以将该模块压入栈中，之后将自定义的模块注册到 Lua 环境中就可以使用了。</p><p>依然以上面的函数为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">average</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 得到参数个数 */</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line"><span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环求参数之和 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 求和 */</span></span><br><span class="line">sum += <span class="built_in">lua_tonumber</span>(L, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 压入平均值 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum / n);</span><br><span class="line"><span class="comment">/* 压入和 */</span></span><br><span class="line"><span class="built_in">lua_pushnumber</span>(L, sum);</span><br><span class="line"><span class="comment">/* 返回返回值的个数 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出需要封装的C++函数，luaL_Reg 为 Lua 中注册函数的数组类型</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg mylibs_funcs[] = &#123;</span><br><span class="line"> &#123; <span class="string">&quot;func&quot;</span>, average &#125;,</span><br><span class="line"> &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有函数放到一个table中，并压入栈中，直接使用 luaL_newlib 即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_openmylib</span><span class="params">(lua_State* L)</span> </span>&#123;</span><br><span class="line"><span class="comment">// luaL_newlib的内部实现为：</span></span><br><span class="line"><span class="comment">// 创建一个新的表，将所有函数放到一个 table 中，将这个table压到stack里</span></span><br><span class="line"><span class="built_in">luaL_newlib</span>(L, mylibs_funcs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将自定义模块加到注册列表里</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg lua_reg_libs[] = &#123;</span><br><span class="line"> &#123; <span class="string">&quot;base&quot;</span>, luaopen_base &#125;,</span><br><span class="line"> &#123; <span class="string">&quot;mylib&quot;</span>, lua_openmylib &#125;,</span><br><span class="line"> &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_State* L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"><span class="built_in">luaL_openlibs</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册让 Lua 使用的模块</span></span><br><span class="line"><span class="type">const</span> luaL_Reg* lua_reg = lua_reg_libs;</span><br><span class="line"><span class="keyword">for</span> (; lua_reg-&gt;func; ++lua_reg) &#123;</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="comment">// 首先查找 package.loaded 表， 检测 modname 是否被加载过。 </span></span><br><span class="line"><span class="comment">// 如果被加载过，require 返回 package.loaded[modname] 中保存的值。</span></span><br><span class="line"><span class="comment">// 如果 modname 不在 package.loaded 中， 则调用函数 openf ，并传入字符串 modname。</span></span><br><span class="line"><span class="comment">// 将其返回值置入 package.loaded[modname]。</span></span><br><span class="line"><span class="comment">// 如果最后一个参数为真， 同时也将模块设到全局变量 modname 里。在栈上留下该模块的副本。</span></span><br><span class="line"><span class="built_in">luaL_requiref</span>(L, lua_reg-&gt;name, lua_reg-&gt;func, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 从栈中弹出 1 个元素</span></span><br><span class="line"><span class="built_in">lua_pop</span>(L, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行脚本 */</span></span><br><span class="line"><span class="built_in">luaL_dofile</span>(L, <span class="string">&quot;test.lua&quot;</span>);</span><br><span class="line"><span class="built_in">lua_close</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Lua 中使用自定义模块中的函数时需要加上模块名字：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--调用C++自定义模块中的函数</span></span><br><span class="line">avg, sum = mylib.func(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The average is &quot;</span>, avg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The sum is &quot;</span>, sum)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316160305168.png" alt="image-20230316160305168"></p><h3 id="6-Lua-以模块形式使用-C-类"><a href="#6-Lua-以模块形式使用-C-类" class="headerlink" title="6 Lua 以模块形式使用 C++ 类"></a>6 Lua 以模块形式使用 C++ 类</h3><p>Lua 中还可以调用 C++ 中的类。我们可以将 C++ 中的类封装成函数模块，供 Lua 使用。</p><p>例如一个 Student 类：</p><ul><li>Student.h</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>();</span><br><span class="line">~<span class="built_in">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get_name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Student.cpp</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>() :_name(<span class="string">&quot;Empty&quot;</span>), _age(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::get_name</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::set_name</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Student::get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::set_age</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name :&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; age : &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要将这个类的各种方法以及创建这个类对象的方法注册成为 Lua 的全局函数：</p><ul><li>StudentRegFunc.h</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------定义相关的全局函数------</span></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_create_new_student</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get/set函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_get_name</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_set_name</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_get_age</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_set_age</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_print</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------注册全局函数供Lua使用------</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg lua_reg_student_funcs[] = &#123;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span>, lua_create_new_student &#125;,</span><br><span class="line">&#123; <span class="string">&quot;get_name&quot;</span>, lua_get_name &#125;,</span><br><span class="line">&#123; <span class="string">&quot;set_name&quot;</span>, lua_set_name &#125;,</span><br><span class="line">&#123; <span class="string">&quot;get_age&quot;</span>, lua_get_age &#125;,</span><br><span class="line">&#123; <span class="string">&quot;set_age&quot;</span>, lua_set_age &#125;,</span><br><span class="line">&#123; <span class="string">&quot;print&quot;</span>, lua_print &#125;,</span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">luaopen_student_libs</span><span class="params">(lua_State* L)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>StudentRegFunc.cpp</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StudentRegFunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_create_new_student</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个对象指针放到stack里，返回给Lua中使用</span></span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_newuserdata</span>(L, <span class="built_in">sizeof</span>(Student*));</span><br><span class="line">*s = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_get_name</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//得到第一个传入的对象参数（在stack最底部）</span></span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_touserdata</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">luaL_argcheck</span>(L, s != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;invalid user data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空stack</span></span><br><span class="line"><span class="built_in">lua_settop</span>(L, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据放入stack中，供Lua使用</span></span><br><span class="line"><span class="built_in">lua_pushstring</span>(L, (*s)-&gt;<span class="built_in">get_name</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_set_name</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//得到第一个传入的对象参数</span></span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_touserdata</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">luaL_argcheck</span>(L, s != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;invalid user data&quot;</span>);</span><br><span class="line"><span class="comment">//检查当前栈顶元素是否符合类型要求</span></span><br><span class="line"><span class="built_in">luaL_checktype</span>(L, <span class="number">-1</span>, LUA_TSTRING);</span><br><span class="line"></span><br><span class="line">std::string name = <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>);</span><br><span class="line">(*s)-&gt;<span class="built_in">set_name</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_get_age</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_touserdata</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">luaL_argcheck</span>(L, s != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;invalid user data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_pushinteger</span>(L, (*s)-&gt;<span class="built_in">get_age</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_set_age</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_touserdata</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">luaL_argcheck</span>(L, s != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;invalid user data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">luaL_checktype</span>(L, <span class="number">-1</span>, LUA_TNUMBER);</span><br><span class="line"></span><br><span class="line">(*s)-&gt;<span class="built_in">set_age</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">lua_tointeger</span>(L, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lua_print</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student** s = (Student**)<span class="built_in">lua_touserdata</span>(L, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">luaL_argcheck</span>(L, s != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;invalid user data&quot;</span>);</span><br><span class="line"></span><br><span class="line">(*s)-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">luaopen_student_libs</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建一张新的表，并把列表的函数注册进去</span></span><br><span class="line"><span class="built_in">luaL_newlib</span>(L, lua_reg_student_funcs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来编写脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--调用由C++类封装成的模块</span></span><br><span class="line"><span class="comment">--创建Student对象</span></span><br><span class="line"><span class="keyword">local</span> student_obj = Student.<span class="built_in">create</span>()</span><br><span class="line"><span class="comment">--调用对象的函数</span></span><br><span class="line">Student.<span class="built_in">print</span>(student_obj)</span><br><span class="line">Student.set_name(student_obj,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">Student.set_age(student_obj,<span class="number">25</span>)</span><br><span class="line">Student.<span class="built_in">print</span>(student_obj)</span><br></pre></td></tr></table></figure><p>最后是主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StudentRegFunc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> luaL_Reg lua_reg_libs[] = &#123;</span><br><span class="line">&#123; <span class="string">&quot;base&quot;</span>, luaopen_base &#125;, <span class="comment">//基础模块</span></span><br><span class="line">&#123; <span class="string">&quot;Student&quot;</span>, luaopen_student_libs&#125;, <span class="comment">//自定义Student模块，注册函数是luaopen_student_libs</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lua_State* L = <span class="built_in">luaL_newstate</span>()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册让lua使用的库</span></span><br><span class="line"><span class="type">const</span> luaL_Reg* lua_reg = lua_reg_libs;</span><br><span class="line"><span class="keyword">for</span> (; lua_reg-&gt;func; ++lua_reg) &#123;</span><br><span class="line"><span class="built_in">luaL_requiref</span>(L, lua_reg-&gt;name, lua_reg-&gt;func, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">lua_pop</span>(L, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载脚本，如果出错，则打印错误</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">luaL_dofile</span>(L, <span class="string">&quot;test.lua&quot;</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">lua_tostring</span>(L, <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">lua_close</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;luaL_newstate error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-C++%E4%B8%8ELua%E4%BA%A4%E4%BA%92%E6%80%BB%E7%BB%93/image-20230316162945712.png" alt="image-20230316162945712"></p><h3 id="7-Lua-以面向对象方式使用-C-类"><a href="#7-Lua-以面向对象方式使用-C-类" class="headerlink" title="7 Lua 以面向对象方式使用 C++ 类"></a>7 Lua 以面向对象方式使用 C++ 类</h3><p>上述将 C++ 类注册为函数模块的形式有一个严重的问题，那就是我们无法保证 userdata 的合法性。因为在 C++ 中，我们只是简单的判断了一下传进来的 userdata 是否为 NULL，并没有办法判断传进来的 userdata 参数是通过 Student.create 函数得到的，如果我传一个错误的 userdata 进去，程序也会继续运行，但有可能使内存遭到破坏。</p><p>一种可行的方案是，为每种类型创建一个唯一的元表。每当创建了一个 userdata 后，就用相应的元表来标记它。而每当得到一个 userdata 后，就检查它是否拥有正确的元表。由于 Lua 代码不能改变 userdata 的元表，因此也就无法传一个错误的 userdata 进去。</p><p>为每个 userdata 都创建一个元表，那就需要有个地方来存储这个新的元表。在 Lua 中，通常习惯是将所有新的 C++ 类型注册到注册表中，以一个类型名作为 key，元表作为 value。由于注册表中还有其它的内容，所以必须小心地选择类型名，以避免与 key 冲突。</p><p>具体的实现可以查看：<a href="https://blog.csdn.net/qq826364410/article/details/88639408">Lua和C++交互：在Lua中以面向对象的方式使用C++注册的类</a></p><h3 id="8-Lua-与-C-全局数组交互"><a href="#8-Lua-与-C-全局数组交互" class="headerlink" title="8 Lua 与 C++ 全局数组交互"></a>8 Lua 与 C++ 全局数组交互</h3><p>具体查看：<a href="https://blog.csdn.net/qq826364410/article/details/88713839">Lua和C++交互：全局数组交互</a></p><h3 id="9-常用-API-总结"><a href="#9-常用-API-总结" class="headerlink" title="9 常用 API 总结"></a>9 常用 API 总结</h3><h4 id="9-1-虚拟栈基本操作"><a href="#9-1-虚拟栈基本操作" class="headerlink" title="9.1 虚拟栈基本操作"></a>9.1 虚拟栈基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>   <span class="title">lua_gettop</span> <span class="params">(lua_State *L)</span></span>;        <span class="comment">//返回栈顶索引（即栈长度）</span></span><br><span class="line"><span class="comment">// lua_settop将栈顶设置为一个指定的位置，即修改栈中元素的数量。</span></span><br><span class="line"><span class="comment">// 如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。</span></span><br><span class="line"><span class="comment">// 所以可以用lua_settop(0)来清空栈。</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_settop</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_pushvalue</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;    <span class="comment">//将idx索引上的值的副本压入栈顶</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_remove</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;<span class="comment">//移除idx索引上的值</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_insert</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;<span class="comment">//弹出栈顶元素，并插入索引idx位置</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">lua_replace</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;<span class="comment">//弹出栈顶元素，并替换索引idx位置的值</span></span><br><span class="line"><span class="comment">// 确保堆栈上至少有 n 个额外空位。 如果不能把堆栈扩展到相应的尺寸，</span></span><br><span class="line"><span class="comment">// 函数返回假。 失败的原因包括将把栈扩展到比固定最大尺寸还大 （至少是几</span></span><br><span class="line"><span class="comment">// 千个元素）或分配内存失败。 这个函数永远不会缩小堆栈； 如果堆栈已经</span></span><br><span class="line"><span class="comment">// 比需要的大了，那么就保持原样</span></span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">lua_checkstack</span> <span class="params">(lua_State *L, <span class="type">int</span> n)</span></span>; </span><br></pre></td></tr></table></figure><h4 id="9-2-数据压栈"><a href="#9-2-数据压栈" class="headerlink" title="9.2 数据压栈"></a>9.2 数据压栈</h4><p>lua_pushXXX：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushnil)</span> <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushnumber)</span> <span class="params">(lua_State *L, lua_Number n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>        <span class="params">(lua_pushinteger)</span> <span class="params">(lua_State *L, lua_Integer n)</span></span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushlstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *s);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushvfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt,</span><br><span class="line">                                                      va_list argp);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span> *(lua_pushfstring) (lua_State *L, <span class="type">const</span> <span class="type">char</span> *fmt, ...);</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushcclosure)</span> <span class="params">(lua_State *L, lua_CFunction fn, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_pushlightuserdata)</span> <span class="params">(lua_State *L, <span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>   <span class="params">(lua_pushthread)</span> <span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="9-3-判断栈中数据类型"><a href="#9-3-判断栈中数据类型" class="headerlink" title="9.3 判断栈中数据类型"></a>9.3 判断栈中数据类型</h4><p>lua_isXXX：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_isnumber)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_isstring)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_iscfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_isinteger)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_isuserdata)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_type)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="9-4-获取栈中数据"><a href="#9-4-获取栈中数据" class="headerlink" title="9.4 获取栈中数据"></a>9.4 获取栈中数据</h4><p>lua_toXXX：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">lua_Number</span>      <span class="params">(lua_tonumberx)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">lua_Integer</span>     <span class="params">(lua_tointegerx)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">int</span> *isnum)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>             <span class="params">(lua_toboolean)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">char</span>     *(lua_tolstring) (lua_State *L, <span class="type">int</span> idx, <span class="type">size_t</span> *len);</span><br><span class="line"><span class="function">LUA_API <span class="title">size_t</span>          <span class="params">(lua_rawlen)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">lua_CFunction</span>   <span class="params">(lua_tocfunction)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line">LUA_API <span class="type">void</span>           *(lua_touserdata) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API lua_State      *(lua_tothread) (lua_State *L, <span class="type">int</span> idx);</span><br><span class="line">LUA_API <span class="type">const</span> <span class="type">void</span>     *(lua_topointer) (lua_State *L, <span class="type">int</span> idx);</span><br></pre></td></tr></table></figure><h4 id="9-5-获取栈中数据"><a href="#9-5-获取栈中数据" class="headerlink" title="9.5 获取栈中数据"></a>9.5 获取栈中数据</h4><p>lua_getXXX：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_getglobal)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_gettable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_getfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_geti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_rawget)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_rawgeti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span> <span class="params">(lua_rawgetp)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">void</span> *p)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_createtable)</span> <span class="params">(lua_State *L, <span class="type">int</span> narr, <span class="type">int</span> nrec)</span></span>;</span><br><span class="line">LUA_API <span class="type">void</span> *(lua_newuserdata) (lua_State *L, <span class="type">size_t</span> sz);</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>   <span class="params">(lua_getmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> objindex)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>  <span class="params">(lua_getuservalue)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="9-6-向栈中写入数据"><a href="#9-6-向栈中写入数据" class="headerlink" title="9.6 向栈中写入数据"></a>9.6 向栈中写入数据</h4><p>lua_setXXX：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_setglobal)</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_settable)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_setfield)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">char</span> *k)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_seti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_rawset)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_rawseti)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, lua_Integer n)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_rawsetp)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx, <span class="type">const</span> <span class="type">void</span> *p)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">int</span>   <span class="params">(lua_setmetatable)</span> <span class="params">(lua_State *L, <span class="type">int</span> objindex)</span></span>;</span><br><span class="line"><span class="function">LUA_API <span class="title">void</span>  <span class="params">(lua_setuservalue)</span> <span class="params">(lua_State *L, <span class="type">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10 参考资料"></a>10 参考资料</h3><ul><li><a href="https://www.lua.org/">The Programming Language Lua</a></li><li><a href="https://blog.csdn.net/qq826364410/article/details/88624824">【最详细易懂】C++和Lua交互总结</a></li><li><a href="https://www.cnblogs.com/KillerAery/p/9249145.html">C++与Lua交互之配置&amp;交互原理&amp;示例 </a></li><li><a href="https://www.cnblogs.com/sevenyuan/p/4511808.html">Lua和C++交互详细总结</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇全面总结了 C++ 与 Lua 脚本交互的相关内容。内容目录：&lt;/p&gt;
&lt;p&gt;1 编译并配置 Lua 库&lt;/p&gt;
&lt;p&gt;2 Lua 与 C++ 交互原理&lt;/p&gt;
&lt;p&gt;3 C++ 调用 Lua 脚本&lt;/p&gt;
&lt;p&gt;4 Lua 调用 C++ 函数&lt;/p&gt;
&lt;p&gt;5 Lua 调用 C++ 函数模块&lt;/p&gt;
&lt;p&gt;6 Lua 以模块形式使用 C++ 类&lt;/p&gt;
&lt;p&gt;7 Lua 以面向对象形式使用 C++ 类&lt;/p&gt;
&lt;p&gt;8 Lua 与 C++ 全局数组交互&lt;/p&gt;
&lt;p&gt;9 常用 API 总结&lt;/p&gt;
&lt;p&gt;10 参考资料&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Lua" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Lua/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="Lua" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>【安全编码】并发和多线程</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-03-16T04:21:16.000Z</published>
    <updated>2023-03-16T04:26:17.098Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结了《C和C++安全编码》中并发和多线程相关的内容。</p><p><em><span id="more"></span></em></p><h3 id="多线程程序常见错误"><a href="#多线程程序常见错误" class="headerlink" title="多线程程序常见错误"></a>多线程程序常见错误</h3><p>当并发实现得不正确时，就会产生漏洞。多线程程序中常见错误有：</p><ul><li>没有用锁保护共享数据(即数据竞争)。</li><li>当锁确实存在时，不使用锁访问共享数据。</li><li>过早释放锁。</li><li>对操作的一部分获取正确的锁，释放它，后来再次取得它，然后又释放它，而正确的做法是一直持有该锁。</li><li>在想要用局部变量时，意外地通过使用全局变量共享数据。</li><li>在不同的时间对共享数据使用两个不同的锁。</li><li>由下列情况引起死锁：不恰当的锁定序列(加锁和解锁序列必须保持一致)；锁定机制使用不当或错误选择；不释放锁或试图再次获取已经持有的锁。</li></ul><p>一些常见的并发陷阱包括以下内容：</p><ul><li>缺乏公平：所有线程没有得到平等的机会来获得处理。</li><li>饥饿：当一个线程霸占共享资源、阻止其它线程使用时发生。</li><li>(3).活锁：线程继续执行，但未能获得处理。</li><li>假设线程将：以一个特定的顺序运行；不能同时运行；同时运行；在一个线程结束前获得处理。</li><li>假设一个变量不需要锁定，因为开发人员认为只有一个线程写入它且所有其它线程都读取它。这还假定该变量上的操作是原子的。</li><li>使用非线程安全库。如果一个库能保证由多个线程同时访问时不会产生数据竞争，那么认为它是线程安全的。</li><li>依托测试，以找到数据竞争和死锁。</li><li>内存分配和释放问题。当内存在一个线程中分配而在另一个线程中释放时，这些问题可能出现，不正确的同步可能会导致内存仍然被访问时被释放。</li></ul><h4 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1 死锁"></a>1 死锁</h4><p>传统上，通过使冲突的竞争窗口互斥，使得一旦一个临界区开始执行时，没有额外的线程可以执行，直到前一个线程退出临界区为止，从而消除竞争条件。但是，同步原语的不正确使用可能会导致死锁(deadlock)。当两个或多个控制流以彼此都不可以继续执行的方式阻止对方时，就会发生死锁。特别是，对于一个并发执行流的循环，如果其中在循环中的每个流都已经获得了导致在循环中随后的流悬停的同步对象，则会发生死锁。死锁的一个明显的安全漏洞是拒绝访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shared_data5 = <span class="number">0</span>;</span><br><span class="line">std::mutex* locks5 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> thread_size5;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function5</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">// 产生死锁</span></span><br><span class="line"><span class="comment">// 此代码将产生一个固定数量的线程,每个线程都修改一个值,然后读取它.虽然通常一个锁就足够了,但是每个</span></span><br><span class="line"><span class="comment">// 线程(thread_size5)都用一个锁守卫共享数据值.每个线程都必须获得两个锁,然后才能再访问该值.如果</span></span><br><span class="line"><span class="comment">// 一个线程首先获得锁0,第二个线程获得锁1,那么程序将会出现死锁</span></span><br><span class="line"><span class="keyword">if</span> (id % <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">locks5[i].<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = thread_size5; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">locks5[i].<span class="built_in">lock</span>();</span><br><span class="line"> </span><br><span class="line">shared_data5 = id;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, set shared value to: %d\n&quot;</span>, id, shared_data5);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (id % <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = thread_size5; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">locks5[i].<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">locks5[i].<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 不会产生死锁</span></span><br><span class="line"><span class="comment">// 每个线程都以同一顺序获取锁,可以消除潜在的死锁.下面的程序无论创建多少线程都不会出现死锁</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">locks5[i].<span class="built_in">lock</span>();</span><br><span class="line"> </span><br><span class="line">shared_data5 = id;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, set shared value to: %d\n&quot;</span>, id, shared_data5);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">locks5[i].<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_concurrency_deadlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread_size5 = <span class="number">5</span>;</span><br><span class="line">std::thread* threads = <span class="keyword">new</span> std::thread[thread_size5];</span><br><span class="line">locks5 = <span class="keyword">new</span> std::mutex[thread_size5];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(thread_function5, i);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size5; ++i)</span><br><span class="line">threads[i].<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test_concurrency_deadlock()继续之前,等待直到线程完成</span></span><br><span class="line"><span class="keyword">delete</span>[] locks5;</span><br><span class="line"><span class="keyword">delete</span>[] threads;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像所有的数据竞争一样，死锁行为对环境的状态而不只是程序的输入敏感。特别是，死锁(和其它的数据竞争)可能对以下条件敏感：</p><ul><li>处理器速度。</li><li>进程或线程调度算法的变动。</li><li>在执行的时候，强加的不同内存限制。</li><li>任何异步事件中断程序执行的能力。</li><li>其它并发执行进程的状态。</li></ul><h4 id="2-过早释放锁"><a href="#2-过早释放锁" class="headerlink" title="2 过早释放锁"></a>2 过早释放锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">std::mutex shared_lock6;</span><br><span class="line"><span class="type">int</span> shared_data6 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function6</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 每个线程都把一个共享变量设置为它的线程编号,然后打印出共享变量的值.为了防止数据竞争,每个线程都</span></span><br><span class="line"><span class="comment">// 锁定一个互斥量,以使变量被正确地设置</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">// 过早地释放锁</span></span><br><span class="line"><span class="comment">// 当共享变量的每一个写操作都由互斥量所保护时,随后的读取是不受保护的</span></span><br><span class="line">shared_lock6.<span class="built_in">lock</span>();</span><br><span class="line">shared_data6 = id;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, set shared value to: %d\n&quot;</span>, id, shared_data6);</span><br><span class="line">shared_lock6.<span class="built_in">unlock</span>();</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(id) * <span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, has shared value to: %d\n&quot;</span>, id, shared_data6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 读取和写入共享数据都必须受到保护,以确保每一个线程读取到它写入的相同的值.将临界区扩展为包括读取值,此代码就呈现为线程安全的</span></span><br><span class="line"><span class="comment">// 需要注意的是,线程的顺序仍然可以有所不同,但每个线程都正确地打印出线程编号</span></span><br><span class="line">shared_lock6.<span class="built_in">lock</span>();</span><br><span class="line">shared_data6 = id;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, set shared value to: %d\n&quot;</span>, id, shared_data6);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(id) * <span class="number">100</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;thread: %d, has shared value to: %d\n&quot;</span>, id, shared_data6);</span><br><span class="line">shared_lock6.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_concurrency_prematurely_release_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> thread_size = <span class="number">10</span>;</span><br><span class="line">std::thread threads[thread_size];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i)</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(thread_function6, i);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_size; ++i)</span><br><span class="line">threads[i].<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// test_concurrency_prematurely_release_lock()继续之前,等待直到线程完成</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-争用"><a href="#3-争用" class="headerlink" title="3 争用"></a>3 争用</h4><p>当一个线程试图获取另一个线程持有的锁时，就会发生锁争用。有些锁争用是正常的，这表明，锁正在”工作”，以防止竞争条件。过多的锁争用会导致性能不佳。减少持有锁的时间量或通过降低每个锁保护的粒度或资源量，可以解决锁争用导致的性能差的问题。持有锁的时间越长，另一个线程尝试获取锁，并被迫等待的概率将越大。反之，减少持有锁的持续时间就减少了争用。例如，不会作用于共享资源的代码，不需要在临界区之内得到保护，并可以与其它线程并行运行。在一个临界区之内执行一个阻塞操作延伸了临界区的持续时间，从而增加了潜在的争用。在临界区之内的阻塞操作也可能导致死锁。在临界区之内执行阻塞操作几乎始终是一个严重的错误。</p><p>锁的粒度也可以影响争用。增加由一个单一锁保护的共享资源的数量，或扩大共享资源的范围(例如，锁定整个表以访问一个单元格)，将使在同一时间多个线程尝试访问该资源的概率增大。在选择锁的数量时，增加锁的开销和减少锁争用之间有一个权衡。更细的粒度(每个保护少量的数据)需要更多的锁，使得锁本身的开销增加。额外的锁也会增加死锁的风险。锁一般是相当快的，但是，当然单个执行线程运行速度会比没有锁更慢。</p><h4 id="4-ABA-问题"><a href="#4-ABA-问题" class="headerlink" title="4 ABA 问题"></a>4 ABA 问题</h4><p>在同步过程中，当一个位置被读取两次，并有相同的值供读取时，就发生 ABA 的问题。然而，第二个线程已在两次读取之间执行并修改了这个值，执行其它工作，然后把值再修改回来，从而愚弄第一个线程，让它以为第二个线程尚未执行。实现无锁数据结构时，经常会遇到 ABA 问题。如果将一个条目从列表中移除，并删除，然后分配一个新的条目，并把它添加到列表中，因为优化，新的对象通常会放置在被删除的对象的相同位置。因此，指向新条目的指针可能等于旧项目的指针，这可能会导致 ABA 问题。</p><p>自旋锁(spinlock)是一种类型的锁实现，其中线程在一个循环中反复尝试获得锁，直到它终于成功。一般而言，只有当等待获得锁的时间很短时，自旋锁才是有效的。在这种情况下，自旋锁避免了昂贵的上下文切换时间和在传统的锁中等待资源时，调度运行需要花费的时间。当获得锁的等待时间是明显长时，自旋锁在试图获取一个锁时就会浪费大量的 CPU 时间。一个常见的防止自旋锁浪费 CPU 周期的缓解措施是，在 while 循环中让该线程休眠或把控制让给其它线程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结了《C和C++安全编码》中并发和多线程相关的内容。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/categories/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【安全编码】整数安全</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E6%95%B4%E6%95%B0%E5%AE%89%E5%85%A8/</id>
    <published>2023-03-16T04:21:07.000Z</published>
    <updated>2023-03-16T04:25:24.325Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结了《C和C++安全编码》中整数相关的内容。</p><p><em><span id="more"></span></em></p><h3 id="常见的整数安全漏洞"><a href="#常见的整数安全漏洞" class="headerlink" title="常见的整数安全漏洞"></a>常见的整数安全漏洞</h3><h4 id="1-无符号整数回绕"><a href="#1-无符号整数回绕" class="headerlink" title="1 无符号整数回绕"></a>1 无符号整数回绕</h4><p>涉及无符号操作数的计算永远不会溢出，因为回绕，一个无符号整数表达式永远无法求出小于零的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回绕:涉及无符号操作数的计算永远不会溢出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_wrap_around</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui value 1: %u\n&quot;</span>, ui); <span class="comment">// 4294967295</span></span><br><span class="line">ui++; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui value 2: %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line">ui = <span class="number">0</span>; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui value 3: %u\n&quot;</span>, ui); <span class="comment">// 0</span></span><br><span class="line">ui--; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui value 4: %u\n&quot;</span>, ui); <span class="comment">// 4294967295</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//for (unsigned i = n; --i &gt;= 0; ) // 此循环将永远不会终止</span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ... 对i, j, sum进行一些赋值运算操作</span></span><br><span class="line"><span class="keyword">if</span> (sum + i &gt; UINT_MAX) &#123; &#125; <span class="comment">// 不会发生,因为sum+i回绕了</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; UINT_MAX - sum) &#123; &#125; <span class="comment">// 好很多</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (sum - j &lt; <span class="number">0</span>) &#123; &#125; <span class="comment">// 不会发生,因为sum-j回绕了</span></span><br><span class="line"><span class="keyword">if</span> (j &gt; sum) &#123; &#125; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但也并非所有无符号整数回绕都是安全缺陷。精心定义的无符号整数算术求模属性经常被特意使用，例如，在散列算法和C标准里rand()的示例实现中就都用到了这个属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_wrap_around2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 展示了一个无符号整数回绕导致的实际漏洞的例子</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* src = <span class="string">&quot;comment&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line">size = len - <span class="number">2</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;size = %u, %x, %x, %d\n&quot;</span>, size, size, size+<span class="number">1</span>, size+<span class="number">1</span>); <span class="comment">// 4294967295, ffffffff, 0, 0</span></span><br><span class="line"><span class="type">char</span>* comment = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//memcpy(comment, src, size); // crash</span></span><br><span class="line"><span class="built_in">free</span>(comment);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> <span class="type">element_t</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 库函数calloc接受两个参数：存储元素类型所需要的空间和元素的个数.为了求出所需内存的大小,使用元素个数</span></span><br><span class="line"><span class="comment">// 乘以该元素类型所需的单位空间来计算.如果计算所得结果无法用类型为size_t的无符号整数表示,那么,尽管分</span></span><br><span class="line"><span class="comment">// 配程序看上去能够成功地执行,但实际上它只会分配非常小的内存空间.结果,应用程序对分配的缓冲区的写操作</span></span><br><span class="line"><span class="comment">// 可能会越界,从而导致基于堆的缓冲区溢出</span></span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="built_in">sizeof</span>(<span class="type">element_t</span>), count);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> off = <span class="number">1</span>, len = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> type_name;</span><br><span class="line"><span class="comment">// 这里的off和len都声明为signed int.因为根据C标准的定义,sizeof运算符返回的是一个无符号整数类型(size_t),</span></span><br><span class="line"><span class="comment">// 整数转换规则要求在那些signed int的宽度等于size_t的宽度的实现上,len - sizeof(type_name)被计算为无符号</span></span><br><span class="line"><span class="comment">// 的值,如果len比sizeof运算符返回的值小,那么减法操作会回绕并产生一个巨大的正值</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;len - sizeof(type_name): &quot;</span>&lt;&lt;len - <span class="built_in">sizeof</span>(type_name)&lt;&lt;std::endl; <span class="comment">// 18446744073709551614</span></span><br><span class="line"><span class="keyword">if</span> (off &gt; len - <span class="built_in">sizeof</span>(type_name)) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 要消除以上问题,可以把整数范围检查编写为下列替代形式</span></span><br><span class="line"><span class="comment">// 程序员仍然必须保证这里的加法操作不会导致回绕,这是通过保证off的值在一个已定义的范围内实现的.为了消除</span></span><br><span class="line"><span class="comment">// 潜在的转换错误,在本例中也应当把off和len都声明为size_t类型</span></span><br><span class="line"><span class="keyword">if</span> ((off + <span class="built_in">sizeof</span>(type_name)) &gt; len) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-有符号整数溢出"><a href="#2-有符号整数溢出" class="headerlink" title="2 有符号整数溢出"></a>2 有符号整数溢出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有符号整数溢出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = INT_MAX; <span class="comment">// 2147483647, int最大值</span></span><br><span class="line">i++; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// -2147483648, int最小值</span></span><br><span class="line"> </span><br><span class="line">i = INT_MIN; <span class="comment">// -2147483648, int最小值</span></span><br><span class="line">i--; <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// 2147483647, int最大值</span></span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;abs(INT_MIN): &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>(INT_MIN) &lt;&lt; std::endl; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// 因为二进制补码表示是不对称的,数值0被表示为”正”数,所以用补码表示的一个给定类型最小负值的相反数不能以那种类型表示</span></span><br><span class="line"><span class="comment">// 对最小的负值而言,结果是未定义的或错误的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs(n) ((n) &lt; 0 ? -(n) : (n))</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> abs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-字符类型表示整数"><a href="#3-字符类型表示整数" class="headerlink" title="3 字符类型表示整数"></a>3 字符类型表示整数</h4><p>在把 char 类型用于数值时必须使用明确的 signed char 或 unsigned char。建议仅使用 signed char 和 unsigned char 类型存储和使用小数值，也就是范围分别在 SCHAR_MIN 和 SCHAR_MAX 之间，或 0 和 UCHAR_MAX 之间的值，因为这是可移植的保证数据的符号字符类型的唯一方式。常规的 char 不应该被用来存储数值，因为编译器有定义 char 的自由，使其要么与 signed char，要么与 unsigned char 具有相同的范围、表示和行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_char</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// char类型的变量c可能是有符号或无符号的</span></span><br><span class="line">        <span class="comment">// 初始值200(它具有signed char类型)无法在(有符号的)char类型中表示(这是未定义的行为)</span></span><br><span class="line">        <span class="comment">// 许多编译器将用标准的由无符号转换到有符号的模字大小(modulo-word-size)规则把200转换为-56</span></span><br><span class="line">        <span class="type">char</span> c = <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;i/c = %d\n&quot;</span>, i / c); <span class="comment">// 在windows/linux上会输出-17, 1000/-56=-17</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 声明unsigned char型变量c,使后面的除法操作与char的符号性无关,因此它有一个可预见的结果</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;i/c = %d\n&quot;</span>, i / c); <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-整数类型提升"><a href="#4-整数类型提升" class="headerlink" title="4 整数类型提升"></a>4 整数类型提升</h4><p>如果一个整数类型具有低于或等于 int 或 unsigned int 的整数转换级别，那么它的对象或表达式在用于一个需要 int 或 unsigned int 的表达式时，就会被提升。整数类型提升被作为普通算术转换的一个组成部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_promotion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>, c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">// 整数类型提升规则要求把c1和c2都提升到int类型</span></span><br><span class="line"><span class="comment">// 然后把这两个int类型的数据相加,得到一个int类型的值,并且该结果被保存在整数类型变量sum中</span></span><br><span class="line">sum = c1 + c2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sum: %d\n&quot;</span>, sum); <span class="comment">// 195</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> cresult, c1, c2, c3;</span><br><span class="line">c1 = <span class="number">100</span>; c2 = <span class="number">3</span>; c3 = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 在用8位补码表示signed char的平台上,c1与c2相乘的结果可能会因超过这些平台上signed char类型的最大值(+127)</span></span><br><span class="line"><span class="comment">// 而引起signed char类型的溢出.然而,由于发生了整数类型提升,c1, c2和c3都被转换为int,因此整个表达式的结果</span></span><br><span class="line"><span class="comment">// 能够被成功地计算出来.该结果随后被截断,并被存储在cresult中.由于结果位于signed char类型的取值范围内,因</span></span><br><span class="line"><span class="comment">// 此该截断操作并不会导致数据丢失或数据解释错误 </span></span><br><span class="line">cresult = c1 * c2 / c3;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;cresult: %d\n&quot;</span>, cresult); <span class="comment">// 75</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc = UCHAR_MAX; <span class="comment">// 0xFF</span></span><br><span class="line"><span class="comment">// 当uc用作求反运算符&quot;~&quot;的操作数时,通过使用零扩展把它扩展为32位,它被提升为signed int类型,因此,在</span></span><br><span class="line"><span class="comment">// x86-32架构平台中,该操作始终产生一个类型为signed int的负值</span></span><br><span class="line"><span class="type">int</span> i = ~uc;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;i: %0x\n&quot;</span>, i); <span class="comment">// 0xffffff00</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-无符号整数类型转换"><a href="#5-无符号整数类型转换" class="headerlink" title="5 无符号整数类型转换"></a>5 无符号整数类型转换</h4><p>从较小的无符号整数类型转换到较大的无符号整数类型始终是安全的，通常通过对其值进行零扩展(zero-extending)而完成。当表达式包含不同宽度的无符号整数操作数时，C标准要求每个操作的结果都具有其中较宽的操作数的类型(和表示范围)。假设相应的数学运算产生一个在结果类型能表示的范围内的结果，则得到的表示值就是那个数学值。如果数学结果值不能用结果类型表示，发生的情况有两类：无符号，损失精度；无符号值转换成有符号值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_unsigned_conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 无符号,损失精度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = <span class="number">300</span>;</span><br><span class="line"><span class="comment">// 当uc被赋予存储在ui中的值时,值300以模2^8取余,或300-256=44</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc = ui;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;uc: %u\n&quot;</span>, uc); <span class="comment">// 44</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 无符号值转换成有符号值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> ul = ULONG_MAX;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> sc;</span><br><span class="line">sc = ul; <span class="comment">// 可能会导致截断错误</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sc: %d\n&quot;</span>, sc); <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 当从一个无符号类型转换为有符号类型时,应验证范围</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> ul = ULONG_MAX;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> sc;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= SCHAR_MAX) &#123;</span><br><span class="line">sc = (<span class="type">signed</span> <span class="type">char</span>)ul; <span class="comment">// 使用强制转换来消除警告</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-有符号整数类型转换"><a href="#6-有符号整数类型转换" class="headerlink" title="6 有符号整数类型转换"></a>6 有符号整数类型转换</h4><p>从较小的有符号整数类型转换为较大的有符号整数类型始终是安全的，并可以采用对该值进行符号扩展的方法在补码表示中实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_signed_conversion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 有符号,损失精度</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> sl = LONG_MAX;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> sc = (<span class="type">signed</span> <span class="type">char</span>)sl; <span class="comment">// 强制转换消除了警告</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sc: %d\n&quot;</span>, sc); <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 当从一个有符号类型转换到精度较低的有符号类型时,应验证范围</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> sl = LONG_MAX;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> sc;</span><br><span class="line"><span class="keyword">if</span> ((sl &lt; SCHAR_MIN) || (sl &gt; SCHAR_MAX)) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sc = (<span class="type">signed</span> <span class="type">char</span>)sl; <span class="comment">// 使用强制转换来消除警告</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sc: %d\n&quot;</span>, sc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 负值和无符号值的比较固有问题</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = UINT_MAX;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 由于整数提升,c被转换为unsigned int类型的值0xFFFFFFFF,即4294967295</span></span><br><span class="line"><span class="keyword">if</span> (c == ui) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;why is -1 = 4294967295\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 从有符号类型转换为无符号类型时,可能发生类型范围错误,包括数据丢失(截断)和损失符号(符号错误)</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si = INT_MIN;</span><br><span class="line"><span class="comment">// 导致损失符号</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = (<span class="type">unsigned</span> <span class="type">int</span>)si; <span class="comment">// 强制转换消除了警告</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ui: %u\n&quot;</span>, ui); <span class="comment">// 2147483648</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 从有符号类型转换为无符号类型时,应验证取值范围</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si = INT_MIN;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui;</span><br><span class="line"><span class="keyword">if</span> (si &lt; <span class="number">0</span>) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ui = (<span class="type">unsigned</span> <span class="type">int</span>)si; <span class="comment">// 强制转换消除了警告</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui: %u\n&quot;</span>, ui);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面展示了一些整数转换和截断错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_conversion_truncation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 由转换错误导致的安全漏洞</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> MAX_ARRAY_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 如果size为负数,此检查将通过,而malloc()函数将被传入一个为负的大小.因为malloc()需要size_t类型的参数,</span></span><br><span class="line"><span class="comment">// 所以size会被转换成一个巨大的无符号数.当有符号整数类型被转换为一个无符号的整数类型时,会重复加上或减去</span></span><br><span class="line"><span class="comment">// 新类型的宽度(2^N),以使结果落在可表示的范围之内.因此,这种转换可能会导致大于MAX_ARRAY_SIZE的值.这种</span></span><br><span class="line"><span class="comment">// 错误可以通过把size声明为size_t而不是int来消除</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; MAX_ARRAY_SIZE) &#123; <span class="comment">// 初始化数组</span></span><br><span class="line"><span class="type">char</span>* array = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="built_in">free</span>(array);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理错误</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 由整数截断错误导致的缓冲区溢出漏洞</span></span><br><span class="line"><span class="type">char</span>* argv[<span class="number">3</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line"><span class="comment">// 攻击者可能会提供两个总长度无法用unsigned short整数total表示的字符做参数,这样,总长度值将会用比结果</span></span><br><span class="line"><span class="comment">// 类型所能表示的最大值大1的数取模截断,函数strlen返回一个无符号整数类型size_t的结果,对于大多数实现而言,</span></span><br><span class="line"><span class="comment">// size_t的宽度大于unsigned short的宽度,必然要进行降级操作,strcpy和strcat的执行将导致缓冲区溢出</span></span><br><span class="line">total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* buff = (<span class="type">char</span>*)<span class="built_in">malloc</span>(total);</span><br><span class="line"><span class="built_in">strcpy</span>(buff, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcat</span>(buff, argv[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;buff: %s\n&quot;</span>, buff);</span><br><span class="line"><span class="built_in">free</span>(buff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-整数操作"><a href="#7-整数操作" class="headerlink" title="7 整数操作"></a>7 整数操作</h4><p>所有证书操作都可能会导致异常情况下的错误，如溢出、回绕和截断。当某个操作产生的结果不能在操作结果类型中表示时，就会发生异常情况。</p><h5 id="7-1-赋值"><a href="#7-1-赋值" class="headerlink" title="7.1 赋值"></a>7.1 赋值</h5><p>在简单的赋值(&#x3D;)中，右操作数的值被转换为赋值表达式的类型并替换存储在左操作数所指定的对象的值。用一个有符号整数为一个无符号整数赋值，或者用一个无符号整数为一个宽度相等的有符号整数赋值，都可能导致所产生的值被误解。当从一个具有较大宽度的类型向较小宽度的类型赋值或强制类型转换时，就会导致发生截断。如果该值不能用结果类型表示，那么数据可能会丢失。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f_5_4</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">66</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_assignment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="comment">// 函数f_5_4返回的int值可能在存储到char时被截断,然后在比较之前将其转换回int宽度</span></span><br><span class="line"><span class="comment">// 在&quot;普通&quot;char具有与unsigned char相同的取值范围的实现中,转换的结果不能为负,所以下面比较的操作数</span></span><br><span class="line"><span class="comment">// 永远无法比较为相等,因此,为了有充分的可移植性,变量c应声明为int类型</span></span><br><span class="line"><span class="keyword">if</span> ((c = <span class="built_in">f_5_4</span>()) == <span class="number">-1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> l;</span><br><span class="line"><span class="comment">// i的值被转换为c=i赋值表达式的类型,那就是char类型,然后包含在括号中的表达式的值被转换为括号外的赋值</span></span><br><span class="line"><span class="comment">// 表达式的类型,即long int型.如果i的值不在char的取值范围内,那么在这一系列的分配后,比较表达式</span></span><br><span class="line"><span class="comment">// l == i是不会为真的</span></span><br><span class="line">l = (c = i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用一个有符号整数为一个无符号整数赋值,或者用一个无符号整数为一个宽度相等的有符号整数赋值,</span></span><br><span class="line"><span class="comment">// 都可能导致所产生的值被误解</span></span><br><span class="line"><span class="type">int</span> si = <span class="number">-3</span>;</span><br><span class="line"><span class="comment">// 因为新的类型是无符号的,那么通过反复增加或减去比新的类型可以表示的最大值大1的数,该值可以被转换,</span></span><br><span class="line"><span class="comment">// 直到该值落在新的类型的取值范围内.如果作为无符号值访问,结果值会被误解为一个大的正值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui = si;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui = %u\n&quot;</span>, ui); <span class="comment">// 4294967293</span></span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ui = %d\n&quot;</span>, ui); <span class="comment">// -3</span></span><br><span class="line"><span class="comment">// 在大多数实现中,通过逆向操作可以轻易地恢复原来的值</span></span><br><span class="line">si = ui;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;si = %d\n&quot;</span>, si); <span class="comment">// -3</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sum, c1, c2;</span><br><span class="line">c1 = <span class="number">200</span>; c2 = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// c1和c2相加产生的值在unsigned char的取值范围之外,把结果赋值给sum时会被截断</span></span><br><span class="line">sum = c1 + c2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sum = %u\n&quot;</span>, sum); <span class="comment">// 34</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-加法"><a href="#7-2-加法" class="headerlink" title="7.2 加法"></a>7.2 加法</h5><p>可以用来将两个算术操作数或者将一个指针与一个整数相加。如果两个操作数都是算术类型，那么将会对它们执行普通算术转换。二元的”+”运算符的结果就是其操作数的和。递增与加1等价。如果表达式是将一个整数类型加到一个指针上，那么其结果将是一个指针，这称为指针算术运算。两个整数相加的结果总是能够用比两个操作数中较大者的宽度大1位的数来表示。任何整数操作的结果都可以用任何比其中较大者的宽度大1的类型表示。如果结果整数类型占用的位数不足以表示其结果，那么整数加法就会导致溢出或回绕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 先验条件测试,补码表示: 用来检测有符号溢出,该解决方案只适用于使用补码表示的架构</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si1, si2, sum;</span><br><span class="line">si1 = <span class="number">-40</span>; si2 = <span class="number">30</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usum = (<span class="type">unsigned</span> <span class="type">int</span>)si1 + si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;usm = %x, si1 = %x, si2 = %x, int_min = %x\n&quot;</span>, usum, si1, si2, INT_MIN);</span><br><span class="line"><span class="comment">// 异或可以被当作一个按位的&quot;不等&quot;操作,由于只关心符号位置,因此把表达式用INT_MIN进行掩码,</span></span><br><span class="line"><span class="comment">// 这使得只有符号位被设置</span></span><br><span class="line"><span class="keyword">if</span> ((usum ^ si1) &amp; (usum ^ si2) &amp; INT_MIN) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum = si1 + si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 一般的先验条件测试</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si1, si2, sum;</span><br><span class="line">si1 = <span class="number">-40</span>; si2 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">if</span> ((si2 &gt; <span class="number">0</span> &amp;&amp; si1 &gt; INT_MAX - si2) || (si2 &lt; <span class="number">0</span> &amp;&amp; si1 &lt; INT_MIN - si2)) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum = si1 + si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 先验条件测试:保证没有回绕的可能性</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1, ui2, usum;</span><br><span class="line">ui1 = <span class="number">10</span>; ui2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (UINT_MAX - ui1 &lt; ui2) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">usum = ui1 + ui2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;usum = %u\n&quot;</span>, usum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 后验条件测试</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1, ui2, usum;</span><br><span class="line">ui1 = <span class="number">10</span>; ui2 = <span class="number">20</span>;</span><br><span class="line">usum = ui1 + ui2;</span><br><span class="line"><span class="keyword">if</span> (usum &lt; ui1) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-减法"><a href="#7-3-减法" class="headerlink" title="7.3 减法"></a>7.3 减法</h5><p>与加法类型，减法也是一种加法操作。对减法而言，两个操作数都必须是算术类型或指向兼容对象类型的指针。从一个指针中减去一个整数也是合法的。递减操作等价于减1操作。如果两个操作之差是负数，那么无符号减法会产生回绕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_substruction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 先验条件测试:两个正数相减或两个负数相减都不会发生溢出</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si1, si2, result;</span><br><span class="line">si1 = <span class="number">10</span>; si2 = <span class="number">-20</span>;</span><br><span class="line"><span class="comment">// 如果两个操作数异号,并且结果的符号与第一个操作数不同,则已发生减法溢出</span></span><br><span class="line"><span class="comment">// 异或用作一个按位的&quot;不等&quot;操作.要测试符号位置,表达式用INT_MIN进行掩码,这使得只有符号位被设置</span></span><br><span class="line"><span class="comment">// 该解决方案只适用于适用补码表示的架构</span></span><br><span class="line"><span class="keyword">if</span> ((si1 ^ si2) &amp; (((<span class="type">unsigned</span> <span class="type">int</span>)si1 - si2) ^ si1) &amp; INT_MIN) &#123; <span class="comment">// 处理错误条件</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = si1 - si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;result = %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可移植的先验条件测试</span></span><br><span class="line"><span class="keyword">if</span> ((si2 &gt; <span class="number">0</span> &amp;&amp; si1 &lt; INT_MIN + si2) || (si2 &lt; <span class="number">0</span> &amp;&amp; si1 &gt; INT_MAX + si2)) &#123; <span class="comment">// 处理错误条件</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = si1 - si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;result = %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 无符号操作数的减法操作的先验条件测试,以保证不存在无符号回绕现象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1, ui2, udiff;</span><br><span class="line">ui1 = <span class="number">10</span>; ui2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (ui1 &lt; ui2) &#123; <span class="comment">// 处理错误条件</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">udiff = ui1 - ui2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;udiff = %u\n&quot;</span>, udiff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 后验条件测试</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1, ui2, udiff;</span><br><span class="line">ui1 = <span class="number">10</span>; ui2 = <span class="number">20</span>;</span><br><span class="line">udiff = ui1 - ui2;</span><br><span class="line"><span class="keyword">if</span> (udiff &gt; ui1) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-4-乘法"><a href="#7-4-乘法" class="headerlink" title="7.4 乘法"></a>7.4 乘法</h5><p>二元运算符”*”的每个操作数都是算术类型。操作数执行普通算术转换。乘法容易产生溢出错误，因为相对较小的操作数相乘时，都可能导致一个指定的整数类型溢出。一般情况下，两个整数的操作数的积总是可以用两个操作数中较大的那个所用的位数的两倍来表示。这意味着，例如，两个8位操作数的积总是可以使用16位类表示，而两个16位操作数的积总是可以使用32位来表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_multiplication</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 在无符号乘法的情况下,如果需要高位来表示两个操作数的积,那么结果以及回绕了</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> product;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) &gt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>), </span><br><span class="line"><span class="string">&quot;Unable to detect wrapping after multiplication&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)ui1 * (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)ui2;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; UINT_MAX) &#123; <span class="comment">// 处理无符号回绕</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">product = (<span class="type">unsigned</span> <span class="type">int</span>)tmp;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;product = %u\n&quot;</span>, product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 保证在long long宽度至少是int宽度两倍的系统上,不可能产生符号溢出</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si1 = <span class="number">20</span>, si2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> result;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &gt;= <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>),</span><br><span class="line"><span class="string">&quot;Unable to detect overflow after multiplication&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp = (<span class="type">long</span> <span class="type">long</span>)si1 * (<span class="type">long</span> <span class="type">long</span>)si2;</span><br><span class="line"><span class="keyword">if</span> ((tmp &gt; INT_MAX) || (tmp &lt; INT_MIN)) &#123; <span class="comment">// 处理有符号溢出</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = (<span class="type">int</span>)tmp;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;result = %d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 一般的先验调试测试</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1 = <span class="number">10</span>, ui2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> product;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (ui1 &gt; UINT_MAX / ui2) &#123; <span class="comment">// 处理无符号回绕</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">product = ui1 * ui2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;product = %u\n&quot;</span>, product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// 可以防止有符号溢出,而不需要向上强制类型转换到现有位数的两倍的整数类型</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> si1 = <span class="number">10</span>, si2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> product;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (si1 &gt; <span class="number">0</span>) &#123; <span class="comment">// si1是正数</span></span><br><span class="line"><span class="keyword">if</span> (si2 &gt; <span class="number">0</span>) &#123; <span class="comment">// si1和si2都是正数</span></span><br><span class="line"><span class="keyword">if</span> (si1 &gt; (INT_MAX / si2)) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end if si1和si2都是正数</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// si1是正数,si2不是正数</span></span><br><span class="line"><span class="keyword">if</span> (si2 &lt; (INT_MIN / si1)) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end if si1是正数,si2不是正数</span></span><br><span class="line">&#125; <span class="comment">// end fif si1是正数</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// si1不是正数</span></span><br><span class="line"><span class="keyword">if</span> (si2 &gt; <span class="number">0</span>) &#123; <span class="comment">// si1不是正数,si2是正数</span></span><br><span class="line"><span class="keyword">if</span> (si1 &lt; (INT_MIN / si2)) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end if si1不是正数,si2是正数</span></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// si1和si2都不是正数</span></span><br><span class="line"><span class="keyword">if</span> ((si1 != <span class="number">0</span>) &amp;&amp; (si2 &lt; (INT_MAX / si1))) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end if si1和si2都不是正数</span></span><br><span class="line">&#125; <span class="comment">// end if si1不是正数</span></span><br><span class="line"> </span><br><span class="line">product = si1 * si2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;product = %d\n&quot;</span>, product);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-5-除法和求余"><a href="#7-5-除法和求余" class="headerlink" title="7.5 除法和求余"></a>7.5 除法和求余</h5><p>整数相除时，”&#x2F;”运算符的结果是代数商的整数部分，任何小数部分都被丢弃，而”%”运算符的结果是余数。这通常称为向零截断(truncation toward zero)。在这两种运算中，如果第二个操作数的值是0，则该行为是未定义的。无符号整数除法不可能产生回绕，因为商总是小于或等于被除数。但并不总是显而易见的是，有符号整数除法也可能导致溢出，因为你可能认为商数始终小于被除数。然而，补码的最小值除以-1时会出现整数溢出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_division_remainder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先验条件:可以通过检查分子是否为整数类型的最小值以及检查分母是否为-1来防止有符号整数除法溢出的发生</span></span><br><span class="line"><span class="comment">// 只要确保除数不为0,就可以保证不发生除以零错误</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> sl1 = <span class="number">100</span>, sl2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> quotient, result;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 此先验条件也可测试余数操作数,以保证不可能有一个除以零错误或(内部)溢出错误</span></span><br><span class="line"><span class="keyword">if</span> ((sl2 == <span class="number">0</span>) || ((sl1 == LONG_MIN) &amp;&amp; (sl2 == <span class="number">-1</span>))) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">quotient = sl1 / sl2;</span><br><span class="line">result = sl1 % sl2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;quotient = %ld, result = %ld\n&quot;</span>, quotient, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-6-求负"><a href="#7-6-求负" class="headerlink" title="7.6 求负"></a>7.6 求负</h5><p>对一个补码表示的有符号的整数求反，也可能产生一个符号错误，因为有符号整数类型的可能值范围是不对称的。</p><h5 id="7-7-移位"><a href="#7-7-移位" class="headerlink" title="7.7 移位"></a>7.7 移位</h5><p>此操作包括左移位和右移位。移位会在操作数上执行整数提升，其中每个操作数都具有整数类型。结果类型是提升后的左操作数类型。移位运算符右边的操作数提供移动的位数。如果该数值为负值或者大于或等于结果类型的位数，那么该行为是未定义的。在几乎所有情况下，试图移动一个负的位数或试图移动比操作数中存在的位数更多的位都表明一个错误(逻辑错误)。这与溢出是不同的，后者是一个表示不足。不要移动一个负的位数或移动比操作数中存在的位数更多的位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_integer_security_shift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// 消除了无符号整数左移位操作造成的未定义行为的可能性</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ui1 = <span class="number">1</span>, ui2 = <span class="number">31</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uresult;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (ui2 &gt;= <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) * CHAR_BIT) &#123; <span class="comment">// 处理错误情况</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">uresult = ui1 &lt;&lt; ui2;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;uresult = %u\n&quot;</span>, uresult);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//int stringify = 0x80000000; // windows/liunx will crash in sprintf function</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stringify = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="built_in">sizeof</span>(<span class="string">&quot;256&quot;</span>)] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">rc = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%u&quot;</span>, stringify &gt;&gt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">if</span> (rc == <span class="number">-1</span> || rc &gt;= <span class="built_in">sizeof</span>(buf)) &#123; <span class="comment">// 处理错误</span></span><br><span class="line"><span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fail\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;value: %s\n&quot;</span>, buf); <span class="comment">// 128</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结了《C和C++安全编码》中整数相关的内容。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/categories/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【安全编码】内存管理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-16T04:20:57.000Z</published>
    <updated>2023-03-16T04:24:07.830Z</updated>
    
    <content type="html"><![CDATA[<p>本章总结《C和C++安全编码》中内存管理相关的内容。</p><p><em><span id="more"></span></em></p><h3 id="常见的C-内存管理错误"><a href="#常见的C-内存管理错误" class="headerlink" title="常见的C++内存管理错误"></a>常见的C++内存管理错误</h3><h4 id="1-未能正确检查分配失败"><a href="#1-未能正确检查分配失败" class="headerlink" title="1 未能正确检查分配失败"></a>1 未能正确检查分配失败</h4><p>下面是一个错误的检测分配内存是否成功的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span>(ip) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 new 在内存分配失败时会抛出异常，因此上面的检验条件总为真，else 分支不会被执行，可以使用 <code>std::nothrow</code> 来使 new 在分配失败时不抛出异常，而是返回一个空指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* p2 = <span class="built_in">new</span>(std::nothrow) T;</span><br></pre></td></tr></table></figure><h4 id="2-不正确配对的内存管理函数"><a href="#2-不正确配对的内存管理函数" class="headerlink" title="2 不正确配对的内存管理函数"></a>2 不正确配对的内存管理函数</h4><p>不要混合使用 C 和 C++ 的内存分配运算符，比如使用 free() 来释放 new 分配的内存，因为这样会导致内存泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_memory_new_delete_unpaired</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">free</span>(ip); <span class="comment">// 错误，应使用delete ip</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span>* ip2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line">*ip2 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">delete</span> ip2; <span class="comment">// 错误，应使用free(ip2)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// new和delete操作符用于分配和释放单个对象</span></span><br><span class="line">Widget* w = <span class="keyword">new</span> <span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">delete</span> w;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// new[]和delete[]操作符用于分配和释放数组</span></span><br><span class="line">Widget* w2 = <span class="keyword">new</span> Widget[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] w2;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// operator new()分配原始内存，但不调用构造函数</span></span><br><span class="line">std::string* sp = <span class="built_in">static_cast</span>&lt;std::string*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(std::string)));</span><br><span class="line"><span class="comment">//delete sp; // 错误</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(sp)</span></span>; <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于 new、delete 和内存泄漏的内容可以查看之前的笔记：<a href="https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/">【知识汇总】C++ 相关</a>。</p><h4 id="3-多次释放内存"><a href="#3-多次释放内存" class="headerlink" title="3 多次释放内存"></a>3 多次释放内存</h4><p>为了防止多次释放内存或内存泄漏，在存放指针的容器中使用智能指针，更多关于内存泄漏、野指针和智能指针的内容可以查看之前的笔记：<a href="https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/">【知识汇总】C++ 相关</a>。</p><h4 id="4-释放函数抛出异常"><a href="#4-释放函数抛出异常" class="headerlink" title="4 释放函数抛出异常"></a>4 释放函数抛出异常</h4><p>如果释放函数通过抛出一个异常终止，那么该行为是未定义的。释放函数，包括全局的operator delete()函数，它的数组形式与其用户定义的重载，经常在销毁类类型的对象时被调用，其中包括作为某个异常结果的栈解开。允许栈解开期间抛出异常导致逃避了调用std::terminate，而导致std::abort函数调用的默认效果。这种情况可能被利用为一种拒绝服务攻击的机会。因此，<strong>释放函数必须避免抛出异常</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章总结《C和C++安全编码》中内存管理相关的内容。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/categories/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【安全编码】字符串</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/16/20230316-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-03-16T04:20:49.000Z</published>
    <updated>2023-03-16T04:23:18.901Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结了《C和C++安全编码》中字符串相关的内容。</p><p><em><span id="more"></span></em></p><h3 id="1-常见的字符串操作错误"><a href="#1-常见的字符串操作错误" class="headerlink" title="1 常见的字符串操作错误"></a>1 常见的字符串操作错误</h3><p>在 C 和 C++ 中，常见的字符串操作错误有四种，分别是是无界字符串复制（unbounded string copy）、差一错误（off-by-one error）、空结尾错误（null termination error）以及字符串截断（string truncation）。</p><h4 id="1-1-无界字符串复制（unbounded-string-copy）"><a href="#1-1-无界字符串复制（unbounded-string-copy）" class="headerlink" title="1.1 无界字符串复制（unbounded string copy）"></a>1.1 无界字符串复制（unbounded string copy）</h4><p>无界字符串复制发生在从源数据复制数据到一个定长的字符数组时。从无界数据源（如cin）读入数据，由于事先无法得知用户将会输入多少个字符，因此不可能预先分配一个长度足够的数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_unbounded_string_copy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">std::cin &gt;&gt; buf; <span class="comment">// 如果用户输入多于11个字符，会导致写越界</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">std::cin.<span class="built_in">width</span>(<span class="number">12</span>); <span class="comment">// 通过将域宽成员设置为字符数组的长度消除了溢出</span></span><br><span class="line">std::cin &gt;&gt; buf;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;echo: &quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，当分配的空间不足以复制一个程序的输入时，就会产生漏洞。如常用的 <code>strcpy()</code>、<code>strcat()</code> 和 <code>sprintf()</code> 等函数，都会执行无界复制操作。</p><p><code>strcpy()</code>相对安全，因为目标数组已经被分配了适当的大小。<code>snprintf()</code> 函数同样是一个相对安全的函数，但像其它格式的输出函数一样，它也容易产生格式化字符串漏洞。需要对<code>snprintf()</code>的返回值进行检查，因为函数可能会失败，这不仅是因为缓冲区空间不足，还有其它原因，如在函数执行过程中发生内存不足的状况。</p><h4 id="1-2-差一错误（off-by-one-error）"><a href="#1-2-差一错误（off-by-one-error）" class="headerlink" title="1.2 差一错误（off-by-one error）"></a>1.2 差一错误（off-by-one error）</h4><p>众所周知，在 C 中，字符串是一个以空字符结尾的字符数组，而 C++ 中 string 的大多数实现也是如此，而<code>sizeof</code>运算返回的是不包含空字符的长度，因此在复制或申请内存时需要加1，否则将导致差一错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_off_by_one_error</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// strcpy_s(s1, sizeof(s2), s2); // error</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(s1, <span class="built_in">sizeof</span>(s2) + <span class="number">1</span>, s2);  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// char* dest = (char*)malloc(strlen(s1)); // error</span></span><br><span class="line"><span class="type">char</span>* dest = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s1) + <span class="number">1</span>);<span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s1); ++i) &#123;</span><br><span class="line">dest[i] = s1[i];</span><br><span class="line">&#125;</span><br><span class="line">dest[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;dest: %s\n&quot;</span>, dest);</span><br><span class="line"><span class="built_in">free</span>(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-空结尾错误（null-termination-error）"><a href="#1-3-空结尾错误（null-termination-error）" class="headerlink" title="1.3 空结尾错误（null termination error）"></a>1.3 空结尾错误（null termination error）</h4><p>如果一个字符串没有以空字符结尾，程序可能会被欺骗，导致在数组边界之外读取或写入数据。这就是空结尾错误。字符串必须在数组的最后一个元素的地址处或在它之前包含一个空终止字符，才可以安全地作为标准字符串处理函数如<code>strcpy()</code>函数或<code>strlen()</code>函数的参数被传递。空终止字符之所以是必要的，是因为前面这些函数以及其它由 C 标准定义的字符串处理函数，都依赖于它的存在来标记字符串的结尾。同样，如果程序对一个字符数组迭代循环的终止条件取决于为字符串分配的内存是否存在一个空终止字符，字符串也必须以空字符结尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_null_termination_error</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//strncpy(a, &quot;0123456789abcdef&quot;, sizeof(a)); // error, a并未以空字符结尾</span></span><br><span class="line"><span class="built_in">strncpy</span>(a, <span class="string">&quot;0123456789abcde&quot;</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="comment">//strncpy(b, &quot;0123456789abcdef&quot;, sizeof(b)); // error, b并未以空字符结尾</span></span><br><span class="line"><span class="built_in">strncpy</span>(b, <span class="string">&quot;0123456789abcde&quot;</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(c, a); <span class="comment">// 若a并未以空字符结尾,那么c也未以空字符结尾，而且c可能写得远远超出了数组界限，导致无法正常打印c</span></span><br><span class="line"> <span class="comment">// 正确的做法</span></span><br><span class="line"><span class="type">char</span> d[<span class="number">16</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(d, <span class="string">&quot;0123456789abcdefghijk&quot;</span>, <span class="built_in">sizeof</span>(d) - <span class="number">1</span>);</span><br><span class="line">d[<span class="built_in">sizeof</span>(d) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;d: %s\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-字符串截断（string-truncation）"><a href="#1-4-字符串截断（string-truncation）" class="headerlink" title="1.4 字符串截断（string truncation）"></a>1.4 字符串截断（string truncation）</h4><p>当目标字符数组的长度不足以容纳一个字符串的内容时，就会发生字符串截断。截断通常发生于读取用户输入或字符串复制时，通常是程序员试图防止缓冲区溢出的结果。尽管没有缓冲区溢出危害那么大，但字符串截断会丢失数据，有时也会导致软件漏洞。</p><h3 id="2-字符串漏洞缓解策略"><a href="#2-字符串漏洞缓解策略" class="headerlink" title="2 字符串漏洞缓解策略"></a>2 字符串漏洞缓解策略</h3><p>当在为一个特定数据结构分配的内存的边界之外写入数据时，就会发生缓冲区溢出。缓冲区溢出在 C 和 C++ 程序中司空见惯，因为这两种语言：</p><ol><li>将字符串定义为以空字符结尾的字符数组；</li><li>不进行隐式的边界检查；</li><li>提供了不执行边界检查的标准字符串调用库。</li></ol><p>在 C++ 中，使用 string 类是一个方便的选择，string 类已经为上面的问题提供了处理办法，因此编程时无需关注上述问题。但使用 string 类需要格外注意迭代器失效的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_string_reference_invalid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> input[] = <span class="string">&quot;aaaa;bbbb;cccc;dddd&quot;</span>;</span><br><span class="line">std::string email;</span><br><span class="line">std::string::iterator loc = email.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(input); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] != <span class="string">&#x27;;&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//email.insert(loc++, input[i]); // 迭代器失效</span></span><br><span class="line">loc = email.<span class="built_in">insert</span>(loc, input[i]); <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//email.insert(loc++, &#x27; &#x27;); // 迭代器失效</span></span><br><span class="line">loc = email.<span class="built_in">insert</span>(loc, <span class="string">&#x27; &#x27;</span>);<span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line">++loc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">&quot;email: %s\n&quot;</span>, email.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-字符串处理函数"><a href="#3-字符串处理函数" class="headerlink" title="3 字符串处理函数"></a>3 字符串处理函数</h3><ul><li><p>gets()：永远不要使用，因为它不对缓冲区溢出进行任何检测。可以用 fgets() 或 getchar() 取代 gets()。</p></li><li><p>fgets()：接受两个额外的参数：期望读入的字符数和输入流。与 gets() 不同，fgets() 函数保留换行符。当使用 fgets() 时，可能只读取了一行的部分数据，然而，可以确定用户的输入是否被截断了，因为那样的话，输入缓冲区内将不会包含一个换行符。fget() 函数从流中最多读入比指定数量少 1 个的字符到一个数组中。如果遇到换行符或者 EOF 标志，则不会继续读取。在最后一个字符读入数组中后，一个空字符随即被写入缓冲区的结尾处。</p></li><li><p>getchar()：返回 stdin 指向的输入流中的下一个字符。如果流在 EOF 处，则该流的 EOF 标记就会被设置，且 getchar() 返回 EOF。如果发生读取错误，则该流的错误标记就会被设置，且 getchar() 返回 EOF。</p></li><li><p>gets_s()：gets_s() 函数是 gets() 的一个兼容且更安全的版本。它只从 stdin 指向的流中读取，且不保留换行符。gets_s() 函数接受一个额外的参数 rsize_t，用于指定输入的最大字符数。如果这个参数等于 0 或者比 RSIZE_MAX 更大，或者目标字符数组指针为 NULL，将产生一个错误条件。如果产生了错误条件，那么将不会有任何的输入动作，并且目标字符数组将不会被更改。否则，该函数最多读入比指定数量少 1 的字符，并且在最后一个字符读入数组后立即在其后加上空字符。如果 gets_s() 函数执行成功，则返回一个指向字符数组的指针，否则返回一个空指针。如果指定的输入字符数超过目标缓冲区的长度，那么 gets_s() 函数仍然可能导致缓冲区溢出。</p></li><li><p>strcpy() 和 strcat()：是缓冲区溢出的频繁来源，因为它们不允许调用者指定目标数组的大小，许多预防策略都建议使用这些函数的更安全的变种。strcpy_s() 和 strcat_s() 函数被定义为与 strcpy() 和 strcat() 函数非常接近的替代函数。strcpy_s() 函数有一个额外的参数，用于给定目标数组的大小，来防止缓冲区溢出。strcpy_s() 仅在源字符串可被完全复制到目标缓冲区且不引起目标缓冲区溢出的情况下才会调用成功。strcpy_s() 函数执行各种运行时约束。strcat_s() 函数将源字符串中的字符追加到目标字符串的末尾，直至遇到空结束符为止，并且追加的字符包含结尾的空字符。在没有正确指定目标缓冲区的最大长度的情况下，strcpy_s()和strcat_s()仍然可能会引起缓冲区溢出的问题。</p></li><li><p>strncpy() 和 strncat()：与 strcpy() 和 strcat() 函数类似，但每个函数都有一个额外的 size_t 类型的参数 n 用于限制要被复制的字符数量。这些函数可以被认为是截断型的复制和拼接函数。strncpy_s() 函数有一个额外的参数用于给出目标数组的大小，以防止缓冲区溢出。如果发生运行时约束违反，则目标数组被设置为空字符串，以增加问题的能见度。strncpy_s() 函数返回 0 表示成功。因为 strncpy() 函数不能保证用空字符终止目标字符串，所有程序员必须小心，以确保目标字符串是正确地以空字符终止的，并且没有覆盖最后一个字符。C 标准的 strncpy() 函数经常被推荐为 strcpy() 函数”更安全”的替代品，然而，strncpy() 容易发生串终止错误。</p></li><li><p>strncat(char* s1, const char* s2, size_t n)函数：从 s2 指向的数组追加不超过 n 个字符(空字符和它后面的字符不追加)到 s1 指向的字符串结尾。s2 最初的字符覆盖了 s1 末尾的空字符。终止空字符总是被附加到结果字符串。因此，在 s1 指向的数组中的最大字符数量是 strlen(s1)+n+1。必须谨慎使用 strncpy() 和 strncat() 函数，或根本不使用它们，尤其是在有更不易出错的替代品的时候。这两个函数都要求指定剩余的长度而不是缓冲区的总长度。由于剩余的长度在每次添加或删除数据时都会改变，因此程序员必须跟踪这些改变或重新计算剩余长度。这个过程很容易出错，并且可能会导致漏洞。</p></li><li><p>memcpy() 和 memmove()：memcpy_s() 和 memmove_s() 函数与相应的安全性较低的 memcpy() 和 memmove() 函数类似，但提供了一些额外的保障。为了防止缓冲区溢出，memcpy_s() 和 memmove_s() 函数具有额外的参数来指定目标数组的大小。</p></li><li><p>strlen()：没有特别的缺陷，但由于底层字符串表示的弱点，它的操作可能被破坏。strlen() 函数接受一个指向一个字符数组的指针，并返回终止空字符之前的字符数量。如果字符数组不是正确地以空字符结尾的，strlen() 函数可能会返回一个错误的超大的数值，使用它时，就可能会导致漏洞。在将字符串传递给 strlen() 函数之前，有必要确保它们是正确地以空值结尾的，从而使函数的结果在预期范围内。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结了《C和C++安全编码》中字符串相关的内容。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/categories/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C和C++安全编码" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C%E5%92%8CC-%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】其他常用模式及总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/09/20230309-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/09/20230309-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-09T03:54:36.000Z</published>
    <updated>2023-03-09T03:56:57.182Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了其他常用设计模式并对所有设计模式及相关设计原则进行了总结。</p><p><em><span id="more"></span></em></p><h3 id="1-其他常用设计模式"><a href="#1-其他常用设计模式" class="headerlink" title="1 其他常用设计模式"></a>1 其他常用设计模式</h3><h4 id="1-1-桥模式（Bridge）"><a href="#1-1-桥模式（Bridge）" class="headerlink" title="1.1 桥模式（Bridge）"></a>1.1 桥模式（Bridge）</h4><p>桥模式与装饰者模式类似，都是执行“单一职责”原则的模式。在某些情况下，有些类的实现可能包含多个维度的变化，例如一个信息发送器类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Messager</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 第一部分，由具体业务实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第二部分，由平台实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该类中第一部分方法需要调用第二部分方法，但每一部分方法都有不同的实现，比如PC平台下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC平台实现具体方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerBase</span> : <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 基于PC平台实现不同业务逻辑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerLite</span> : <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;        </span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerPerfect</span> : <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当我们想要加入一个移动平台时，移动平台的业务逻辑也需要全部重写，从而产生大量重复代码，并且在修改业务逻辑时，也要对每个平台的代码进行修改。</p><p>使用桥模式，将抽象部分（业务）和实现部分（平台）分离，使他们可以独立的变化。因此将业务和平台分离成两个基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Messager</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 平台部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerImp</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">MessagerImp</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后平台的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PC平台</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCMessagerImp</span> : <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 移动平台</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobileMessagerImp</span> : <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后业务部分包含一个平台对象，就无需关注具体的平台是谁了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerLite</span> :<span class="keyword">public</span> Messager &#123;   </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessagerPerfect</span>  :<span class="keyword">public</span> Messager &#123;   </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;        </span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就实现了抽象和实现的解耦，每个类只具有单一的职责。</p><p>桥模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。桥模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则，因此复用性比较差。桥模式是比多继承方案更好的解决方法。</p><h4 id="1-2-生成器模式（Builder）"><a href="#1-2-生成器模式（Builder）" class="headerlink" title="1.2 生成器模式（Builder）"></a>1.2 生成器模式（Builder）</h4><p>生成器模式与工厂模式同属于对象创建模式，都是用来管理对象创建的模式。在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成，但由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在 一起的算法却相对稳定。生成器模式将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>以搭建房子为例，生成器模式会很好理解，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HouseBuilder</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:   </span><br><span class="line">    House* pHouse;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouse</span>: <span class="keyword">public</span> House&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoneHouseBuilder</span>: <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseDirector</span>&#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HouseDirector</span>(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;        </span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart1</span>();        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart2</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="type">bool</span> flag=pHouseBuilder-&gt;<span class="built_in">BuildPart3</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;<span class="built_in">BuildPart4</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">        pHouseBuilder-&gt;<span class="built_in">BuildPart5</span>();        </span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的代码可见，Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</p><h4 id="1-3-职责链模式（Chain-of-Resposibility）"><a href="#1-3-职责链模式（Chain-of-Resposibility）" class="headerlink" title="1.3 职责链模式（Chain of Resposibility）"></a>1.3 职责链模式（Chain of Resposibility）</h4><p>职责链模式与组合模式、迭代器模式类似，都属于面向数据结构的设计模式。在软件设计中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接收者，如果显式指定，将带来发送者和接收者之间的紧耦合。职责链模式将对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p><p>代码实现也非常直观：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 请求类型，不同的接收者只能处理一个类型的请求</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">RequestType</span></span><br><span class="line">&#123;</span><br><span class="line">    REQ_HANDLER1,</span><br><span class="line">    REQ_HANDLER2,</span><br><span class="line">    REQ_HANDLER3</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求发出者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reqest</span></span><br><span class="line">&#123;</span><br><span class="line">    string description;</span><br><span class="line">    RequestType reqType;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reqest</span>(<span class="type">const</span> string &amp; desc, RequestType type) : <span class="built_in">description</span>(desc), <span class="built_in">reqType</span>(type) &#123;&#125;</span><br><span class="line">    <span class="function">RequestType <span class="title">getReqType</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> reqType; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 责任链对象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChainHandler</span>&#123;   </span><br><span class="line">    ChainHandler *nextChain;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendReqestToNextHandler</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextChain != <span class="literal">nullptr</span>)</span><br><span class="line">            nextChain-&gt;<span class="built_in">handle</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChainHandler</span>() &#123; nextChain = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextChain</span><span class="params">(ChainHandler *next)</span> </span>&#123; nextChain = next; &#125;</span><br><span class="line">    <span class="comment">// 能处理请求则处理，否则将请求发送给链上的下一个对象  </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canHandleRequest</span>(req))</span><br><span class="line">            <span class="built_in">processRequest</span>(req);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sendReqestToNextHandler</span>(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求接收对象1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler1</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler1 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求接收对象2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler2</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler2 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求接收对象3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler3</span> : <span class="keyword">public</span> ChainHandler&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canHandleRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> req.<span class="built_in">getReqType</span>() == RequestType::REQ_HANDLER3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">processRequest</span><span class="params">(<span class="type">const</span> Reqest &amp; req)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handler3 is handle reqest: &quot;</span> &lt;&lt; req.<span class="built_in">getDescription</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Handler1 h1;</span><br><span class="line">    Handler2 h2;</span><br><span class="line">    Handler3 h3;</span><br><span class="line">    h1.<span class="built_in">setNextChain</span>(&amp;h2);</span><br><span class="line">    h2.<span class="built_in">setNextChain</span>(&amp;h3);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Reqest <span class="title">req</span><span class="params">(<span class="string">&quot;process task ... &quot;</span>, RequestType::REQ_HANDLER3)</span></span>;</span><br><span class="line">    h1.<span class="built_in">handle</span>(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>职责链模式使多个对象都有处理请求的机会，从而避免了请求发送者和接受者的紧耦合。应用职责链模式可以使对象的指责分派更加灵活，可以在运行时动态的添加或者修改请求处理的职责。</p><h4 id="1-4-享元模式（Flyweight）"><a href="#1-4-享元模式（Flyweight）" class="headerlink" title="1.4 享元模式（Flyweight）"></a>1.4 享元模式（Flyweight）</h4><p>在软件运行中，大量相同的对象会带来很大的运行开销，降低软件运行效率。享元模式通过共享技术减少运行时实例对象的个数从而提升性能。所谓共享技术就是使用一个对象工厂来管理许多虚拟对象，这些虚拟对象只要状态一样就只会存在一个，从而达到了减少对象数量的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//unique object key</span></span><br><span class="line">    string key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//object state</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Font</span>(<span class="type">const</span> string&amp; key)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FontFactory</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string,Font* &gt; fontPool;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Font* <span class="title">GetFont</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span>&#123;</span><br><span class="line">        map&lt;string,Font*&gt;::iterator item=fontPool.<span class="built_in">find</span>(key);        </span><br><span class="line">        <span class="keyword">if</span>(item!=footPool.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> fontPool[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">            fontPool[key]= font;</span><br><span class="line">            <span class="keyword">return</span> font;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-5-备忘录模式（Memento）"><a href="#1-5-备忘录模式（Memento）" class="headerlink" title="1.5 备忘录模式（Memento）"></a>1.5 备忘录模式（Memento）</h4><p>备忘录模式与状态模式类似，属于应对状态变化的模式。在软件设计中，某些对象在状态转换过程中，由于某种需要可能要求程序能够回溯到对象之前的某个状态，如果使用一些公有接口来实现，则会暴露对象的实现细节。备忘录模式在不破坏封装的前提下，捕获一个对象的内部状态，并在对象外保存这个状态，这样就可以在之后需要的时候将对象恢复到原先保存的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">state</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(<span class="type">const</span> string &amp; s)</span> </span>&#123; state = s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span></span><br><span class="line">&#123;</span><br><span class="line">    string state;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Originator</span>() &#123;&#125;</span><br><span class="line">    <span class="function">Memento <span class="title">createMomento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">Memento <span class="title">m</span><span class="params">(state)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMomento</span><span class="params">(<span class="type">const</span> Memento &amp; m)</span> </span>&#123;</span><br><span class="line">        state = m.<span class="built_in">getState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Originator orginator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//捕获对象状态，存储到备忘录</span></span><br><span class="line">    Memento mem = orginator.<span class="built_in">createMomento</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//... 改变orginator状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从备忘录中恢复</span></span><br><span class="line">    orginator.<span class="built_in">setMomento</span>(memento);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-访问者模式（Visitor）"><a href="#1-6-访问者模式（Visitor）" class="headerlink" title="1.6 访问者模式（Visitor）"></a>1.6 访问者模式（Visitor）</h4><p>在软件构建过程中，由于需求变化，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中更改，将会给子类带来繁重的变更负担，甚至破坏原有设计。访问者模式定义一个访问者对象来表示一个作用于某对象结构中各元素的操作，使得可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor&amp; visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Element</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visitElementA</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accept</span><span class="params">(Visitor &amp;visitor)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        visitor.<span class="built_in">visitElementB</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Visitor</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor1</span> : <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor1 is processing ElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//扩展2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor2</span> : <span class="keyword">public</span> Visitor&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementA</span><span class="params">(ElementA&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitElementB</span><span class="params">(ElementB&amp; element)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Visitor2 is processing ElementB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">             </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Visitor2 visitor;</span><br><span class="line">    ElementB elementB;</span><br><span class="line">    elementB.<span class="built_in">accept</span>(visitor);</span><br><span class="line">    </span><br><span class="line">    ElementA elementA;</span><br><span class="line">    elementA.<span class="built_in">accept</span>(visitor);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-解释器模式（Interpreter）"><a href="#1-7-解释器模式（Interpreter）" class="headerlink" title="1.7 解释器模式（Interpreter）"></a>1.7 解释器模式（Interpreter）</h4><p>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，使用普通编程方式将面临非常频繁的变化，此时将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，就可以解决问题。</p><h4 id="1-8-中介者模式（Mediator）"><a href="#1-8-中介者模式（Mediator）" class="headerlink" title="1.8 中介者模式（Mediator）"></a>1.8 中介者模式（Mediator）</h4><p>中介者模式与适配器、外观、代理模式类似，是用于接口隔离的模式。在软件设计中，经常会出现多个对象互相关联交互的情况，对象之间经常会维持一种复杂的引用关系，如果遇到一些需求的更改，这样复杂的关系将面临不断地变化。中介者模式使用一个中介对象管理这种复杂关系，使这些对象之间不需要显式的引用彼此，避免相互交互的对象之间的紧耦合。</p><h4 id="1-9-原型模式（Prototype）"><a href="#1-9-原型模式（Prototype）" class="headerlink" title="1.9 原型模式（Prototype）"></a>1.9 原型模式（Prototype）</h4><p>当创建给定类的实例的过程很复杂或者代价很大时，就可以使用原型模式。原型模式允许通过复制现有的实例来创建性的实例。</p><h3 id="2-设计模式总结"><a href="#2-设计模式总结" class="headerlink" title="2 设计模式总结"></a>2 设计模式总结</h3><p>到此为止已经学习了全部常用的设计模式，但是模式并不代表是一成不变的，以上只是前人的经验总结出来的解决通用问题的通用技法，在具体任务中，最重要的还是利用面向对象的设计原则和思路，来使用适合当前任务的”模式“，这里的模式不一定是已经存在的模式，而是我们利用设计原则让复杂问题简单化的方法，是我们自己的”模式“，最好的模式就是忘掉模式，只记住原则。因此这里总结前面设计到的所有面向对象设计原则：</p><ul><li>依赖倒置原则（DIP）：高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li><li>开放封闭原则（OCP）：对扩展开放，对更改封闭。类模块应该是可扩展的，但是不可修改。</li><li>单一职责原则（SRP）：一个类应该仅有一个引起它变化的原因。变化的方向隐含着类的责任。</li><li>Liskov 替换原则（LSP）：子类必须能够替换它们的基类(IS-A)。</li><li>接口隔离原则（ISP）：不应该强迫客户程序依赖它们不用的方法。接口应该小而完备。</li><li>优先使用对象组合，而不是继承：继承在某种程度上破坏了封装性，子类父类耦合度高。而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li><li>封装变化：使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li><li>针对接口编程，而不是针对实现编程：客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。</li></ul><p>最后，所有设计原则都有一个共同的目标，就是<strong>管理变化，提高复用</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了其他常用设计模式并对所有设计模式及相关设计原则进行了总结。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】复合模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-08T06:26:16.000Z</published>
    <updated>2023-03-08T06:27:20.263Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了由多种设计模式组合而成的复合设计模式，其中最经典的三个模式分别为 MVC、MVP 和 MVVM 模式。</p><p><em><span id="more"></span></em></p><h3 id="1-MVC-模式"><a href="#1-MVC-模式" class="headerlink" title="1 MVC 模式"></a>1 MVC 模式</h3><p>MVC 模式是最经典的复合设计模式之一，其中：</p><ul><li>M : Model，负责存储页面的业务数据，以及对相应数据的操作。</li><li>V : View，负责页面的显示逻辑。</li><li>C : Controller， 是 View 层和 Model 层的纽带，负责用户与应用的响应操作。</li></ul><p>他们的关系如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230308140251789.png" alt="image-20230308140251789"></p><p>在 MVC 模式中，通过分离 Model、View 和 Controller 的方式来组织代码结构。当用户与页面产生交互的时候，Controller 层的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p>回顾之前的设计模式，实际上 MVC 模式包含了观察者模式、策略模式和和组合模式等多种模式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230308140450568.png" alt="image-20230308140450568"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230308140524872.png" alt="image-20230308140524872"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230308140540315.png" alt="image-20230308140540315"></p><p>当然，在模型、视图、控制器的具体实现过程中，肯定还会使用到其他的设计模式，但 MVC 的整体框架中涉及到的基本就是以上三种模式。MVC 模式将程序中的对象、显示、控制分离以提高软件的的灵活性和复用性，可以使程序具有对象化的特征，也更容易维护。</p><h3 id="2-MVP-模式"><a href="#2-MVP-模式" class="headerlink" title="2 MVP 模式"></a>2 MVP 模式</h3><p>MVP 模式是 MVC 模式的一种变体，其中：</p><ul><li>M : Model，负责存储页面的业务数据，以及对相应数据的操作。</li><li>V : View，负责页面的显示以及与用户交互。</li><li>P : Presenter， 负责完成 View 与 Model 之间的交互。</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/8a122cedc7034ff4b34c5512658cb667.png" alt="8a122cedc7034ff4b34c5512658cb667"></p><p>MVP 与 MVC 有着一个重大的区别：在 MVP 中 View 并不直接使用 Model，它们之间的通信是通过 Presenter (MVC 中的 Controller) 来进行的，所有的交互都发生在 Presenter 内部，而在 MVC 中 View 会直接从 Model 中读取数据而不是通过 Controller。</p><p>MVP 模式通过使用 Presenter 实现了对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，而在MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p><p>在 View 层通过 presenter 对象来调用 Model 层中数据请求的接口，而 Model 层中数据请求的结果会通过 presenter 中定义的接口回调给 presenter ，然后 presenter 再通知给 View 层。</p><h3 id="3-MVVM-模式"><a href="#3-MVVM-模式" class="headerlink" title="3 MVVM 模式"></a>3 MVVM 模式</h3><p>MVVM 是对 MVC 的进一步改进，其中：</p><ul><li>M : Model，负责存储页面的业务数据和业务逻辑。</li><li>V : View，负责页面的显示。</li><li>VM : ViewModel，负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作。</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F/bad4a11617954c68bc3f5c5070f630b4.png" alt="bad4a11617954c68bc3f5c5070f630b4"></p><p>MVVM 将数据双向绑定（data-binding）作为核心思想，View 和 Model 之间没有联系，它们通过 ViewModel 这个桥梁进行交互。Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。</p><p>通过上面的模型图来看，MVP 和 MVVM 模式似乎是相同的，其实不然。它们是相似的，唯一区别在于 MVVM 模式采用了双向数据绑定。开发者只需要更改 View 层或者 Model 层中的数据值，不需要进行同步 Model 层和 View 层的操作，因为数据的同步会由 ViewModel 层自动完成。而 MVP 模式中，开发者需要进行处理接收事件和 View 更新的工作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了由多种设计模式组合而成的复合设计模式，其中最经典的三个模式分别为 MVC、MVP 和 MVVM 模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】代理模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-08T05:43:55.000Z</published>
    <updated>2023-03-08T05:44:57.469Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了代理模式及相关的面向对象设计原则。代理模式为其他对象提供一种替身或占位符（代理）以控制对这个对象的访问。</p><p><em><span id="more"></span></em></p><p>代理模式顾名思义，为某一个对象提供一个代理，从而使客户想要访问该对象的时候与代理进行沟通，而不是直接与该对象发生交互。这在很多时候是很重要的，比如某些系统需要安全控制或者直接访问对象的开销很大时，就需要代理模式来控制对象的访问。</p><p>我们可以让代理对象和实际对象继承于同一个基类，这样在需要访问实际对象的时候就可以使用代理对象来替代了。代理模式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/08/20230308-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/image-20230308133854858.png" alt="image-20230308133854858"></p><p>框架代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实际对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> ISubject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubjectProxy</span>: <span class="keyword">public</span> ISubject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对RealSubject的一种间接访问</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientApp</span> &#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    ISubject* subject;    </span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="built_in">ClientApp</span>() &#123;</span><br><span class="line">        subject = <span class="keyword">new</span> <span class="built_in">SubjectProxy</span>();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体代理模式的实现方式差别很大，有些可能对单个对象做细粒度的控制，有些可能对组件模块提供抽象代理层，在架构层次对对象做代理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了代理模式及相关的面向对象设计原则。代理模式为其他对象提供一种替身或占位符（代理）以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】状态模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-07T05:57:54.000Z</published>
    <updated>2023-03-07T06:00:54.672Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了状态模式及相关的面向对象设计原则。状态模式允许对象在内部状态改变时改变它的行为，从而使对象看起来像是修改了它的行为。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>一些情况下某些对象的状态如果改变，那么它的行为也会随着发生变化。比如一个网络管理器，存在三种状态：网络开启、关闭和连接。通过某些操作能在这些状态间进行转换，但是在不同状态下时，同样的操作导致的结果可能不同（行为发生变化），下面是一个简单的实现，利用枚举存储了三种状态，然后通过最直接的 if-else 来判断当前状态并实现不同的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkState</span> &#123;</span><br><span class="line">    Network_Open,</span><br><span class="line">    Network_Close,</span><br><span class="line">    Network_Connect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    NetworkState state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == Network_Open) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Connect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Close) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Open;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == Network_Connect) &#123;</span><br><span class="line">            <span class="comment">// 其他操作</span></span><br><span class="line">            state = Network_Close;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照这种实现方式，当我们要加入新的状态或者新的操作的时候，就大量需要修改类中的代码，当状态复杂的时候很容易就出现各种错误，带来维护问题。</p><h3 id="2-状态模式"><a href="#2-状态模式" class="headerlink" title="2 状态模式"></a>2 状态模式</h3><p>状态模式将所有的状态打包成一个状态族，每一个具体的状态只负责当前状态下的操作，而原本对象的所有操作都委托给当前的状态对象去进行。对于客户来说，就好像原本的对象在不同状态下改变了它本身的行为，但实际上是通过和状态对象的组合来实现的。</p><p>状态模式的类图如下：<br><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20230307134445001.png" alt="image-20230307134445001"></p><p>形式上与策略模式一模一样，但策略模式是将操作打包成为一族算法，与对象进行组合从而使对象能够切换行为。而状态模式将状态独立出来，使对象可以随着客户的操作自动切换状态并改变行为，而对象本身对此无需知情，只要将对应的操作委托给当前的状态对象去执行即可。</p><p>接下来我们将上面的例子使用状态模式进行实现。首先需要实现一个状态接口，其中包含了系统中的所有操作，每个状态都要实现这些操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkState</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetworkState* pNext;<span class="comment">// 记录转换后的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NetworkState</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后每一个具体的状态都实现自己的操作，这里以网络开状态为例，其他两个状态同理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OpenState</span> :<span class="keyword">public</span> NetworkState&#123;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="type">static</span> NetworkState* m_instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 状态对象只能有一个，使用简单单例模式</span></span><br><span class="line">    <span class="function"><span class="type">static</span> NetworkState* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">OpenState</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 实现操作并进行状态转换</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = CloseState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = ConnectState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">// 其他操作</span></span><br><span class="line">        pNext = OpenState::<span class="built_in">getInstance</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后网络管理器的代码也需要修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkProcessor</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NetworkState* pState;<span class="comment">// 管理器的当前状态   </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 构造的时候要初始化一个状态</span></span><br><span class="line">    <span class="built_in">NetworkProcessor</span>(NetworkState* pState) &#123;       </span><br><span class="line">        <span class="keyword">this</span>-&gt;pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation1</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation2</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operation3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 委托给当前状态执行</span></span><br><span class="line">        pState-&gt;<span class="built_in">Operation3</span>();</span><br><span class="line">        <span class="comment">// 切换状态</span></span><br><span class="line">        pState = pState-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来，当新增状态或者操作有变化时，网络管理器对象的代码完全不需要更改，只需修改对应的状态对象的部分就可以了，实现了对象和其状态之间的解耦，或者说实现了具体操作和状态转换之间的解耦。状态模式的另一个潜在好处是，为不同状态引入不同的对象使得状态转换更加明确，可以保证不会出现状态不一致的情况，因为状态的转换是原子的，即要么彻底转换为另一状态，要么不转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了状态模式及相关的面向对象设计原则。状态模式允许对象在内部状态改变时改变它的行为，从而使对象看起来像是修改了它的行为。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】迭代器模式和组合模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-07T04:06:03.000Z</published>
    <updated>2023-03-07T06:00:35.667Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了迭代器模式和组合模式及相关的面向对象设计原则。这两种模式都是面向数据结构的设计模式。</p><ul><li>迭代器模式（Iterator）提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</li><li>组合模式（Composite）将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-迭代器模式"><a href="#1-迭代器模式" class="headerlink" title="1 迭代器模式"></a>1 迭代器模式</h3><p>我们对迭代器的概念非常熟悉，许多情况下面对不同的对象集合，我们希望能有统一的方式遍历他们，但不对外暴露其内部的实现方式。比如 C++ 的 vector、list、map 等容器都支持迭代器，利用迭代器我们可以使用统一的方法，比如 <code>first()</code>、<code>end()</code>、<code>next()</code> 等，对不同集合的对象进行统一的操作。</p><p>迭代器模式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230307111924414.png" alt="image-20230307111924414"></p><p>首先实现迭代器接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">current</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个和自己的元素容器，该容器需要有一个迭代器对象，并能够返回该迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCollection</span>&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">GetIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 提供当前容器的迭代器</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现我们容器的具体迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollectionIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt;&#123;</span><br><span class="line">    MyCollection&lt;T&gt; mc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollectionIterator</span>(<span class="type">const</span> MyCollection&lt;T&gt; &amp; c): <span class="built_in">mc</span>(c) &#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指向下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">// 是否指向最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T&amp; <span class="title">current</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回当前指向的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后调用时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAlgorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCollection&lt;<span class="type">int</span>&gt; mc;</span><br><span class="line">    Iterator&lt;<span class="type">int</span>&gt; iter = mc.<span class="built_in">GetIterator</span>();</span><br><span class="line">    <span class="keyword">for</span> (iter.<span class="built_in">first</span>(); !iter.<span class="built_in">end</span>(); iter.<span class="built_in">next</span>())&#123;</span><br><span class="line">        cout &lt;&lt; iter.<span class="built_in">current</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器模式把元素之间游走的责任交给迭代器去处理，这样一来元素容器本身就不需要关注如何处理对象的遍历，而是专注于对象的管理操作上。迭代器模式不仅让客户遍历不同的容器更加方便，也会让元素容器的接口更加简洁。</p><p>那么为什么不让元素容器本身去实现各自的遍历操作呢，因为一个类的每个责任都有发生变化的可能，容器管理对象是一个责任，负责对象的遍历和访问又是一个责任，责任越多，意味着未来发生变化的可能性越大，要修改的代码也就越多。因此迭代器模式引出了一个重要的设计原则：</p><blockquote><p><strong>设计原则：单一责任原则</strong></p><p>一个类应该只有一个引起变化的原因，尽量让每个类保持单一责任。</p></blockquote><h3 id="2-组合模式"><a href="#2-组合模式" class="headerlink" title="2 组合模式"></a>2 组合模式</h3><p>在一些情况下，对象内部的结构可能较为复杂，不再是单一的容器了。比如一个容器内部的每一个元素又是一个可以容纳多个对象的容器，此时使用迭代器模式就没有办法直接遍历这样的复杂结构了，因此需要使用组合模式。</p><p>组合模式将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。上面的例子中，一级容器的每个元素相当于树的一个中间节点，节点包含二级容器中的各个元素，因此我们可以将这个树状结构构建出来，并让每一级容器中的元素都继承自同一个父类，这个父类被称为基本的组件（Component），这样在客户代码中就无需关注对象是叶子节点（单一对象）还是中间节点（组合对象）了，因为他们都有相同的接口。</p><p>组合模式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/07/20230307-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20230307115555425.png" alt="image-20230307115555425"></p><p>首先是实现 Component 接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Component</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现叶子节点，叶子节点不包含其他子节点，只实现对应的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叶子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leaf</span>(string s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// process current node</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是中间节点，也就是组合对象，中间节点包含其他叶子节点，执行操作时就是先处理自身，然后遍历所有叶子节点，按顺序调用叶子节点的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line">    string name;</span><br><span class="line">    list&lt;Component*&gt; elements;<span class="comment">// 包含的子节点集合，子节点可以是其他组合对象，也可以是叶子节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(<span class="type">const</span> string &amp; s) : <span class="built_in">name</span>(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 组合对象还支持增加或删除节点的操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Component* element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">remove</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合节点的操作就是处理自身，并依次调用叶子节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. process current node</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. process leaf nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : elements)</span><br><span class="line">            e-&gt;<span class="built_in">process</span>();  <span class="comment">// 递归多态调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后为该对象的处理写一个统一的接口供客户代码使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Component &amp; c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    c.<span class="built_in">process</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构建对象关系</span></span><br><span class="line">    <span class="function">Composite <span class="title">root</span><span class="params">(<span class="string">&quot;root&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode1</span><span class="params">(<span class="string">&quot;treeNode1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode2</span><span class="params">(<span class="string">&quot;treeNode2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode3</span><span class="params">(<span class="string">&quot;treeNode3&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Composite <span class="title">treeNode4</span><span class="params">(<span class="string">&quot;treeNode4&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat1</span><span class="params">(<span class="string">&quot;left1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">leat2</span><span class="params">(<span class="string">&quot;left2&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode1);</span><br><span class="line">    treeNode1.<span class="built_in">add</span>(&amp;treeNode2);</span><br><span class="line">    treeNode2.<span class="built_in">add</span>(&amp;leaf1);</span><br><span class="line">    </span><br><span class="line">    root.<span class="built_in">add</span>(&amp;treeNode3);</span><br><span class="line">    treeNode3.<span class="built_in">add</span>(&amp;treeNode4);</span><br><span class="line">    treeNode4.<span class="built_in">add</span>(&amp;leaf2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对组合对象和单一对象的调用是统一的</span></span><br><span class="line">    <span class="built_in">Invoke</span>(root);</span><br><span class="line">    <span class="built_in">Invoke</span>(leaf2);</span><br><span class="line">    <span class="built_in">Invoke</span>(treeNode3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们也可以结合组合模式和迭代器，实现组合迭代器，只要为每个组件加上一个迭代器对象，然后递归的遍历即可。之前在实现光线追踪时的 BVH 结构就是组合模式的典型例子，可以回顾一下<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/">【RayTracer】（十）实现 BVH</a>。</p><p>组合模式采用树形结构来表达层次关系，将“一对多”的关系转变为“一对一”的关系，使客户代码可以一致的处理对象本身和对象容器，而无需关心处理的是单个对象还是组合对象。组合模式将客户代码和复杂的对象容器结构解耦，客户代码只与纯粹的抽象接口发生依赖，而不是具体的对象容器，从而更能应对变化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了迭代器模式和组合模式及相关的面向对象设计原则。这两种模式都是面向数据结构的设计模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代器模式（Iterator）提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。&lt;/li&gt;
&lt;li&gt;组合模式（Composite）将对象组合成树形结构来表示“整体-部分”的层次关系，从而让客户对单个对象和组合对象的使用具有一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T07:11:09.000Z</published>
    <updated>2023-03-05T07:12:06.845Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了模板方法模式及相关的面向对象设计原则。模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>例如有一个任务需要用到某个程序库，程序库开发人员设计了一个 Library 类，它实现了三种方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBRARY_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而应用程序开发人员要实现这个任务的话，还需要编写一些代码，并调用程序库，因此他可能会编写以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLICATION_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#endlif</span></span><br></pre></td></tr></table></figure><p>最终实现整个任务流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Application.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Library.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(app.<span class="built_in">Step2</span>())&#123;</span><br><span class="line">lib.<span class="built_in">Step3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">app.<span class="built_in">Step4</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lib.<span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2 模板方法模式"></a>2 模板方法模式</h3><p>上面的实现的问题在于，无论谁来使用程序库，完成类似的任务，都需要编写主函数中的一个完整流程，并编写自己的 Application 类，因此对于这类任务来说，流程是固定的，而库代码是不变的部分，Application 代码是变化的部分，因此我们可以设计一个方法模板，改模板按照固定流程实现某类任务，任务中有些步骤固定不变，但某些步骤可能发生改变，将这些可能发生变化的部分设定为纯虚函数，交给子类去实现，这样在客户代码中只需要调用统一的接口，就可以实现不同的任务了。</p><p>于是首先是模板方法接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBRARY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBRARY_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//稳定的template Method</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Step2</span>())&#123;<span class="comment">//支持变化===&gt;虚函数的多态调用 </span></span><br><span class="line"><span class="built_in">Step3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">Step4</span>();<span class="comment">//支持变化===&gt;虚函数的多态调用 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span></span>&#123;<span class="comment">//稳定 </span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化 </span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后让具体的程序继承该接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLICATION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Library.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> : <span class="keyword">public</span> Library&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Step4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样一来，主程序就变得非常简单，并且h后续维护也不需要做任何更改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Application.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Library *pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">pLib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Template Method 模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性） 为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了模板方法模式及相关的面向对象设计原则。模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中实现。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】适配器模式和外观模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T06:45:32.000Z</published>
    <updated>2023-03-05T07:40:23.222Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了适配器模式和外观模式及相关的面向对象设计原则。适配器模式（Adapter）和外观模式（Facade）都是用于“接口隔离”的设计模式。</p><ul><li>适配器模式将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。</li><li>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1 适配器模式"></a>1 适配器模式</h3><p>很多情况下，当我们已经有一个软件系统，并希望和一个新的厂商类库搭配使用，但厂商类库的接口和当前软件的接口不适配：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142721206.png" alt="image-20230305142721206"></p><p>而我们又不想改变现有代码，于是就需要写一个适配器，来讲类库的接口转变为当前软件支持的接口：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142803328.png" alt="image-20230305142803328"></p><p>这就是适配器模式。</p><p>适配器模式有两种实现方式，一种称为对象适配器，我们可以将被适配对象包含在适配器对象中，这样适配器就可以调用被适配对象的方法，并实现一个客户支持的接口，这种方式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305142925575.png" alt="image-20230305142925575"></p><p>另一种方式是类适配器，可以利用多重继承，让适配器成为被适配对象和目标接口的子类，这样就可以将被适配对象的接口转化为目标接口了，这种方式的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305143022285.png" alt="image-20230305143022285"></p><p>显然，对象适配器通过组合来实现适配，而类适配器通过继承来实现适配，二者各有优劣，可以根据实际情况使用。</p><h3 id="2-外观模式"><a href="#2-外观模式" class="headerlink" title="2 外观模式"></a>2 外观模式</h3><p>外观模式非常简单，直接来看类图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/image-20230305143835788.png" alt="image-20230305143835788"></p><p>需要注意的是，外观模式并不是要把所有类的接口都整合到一起，外观对象的内部应该是一个相互关联的子系统，而不是简单的功能集合。</p><p>从客户程序的角度来看，外观模式简化了整个组件系统的接口，将他们统一起来，方便客户程序调用，这样一来子系统内部的任何变化都不会改变客户程序的调用接口，从而实现了解耦。</p><p>外观模式带来了新的设计原则：</p><blockquote><p><strong>设计原则：最少知识原则</strong></p><p>设计中尽可能减少对象之间的交互。当然，减少对象之间的交互意味着需要更多的包装，这也可能为程序带来更高的运行开销。</p></blockquote><p>外观模式更注重从架构的层次去看整个系统，而不仅仅是单个类，因此外观模式更像是一种架构设计模式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了适配器模式和外观模式及相关的面向对象设计原则。适配器模式（Adapter）和外观模式（Facade）都是用于“接口隔离”的设计模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。&lt;/li&gt;
&lt;li&gt;外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】命令模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-05T06:06:52.000Z</published>
    <updated>2023-03-05T06:08:18.476Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了命令模式及相关的面向对象设计原则。命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象，从而实现请求发出者和请求执行者之间的解耦。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>我们需要设计这样一个系统，有一个遥控器，遥控器有一个插槽和三个按钮，其中两个按钮对应“开”和“关”，一个按钮对应“撤销”操作，插槽中可以插入不同的控制模块来控制不同的电器，比如电灯、热水器、电动窗帘、空调等等，也就是说遥控器的功能取决于插槽内的控制模块。而不同电器的“开”和“关”操作都有各自的实现，他们是毫无关联的单独的类。</p><p>直观的方式是判断当前插槽内是什么模块，然后为按钮调用对应的电器的命令，但是当出现更多的电器时，需要不停的修改遥控器的代码。因为此时请求发出者（遥控器）和请求执行者（被操控的电器）是紧耦合的，如果能将它们解耦，那么系统将具有更好的弹性来应对各种变化。</p><h3 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2 命令模式"></a>2 命令模式</h3><p>我们可以将遥控器的命令封装成一系列统一的命令对象，让命令对象和具体的命令执行者绑定，负责执行对应的命令，而命令发出者只需要调用命令对象的统一接口就可以实现对不同执行者的控制。</p><p>在上例中，遥控器的命令只有三种：开、关和撤销。接下来以电灯为例，按照上述思路来设计一个遥控器。电灯类非常简单，只具有开和关两种操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开灯</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是遥控器系统的实现，按照上面的思路，首先设计一个命令对象的接口，所有命令对象只有一个方法，那就是执行操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">// 执行命令</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">// 撤销命令</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，开和关是两种命令，因此要定义为两类命令对象，命令对象需要包含命令的执行对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light* light;</span><br><span class="line">    <span class="built_in">LightOnCommand</span>(Light* lt) : <span class="built_in">light</span>(lt) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销开灯即为关灯</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 关灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOffCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Light* light;</span><br><span class="line">    <span class="built_in">LightOffCommand</span>(Light* lt) : <span class="built_in">light</span>(lt) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销关灯即为开灯</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light-&gt;<span class="built_in">on</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后是遥控器，遥控器需要包含命令对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Command* OnCommand;<span class="comment">// 开按钮对应的命令对象</span></span><br><span class="line">    Command* OffCommand;<span class="comment">// 关按钮对应的命令对象</span></span><br><span class="line">    Command* undoCommand;<span class="comment">// 记录上一次按的按钮对应的命令，用于撤销按钮</span></span><br><span class="line">    <span class="comment">// 初始为按钮绑定一个默认命令对象，该命令不做任何操作，这样可以避免对象是否为空的判断</span></span><br><span class="line">    <span class="built_in">RemoteControl</span>() &#123;</span><br><span class="line">        OnCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">        OffCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">        undoCommand = <span class="keyword">new</span> <span class="built_in">noCommand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为按钮绑定对应的命令对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommand</span><span class="params">(Command* on, Command* off)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> OnCommand;</span><br><span class="line">        OnCommand = on;</span><br><span class="line">        <span class="keyword">delete</span> OffCommand;</span><br><span class="line">        OffCommand = off;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressOnButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OnCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        undoCommand = OnCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressOffButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OffCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        undoCommand = OffCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PressUndoButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        undoCommand-&gt;<span class="built_in">undo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以使用这个遥控器了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RemoteControl* rc = <span class="keyword">new</span> <span class="built_in">RemoteControl</span>();</span><br><span class="line">    Light* lt = <span class="keyword">new</span> <span class="built_in">light</span>();</span><br><span class="line">    Command* OnCommand = <span class="keyword">new</span> <span class="built_in">LightOnCommand</span>(lt);</span><br><span class="line">    Command* OffCommand = <span class="keyword">new</span> <span class="built_in">LightOffCommand</span>(lt);</span><br><span class="line">    </span><br><span class="line">    rc.<span class="built_in">setCommand</span>(OnCommand, OffCommand);</span><br><span class="line">    rc.<span class="built_in">PressOnButton</span>();</span><br><span class="line">    rc.<span class="built_in">PressOffButton</span>();</span><br><span class="line">    rc.<span class="built_in">PressUndoButton</span>();</span><br><span class="line">    <span class="comment">// delete ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来遥控器不需要知道命令的执行者是谁，只要为按钮绑定好对应的命令对象，然后发出命令，命令对象就会让对应的命令执行者执行对应的动作。同时，遥控器、命令和电器这三者之间是组合的关系，组合意味着可以随意替换，也就是说遥控器可以更换不同的命令对象，而命令对象同样可以更换不同的电器，只要这个电器符合该命令的接口就可以，比如客厅的电灯和卧室的电灯就可以分别绑定到两个不同的 <code>LightXXXCommand</code> 对象上，而无需重新编码。</p><p>命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象。命令模式的类图如下所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/05/20230305-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/image-20230305134334949.png" alt="image-20230305134334949"></p><p>当然，具体命令对象的实现非常灵活，命令要实现什么功能完全取决于 <code>execute()</code> 方法的实现，比如要打开电视，同时将电视的音量设定为 10，那么命令对象可以设计成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TVOnCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TV* tv;</span><br><span class="line">    <span class="built_in">TVOnCommand</span>(TV* t) : <span class="built_in">tv</span>(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv-&gt;<span class="built_in">on</span>();</span><br><span class="line">        tv-&gt;<span class="built_in">setVolume</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv-&gt;<span class="built_in">off</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，命令对象还可以实现复合命令，来执行一系列命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MacroCommand</span> : <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;Command*&gt; commands;</span><br><span class="line">    <span class="built_in">MacroCommand</span>(<span class="type">const</span> vector&lt;Command*&gt;&amp; cs) : <span class="built_in">commands</span>(cs) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : commands) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">undo</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命令模式应用非常广泛，比如可以实现命令队列，让多个线程从队列中获取命令对象并执行，这样一来线程无需知道命令执行的具体对象是谁，只要调用命令对象的执行方法即可；再比如软件中的执行日志，可以将软件运行时执行过的命令对象序列化到磁盘上，在软件异常中断恢复数据时，只需要按顺序再从磁盘读取该对象并执行命令就可以恢复到中断前的状态了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了命令模式及相关的面向对象设计原则。命令模式将请求封装成对象，以便使用不同的请求来参数化其他对象，从而实现请求发出者和请求执行者之间的解耦。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】单例模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-04T09:08:43.000Z</published>
    <updated>2023-03-04T09:15:34.836Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了单例模式及相关的面向对象设计原则。单例模式保证一个类仅有一个实例，并提供一个该实例的全局访问点。重点在于如何实现线程安全的单例模式。</p><p><em><span id="more"></span></em></p><h3 id="1-经典单例模式"><a href="#1-经典单例模式" class="headerlink" title="1 经典单例模式"></a>1 经典单例模式</h3><p>许多时候，我们程序中的某些对象只需要一个或者只能存在一个，比如线程池、缓存、硬件的驱动等，如果存在多个实例就会造成逻辑错误或程序异常。因此作为类的设计者，就需要保证这个类在程序中只能存在一个实例对象。</p><p>显然，利用全局静态变量似乎就可以做到，但是全局静态变量并不完美。比如我们需要唯一的一个全局静态对象，那么这个全局对象在程序一开始就会被分配内存，如果后续并没有使用到这个全局对象，就造成了资源的浪费。而使用单例模式，可以随时在需要时才创建这个唯一的对象，并保证不会出现第二个对象。</p><p>经典的单例模式实现非常简单，在类中设定一个该类的静态对象成员，将构造函数设置为 private，然后提供一个静态的 <code>getInstance()</code>方法来获取全局唯一的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="comment">// 防止外部构造、析构、拷贝和移动</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><h3 id="2-线程安全的单例模式"><a href="#2-线程安全的单例模式" class="headerlink" title="2 线程安全的单例模式"></a>2 线程安全的单例模式</h3><p>上面的经典实现在多线程的情况下会出现问题，有可能创建出两个实例对象，例如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230304162841491.png" alt="image-20230304162841491"></p><p>因此上述实现不是线程安全的。要实现线程安全的单例模式有多种方法。</p><h4 id="2-1-DCLP"><a href="#2-1-DCLP" class="headerlink" title="2.1 DCLP"></a>2.1 DCLP</h4><p>一种经典的方法是 Double-Checked Locking Pattern (DCLP)，在构造对象时使用互斥锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// DCLP</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(uniqueInstance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure><p>但 DCLP 也不是绝对安全的，问题出在<code>uniqueInstance = new Singleton()</code>这一句上，我们知道 C++ 中 <code>new</code> 一个对象实际上进行了三次操作：</p><ul><li>首先调用 <code>operator new</code> 申请一块内存</li><li>然后调用构造函数在该内存上构造对象</li><li>最后将该内存地址赋值给指针</li></ul><p>但由于编译器优化的原因，C++ 编译器可能会在构造函数不抛出异常的前提下调整语句的执行顺序，也就是上面的三步可能变成：</p><ul><li>首先调用 <code>operator new</code> 申请一块内存</li><li>然后将该内存地址赋值给指针</li><li>最后调用构造函数在该内存上构造对象</li></ul><p>在单线程的情况下，这样的顺序变化不会影响程序的结果，但在多线程情况下就不一定了，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230304164102931.png" alt="image-20230304164102931"></p><p>这种情况下，线程 A 恰好完成内存申请，并且将内存地址赋给指针，但是还没有调用构造函数，此时线程 B 执行到指针判断，判断指针不为空，于是返回该对象指针，然后调用该对象的函数，但是这时该对象还没有进行构造，就产生了错误。</p><p>DCLP 产生该问题的关键在于 <code>new</code> 的操作不是原子的，虽然使用互斥锁对指针的写操作<code>uniqueInstance = new Singleton()</code>加了锁，但没有对之前的读操作<code>if(uniqueInstance == nullptr) </code>加锁，从而产生了线程不安全问题。</p><p>因此一种解决方案是利用原子变量<code>std::atomic</code>将对象指针变为原子类型，并使用<code>std::memory_order_acquire</code>和<code>std::memory_order_release</code>强制对该指针的内存操作顺序不变，从而避免线程不安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;Singleton*&gt; uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保证内存命令的顺序不会被重排</span></span><br><span class="line">        Singleton* ins = uniqueInstance.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            ins = uniqueInstance.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">            <span class="keyword">if</span>(ins == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ins = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">                uniqueInstance.<span class="built_in">store</span>(ins, std::memory_order_release);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> std::atomic&lt;Singleton*&gt; Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::mutex Singleton::m_mutex;</span><br></pre></td></tr></table></figure><h4 id="2-2-call-once"><a href="#2-2-call-once" class="headerlink" title="2.2 call_once"></a>2.2 call_once</h4><p>除了 DCLP 之外，还有一种更简单的实现线程安全的单例模式的方法，利用 C++ 的 <code>std::call_once()</code> 来实现，<code>std::call_once()</code> 可以保证函数只被线程安全的调用一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">    <span class="type">static</span> std::once_flag m_flag;<span class="comment">// 函数调用标识</span></span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(m_flag, createInstance);</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态对象初始化</span></span><br><span class="line"><span class="type">static</span> Singleton* Singleton::uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">static</span> std::once_flag Singleton::m_flag;</span><br></pre></td></tr></table></figure><h4 id="2-3-Meyers-单例模型"><a href="#2-3-Meyers-单例模型" class="headerlink" title="2.3 Meyers 单例模型"></a>2.3 Meyers 单例模型</h4><p>最后还有一种最为简单的实现，利用 C++ 的局部静态变量机制，C++ 的局部静态变量在第一次被调用时进行初始化，且保证只初始化一次，因此可以直接在 <code>getInstance()</code> 方法中初始化一个局部静态对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 防止外部构造、析构和拷贝</span></span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(Singleton &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 全局的对象访问接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton* uniqueInstance;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局的对象删除接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance) &#123;</span><br><span class="line">            <span class="keyword">delete</span> uniqueInstance;</span><br><span class="line">            uniqueInstance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了单例模式及相关的面向对象设计原则。单例模式保证一个类仅有一个实例，并提供一个该实例的全局访问点。重点在于如何实现线程安全的单例模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】工厂模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-04T07:35:34.000Z</published>
    <updated>2023-03-05T06:08:10.623Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了工厂模式及相关的面向对象设计原则。工厂模式分为工厂方法（Factory Method）和抽象工厂（Abstract Factory）两类：</p><ul><li>工厂方法定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法使得一个类的实例化延迟到子类。</li><li>抽象工厂提供了一个接口，让该接口负责创建一系列相关或者相互依赖的对象，而无需在主程序中指定它们具体的类型。</li></ul><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>假设有一个披萨店，整个披萨店的工作流程可以表示为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza* pizza = <span class="keyword">new</span> <span class="built_in">Pizza</span>();</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要更多类型的披萨的时候，就需要加上一些判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">    Pizza* pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们之后想要去掉或加上某些类型的披萨时，就需要不断地删改上面的代码，因为我们违背了前面提到过的一些设计原则：应该把代码中需要变化的部分封装起来。</p><p>于是我们将创建披萨对象的代码提取出来，放到一个单独的对象中，这个对象称之为“工厂”，因为它只负责生成披萨对象，而<code>orderPizza()</code>方法就不需要再关注披萨对象的具体类型了，它只知道会从工厂拿到一个披萨，然后对披萨进行处理即可。于是工厂类的定义可能像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后<code>orderPizza()</code>方法就变得非常简洁，并且与具体的披萨类型解耦开来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">    PizzaFactory* factory = <span class="keyword">new</span> <span class="built_in">PizzaFactory</span>();</span><br><span class="line">    Pizza* pizza;</span><br><span class="line">    pizza = factory-&gt;<span class="built_in">createPizza</span>(type);</span><br><span class="line">    </span><br><span class="line">    pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">    pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种常见的代码优化思路，但还称不上是设计模式，因为这更像是一种好的编程习惯，这种方法被称为简单工厂。</p><p>当我们要在不同地区开连锁店时，虽然我们希望所有店都使用相同的流程，但是不同地区的披萨风味可能有所不同，因此不同店的披萨类型也有所不同，此时如果使用简单工厂，我们需要为不同地区编写各自的工厂类，然后在<code>orderPizza()</code>方法中判断当前所处哪一个地区，再实例化对应的工厂，生产对应的披萨。这样一来又回到了一开始的问题，因此简单工厂并不足够灵活。</p><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><p>解决上述问题的方法是我们可以设计一个披萨店的抽象类<code>PizzaStore</code>，那么<code>orderPizza()</code>自然是该类中的一个方法，同时该类“抽象”的地方在于拥有一个创建披萨的纯虚函数<code>createPizza(string&amp; type)</code>，所有不同地区的连锁店都是对该抽象类的一个具体实现，都拥有自己的创建披萨方法，也就是说，这个纯虚函数是一个<strong>工厂方法</strong>，负责生成不同类型的披萨对象，而所有类的<code>orderPizza()</code>方法都无需关注披萨对象的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        pizza = <span class="built_in">createPizza</span>(type);</span><br><span class="line">    </span><br><span class="line">        pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纽约的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 创建其它类型的披萨</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的好处在于，使用了工厂方法负责对象的创建，并且把具体的创建行为封装在子类中，只要顾客决定了到哪家分店吃披萨，就决定了将会创建哪些披萨对象，也就是把具体对象的创建延迟到了子类中去决定，而客户代码中统一调用披萨店的<code>orderPizza()</code>方法即可，这样一来无论是新开分店，还是某个分店改变了披萨类型，都不会对客户代码产生任何影响，这就是解耦。另一个潜在的好处是继承关系使得每一家分店还可以自己定义披萨的制作流程，而无需局限在基类<code>orderPizza()</code>方法所定义的流程框架中。</p><p>上面的披萨店是披萨的“创建者”，那么自然还需要有被创建的“产品”披萨，披萨类的设计很简单：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304141104864.png" alt="image-20230304141104864"></p><p>于是工厂方法模式的类图一目了然：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304141227114.png" alt="image-20230304141227114"></p><p>工厂方法模式定义了一个创建对象的接口，但由子类来实现该接口，从而决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类。需要注意的是，这里所说的“让子类决定”并不是指子类能够在运行时做决定，而是指在实际编写创建者类时，不需要知道实际创建的产品是哪一个，选择使用了哪个子类，就决定了创建的产品是哪些。另外，工厂方法模式中，基类不必须是抽象的，我们可以定义一些默认的对象创建行为，这样即使没有具体的子类，基类本身也可以创建对象。</p><p>回到一开始，如果不使用工厂方法，而是使用一种最直观的方式来实现，可能的代码会是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pizza* <span class="title">orderPizza</span><span class="params">(string&amp; area, string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        pizza = <span class="built_in">createPizza</span>(area, type);</span><br><span class="line">    </span><br><span class="line">        pizza-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">bake</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">cut</span>();</span><br><span class="line">        pizza-&gt;<span class="built_in">box</span>();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Pizza* <span class="title">createPizza</span><span class="params">(string&amp; area, string&amp; type)</span> </span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="keyword">if</span>(area == <span class="string">&quot;NewYork&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYCheesePizza</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYGreekPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">NYPepperoinPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(area == <span class="string">&quot;Chicago&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CCheesePizza</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CGreekPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="built_in">CPepperoinPizza</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样实现的披萨店的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304143043787.png" alt="image-20230304143043787"></p><p>显然披萨店这一个类，依赖于所有的具体披萨类，当任何一个披萨的具体实现改变了，都会影响到披萨店。这是因为这样的设计使得“高层”的组件披萨店依赖了“低层”的组件披萨，违背了<strong>依赖倒置原则</strong>。</p><blockquote><p><strong>设计原则：依赖倒置原则</strong></p><p>不能让高层组依赖低层组件，也就是要让类依赖于抽象，而不是依赖于具体的其他类。</p></blockquote><p>相比之下，上面的工厂方法模式所实现的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304143134405.png" alt="image-20230304143134405"></p><p>所有披萨店只依赖于披萨基类这一个类，而披萨基类正是一个抽象类，而所有的具体披萨类也只依赖于披萨基类这一个类，因此满足了依赖倒置原则。</p><p>工厂方法模式可以解决单个对象的需求变化，但是要求创建对象的工厂方法必须参数一致。但有些情况下，我们面对的可能是更复杂的情况，当一系列互相依赖或互相作用的多个对象发生变化时，工厂方法就不能很好地解决问题了。</p><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3 抽象工厂"></a>3 抽象工厂</h3><p>继续以披萨店为例，不同地区可能会制作同一类型的披萨，但是不同地区对同样的披萨使用的原料都不同，不过制作披萨所需要的原料都是同一组，比如都需要一种面团、一种酱料和一种芝士，只是不同地区对这些原料组件都有不同的实现方式。具体来说，在任何地方制作披萨都需要使用一个原料家族，不同地方的家族中，都包含同样的成员，但这些成员的具体实现不同，比如纽约使用一种芝士，而芝加哥使用另一种芝士。</p><p>于是我们需要创建一些原料工厂来负责生产不同的原料家族，但它们都需要继承自同一个抽象基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原料工厂抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IngredientFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纽约的原料工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkIngredientFactory</span> : <span class="keyword">public</span> IngredientFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYSauce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NYCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的原料工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoIngredientFactory</span> : <span class="keyword">public</span> IngredientFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dough* <span class="title">createDough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sauce* <span class="title">createSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CSauce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Cheese* <span class="title">createCheese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以在披萨类中加入这些原料：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dough* dough;</span><br><span class="line">    Sauce* sauce;</span><br><span class="line">    Cheese* cheese;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而所有的具体披萨类型都要和原料工厂绑定，从而使用该工厂的原料制作披萨：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CheesePizza</span> : <span class="keyword">public</span> Pizza &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IngredientFactory* ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CheesePizza</span>(IngredientFactory* <span class="keyword">if</span>) : <span class="built_in">ingredientFactory</span>(<span class="keyword">if</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dough = ingredientFactory-&gt;<span class="built_in">createDough</span>();</span><br><span class="line">        sauce = ingredientFactory-&gt;<span class="built_in">createSauce</span>();</span><br><span class="line">        cheese = ingredientFactory-&gt;<span class="built_in">createCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在披萨店中制作披萨的时候就需要选择一个原料工厂来创建披萨：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纽约的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewYorkPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 使用纽约原料工厂的原料</span></span><br><span class="line">        IngredientFactory* ingredientFactory = <span class="keyword">new</span> <span class="built_in">NewYorkIngredientFactory</span>();</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="string">&quot;cheese&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">CheesePizza</span>(ingredientFactory);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;greek&quot;</span>) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">GreekPizza</span>(ingredientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;pepperoin&quot;</span>)&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="built_in">PepperoinPizza</span>(ingredientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 芝加哥的分店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> : <span class="keyword">public</span> PizzaStore &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pizza* <span class="title">createPizza</span><span class="params">(string&amp; type)</span></span>&#123;</span><br><span class="line">        Pizza* pizza;</span><br><span class="line">        <span class="comment">// 使用芝加哥原料工厂的原料</span></span><br><span class="line">        IngredientFactory* ingredientFactory = <span class="keyword">new</span> <span class="built_in">ChicagoIngredientFactory</span>();</span><br><span class="line">        <span class="comment">// 创建其它类型的披萨</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的整个过程我们创建了一个抽象的原料工厂，用来创造原料家族，而原料家族就是由一系列相互关联、相互依赖的对象构成的，这些对象都有可能发生变化，但通过抽象工厂，我们把这种变化约束在了具体的工厂当中，而不会影响代码的其他部分。此外，还可以通过替换不同的工厂使得同一类对象产生不同的行为，比如我们可以将披萨类中的原料工厂替换成其他的原料工厂，从而实现通过组合来创建不同的披萨对象的功能。</p><p>抽象工厂模式定义了一个接口，用于创建一系列相关或依赖的对象，而不需要明确指定他们的具体类型。抽象工厂允许客户代码使用一个抽象的接口来创建一系列产品，而不需要关注产生的具体产品是什么，这样一来客户和产品就被解耦开来。抽象工厂的类图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/04/20230304-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/image-20230304151212414.png" alt="image-20230304151212414"></p><p>在上面的例子中，各种原料就是一系列相关的产品，原料工厂是负责生成这一系列产品的抽象工厂，而披萨店则是原料工厂的客户。在披萨店的代码中我们不需要关注原料具体是哪些，只负责制作披萨就可以了。</p><h3 id="4-总结与对比"><a href="#4-总结与对比" class="headerlink" title="4 总结与对比"></a>4 总结与对比</h3><p>两种工厂模式的异同总结如下：</p><ul><li>工厂方法用于应对“单个对象”的需求变化，而抽象工厂用于应对“一个系列”的需求变化。</li><li>工厂方法通过继承来实现，把对象创建委托给子类，子类实现工厂方法来创建对象；而抽象工厂通过对象组合来实现，对象的创建被实现在抽象工厂所声明的方法中。</li><li>所有工厂模式都是通过减少客户程序（主程序）和具体类之间的依赖来实现松耦合的。</li><li>所用工厂模式都遵循依赖倒置原则，指导我们要避免依赖具体类，而要尽量依赖抽象。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了工厂模式及相关的面向对象设计原则。工厂模式分为工厂方法（Factory Method）和抽象工厂（Abstract Factory）两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工厂方法定义了一个用于创建对象的接口，让子类决定实例化哪一个类。 工厂方法使得一个类的实例化延迟到子类。&lt;/li&gt;
&lt;li&gt;抽象工厂提供了一个接口，让该接口负责创建一系列相关或者相互依赖的对象，而无需在主程序中指定它们具体的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】装饰者模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-02T09:18:17.000Z</published>
    <updated>2023-03-02T09:19:42.691Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了装饰者模式及相关的面向对象设计原则。装饰者模式动态的将责任附加到对象身上，扩展功能时，装饰者模式相比于继承能为系统带来更好的弹性。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>一个咖啡饮料系统需要为所有类型的饮料定义各自的类，最原始的设计是这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302164118582.png" alt="image-20230302164118582"></p><p>在购买饮料时，顾客可以在某种饮料的基础上加入各种调料，比如奶泡、摩卡等，不同调料的价格也不同，组合而成的饮料价格也就不同，不同的调料搭配不同的饮料可能会出现无数种组合，如果一味的使用继承，将会使饮料子类的数量急剧膨胀，难以管理的同时还会出现大量的重复代码。因此我们希望能有一种设计模式来解决这种问题。</p><h3 id="2-装饰者模式"><a href="#2-装饰者模式" class="headerlink" title="2 装饰者模式"></a>2 装饰者模式</h3><blockquote><p><strong>设计原则：开放-关闭原则，对扩展开放，对修改关闭。</strong></p></blockquote><p>开放-关闭原则是指当一个类设计好之后，尽可能不对他进行修改，但又能允许该类进行扩展，也就是在不修改现有代码的前提下，扩展新的行为。装饰者模式就实现了这一目的。</p><p>以一杯加了奶泡和摩卡的深焙咖啡为例，构建这样一种饮品的流程是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165122699.png" alt="image-20230302165122699"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165135782.png" alt="image-20230302165135782"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165152185.png" alt="image-20230302165152185"></p><p>这就是一个装饰者模式的流程，装饰者模式的类图结构如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302165414471.png" alt="image-20230302165414471"></p><p>按着上面的类图，饮料就作为组件，具体的饮料类型对应于具体组件，而调料作为装饰器，具体的调料对应不同的具体装饰器，于是我们可以开始用装饰者模式实现上面的饮料系统。</p><p>首先是组件（饮料）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 其他内容...</span></span><br><span class="line">    </span><br><span class="line">    string discription = <span class="string">&quot;Unknow Beverage&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">getDiscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discription;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>装饰器（调料）要和组件是同一类，这样才能保证所有装饰器都能代替组件，调用同一个接口，因此需要继承于组件类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 所有调料都要有自己的描述，这样才能输出完整的配料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDiscription</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来实现一个具体组件类，比如浓缩咖啡（Espresso）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> : <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Espresso</span>() &#123;</span><br><span class="line">        discription = <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个具体装饰器，比如摩卡（Mocha）类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mocha</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Component* beverage;<span class="comment">//被装饰者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mocha</span>(Component* b) : <span class="built_in">beverage</span>(b) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getDiscription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDiscription</span>() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage-&gt;<span class="built_in">cost</span>() + <span class="number">0.2</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照上面的方法可以构建不同的饮料和调料，之后就可以随意组合了，在调用的时候也会变得无比方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Component* beverage = <span class="keyword">new</span> <span class="built_in">Espresso</span>();<span class="comment">// 一杯浓缩咖啡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Mocha</span>(beverage);<span class="comment">// 加入一份摩卡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Whip</span>(beverage);<span class="comment">// 加入一份奶泡</span></span><br><span class="line">    beverage = <span class="keyword">new</span> <span class="built_in">Sugar</span>(beverage);<span class="comment">// 加入一份糖</span></span><br><span class="line">    cout &lt;&lt; beverage.<span class="built_in">getDiscription</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; beverage.<span class="built_in">cost</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，装饰者类是一个组件类，也就是和被装饰者是 is-a 的关系，但同时装饰者类中又包含组件类，对组件类进行扩展，因此二者之间还存在 has-a 的关系。装饰者模式利用组合解决了继承带来的子类膨胀和灵活性差的问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了装饰者模式及相关的面向对象设计原则。装饰者模式动态的将责任附加到对象身上，扩展功能时，装饰者模式相比于继承能为系统带来更好的弹性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】观察者模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-02T07:53:14.000Z</published>
    <updated>2023-03-02T07:54:50.456Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了观察者模式及相关的面向对象设计原则。观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>有一个气象站系统需要构建，系统中包含三部分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302131902396.png" alt="image-20230302131902396"></p><p>其中气象站负责感应气象数据，WeatherData 对象从气象站获取数据并更新气象显示装置，气象显示装置有不同的显示界面，比如目前状况、气象统计、天气预报等等，未来还可能加入新的显示界面。</p><p>一种实现方式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span>&#123;</span><br><span class="line">    <span class="comment">//其他内容...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">float</span> temp = <span class="built_in">getTemperature</span>();</span><br><span class="line">        <span class="type">float</span> humidity = <span class="built_in">getHumidity</span>();</span><br><span class="line">        <span class="type">float</span> pressure = <span class="built_in">getPressure</span>();</span><br><span class="line">        <span class="comment">// 调用各显示面板的更新函数，以更新各显示界面</span></span><br><span class="line">        currentConditionsDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">        statisticsDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">        forecastDisplay.<span class="built_in">update</span>(temp, humidity, pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然这样的实现方式违背了上一节提到的诸多设计原则，比如没有把不变和变化的代码分开，如果后续需要加入新的显示面板，就要更改 WeatherData 的代码，再比如调用面板的<code>update()</code>方法没有面向接口编程，而是一个一个的调用了具体面板的接口。因此这样的设计会为后续的系统维护带来巨大的成本。</p><h3 id="2-观察者模式"><a href="#2-观察者模式" class="headerlink" title="2 观察者模式"></a>2 观察者模式</h3><p>观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302134222869.png" alt="image-20230302134222869"></p><p>观察者模式通常通过构建 Subject 接口 Observer 接口来实现：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/03/02/20230302-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20230302134606606.png" alt="image-20230302134606606"></p><p>观察者模式提供了一种对象设计，让主题对象和观察者对象之间<strong>松耦合</strong>。所谓松耦合是指两个对象之间依然可以交互，但彼此不清楚对方的细节。松耦合的好处在于，主题对象只知道观察者实现了 Observer 接口，而无需关注观察者具体是谁，做了什么或者任何其他细节。在代码运行的任何时候都可以增加或者删除观察者，主题不会受到任何影响，它只在状态改变时，遍历观察者列表并通知他们。当我们改变主题或者观察者任意一方时，另一方都不会受到任何影响，只要它们之间的接口依然被遵守。因此使用松耦合设计系统会更有的弹性，更容易应对变化，因为对象之间的互相依赖降到了最低。</p><blockquote><p><strong>设计原则：为了交互对象之间的松耦合而努力。</strong></p></blockquote><p>回顾上面的气象站项目，显然 WeatherData 对象就是主题，主题在实现的时候通常也被称为 Observable（可观察对象），也就是被观察者，而不同的显示面板就是观察者。</p><p>于是我们首先需要实现两个接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现 WeatherData 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> : <span class="keyword">public</span> Observable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    <span class="type">float</span> humidity;</span><br><span class="line">    <span class="type">float</span> pressure;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">remove</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::list&lt;Observer*&gt;::iterator it = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (it != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            (*it)-&gt;<span class="built_in">update</span>(temperature, humidity, pressure);</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">notifyObservers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>某个观察者显示面板的实现更为简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> : <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    <span class="type">float</span> humidity;</span><br><span class="line">    Observable* weatherData;<span class="comment">//绑定一个被观察者，用于注册或者取消观察</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CurrentConditionsDisplay</span>(Observable* o) : <span class="built_in">weatherData</span>(o) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">        <span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 显示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个简单的观察者模式就是实现完毕了，这是经典的观察者模式实现，但存在一些缺陷：</p><ul><li>需要继承，继承是强对象关系，只能对特定的观察者才有效，即必须是Observer抽象类的派生类才行</li><li>观察者被通知的接口参数不支持变化，导致观察者不能应付接口的变化，并且这个观察者还不能带参数</li></ul><h3 id="3-改进的观察者模式"><a href="#3-改进的观察者模式" class="headerlink" title="3 改进的观察者模式"></a>3 改进的观察者模式</h3><p>C++11 提供的仿函数和模板等特性可以解决上述问题。C++11 实现的观察者模式，内部维护了一个泛型函数列表，观察者只需要将观察者函数注册进来即可，消除了继承导致的强耦合。通知接口还使用了可变参数模板，支持任意数量的参数，消除了接口变化的影响。</p><p>改进之后的观察者模式和 C# 中的 event 类似，通过定义观察者的模板类型来限定观察者，即不要求观察者必须为某个派生类，只要求所有观察者使用相同的函数模板即可，当需要和原来不同的观察者时，只需要定义一个新的 event 类型即可。</p><p>需要注意的是 event 对象不能拷贝和复制，这可以通过 delete 关键字来实现。</p><p>一个改进的观察者模式实现如下：</p><p><strong>observer.hpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _OBSERVER_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OBSERVER_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//禁用复制构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>(<span class="type">const</span> NonCopyable&amp; n) = <span class="keyword">delete</span>; <span class="comment">// deleted</span></span><br><span class="line">    <span class="comment">//禁用赋值构造函数</span></span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyable&amp; n) = <span class="keyword">delete</span>; <span class="comment">// deleted</span></span><br><span class="line">    <span class="built_in">NonCopyable</span>() = <span class="keyword">default</span>; <span class="comment">// available</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Events</span> : <span class="keyword">public</span> NonCopyable &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_observerId = <span class="number">0</span>; <span class="comment">//观察者对应编号</span></span><br><span class="line">    map&lt;<span class="type">int</span>, Func&gt; m_connections; <span class="comment">// 观察者列表</span></span><br><span class="line">    <span class="comment">// 保存观察者并分配观察者编号</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Assign</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = m_observerId++;</span><br><span class="line">        m_connections.<span class="built_in">emplace</span>(k, std::forward&lt;F&gt;(f));</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册观察者，支持右值引用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(Func&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Assign</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者，左值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> Func&amp; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Assign</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Disconnect</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        m_connections.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : m_connections) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; func = it.second;</span><br><span class="line">            <span class="built_in">func</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;observer.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> ObserverFunc = std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Observer函数对象的事件2被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> res = a + b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">observerFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Observer2成员函数事件3被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> res = a + b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gobserverFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局的gobserverFunc事件4被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> res = a + b;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Events&lt;ObserverFunc&gt; e;</span><br><span class="line">    <span class="comment">// 调用基于lambda表达式的观察者函数</span></span><br><span class="line">    <span class="type">int</span> lambdaID = e.<span class="built_in">Connect</span>([](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="type">int</span> res = a+b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lambda函数的事件1被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用仿函数的观察者函数</span></span><br><span class="line">    <span class="type">int</span> obsID = e.<span class="built_in">Connect</span>(<span class="built_in">Observer</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用成员函数的观察者函数</span></span><br><span class="line">    Observer2 o2;</span><br><span class="line">    <span class="type">int</span> obsID1 = e.<span class="built_in">Connect</span>(std::<span class="built_in">bind</span>(&amp;Observer2::observerFunc, o2, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用全局观察者函数</span></span><br><span class="line">    <span class="type">int</span> gID4 = e.<span class="built_in">Connect</span>(gobserverFunc);</span><br><span class="line"> </span><br><span class="line">    e.<span class="built_in">Notify</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了观察者模式及相关的面向对象设计原则。观察者模式定义了对象之间的一对多依赖，当一个对象的状态改变时，他的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】策略模式</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-02-28T07:46:59.000Z</published>
    <updated>2023-02-28T07:49:42.551Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍了策略模式及相关的面向对象设计原则。策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。</p><p><em><span id="more"></span></em></p><h3 id="1-引例"><a href="#1-引例" class="headerlink" title="1 引例"></a>1 引例</h3><p>鸭子模拟游戏中会出现各种鸭子，一边游泳，一边呱呱叫，此系统内部使用了标准的面向对象技术，设计了一个鸭子父类，并让各种鸭子继承此父类。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141328616.png" alt="image-20230228141328616"></p><p>此时如果希望鸭子能飞起来，最简单的方法就是在父类中加上一个<code>fly()</code>方法：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141532173.png" alt="image-20230228141532173"></p><p>但并不是所有鸭子都会飞，于是想到可以在子类中重写<code>fly()</code>方法，让其什么也不做，从而覆盖掉父类的<code>fly()</code>方法。同样，也是不所有鸭子都会嘎嘎叫，比如橡皮鸭子是吱吱叫，同样可以通过重写<code>quack()</code>方法覆盖掉父类的方法来实现。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228141813782.png" alt="image-20230228141813782"></p><p>之后，如果我们想新加入一个木头假鸭类型，它既不会飞也不会叫，那么用同样的方式覆盖父类对应的方法就可以实现。但是当我们需要不断地新增不同类型的鸭子，或者不断地修改不同类型鸭子的行为时，就需要不停的新建子类，重写并覆盖原来的方法，显然这样的实现方式使得我们虽然利用了面向对象的“继承”这一特性，但却并没有实现代码的复用。</p><p>转变思路，我们可以将<code>fly()</code>方法从鸭子类中分离出来，放进一个<code>Flyable</code>的接口（抽象类）中，只有会飞的鸭子才继承此抽象类，并实现其中的<code>fly()</code>方法，<code>quack()</code>方法同样分离出来放在<code>Quackable</code>的抽象类中，只有会叫的鸭子才继承此抽象类并实现其中的<code>quack()</code>方法。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2023/02/28/20230228-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/image-20230228142529567.png" alt="image-20230228142529567"></p><p>这样的设计看似更加巧妙，但重复的代码会变得更多，且代码依然无法复用，我们要为每一个会叫的鸭子写一套<code>quack()</code>代码，即使他们叫的方式是相同的。</p><p>对于上面这个例子，似乎继承和接口都不能很好的解决问题，而恰好有一个设计模式，可以适用于这种情况。</p><h3 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2 策略模式"></a>2 策略模式</h3><blockquote><p><strong>设计原则：将变化的部分单独封装起来</strong></p><p>找出程序中可能需要变化的地方，把他们独立出来并进行封装，使他们和那些不会变化的代码分开，以便之后可以轻易的修改或扩充这一部分代码，而不影响那些不需要变化的部分。</p></blockquote><p>对于上面的例子，显然<code>fly()</code>和<code>quack()</code>就是代码中需要变化的部分，因为他们会随着不同的鸭子类型或者不同的用户需求随时发生变化，所以我们可以将他们从鸭子类中独立出来，分别建立两个抽象类<code>FlyBehavior</code>和<code>QuackBehavior</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyBehavior</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个抽象类代表飞和叫这两种行为，至于怎么飞，怎么叫，通过具体的行为类继承于这两个抽象类来实现，比如飞的行为可以分为用翅膀飞和不会飞这两种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyWithWings</span> : <span class="keyword">public</span> FlyBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;用翅膀飞&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyNoWay</span> : <span class="keyword">public</span> FlyBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不会飞&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>叫的行为也类似，比如可以实现嘎嘎叫和不会叫：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quack</span> : <span class="keyword">public</span> QuackBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;嘎嘎叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MuteQuack</span> : <span class="keyword">public</span> QuackBehavior &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不会叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后我们在鸭子类中加入这两种行为类的对象，然后将原本的<code>fly()</code>和<code>quack()</code>方法改为<code>PerformFly()</code>和<code>PerformQuack()</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FlyBehavior* flyBehavior;</span><br><span class="line">    QuackBehavior* quackBehavior;</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior-&gt;<span class="built_in">fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quackBehavior-&gt;<span class="built_in">quack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要构造一个鸭子子类的时候，只需要继承鸭子父类，并在构造函数中指定该子类的具体行为对象，就可以控制鸭子子类的行为了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MallardDuck</span> : <span class="keyword">public</span> Duck&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MallardDuck</span>()&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> <span class="built_in">FlyWithWings</span>();<span class="comment">// 绿头鸭会用翅膀飞</span></span><br><span class="line">        quackBehavior = <span class="keyword">new</span> <span class="built_in">Quack</span>();<span class="comment">// 绿头鸭会嘎嘎叫</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用上面的设计方法可以让我们在编程时不需要关注鸭子是什么具体类型，因为我们可以利用多态，比如有一个<code>getDuck()</code>函数会返回一个具体类型的鸭子，至于是什么类型，可能在程序运行时才能确定，那么我们的主函数就可以这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Duck* duck = <span class="built_in">getDuck</span>();</span><br><span class="line">    duck-&gt;<span class="built_in">PerformFly</span>();</span><br><span class="line">    duck-&gt;<span class="built_in">PerformQuack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面的设计依然不够有弹性，因为每一个子类的鸭子具有什么行为是在构造函数中指定的，如果我们希望同一类鸭子也能自由的设定不同的行为，那么只需要在鸭子父类中加上一个设定行为的方法就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FlyBehavior* flyBehavior;</span><br><span class="line">    QuackBehavior* quackBehavior;</span><br><span class="line">    <span class="comment">//其他成员</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flyBehavior-&gt;<span class="built_in">fly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quackBehavior-&gt;<span class="built_in">quack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态设定行为</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFlyBehavior</span><span class="params">(FlyBehavior* fb)</span></span>&#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetQuackBehavior</span><span class="params">(QuackBehavior* qb)</span></span>&#123;</span><br><span class="line">        quackBehavior = qb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们通过调用鸭子的<code>SetFlyBehavior()</code>和<code>SetQuackBehavior()</code>方法就可以随时改变鸭子的行为了。</p><p>纵观上面的设计过程，我们把鸭子类中经常变化的部分独立出来，封装成了单独的抽象类，也就是一个接口，然后用不同的代码去实现这个接口（抽象类的子类），这些不同的代码就是“一族算法”，而在鸭子类中，只要包含这一族算法的统一接口就可以灵活地使用他们当中的任何一个。</p><blockquote><p><strong>设计原则：面向接口编程，而不是面向实现编程。</strong></p></blockquote><p>能够实现这样灵活的效果的原因在于，所有鸭子的行为并不是从父类继承而来的，而是与不同的行为对象组合而来的，因此恰当的使用类的组合有时要比一味的使用类的继承灵活的多。而进行组合的类也不一定是行为，也可以是物品、属性等等，比如游戏中不同的角色有不同的武器，那么一个角色就可以由角色类和武器类组合而来。</p><blockquote><p><strong>设计原则：多用组合，少用继承。</strong></p></blockquote><p>利用组合构建系统具有很大的弹性，不仅可以将一族算法封装成类，还可以在运行时动态的改变类对象的行为或属性，只要组合的类符合接口标准即可。因此在面向对象程序设计中，简单的使用继承和多态不一定能降低代码量和代码维护成本，灵活使用类的组合也可以达到代码复用的目的。</p><p>上面的设计还有一个好处就是，每一族算法或者其中的每一个算法都可以有自己的成员，比如算法要用到的参数，状态和其他辅助函数等等，只要最终实现了接口就可以，这可以让算法的设计更加灵活。</p><p><strong>上面的设计模式就是策略模式，策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇介绍了策略模式及相关的面向对象设计原则。策略模式定义了一族算法，将它们分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】遮挡剔除总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-07T01:51:11.000Z</published>
    <updated>2022-08-07T02:31:33.777Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对常见的遮挡剔除技术进行总结概括，主要包括：</p><ul><li>Precomputed Visibility</li><li>Portal-Culling</li><li>Software Occlusion</li><li>Occlusion Query</li><li>Hierarchical Z-Buffer</li></ul><p><em><span id="more"></span></em></p><h3 id="1-Precomputed-Visibility"><a href="#1-Precomputed-Visibility" class="headerlink" title="1 Precomputed Visibility"></a>1 Precomputed Visibility</h3><p>预计算可见性是比较简单的遮挡剔除方案，UE 中内置了这一方法。官方文档：<a href="https://docs.unrealengine.com/4.26/zh-CN/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/">预计算可视性体积 | 虚幻引擎文档 (unrealengine.com)</a></p><p>其基本思路是就是先将场景划分成一个个 Cell，让后对于每个 Cell 区域，预计算出摄影机在这个 Cell 范围内时，所有可能看到的物体，并将可见信息保存下来。这样在运行时就可以直接查表来得到所有静态物体的可见信息，运行时开销几乎为 0。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/PVis_VisualizationEnabled.png" alt="PVis_VisualizationEnabled"></p><p>当然这种方式的缺点也很明显，完全无法剔除动态物体，并且静态物体可见性全部都是不可变的。并且对于比较自由的大型场景，计算量和存储量都非常大，因此只适用于线性流程关卡等相机移动范围有限的场景中。</p><p>如果我们想要实现对动态物体的剔除，可以对该算法进行改进：在每个 Cell 中，同时保存其他 Cell 的可见性。对于小型的动态物体，我们先计算出动态物体所在的 Cell 坐标，然后根据 Cell 之间的可见性信息，判断可见性。这样做会额外消耗内存，如果动态的小型物体较多时，可以考虑配合使用。</p><h3 id="2-Portal-Culling"><a href="#2-Portal-Culling" class="headerlink" title="2 Portal-Culling"></a>2 Portal-Culling</h3><p>这种方式也是将场景划分成 Cell，不同的是，烘焙时保存的是每两个相邻 Cell 之间的连通性。这样，在运行时，根据摄影机所在的位置的 Cell 和观察方向，就可以根据 Cell 间的连通性信息，快速计算出目标物体是否处于可见范围内。</p><p>相对上面完全的预计算，这种方式的优点就是可以剔除动态物体，同时提供了些许的静态遮挡物体变化的灵活性。比如有扇可以开关的门，当门被打开后，就可以将门两侧的 Cell 的连通打开。Unity 自带的遮挡剔除使用这种方案。</p><h3 id="3-Software-Occlusion"><a href="#3-Software-Occlusion" class="headerlink" title="3 Software Occlusion"></a>3 Software Occlusion</h3><p>软光栅遮挡查询是 UE 中面向移动端的一种遮挡查询方案，官方文档：<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/VisibilityCulling/SoftwareOcclusionQueries/">面向移动平台的软件遮挡查询 | 虚幻引擎文档 (unrealengine.com)</a></p><p>这种方式需要手动标记好大型的用来遮挡的物体，在运行时，将遮挡物的包围盒（或最高 LOD 级别的模型）软光栅到 CPU 内存中的 z-buffer 上，然后根据 z-buffer 中的深度信息，根据需要剔除物体的包围盒，实时计算遮挡信息。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/soq_sceneOccludersHighlighted.png" alt="soq_sceneOccludersHighlighted"></p><p>这种方式缺点是对 CPU 端压力很大，优点是相对前面两种方案，软光栅剔除提供了非常大的灵活性，支持完全可变或任意大小的场景，适用于流式关卡或者大世界中的遮挡剔除。并且相对 GPU 实现的遮挡剔除，这种方案完全不用担心硬件兼容问题。但是由于 CPU 的软光栅计算压力非常大，因此我们需要注意，不能在光栅化时计算太多的物体，不能使用精细的模型计算。</p><h3 id="4-Occlusion-Query"><a href="#4-Occlusion-Query" class="headerlink" title="4 Occlusion Query"></a>4 Occlusion Query</h3><p>硬件遮挡查询利用 GPU 进行遮挡剔除，其思想也非常简单，首先使用一个简单的 depth-only 的 pass 将深度写入到 z-buffer 中，然后使用物体的包围盒传入到 GPU 进行遮挡测试，也就是判断深度，如果测试发现所有像素都被遮挡，说明这个物体是被遮挡的物体，否则的话认为是可见的。</p><p>由于从 GPU 回读数据到 CPU 通常很慢，因此通常会将得到的数据放在下一帧中作为剔除数据来使用，这样遮挡剔除其实是延迟一帧（移动端延迟两帧）生效的。不过一般来说，延迟一帧的剔除对实际的渲染影响并不大。</p><p>几乎所有的图形 API 都提供硬件遮挡查询，UE 默认也采用这种方式进行遮挡剔除。</p><p>当然硬件遮挡查询也存在一定的问题，比如：</p><ul><li>虽然基于 GPU 的判断效率高，但涉及数据传输，在大规模场景下会造成 CPU 一直等待 GPU 查询结果返回造成 GPU 性能饥饿的情况</li><li>虽然基于 GPU 判断效率高，不过在复杂场景下仍有大量渲染目标需要被测试，仍有提升空间</li></ul><p>因此有人提出了改进的 <strong>Coherent Occlusion Culling（CHC）</strong> 算法，其核心思想是：</p><ul><li>利用 BVH（Bounding Volume Hirachical）管理场景，并利用 Spatial Coherence（空间相关性）减少每一帧需要进行遮挡查询的次数。</li><li>重用上一帧的查询结果，利用 Time Coherence（时间相关性）进一步减少查询次数。</li><li>维护一个查询队列，延迟进行查询的时间，并利用渲染部分场景的时间来填充 CPU 等待 GPU 查询结果返回的时间，减少 GPU 的饥饿。</li></ul><p>具体可以查看<a href="https://zhuanlan.zhihu.com/p/35067260">Coherent Occlusion Culling(CHC)算法的原理与实现</a>一文。</p><h3 id="5-Hierarchical-Z-Buffer"><a href="#5-Hierarchical-Z-Buffer" class="headerlink" title="5 Hierarchical Z-Buffer"></a>5 Hierarchical Z-Buffer</h3><p>HZB 是多 Mip 层级的 z-buffer，每个更高级别 Mip 的 buffer 记录上一级别中周围四点中最远处的深度值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/image-20220807102055112.png" alt="image-20220807102055112"></p><p>将 HZB 生成后，就可以将待剔除物体的包围盒信息传入到 Computer Shader 中进行计算，计算时会选择最适合的 Mip 级别进行遮挡测试。在屏幕中占比更大的物体会选择更高级别 Mip 的深度进行测试，因为更大的物体更容易被看到，就可以用更高级别的 Mip 中的深度，而不必取过于精细的深度来判断。</p><p>具体来说，要测试对象是否被遮挡，可以将其包围体投射到屏幕空间，并估计在 z-pyramid 中的 Mip 级别。将对象的包围体投影到屏幕空间。使用最长的边（像素）计算 Mip 等级：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%80%BB%E7%BB%93/image-20220807102419175.png" alt="image-20220807102419175"></p><p>然后根据选定的 Mip 测试遮挡。如果结果不明确，可以继续使用更细的 Mip 级别进行测试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对常见的遮挡剔除技术进行总结概括，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Precomputed Visibility&lt;/li&gt;
&lt;li&gt;Portal-Culling&lt;/li&gt;
&lt;li&gt;Software Occlusion&lt;/li&gt;
&lt;li&gt;Occlusion Query&lt;/li&gt;
&lt;li&gt;Hierarchical Z-Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【UE渲染体系】目录索引</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-UE%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB-%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/08/07/20220807-UE%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB-%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95/</id>
    <published>2022-08-07T01:22:40.000Z</published>
    <updated>2022-08-07T01:44:15.840Z</updated>
    
    <content type="html"><![CDATA[<p>本篇提供了博客园博主<a href="https://www.cnblogs.com/timlly/">0向往0 - 博客园 (cnblogs.com)</a>的《剖析虚幻渲染体系》系列文章的索引，便于查找学习。</p><p><em><span id="more"></span></em></p><ul><li><a href="https://www.cnblogs.com/timlly/p/13877623.html">剖析虚幻渲染体系（01）- 综述和基础 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14327537.html">剖析虚幻渲染体系（02）- 多线程渲染 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14588598.html">剖析虚幻渲染体系（03）- 渲染机制 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14732412.html">剖析虚幻渲染体系（04）- 延迟渲染管线 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14817455.html">剖析虚幻渲染体系（05）- 光源和阴影 </a></li><li><a href="https://www.cnblogs.com/timlly/p/14927797.html">剖析虚幻渲染体系（06）- UE5特辑Part 1（特性和Nanite） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15007236.html">剖析虚幻渲染体系（06）- UE5特辑Part 2（Lumen和其它） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15092257.html">剖析虚幻渲染体系（08）- Shader体系 </a></li><li><a href="https://www.cnblogs.com/timlly/p/15109132.html">剖析虚幻渲染体系（09）- 材质体系 </a></li><li><a href="https://www.cnblogs.com/timlly/p/15156626.html">剖析虚幻渲染体系（10）- RHI </a></li><li><a href="https://www.cnblogs.com/timlly/p/15217090.html">剖析虚幻渲染体系（11）- RDG </a></li><li><a href="https://www.cnblogs.com/timlly/p/15511402.html">剖析虚幻渲染体系（12）- 移动端专题Part 1（UE移动端渲染分析） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15546797.html">剖析虚幻渲染体系（12）- 移动端专题Part 2（GPU架构和机制） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15574911.html">剖析虚幻渲染体系（12）- 移动端专题Part 3（渲染优化） </a></li><li><a href="https://www.cnblogs.com/timlly/p/15680064.html">剖析虚幻渲染体系（13）- RHI补充篇：现代图形API之奥义与指南 </a></li><li><a href="https://www.cnblogs.com/timlly/p/16097134.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 1（萌芽期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16147358.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 2（成长期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16216707.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 3（开花期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16268881.html">剖析虚幻渲染体系（14）- 延展篇：现代渲染引擎演变史Part 4（结果期） </a></li><li><a href="https://www.cnblogs.com/timlly/p/16357850.html">剖析虚幻渲染体系（15）- XR专题 </a></li><li><a href="https://www.cnblogs.com/timlly/p/16404963.html">剖析虚幻渲染体系（16）- 图形驱动的秘密 </a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇提供了博客园博主&lt;a href=&quot;https://www.cnblogs.com/timlly/&quot;&gt;0向往0 - 博客园 (cnblogs.com)&lt;/a&gt;的《剖析虚幻渲染体系》系列文章的索引，便于查找学习。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="虚幻引擎渲染体系" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="虚幻引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
