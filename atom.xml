<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-04-21T09:57:36.800Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RayTracer】（十三）图片纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-21T09:53:17.000Z</published>
    <updated>2022-04-21T09:57:36.800Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。</p><p><em><span id="more"></span></em></p><h3 id="1-图片纹理类"><a href="#1-图片纹理类" class="headerlink" title="1 图片纹理类"></a>1 图片纹理类</h3><p>要实现图片纹理类，我们先要读入一张图片，这可以用到一开始存图使用的轻量而强大的 <code>stb_image</code> 库，然后我们要找到纹理坐标和图片坐标的映射关系，非常简单，对于一张 M * N 的图片上的像素 (i, j)，它的纹理坐标是：<br>$$<br>u &#x3D; \frac{i}{M-1},\ v &#x3D; \frac{j}{N-1}<br>$$<br>于是可以实现一个图片纹理类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 纹理类，包含各种纹理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;perlin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 图片纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>()</span><br><span class="line">        : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">bytes_per_scanline</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        <span class="keyword">auto</span> components_per_pixel = bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        data = <span class="built_in">stbi_load</span>(</span><br><span class="line">            filename, &amp;width, &amp;height, &amp;components_per_pixel, components_per_pixel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load texture image file &#x27;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">            width = height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_per_scanline = bytes_per_pixel * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">image_texture</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有图片的话返回一个固定的颜色，便于debug</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入的纹理坐标截断在[0,1]区间</span></span><br><span class="line">        u = <span class="built_in">clamp</span>(u, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 由于图片是从上到下存储的，相当于原点在左上角，而纹理坐标原点在左下角，因此纵坐标要翻转一下</span></span><br><span class="line">        v = <span class="number">1.0</span> - <span class="built_in">clamp</span>(v, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">        <span class="comment">// 纹理坐标映射到图片坐标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(u * width);</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(v * height);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= width)  i = width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= height) j = height - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们返回的颜色都在[0,1]之间，因此要除以255</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> pixel = data + j * bytes_per_scanline + i * bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale * pixel[<span class="number">0</span>], color_scale * pixel[<span class="number">1</span>], color_scale * pixel[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="type">int</span> bytes_per_scanline;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-测试效果"><a href="#2-测试效果" class="headerlink" title="2 测试效果"></a>2 测试效果</h3><p>新建一个场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地球</span></span><br><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string TexturePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(TexturePath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并对应修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> sence = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        world = <span class="built_in">earth</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/Earth.png" alt="Earth"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十二）Perlin噪声</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/</id>
    <published>2022-04-19T12:48:53.000Z</published>
    <updated>2022-04-19T13:01:37.621Z</updated>
    
    <content type="html"><![CDATA[<p>噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。</p><p><em><span id="more"></span></em></p><h3 id="1-Perlin-噪声原理"><a href="#1-Perlin-噪声原理" class="headerlink" title="1 Perlin 噪声原理"></a>1 Perlin 噪声原理</h3><p>Perlin 噪声的产生是由于，如果我们用完全随机的噪声，比如白噪声，生成的纹理或者效果会显得非常不自然，因为很多真实世界中看似没有规律的事物，实际上是存在一定规律的，只是看起来是杂乱无章的。因此 Perlin 噪声诞生了，Perlin 噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影、动画等多媒体领域广泛应用。在游戏领域，Perlin 噪声可以用于生成波形，起伏不平的材质或者纹理。Perlin 噪声绝大部分应用在二维，三维层面上，但某种意义上也能拓展到四维。Perlin 噪声在一维层面上可用于卷轴地形、模拟手绘线条等，在二维或三维上用于生成随机地形，火焰燃烧特效，水和云等等。如果将 Perlin 噪声拓展到四维层面，即 w 轴代表时间，就能利用 Perlin 噪声生成动画。</p><p>Perlin噪声实现需要三个步骤：</p><ul><li>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量。所谓“伪随机”是指，对于给定的输入得到的值是一样的，因此并不是真正的随机。但并不影响效果，因为只要相同的值离得足够远，就看不出来是伪随机。对于二维的 Perlin 噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</li><li>输入一个点（二维的话就是二维坐标，三维就是三维坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到二维下 4 个，三维下 8 个点乘结果。</li><li>使用缓和曲线（ease curves）来计算它们的权重和。在原始的 Perlin 噪声实现中，缓和曲线是 $s(t)&#x3D;3t^2−2t^3$，在2002年的论文中，Perlin 改进为 $s(t)&#x3D;6t^5−15t^4+10t^3$。</li></ul><blockquote><p>这里简单解释一下，为什么不直接使用线性插值，即 $s(t) &#x3D; t$。直接使用的线性插值的话，它的一阶导在晶格顶点处（即 t &#x3D; 0 或 t &#x3D; 1）不为 0，会造成明显的不连续性。 $s(t)&#x3D;3t^2−2t^3$ 在一阶导满足连续性， $s(t)&#x3D;6t^5−15t^4+10t^3$ 在二阶导上仍然满足连续性。</p></blockquote><p>下图描述了前两个步骤：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/20151218110535114.png" alt="20151218110535114"></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>我们从简到繁一步一步实现 Perlin 噪声，首先实现一个简化版本。Perlin 噪声函数实际上就是对于一个给定的输入点，输出一个 double 类型的噪声值，这个值是伪随机的，也就是说对于相同的给定点，得到的值会是一样的。因此我们实现一个 Perlin 噪声类，在类中根据以上步骤计算噪声值。</p><p>在具体实现中，我们使用 256 个晶格，但是先不去计算每个晶格顶点的随机梯度向量，也不去计算给定的点和周围八个晶格顶点的距离向量和随机梯度向量的点乘，我们直接随机生成这些点乘结果存在一个查找表中（只是这样理解，因为点乘也只是一个数字而已，但实际上这是一种并不正确的简化，之后会正确的实现），然后根据给定点的坐标去查找点乘结果，然后将这些点乘结果利用三线性插值结合起来。</p><p>在查找的时候，我们预先计算一个随机排列数组 P[n]，P[n] 里面存储的是打乱后的 0-255 的排列值，然后我们根据给定点的坐标作为索引，到 P[n] 中找到一个 0-255 的下标，用这个下标取到查找表中对应的点乘结果。对于三维空间，我们要分别计算三个维度的 P[n] 数组，然后将三个下标值加起来并限制在  0~255 的范围，再去查找对应的点乘结果，作为一个顶点的点乘，这样查找八次即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机点乘结果</span></span><br><span class="line">        ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">        <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranfloat[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span>* ranfloat;   <span class="comment">// 存储随机点乘结果的查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">trilinear_interp</span><span class="params">(<span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    accum += (i * u + (<span class="number">1</span> - i) * (<span class="number">1</span> - u)) *</span><br><span class="line">                    (j * v + (<span class="number">1</span> - j) * (<span class="number">1</span> - v)) *</span><br><span class="line">                    (k * w + (<span class="number">1</span> - k) * (<span class="number">1</span> - w)) * c[i][j][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3 测试效果"></a>3 测试效果</h3><p>然后我们创建一个 Perlin 噪声纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再创建一个新场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改主函数部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        world = <span class="built_in">two_perlin_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise.png" alt="PerlinNoise"></p><h3 id="4-改进实现"><a href="#4-改进实现" class="headerlink" title="4 改进实现"></a>4 改进实现</h3><p>接下来我们改进上面的简化版实现，首先是插值系数，我们使用 $s(t)&#x3D;6t^5−15t^4+10t^3$ 来改进插值系数，在 Perlin 类中加一个 <code>fade</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>noise</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">    <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">    <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">    <span class="comment">// 使用fade函数修改插值系数</span></span><br><span class="line">    u = <span class="built_in">fade</span>(u);</span><br><span class="line">    v = <span class="built_in">fade</span>(v);</span><br><span class="line">    w = <span class="built_in">fade</span>(w);</span><br><span class="line">    <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">    <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                c[di][dj][dk] = ranfloat[</span><br><span class="line">                perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">            ];</span><br><span class="line">    <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise2-16503697126921.png" alt="PerlinNoise2"></p><p>可以看出一些随机效果，但是频率太低了，我们可以为纹理加上一个频率属性，控制随机的频率，这可以通过对传入 <code>noise</code> 函数的顶点值 p 进行缩放实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景中的纹理，给定一个缩放系数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise3.png" alt="PerlinNoise3"></p><p>最后我们来实现真正的 Perlin 噪声函数，现在只要将随机生成的点乘结果，变为随机生成梯度向量，然后和点 p 到八个晶格顶点的距离向量做点乘，再利用三线性插值融合点乘结果即可。为此我们需要修改 Perlin 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机梯度向量</span></span><br><span class="line">        ranvec = <span class="keyword">new</span> vec3[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranvec[i] = <span class="built_in">normalize</span>(<span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranvec;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量</span></span><br><span class="line">        vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个随机梯度向量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranvec[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 用八个梯度向量和距离向量点乘并线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">perlin_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    vec3* ranvec;       <span class="comment">// 存储随机梯度向量查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将八个顶点的梯度向量和点p到八个顶点的距离向量点乘，并做三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过改进的线性插值系数</span></span><br><span class="line">        <span class="keyword">auto</span> uu = <span class="built_in">fade</span>(u);</span><br><span class="line">        <span class="keyword">auto</span> vv = <span class="built_in">fade</span>(v);</span><br><span class="line">        <span class="keyword">auto</span> ww = <span class="built_in">fade</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u - i, v - j, w - k)</span></span>;</span><br><span class="line">                    accum += (i * uu + (<span class="number">1</span> - i) * (<span class="number">1</span> - uu))</span><br><span class="line">                        * (j * vv + (<span class="number">1</span> - j) * (<span class="number">1</span> - vv))</span><br><span class="line">                        * (k * ww + (<span class="number">1</span> - k) * (<span class="number">1</span> - ww))</span><br><span class="line">                        * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓和曲线，用于缓和线性插值系数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>按照这样的实现，由于向量点乘可能为负，因此 <code>noise</code> 函数输出的值可能为负，这样得到的颜色值就可能为负，最后进行伽马校正的时候我们要开根号，就会得到不正确的值。所以我们要在纹理类中将得到的噪声值从 [-1, 1] 映射到 [0, 1]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到的noise值范围是[-1,1]，防止颜色为负，映射到[0,1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1.0</span> + noise.<span class="built_in">noise</span>(scale * p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后看一下真正的 Perlin 噪声的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise4.png" alt="PerlinNoise4"></p><h3 id="5-Turbulence"><a href="#5-Turbulence" class="headerlink" title="5 Turbulence"></a>5 Turbulence</h3><p>将多个不同频率的噪声混合起来得到的噪声称为 Turbulence，利用 Turbulence 可以实现许多随机纹理，我们可以通过多次调用 <code>noise</code> 函数并将结果融合来得到 Turbulence。在 Perlin 类中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个noise组合形成turbulence</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">int</span> depth = <span class="number">7</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> temp_p = p;</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">        accum += weight * <span class="built_in">noise</span>(temp_p);</span><br><span class="line">        weight *= <span class="number">0.5</span>;</span><br><span class="line">        temp_p *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改噪声纹理类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于turb函数对最终融合的噪声取了绝对值，这里不需要再做任何映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">turb</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise5.png" alt="PerlinNoise5"></p><h3 id="6-大理石纹理"><a href="#6-大理石纹理" class="headerlink" title="6 大理石纹理"></a>6 大理石纹理</h3><p>一般来说，Turbulence 不会像上面那样直接使用。而是会作为一个随机扰动来生成不同的纹理，比如大理石纹理。我们可以让点 p 的某一维度和三角函数成正比，这样就可以模拟大理石的裂痕曲线，但是为了不让曲线有规律，我们使用 Turbulence 来改变三角函数的相位，这样就可以实现一个随机的大理石纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大理石纹理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise6.png" alt="PerlinNoise6"></p><p>如果我们把点 p 和三角函数成正比的维度改为 y 轴，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise7.png" alt="PerlinNoise7"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十一）纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-18T12:48:03.000Z</published>
    <updated>2022-04-18T12:59:48.661Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。</p><p><em><span id="more"></span></em></p><h3 id="1-实现纯色纹理"><a href="#1-实现纯色纹理" class="headerlink" title="1 实现纯色纹理"></a>1 实现纯色纹理</h3><p>纯色纹理的实现非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯色纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">solid_color</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">solid_color</span>(color c) : <span class="built_in">color_value</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue)</span><br><span class="line">        : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red, green, blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    color color_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来要更新 <code>hit_record</code> ，存储交点的纹理坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">double</span> u;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">double</span> v;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-计算纹理坐标"><a href="#2-计算纹理坐标" class="headerlink" title="2 计算纹理坐标"></a>2 计算纹理坐标</h3><p>对于球体来说，计算纹理坐标其实就是把球面上每一个点映射到纹理平面 uv 上。最简单的表示一个球面上的点的方法是用方位角 $\phi$ 和俯仰角 $\theta$，由于 uv 平面的范围是 [0, 1]，所以映射关系为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200148322.png" alt="image-20220418200148322"></p><p>给定方位角和俯仰角，可以计算球心在原点的单位球面上的一点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200253256.png" alt="image-20220418200253256"></p><p>于是我们可以通过光线和球面的交点坐标解出方位角和俯仰角然后映射为纹理坐标。根据以上公式可以看出俯仰角 $\theta &#x3D; arccos(-y)$，方位角 $\phi &#x3D; arctan(-z &#x2F; x)$，反三角函数计算可以直接使用 <code>&lt;cmath&gt;</code> 提供的函数 <code>acos</code> 和 <code>atan2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(z, -x);</span><br></pre></td></tr></table></figure><p>但是 <code>atan2</code> 返回的值的范围是 $[-\pi, \pi]$ ，并且是从 0 到 $\pi$，再从 $-\pi$ 到 0，这样映射的话，纹理坐标 u 就会是从 0 到 1&#x2F;2，再从 -1&#x2F;2 到 0，是不对的，但是可以利用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atan2</span>(a, b) == <span class="built_in">atan2</span>(-a, -b) + pi;</span><br></pre></td></tr></table></figure><p> 这个公式返回的是从 0 到 $2\pi$ 的连续值，就可以映射为正确的纹理坐标了。因此可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(-z, x) + pi;</span><br></pre></td></tr></table></figure><p>得到正确的方位角和俯仰角，然后映射得到纹理坐标。在球体类中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算给定球面上的点p的纹理坐标，p是圆心在原点的单位球面上的坐标，一般用归一化的法线</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">        u = phi / (<span class="number">2</span> * pi);</span><br><span class="line">        v = theta / pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时更新球体的 <code>hit</code> 函数，将纹理坐标记录到 <code>hit_record</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-为材质类添加纹理"><a href="#3-为材质类添加纹理" class="headerlink" title="3 为材质类添加纹理"></a>3 为材质类添加纹理</h3><p>现在我们可以为所有的材质增加纹理，代替之前的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-格子纹理"><a href="#4-格子纹理" class="headerlink" title="4 格子纹理"></a>4 格子纹理</h3><p>我们利用两种纹理交替形成一个格子纹理，这是一种经典的生成格子纹理的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格子纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; _even, shared_ptr&lt;texture&gt; _odd)</span><br><span class="line">        : <span class="built_in">even</span>(_even), <span class="built_in">odd</span>(_odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(color c1, color c2)</span><br><span class="line">        : <span class="built_in">even</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c1)), <span class="built_in">odd</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5 测试效果"></a>5 测试效果</h3><p>我们把随机场景中的地面的球体改为格子纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/CheckerTexture.png" alt="CheckerTexture"></p><h3 id="6-新的场景"><a href="#6-新的场景" class="headerlink" title="6 新的场景"></a>6 新的场景</h3><p>接下来我们构建一个新的场景，由于之后我们可能还会有其他场景，为了便于管理，我们新建一个 <code>sence.h</code> 来存放各种场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个球体场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/TwoSphere.png" alt="TwoSphere"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十）实现BVH</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/</id>
    <published>2022-04-18T11:23:08.000Z</published>
    <updated>2022-04-18T12:54:51.151Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的<strong>层次包围盒（BVH）</strong>去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>。</p><p><em><span id="more"></span></em></p><h3 id="1-轴对齐包围盒（AABB）"><a href="#1-轴对齐包围盒（AABB）" class="headerlink" title="1 轴对齐包围盒（AABB）"></a>1 轴对齐包围盒（AABB）</h3><p>构建 BVH 首先需要我们实现一个轴对齐包围盒类，并实现光线和 AABB 的交点计算。在图形学中我们学过计算光线和 AABB 三对平面的交点只需要用一个维度的坐标计算即可，因此我们只需要存储三对平面的坐标，这里的坐标是指一个数字，因为 AABB 是轴对齐的，因此一对平面可以表示为：<br>$$<br>x &#x3D; x_0 ,\ x&#x3D;x_1<br>$$<br>的形式，所以只需要用六个数字就可以表示一个轴对齐包围盒。</p><p>于是我们计算出光线和三对平面的交点 tmin 和 tmax ，然后用三对 tmin 和 tmax 判断光线是否和 AABB 有交点。判断方法也在图形学中有学过，这里不再赘述。</p><p>需要注意的是在实现中因为我们是用单独一个维度坐标计算的，那就有可能出现分母为 0 的情况，好消息是只要光线的起点不在两对平面之间，即使分母为 0 ，那么得到的 tmin 和 tmax 就会是同样为正无穷或者负无穷，因为计算机中 0 只是一个很小的有符号浮点数。所以我们可以使 tmin 永远为二者中较小的，tmax 永远为二者中较大的，就可以得到正确的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    轴对齐包围盒类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 minslab;</span><br><span class="line">    point3 maxslab;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; m1, <span class="type">const</span> point3&amp; m2) &#123; minslab = m1; maxslab = m2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> minslab; &#125;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> maxslab; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            tmin = <span class="built_in">fmax</span>(tmin, t0);</span><br><span class="line">            tmax = <span class="built_in">fmin</span>(tmax, t1);</span><br><span class="line">            <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一个更稳定的 <code>hit</code> 函数的实现方式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的图形学中推导光线和 AABB 有交点的时候，得出的条件是 <code>tmax &gt; tmin</code> 且 <code>tmax &gt;= 0</code>，但是在上面的代码中我们并没有考虑是否满足 <code>tmax &gt;= 0</code>，这是因为这里的 <code>hit</code> 函数的 <code>tmin</code> 和 <code>tmax</code> 是作为参数给定的，我们在传入参数的时候就会保证得到的交点的 t 值一定是大于 0 的。</p><h3 id="2-计算-BoundingBox"><a href="#2-计算-BoundingBox" class="headerlink" title="2 计算 BoundingBox"></a>2 计算 BoundingBox</h3><p>现在需要为物体类 <code>hittable</code> 添加一个计算物体 BoundingBox 的方法，并在不同的物体中有不同的实现，该函数返回 bool 类型，因为不是所有物体都能有 BoundingBox ，比如一个无限大的平面。此外对于移动的物体，需要 BoundingBox 能够覆盖所有时刻物体所在的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aabb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后实现球体的 <code>bounding_box</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> _time0, <span class="type">double</span> _time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>surrounding_box</code> 函数在 <code>aabb.h</code> 中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个包围盒形成一个大的包围盒</span></span><br><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small, big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现物体列表 <code>hittable_list</code> 的包围盒计算，思路是计算每个物体的包围盒，然后利用 <code>surrounding_box</code> 函数合并这些包围盒形成整个场景的包围盒：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现-BVH-树"><a href="#3-实现-BVH-树" class="headerlink" title="3 实现 BVH 树"></a>3 实现 BVH 树</h3><p>在图形学中我们学过，BVH 树的中间节点只存储包围盒，叶子节点存储物体，因此我们可以实现一个 BVH 节点类，每个 BVH 节点的孩子节点可以是另外的 BVH 节点或者是场景中的物体，同时每个 BVH 节点也需要计算和光线的交点，因此我们可以让 BVH 节点类也继承于 <code>hittable</code> 基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BVH类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>();</span><br><span class="line">    <span class="comment">// 可以通过hittable_list来构建BVH</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(<span class="type">const</span> hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造BVH树</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">        <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 孩子节点可以是其他的BVH节点也可以是物体</span></span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    <span class="comment">// 如果和左子树中有交点，要更新t_max，使得最终的交点是最近的交点</span></span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>比较复杂的是构建 BVH 树，我们在构造函数中构造整个 BVH 树，对于给定的物体列表，我们将其按照某一方向（x，y，z随机选择）排序，然后一分为二，一部分放到左子树，一部分放到右子树，因此这是一个类似于二分的递归过程。当物体列表中只有两个物体的时候，左右子树各放一个物体，当只有一个物体的时候，我们把这个物体复制一份，同时放到左右子树中，这样可以保证整个 BVH 树是一个完全二叉树，并且所有非叶子节点都一定有两个孩子节点，可以方便我们之后的处理，不需要判断孩子节点是否存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 不要修改原来的物体列表</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects;</span><br><span class="line">    <span class="comment">// 随机选择一个划分方向，并传递相应的比较函数指针</span></span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                    : box_z_compare;</span><br><span class="line">    <span class="comment">// 区间内的物体数量</span></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">// 只有一个物体，同时放到两个孩子节点</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个物体，左右孩子结点各一个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start + <span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start + <span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个物体递归的进行划分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先按照指定的维度进行排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span / <span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的box由左右两个子树的box的合并而来</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_left)</span><br><span class="line">        || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">        )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面用到了 <code>random_int</code> 函数，在 <code>utilities.h</code> 中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成[min,max]之间的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及自定义的比较函数，我们根据不同的方向，按照物体或者 BVH 节点的包围盒位置从小到大排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的&lt;strong&gt;层次包围盒（BVH）&lt;/strong&gt;去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记&lt;a href=&quot;https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/&quot;&gt;【计算机图形学】（十一）Whitted 风格光线追踪&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（九）运动模糊</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/</id>
    <published>2022-04-17T06:15:22.000Z</published>
    <updated>2022-04-17T06:17:08.858Z</updated>
    
    <content type="html"><![CDATA[<p>从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。</p><p><em><span id="more"></span></em></p><h3 id="1-运动模糊实现原理"><a href="#1-运动模糊实现原理" class="headerlink" title="1 运动模糊实现原理"></a>1 运动模糊实现原理</h3><p>在实际拍照的时候，运动模糊是由于在快门时间内，物体的位置发生了变化，使得一个像素融合了物体在不同位置的颜色，从而产生模糊的效果。快门时间是指从快门开启到快门关闭的这段时间。因此我们也可以加入快门时间这一概念，在投射光线的时候，随机在快门时间内投射一条光线，并且保证场景内的物体在该时间下在它应该在的位置即可。这样就可以让一个像素融合物体在多个位置的颜色，产生运动模糊效果。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>根据以上原理，我们首先要为每一条光线加上一个时间属性，说明这条光线是在什么时刻被投射出的，然后就可以根据这个时刻找到该时刻场景中物体的位置，再去计算交点等后续步骤。修改 <code>ray.h</code> 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    光线类ray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time = <span class="number">0.0</span>) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;    <span class="comment">// 光线被投射出的时刻</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改相机类，使它能够在给定快门时间内随机投射光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist,  <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">        <span class="type">double</span> _time0 = <span class="number">0</span>,  <span class="comment">// 快门开启时间</span></span><br><span class="line">        <span class="type">double</span> _time1 = <span class="number">0</span>   <span class="comment">// 快门关闭时间</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 快门时间</span></span><br><span class="line">        time0 = _time0;</span><br><span class="line">        time1 = _time1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦，并在快门时间内随机选择一个时刻作为该光线投射出的时刻</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset, </span><br><span class="line">            <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">    <span class="type">double</span> time0;</span><br><span class="line">    <span class="type">double</span> time1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后还要记得修改材质类中构造散射光线的地方，散射光线的时刻和入射光线一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后修改场景中的物体类，使其能够随时间移动，目前我们只有球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">    支持移动，time0时球心在center0，time1时球心在enter1，线性移动</span></span><br><span class="line"><span class="comment">    不移动的球体可以将初始位置和结束位置设为相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(</span><br><span class="line">        point3 cen0, point3 cen1, <span class="type">double</span> _time0, <span class="type">double</span> _time1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">        : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到物体在某一时刻的球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time1 - time0 == <span class="number">0</span>) <span class="keyword">return</span> center0;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>修改主函数，还是用随机构建的场景，但是球体的初始化要用新的方法，同时为了渲染快一些，我们还是用之前的 16 : 9 的 400 * 225 的分辨率，每个像素采样 100 根光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>,  <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\The Next Week\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MotionBlur.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/MotionBlur.png" alt="MotionBlur"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（八）构建随机场景</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/</id>
    <published>2022-04-16T13:41:00.000Z</published>
    <updated>2022-04-17T05:52:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。</p><p><em><span id="more"></span></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.75</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;final.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/FinalRender2.png" alt="FinalRender2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（七）景深效果</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-04-16T12:28:52.000Z</published>
    <updated>2022-04-17T06:17:32.688Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。</p><p><em><span id="more"></span></em></p><h3 id="1-更强大的相机"><a href="#1-更强大的相机" class="headerlink" title="1 更强大的相机"></a>1 更强大的相机</h3><p>到目前为止我们的相机基本上还是固定的，我们希望能够让相机更强大一些。比如可以调节视场角大小以扩充我们的视野，以及能够移动相机，从不同的角度观察整个场景。</p><h4 id="1-1-自定义视场"><a href="#1-1-自定义视场" class="headerlink" title="1.1 自定义视场"></a>1.1 自定义视场</h4><p>对于视场角，一般使用垂直视场角，我们将视场角加到相机类的构造函数中，通过视场角和宽高比来计算视口尺寸，这是一个简单的几何计算：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.14-cam-view-geom.jpg" alt="fig-1.14-cam-view-geom"></p><p>我们假设视口平面在 z &#x3D; -1 处，于是视口的高度 h 即为：<br>$$<br>h &#x3D; tan(\frac{\theta}{2})<br>$$<br>由此我们可以修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">    <span class="built_in">camera</span>(<span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="1-2-自定义指向和位置"><a href="#1-2-自定义指向和位置" class="headerlink" title="1.2 自定义指向和位置"></a>1.2 自定义指向和位置</h4><p>接下来我们希望摄像机能在任何位置任何角度观察场景。首先回顾之前图形学中学习的如何固定一个相机位置和姿态，我们需要一个位置、观察方向，以及一个 up 向量，这个 up 向量指定了相机旋转的角度，然后我们要根据这些值来计算在这个对应的角度下视口平面是怎样的，这可以通过两次叉乘得到：</p><ul><li>up 向量和观察方向 w 叉乘得到视口平面 u 方向</li><li>u 方向和 w 方向叉乘得到视口平面 v 方向</li></ul><p>其中观察方向 w 可以通过给定的相机位置 lookfrom 和要观察的点 lookat 得到，我们沿着 -w 方向观察，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.16-cam-view-up.jpg" alt="fig-1.16-cam-view-up"></p><p>于是我们可以继续修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(point3 lookfrom, point3 lookat, vec3 vup, <span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        <span class="keyword">auto</span> w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        <span class="keyword">auto</span> u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        horizontal = viewport_width * u;</span><br><span class="line">        vertical = viewport_height * v;</span><br><span class="line">        <span class="comment">// 视口平面左下角点</span></span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s * horizontal + t * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;CameraView.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>), point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraView.png" alt="CameraView"></p><p>调整视场角为 30 度，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraViewTiny.png" alt="CameraViewTiny"></p><h3 id="2-散焦模糊"><a href="#2-散焦模糊" class="headerlink" title="2 散焦模糊"></a>2 散焦模糊</h3><p>之前我们投射光线都假设相机的镜头是一个只容纳一根光线的针孔，一根光线投射出去会打到场景中的一个点，但实际相机的镜头是一个透镜，透镜会将场景中多束光线汇聚到一个点上，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/20200301194134436.png" alt="20200301194134436"></p><p>对于树的顶点P，其传入到成像屏幕的范围，从之前的一条光线，扩大到 L1 到 L2 两条光线之间的部分，尽管采样的光线变多了，但并不影响这一棵树的清晰成像，因为目前这棵树到相机的距离，刚好是新的屏幕到相机的距离，即焦点距离。焦点距离不等同于焦距，焦距是投影点到图像平面的距离。</p><p>但是如果我们的相机向前移动一点，原本能采样到树顶的像素颜色，变成了多条光线采样值的混合色，也就是树顶部下面一片区域的颜色，从而导致这个像素变模糊，越往前移动，越模糊，因为 L1 和 L2 的区间会扩大更多；而如果我们的相机向后移动一点，并延长光线L1 和 L2 至树的纵切平面，则会采样天空和树头顶的颜色的混合色，同样实现模糊。越往后，L1 和 L2 的区间将会扩大，从而越模糊。</p><p>因此，只要物体到相机的距离不等于焦点距离，就会出现模糊，光圈越大，采样射线的跨度越大，模糊效果越明显，这就是散焦模糊的原理。我们为了简单的模拟这一过程，可以将原本相机位置的一个点，变为相机所在位置为中心的一个圆盘内的点，然后从圆盘内的多个点出发，投射光线到场景中并采样求平均，就可以实现上述镜头景深的效果。</p><p>首先先增加一个生成单位圆盘内随机点的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成单位圆盘内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist   <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改相机参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom - lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur.png" alt="DefoucsBlur"></p><p>减小光圈将会降低模糊：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> aperture = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur1.0.png" alt="DefoucsBlur1.0"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（六）电介质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/</id>
    <published>2022-04-16T09:29:46.000Z</published>
    <updated>2022-04-17T06:32:06.329Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。</p><p><em><span id="more"></span></em></p><h3 id="1-折射光线"><a href="#1-折射光线" class="headerlink" title="1 折射光线"></a>1 折射光线</h3><p>之前在图形学中我们知道，Snell‘s law 描述了折射光线和入射光线之间存在关系：<br>$$<br>\eta·sin\theta &#x3D; \eta’·sin\theta’<br>$$<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/fig-1.13-refraction.jpg" alt="fig-1.13-refraction"></p><p>所以求解折射光线就是求解折射角 $\theta’$，$\theta’$ 是折射光线 $R’$ 和法线的夹角，我们可以把  $R’$ 分解为垂直于法线的分量和平行于法线的分量 ：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220435357.png" alt="image-20220416220435357"></p><p>然后可以根据两个分量的计算公式得到折射光线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220421971.png" alt="image-20220416220421971"></p><p>其中 $cos\theta$ 可以通过归一化的入射光线和法线的点乘得到，因此垂直分量可以改写为：<br>$$<br>R’_{perp} &#x3D; \frac{\eta}{\eta’}(R + (-R·n) \ n)<br>$$<br>由此我们可以编写一个计算折射光线的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算折射光线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">refract</span><span class="params">(<span class="type">const</span> vec3&amp; R, <span class="type">const</span> vec3&amp; n, <span class="type">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-R, n), <span class="number">1.0</span>);</span><br><span class="line">    vec3 r_out_perp = etai_over_etat * (R + cos_theta * n);</span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.<span class="built_in">length_squared</span>())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-电介质材质"><a href="#2-电介质材质" class="headerlink" title="2 电介质材质"></a>2 电介质材质</h3><p>有了折射光线计算，我们可以实现一个只计算折射光线的电介质材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景，将中间和左边的球体材质更换为电介质，设置折射率为1.5，模拟玻璃材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract.png" alt="Refract"></p><p>这看起来显然是不对的，因为我们现在只计算了折射光线，但是当介质折射率较大的时候，有可能存在无法发生折射的情况，也就是 $\theta’$ 无解，比如上面的玻璃，折射率为 1.5，那么：<br>$$<br>sin\theta’ &#x3D; \frac{1.5}{1}sin\theta<br>$$<br>可能出现 $sin\theta’$ 大于 1 的情况，此时不会发生折射，这个现象我们在图形学中也有学过。</p><p>因此我们需要在材质的散射函数中做一个判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 折射</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是修改我们的电介质材质类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract)</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景中的材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract1.png" alt="Refract1"></p><h3 id="3-加入菲涅尔项"><a href="#3-加入菲涅尔项" class="headerlink" title="3 加入菲涅尔项"></a>3 加入菲涅尔项</h3><p>现在为电介质材质加入菲涅尔项，使其随着观察角度变化发生更多的反射，依然使用 Schlick’s 近似计算菲涅尔项，修改后的最终材质类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们现在实现的电介质材质类是简化后的版本，光线打到物体上要么发生反射，要么发生折射，我们并没有同时考虑折射光线和反射光线。</p><h3 id="4-空心玻璃球"><a href="#4-空心玻璃球" class="headerlink" title="4 空心玻璃球"></a>4 空心玻璃球</h3><p>对于玻璃球来说，如果使用负半径，几何形状不受影响，但表面法线指向内（可以回顾球体类中 <code>hit</code> 方法的实现）。这可以作为一个气泡来制作一个中空的玻璃球：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.4</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure><p>我们向场景中左边球体内加了一个同心半径为负的球体，使它们构成了一个空心玻璃球，渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/RefractHollow.png" alt="RefractHollow"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（五）金属材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/</id>
    <published>2022-04-16T07:25:48.000Z</published>
    <updated>2022-04-16T08:30:17.884Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。</p><p><em><span id="more"></span></em></p><h3 id="1-材质抽象类"><a href="#1-材质抽象类" class="headerlink" title="1 材质抽象类"></a>1 材质抽象类</h3><p>材质简单来说需要做两件事情：</p><ul><li>描述光现在材质表面如何散射（或者说如何被吸收）</li><li>如果发生散射描述光线如何衰减</li></ul><p>因此对于所有材质都要有一个产生散射光线的函数。所以我们可以先定义一个材质抽象类，然后让具体的材质去实现不同的产生散射光线的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>之后我们的渲染流程变为，投射光线到场景中计算和场景中所有物体最近的交点并记录下来，这个记录要有交点的位置、法线等信息，现在还要加上物体的材质信息，这样在之后才能利用该材质产生散射光线，然后计算颜色。因此我们先修改记录交点的结构体，并将该结构体移入 <code>material.h</code> 头文件中避免循环引用，在结构体声明之前加上 <code>class material</code> 告诉该结构体 material 这个类，不然会找不到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改物体类，为每个物体也加上材质，并在 <code>hit</code> 函数中把材质传递给上面的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r, shared_ptr&lt;material&gt; m) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;                  <span class="comment">// 球心</span></span><br><span class="line">    <span class="type">double</span> radius;                  <span class="comment">// 半径</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">// 物体材质</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-实现漫反射材质"><a href="#2-实现漫反射材质" class="headerlink" title="2 实现漫反射材质"></a>2 实现漫反射材质</h3><p>现在可以实现各种材质派生类了，先把上一节中的漫反射材质封装在类中，首先是 Lambertian 材质，可以理解为它以发生散射并以反射率 R 衰减，也可以理解为发生散射但不衰减，只是吸收了 1-R 的光线，上一节中我们把反射率直接固定了 rgb 都等于 0.5 ，但在材质类中反射率应该可以自定义。我们直接把上一节中的实现拿来组织成一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的实现中还有一个问题，如果随机生成的方向和法线方向刚好相反，这两个向量的和将为 0 ，这将会导致散射方向为 0 ，进而使渲染出来的场景出现问题。因此我们需要阻止这种情况发生，我们在 <code>vec3</code> 类中增加一个判断向量是否接近 0 的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">near_zero</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有维度都接近 0 则返回 true</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(e[<span class="number">0</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">1</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">2</span>]) &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在材质类中的散射函数中增加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后顺便实现另外两种散射方法的漫反射材质，在半球采样不需要考虑散射方向为 0 的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单位球体内部采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_insphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_insphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在半球采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_hemisphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_hemisphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-实现金属材质"><a href="#3-实现金属材质" class="headerlink" title="3 实现金属材质"></a>3 实现金属材质</h3><h4 id="3-1-镜面反射"><a href="#3-1-镜面反射" class="headerlink" title="3.1 镜面反射"></a>3.1 镜面反射</h4><p>金属材质因为足够光滑，因此光线会在表面发生完美的镜面反射，因此金属材质的散射方向就是入射光线的镜面反射方向，首先我门要考虑如何求镜面反射方向，这在图形学中已经学过，但在我们的实现稍微有些不同，我们的代码中入射光线（从像素投射的光线）是指向表面的（之前都是从表面向外指的）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.11-reflection.jpg" alt="fig-1.11-reflection"></p><p>入射光线方向为 $\vec v$ ，法线为 $\vec n$，则反射方向为 $\vec v + 2\vec b$，$\vec b$ 和法线同方向，长度为 $\vec v$ 在法线方向的投影，因此镜面反射光线为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 镜面反射方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="number">2</span> * <span class="built_in">dot</span>(-v, n) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设传入该函数的都是单位向量，所以 $\vec v$ 在法线方向的投影就可以表示成点乘。</p><p>然后就可以定义金属材质类了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数，让它使用材质类计算颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数，向场景中加入各种材质的物体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Metal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Metal.png" alt="Metal"></p><p>随着场景变得复杂，我们现在的算法又暴露出一个小问题，噪声过大，这是因为使用了俄罗斯轮盘赌算法，我们现在的生存概率是 0.8，也就说当光线第一次打到物体上的时候就会有 0.2 概率返回 0 颜色，所以会产生很多噪点。因此我们可以先让光线至少弹射几次，之后再应用俄罗斯轮盘赌算法终止递归。为了方便之后修改，可以将生存概率和最少弹射次数作为可修改参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中设定最少弹射次数为 3 次，生存概率为 0.9，渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/MetalDenoise.png" alt="MetalDenoise"></p><h4 id="3-2-Glossy-反射"><a href="#3-2-Glossy-反射" class="headerlink" title="3.2 Glossy 反射"></a>3.2 Glossy 反射</h4><p>可以看到金属球上的倒影是完美的镜面反射，接下来我们可以向金属材质中添加 Glossy 反射，在镜面反射方向找一个小的球体对镜面反射方向进行扰动，使得光线朝着镜面反射方向周围一定范围散射：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.12-reflect-fuzzy.jpg" alt="fig-1.12-reflect-fuzzy"></p><p>我们可以在材质类中定义一个扰动球半径，扰动球半径越大，模糊越严重，扰动球半径为 0 就是完美的镜面反射，同时扰动球半径不能大于 1 ，否则光线可能被扰动到物体内部，所以如果给定的扰动球半径大于 1 ，我们要截断到 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在创建材质的时候可以赋予不同的扰动系数，是的物体产生不同的表现，修改主函数创建两种不同扰动系数的金属材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MetalDenoise.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Glossy.png" alt="Glossy"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（四）漫反射材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/</id>
    <published>2022-04-15T09:37:14.000Z</published>
    <updated>2022-04-15T12:38:45.814Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。</p><p><em><span id="more"></span></em></p><h3 id="1-简单的漫反射材质"><a href="#1-简单的漫反射材质" class="headerlink" title="1 简单的漫反射材质"></a>1 简单的漫反射材质</h3><p>回顾漫反射的形成原理，光线打到物体表面后一部分光会折射进入物体，并在物体内部发生各种次表面散射后从物体表面的某个方向再折射出去，因此漫反射的颜色主要取决于环境光颜色，并用物体自身的颜色去调节这些来自环境的光线，因此也可以认为漫反射反映了物体自身的颜色。从宏观来看漫反射就像是光线向各个方向均匀散射，而在我们的简单实现中可以认为光线在物体表面的反射方向是随机的，比如三根光线打到两个物体的夹缝处，他们可能产生完全不同的行为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.08-light-bounce.jpg" alt="fig-1.08-light-bounce"></p><p>因此要模拟漫反射材质，我们首先要能够随机生成漫反射弹射光线。可以使用如下方法生成：</p><ul><li>光线与物体表面相交于一点 $p$</li><li>在 $p + \vec n$ 处构造一个与点 $p$ 相切的单位球体，其中 $\vec n$ 是点 $p$ 处的法线</li><li>随机在单位球体中选择一点 $s$ ，漫反射弹射光线的方向就是 $s - p &#x3D; \vec{ps}$</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.09-rand-vec.jpg" alt="fig-1.09-rand-vec"></p><p>为此我们要先增加一些工具函数用于在单位球体内生成随机点，由于直接生成单位球体内的点并不是很方便实现，我们可以先生成单位立方体内的点，即三个维度的坐标都在 [-1, 1] 范围内，然后判断该点是否在球体内，如果不在球体内就重新随机选择，直到满足条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[0,1]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[min,max]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成单位球体内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> point3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以递归的计算光线弹射多次所得到的漫反射颜色了。</p><h3 id="2-限制光线弹射次数"><a href="#2-限制光线弹射次数" class="headerlink" title="2 限制光线弹射次数"></a>2 限制光线弹射次数</h3><p>上面的实现中，没有递归结束的条件，也就是限制光线弹射的次数，因此需要加一个递归深度来限制光线的弹射次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 限制弹射次数</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world, depth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Diffuse.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/Diffuse.png" alt="Diffuse"></p><p>使用固定弹射次数会导致很多没用的计算，仅仅渲染上面这样一张图就要用掉近三分钟，效率非常低，并且固定弹射次数会影响最终渲染效果。之前在图形学中我们学习过，更好的限制光线弹射次数的方法是使用俄罗斯轮盘赌算法（RR），该算法在保证期望正确的情况下大幅提高了渲染效率，因此我们用 RR 算法来限制光线弹射次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 要记得除以生存概率才能得到正确的期望</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中之前做的修改可以 Ctrl + Z 了，现在无需做任何修改，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRR.png" alt="DiffuseRR"></p><p>渲染这张图只用了不到 20 秒，效率大幅提升并且渲染效果更好。</p><h3 id="3-伽马校正"><a href="#3-伽马校正" class="headerlink" title="3 伽马校正"></a>3 伽马校正</h3><p>在上面的例子中我们设置了一半的光线被吸收，一半的光线被反射，在现实中这个球体看起来应该更亮一些，呈现灰色，但上面的渲染结果中球体颜色非常暗，尤其是球体下的阴影处，这是因为我们没有进行<strong>伽马校正（Gamma Correction）</strong>。</p><p>伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下：<br>$$<br>L_{out} &#x3D; L_{in}^\gamma<br>$$<br>其中指数部分的发音就是伽马。最开始的时候，人们使用伽马曲线来对拍摄的图像进行伽马编码。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可以简化为，把进入到镜头内的光线亮度编码成图像中的像素。如果采集到的亮度是 0，像素就是 0，亮度是 1，像素就是 1，亮度是 0.5，像素就是 0.5。如果我们只用 8 位空间来存储像素的每个通道的话，这意味着 0~1 区间可以对应 256 种不同的亮度值。但是，后来人们发现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/image-20220415161441639.png" alt="image-20220415161441639"></p><p>颜色越暗，我们就感觉从左到右的变化越明显。<strong>所以亮度上的线性变化对人眼的感知来说是非均匀的。</strong></p><p>另一个例子可以说明这个现象，当一个屋子的光照由一盏灯增加到两盏灯的时候，人眼对这种亮度变化的感知性要远远大于从 101 盏灯增加到 102 盏灯的变化，但是从物理上来说这两种变化基本是相同的。</p><p>所以，如果使用 8 位空间来存储每个通道的话，我们仍然把 0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费。一种更好的方法是，我们应该把把更多的空间来存储更多的暗部区域，这样存储空间就可以被充分利用起来了。摄影设备如果使用了 8 位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5，而大约为 0.22。这是因为：<br>$$<br>0.5 \approx 0.22^{0.45}<br>$$<br>如上所见，对拍摄图像使用的伽马编码使得我们可以充分利用图像的存储空间。但当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p><p>这时，人们发现了一个奇妙的巧合—— CRT 显示器本身几乎已经自动做了这个解码操作。在早期，CRT（Cathode Ray Tube，阴极射线管）几乎是唯一的显示设备。这类设备的显示机制是，使用一个电压轰击它屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但 CRT 显示器有一个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为**显示伽马 (diplay gamma)**。非常巧合的是，CRT 的显示伽马值大约就是编码伽马的倒数。CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线。虽然现在 CRT 设备很少见了，并且后来出现的显示设备有着不同的伽马响应曲线，但是，人们仍在硬件上做了调整来提供兼容性。</p><p>随后，微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 $2.2 \times 0.45 \approx 1$ ）。绝大多数的摄像机、 PC 和打印机都使用了上述的 sRGB 标准。</p><p>对于我们的渲染来说，如果我们直接输出渲染结果而不做任何处理，在经过显示器的显示伽马处理后，就会导致颜色偏暗的现象。因此我们在计算像素颜色时有必要进行伽马校正。</p><p>为了简化计算我们假设显示伽马为 2.0，因此我们的编码伽马为 0.5，在写入像素的时候对像素的最终颜色值进行伽马编码，就可以让颜色显示正常了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过伽马矫正后的渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRRGammaCorrect.png" alt="DiffuseRRGammaCorrect"></p><h3 id="4-True-Lambertian-Reflection"><a href="#4-True-Lambertian-Reflection" class="headerlink" title="4 True Lambertian Reflection"></a>4 True Lambertian Reflection</h3><p>现在回顾上面在<strong>单位球体内</strong>选取随机点的实现。这样的实现会使得选取到的随机反射方向大概率接近法线，而以很小的概率接近掠射角方向，这是因为整个球体中大部分位置和表面交点的连线都接近法线方向，只有很小一部分接近掠射角方向，这代表我们随机选取的反射方向不是均匀分布的，但这似乎是合理的，因为越接近掠射角代表光线越接近该交点的切线方向，所以对最终颜色的贡献也更小。</p><p>而 True Lambertian Reflection 并不是这样的， True Lambertian Reflection 的随机方向更均匀，因为它是在<strong>单位球面上</strong>随机取点并构成反射方向，这样显然随机选取的反射方向会更加均匀。</p><p>我们可以通过先在球面内随机取点，并将其单位化，以得到球面上随机一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成单位球面上随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这次使用球面上的随机点</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/TrueLambertianReflection.png" alt="TrueLambertianReflection"></p><p>可以注意到和之前的结果中两个不同的视觉变化：</p><ul><li>阴影变得不那么明显了</li><li>物体变得稍微亮了一点</li></ul><p>这两种变化都是由于光线散射更均匀，向法线附近散射的光线更少而产生的。对于漫反射物体，它们会显得更亮是因为更多的光线会反射到相机上。对于阴影，因为向法线附近散射的光线更少，所以大球体表面和上面的小球体的夹缝处就会有更多的光线散射出去，而不是在夹缝处一直弹射。</p><h3 id="5-另一种散射方法"><a href="#5-另一种散射方法" class="headerlink" title="5 另一种散射方法"></a>5 另一种散射方法</h3><p>除了上面的在球体内随机取点和在球面上随机取点之外，还有一种随机散射的方法。在之前的方法中我们选取了一个单位球，这个单位球的球心相比于光线和表面的交点偏移了一个法线，但很难解释我们为什么这么做。一个更直观的方法是不进行法线偏移，在单位球体内随机取一点作为光线和物体的交点 p 的偏移，然后用偏移后的点 p 和原来的点 p 构成随机反射方向。这相当于以 p 为球心，在一个半球上随机取点构成反射方向，在实现中要注意如果偏移后的点 p 落入了下半球，意味着反射光线指向了物体内部，这是错误的，此时要对偏移量取反，以保证反射光线和该点的法线在同一个半球。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在半球内随机取点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="type">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="comment">// 判断该偏移量是否落入了下半球，如果落入下半球则偏移量应该取反</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体内部随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体表面随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 在以交点为球心的半径为 1 的半球内随机取一点得到反射方向</span></span><br><span class="line">        point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/RandomInHemisphere.png" alt="RandomInHemisphere"></p><p>以上三种散射方法没有对错之分，在后面场景变得越来越复杂之后，可以通过尝试切换这三种漫反射渲染器来观察不同的方法对渲染效果的影响。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（三）相机类和反走样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/</id>
    <published>2022-04-15T03:37:24.000Z</published>
    <updated>2022-04-19T11:56:08.877Z</updated>
    
    <content type="html"><![CDATA[<p>上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。</p><p><em><span id="more"></span></em></p><h3 id="1-生成随机数的工具函数"><a href="#1-生成随机数的工具函数" class="headerlink" title="1 生成随机数的工具函数"></a>1 生成随机数的工具函数</h3><p>首先我们要向 <code>utilities.h</code> 中添加两个生成随机数的函数，用于在像素内部随机采样，一个生成 [0 ,1] 之间的随机数，另一个可以定制随机数范围，在 C++ 11 中可以不使用传统的 <code>rand()</code> 实现，可以使用 <code>&lt;random&gt;</code> 中提供的方法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成[0,1]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0~1之间的均匀分布</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// random_device用于生成均匀整数，用来给mt19937播种，类似于之前的srand()</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="comment">// 生成符合分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成[min,max]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-实现相机类"><a href="#2-实现相机类" class="headerlink" title="2 实现相机类"></a>2 实现相机类</h3><p>现在我们实现一个相机类来管理虚拟摄像机以及场景中的各种采样任务，我们先使用之前的轴对齐摄像机作为默认构造方法，来实现一个简单的相机类，只需要把之前主函数中的设置相机的代码拿过来组织一下即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-反走样"><a href="#3-反走样" class="headerlink" title="3 反走样"></a>3 反走样</h3><p>光线追踪中最简单的反走样就是在一个像素内部投射出多条光线，将他们的得到的颜色混合起来作为该像素的颜色。</p><p>在实现时，我们可以将多根光线的颜色先全部累加到像素中，然后在 <code>write_color</code> 函数中将该像素颜色除以采样数量即可。在此之前我们先在 <code>utilities.h</code> 中添加一个截断函数，用于将给定值截取在指定范围内，同时修改 <code>write_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的数字截取到[min,max]范围内</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">clamp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-测试反走样效果"><a href="#4-测试反走样效果" class="headerlink" title="4 测试反走样效果"></a>4 测试反走样效果</h3><p>接下来修改主函数，测试一下反走样实现效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Antialiasing.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/Antialiasing.png" alt="Antialiasing"></p><p>没有反走样的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/WorldSphereNormal.png" alt="WorldSphereNormal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二）实现物体类</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/</id>
    <published>2022-04-15T02:29:14.000Z</published>
    <updated>2022-04-15T03:40:10.840Z</updated>
    
    <content type="html"><![CDATA[<p>有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。<br><em><span id="more"></span></em></p><h3 id="1-渲染一个球体"><a href="#1-渲染一个球体" class="headerlink" title="1 渲染一个球体"></a>1 渲染一个球体</h3><p>在光线追踪中如果投射出的光线碰到了物体，就计算该点的颜色作为像素值，那么我们从最简单的情形开始，渲染一个球体，我们在 z &#x3D; -1 处放置一个球体，然后计算投射出的每一条光线和该球体是否有交点，如果有的话我们将该像素设置为一个定值，这样就可以在屏幕上显示出这个球体了。</p><p>计算光线和空间中球体是否有交点我们在图形学中已经学过，非常简单，对于射线 $P(t)$ 和一个空间中球心在 $C$ ，半径为 $r$  的球体，如果射线上的点在球面上，则满足：<br>$$<br>(P(t)−C)⋅(P(t)−C)&#x3D;r^2<br>$$<br>将 $P(t) &#x3D; A + t \vec b$ 代入得：<br>$$<br>(A+t\vec b−C)⋅(A+t\vec b−C)&#x3D;r^2<br>$$<br>再展开即可得到关于 $t$ 的一元二次方程：<br>$$<br>t^2 \vec b⋅\vec b+2t\vec b⋅(A−C)+(A−C)⋅(A−C)−r^2&#x3D;0<br>$$<br>只需要判断这个一元二次方程有没有实数根即可。于是我们可以写出判断光线是否和球体相交的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在之前的 <code>ray_color</code> 函数中加上判断光线是否和球体相交的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//放置在 z = -1 处的一个半径为0.5的球体</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r)) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/Sphere.png" alt="Sphere"></p><p>需要注意的是，现在我们只考虑了是否有实数根，并没有考虑 t 的正负，这会导致即使把球体放到 z &#x3D; 1 处，也能得到和上图相同的结果，这相当于我们看到了在相机后面的物体，这个问题之后我们会解决。</p><h3 id="2-表面法线"><a href="#2-表面法线" class="headerlink" title="2 表面法线"></a>2 表面法线</h3><h4 id="2-1-可视化物体表面法线"><a href="#2-1-可视化物体表面法线" class="headerlink" title="2.1 可视化物体表面法线"></a>2.1 可视化物体表面法线</h4><p>我们计算光线与物体交点的光照时首先需要知道该交点的法线，对于一个球体来说，表面上任意一点的法线方向就是该点和球心连线的方向并从球心向外指。因此我们只要计算出投射的光线和球体的交点就可以得到该点的法向量，由于法向量是单位向量，每个分量范围都在 [-1, 1] ，因此我们可以将每个分量都映射到 [0, 1]，作为颜色值显示出来。</p><p>为此我们先修改刚才的 <code>hit_sphere</code> 使其返回交点的 t 值，由于我们的球体放在 z &#x3D; -1 处，所以两个交点都一定是正实数，我们返回较小的那个一根即可，即：<br>$$<br>t_{return} &#x3D; \frac{-b - \sqrt{b^2-4ac} }{2a}<br>$$<br>因为只能看到离我们最近的点，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> (-b - <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//放置在 z = -1 处的一个半径为0.5的球体，计算交点法线作为颜色返回</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec3 normal = <span class="built_in">normalize</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> (normal + <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/SphereNormal.png" alt="SphereNormal"></p><h4 id="2-2-代码优化"><a href="#2-2-代码优化" class="headerlink" title="2.2 代码优化"></a>2.2 代码优化</h4><p>上面的 <code>hit_sphere</code> 函数有一些可以优化的地方，首先两个相同向量的点乘，可以通过我们在 <code>vec3</code> 类中定义的 <code>length_squared()</code> 方法得到，另外考虑方程的求根公式：<br>$$<br>\frac{-b \pm \sqrt{b^2-4ac} }{2a}<br>$$<br>如果把 b 替换成 2h，可以得到：<br>$$<br>\frac{-2h \pm \sqrt{(2h)^2-4ac} }{2a}<br>$$<br>展开整理得：<br>$$<br>\frac{-h \pm \sqrt{h^2-ac} }{a}<br>$$<br>于是我们只需要计算 b 的一半即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line"><span class="keyword">auto</span> h = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = h * h - a * c;</span><br><span class="line"><span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> (-h - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个物体"><a href="#3-多个物体" class="headerlink" title="3 多个物体"></a>3 多个物体</h3><h4 id="3-1-实现物体类"><a href="#3-1-实现物体类" class="headerlink" title="3.1 实现物体类"></a>3.1 实现物体类</h4><p>在实际场景中我们不可能只有一个物体，并且物体也不可能只是球体，还可能有有各种各样的模型，因此为了能让所有模型都可以放置到场景中并计算我们投射光线和物体的交点，我们可以先定义一个可计算交点的抽象物体类 <code>hittable</code>，这个类定义一个纯虚函数 <code>hit</code> 用来判断物体和光线的交点，然后再以该抽象类为基类，实现各种物体类即可，这样一来，不同的物体的 <code>hit</code> 函数有可以有不同的实现了。</p><p><code>hit</code> 函数也和我们上面写的稍有不同，除了要接收一根光线作为参数外，还要有一个限定范围 $t_{min}$ 和 $t_{max}$，只有当交点的 t 在这个范围内才会与物体相交，这部分也在之前的图形学中也有学过，同时这个范围也可以用于后面计算多个物体中最近的交点。</p><p>此外，光线可能和物体有多个交点，我们需要取在限定范围内的离我们最近的交点，把该交点及其法线等属性记录下来，因此还要定义一个存储交点属性的结构体。</p><p>最后还需要考虑一个问题，交点是物体的正面还是背面？这对我们渲染来说非常重要，尤其是一些双面不同的物体。这可以通过光线和法线的点乘来判断，如果光线和交点的法线反向，这说明交点在物体的正面，因为法线都是从物体中心指向表面的；相反如果光线和交点的法线同向，这说明交点在物体的背面。同向和反向实际上是两个向量的夹角，因此点乘即可。如果交点在物体背面，那么计算光照时用到的法线应该是这个点表面法线的反方向，所以要对原法线取反。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/fig-1.06-normal-sides.jpg" alt="fig-1.06-normal-sides"></p><p>现在我们可以开始实现上面的思路了，首先是抽象类和结构体的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"><span class="comment">// utilities.h 包含了常用的工具函数并整合了常用头文件，避免循环嵌套，我们在后面会实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来实现一个球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重载虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-实现物体列表类"><a href="#3-2-实现物体列表类" class="headerlink" title="3.2 实现物体列表类"></a>3.2 实现物体列表类</h4><p>现在我们已经有了可以与光线相交的物体的基类 <code>hittable</code>，可以在其基础上实现各种物体类，接下来我们要定义一个类来存储多个物体，代码比较容易理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">物体列表类hittable_list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line">    <span class="comment">// 一个物体列表的hit函数用于得到光线和这个列表中所有物体最近的一个交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="type">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录当前的最近的t</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line">    <span class="comment">// 遍历每一个物体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 更新最近的t</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="3-3-关于智能指针"><a href="#3-3-关于智能指针" class="headerlink" title="3.3 关于智能指针"></a>3.3 关于智能指针</h4><p>上面的物体列表类中使用了智能指针，在之后的代码中我们也会经常使用，智能指针能帮助我们自动管理内存，防止内存泄漏，一般来说初始化一个智能指针可以使用如下形式的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>auto 支持对智能指针类型的自动推导，因此我们写起来会更方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line"><span class="keyword">auto</span> vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line"><span class="keyword">auto</span> sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>声明后就可以像正常指针一样使用了。更多关于智能指针的内容可以查看 C++ 与 STL 部分的笔记。</p><h3 id="4-常用常量和工具函数"><a href="#4-常用常量和工具函数" class="headerlink" title="4 常用常量和工具函数"></a>4 常用常量和工具函数</h3><p>接下来需要定义一些常用的常量以及角度转弧度等工具函数，并将一些类的头文件整合起来，使代码组织更整洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常用常量及工具函数</span></span><br><span class="line"><span class="comment">整合包含其他头文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> infinity = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="type">double</span> degrees)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用头文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> UTILITIES_H</span></span><br></pre></td></tr></table></figure><h3 id="5-再次可视化法线"><a href="#5-再次可视化法线" class="headerlink" title="5 再次可视化法线"></a>5 再次可视化法线</h3><p>使用上面实现的一系列代码，再次实现一个可视化法线的效果，首先修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">hit_record rec;</span><br><span class="line"><span class="comment">// 计算和世界中的物体的交点的法线</span></span><br><span class="line"><span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;WorldSphereNormal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******场景属性*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/WorldSphereNormal.png" alt="WorldSphereNormal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。&lt;br&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【算法】排序算法</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-13T09:00:01.000Z</published>
    <updated>2022-04-13T09:02:25.442Z</updated>
    
    <content type="html"><![CDATA[<p>排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：</p><ul><li>时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序</li><li>时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序</li><li>时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序</li></ul><p>可以通过<a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a>题目实践这些算法。</p><p><em><span id="more"></span></em></p><h2 id="1-时间复杂度为-O-n-2-的排序"><a href="#1-时间复杂度为-O-n-2-的排序" class="headerlink" title="1 时间复杂度为 $O(n^2)$ 的排序"></a>1 时间复杂度为 $O(n^2)$ 的排序</h2><p>这一类排序算法属于入门算法，性能较差，在实际工程中几乎不会用到，但他们的思想对解决一些特定问题还是很有启发的。</p><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="1-1-1-算法思想"><a href="#1-1-1-算法思想" class="headerlink" title="1.1.1 算法思想"></a>1.1.1 算法思想</h4><p>冒泡排序是入门级排序算法，但也有一些优化的写法，首先来看最简单的冒泡排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-算法优化"><a href="#1-1-2-算法优化" class="headerlink" title="1.1.2 算法优化"></a>1.1.2 算法优化</h4><p>稍微优化一下，因为在每一次冒泡的过程中，多次交换不仅会把最大&#x2F;最小的数放到末尾，还会使中间一部分变得有序，这样会导致在后面的冒泡过程中没有任何交换，但还是进行了遍历，从而造成性能的浪费。因此使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;<span class="comment">//初始化为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;<span class="comment">//如果前一轮没有发生过交换说明已经有序，无需继续进行下去</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步进行优化，除了记录当前轮次是否发生过交换外，再用一个变量记录最后一次发生交换的位置，下一次遍历只要到该位置即可，因为该位置之后必然都已经有序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> indexOfLastUnsortedElement = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-swap-函数"><a href="#1-1-3-swap-函数" class="headerlink" title="1.1.3 swap 函数"></a>1.1.3 swap 函数</h4><p>优化后的冒泡排序的平均时间复杂度实际上还是 $O(n^2)$，所以这些优化对算法的性能并没有质的提升，因此冒泡排序也并不会在实际工程中使用，面试中也几乎不可能会问到，但是现在学习冒泡排序的另一个价值是关于上面的 swap 函数，这是面试中一个经典的问题：<strong>不使用额外空间交换数组中的两个数</strong>。做法非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] - nums[i];</span><br></pre></td></tr></table></figure><p>另一种实现，先减后加，原理一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] -= nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] + nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i] - nums[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面两种方法都可能会数字越界，最好的方法是位运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[j] ^ arr[i];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br></pre></td></tr></table></figure><h4 id="1-1-4-相关练习"><a href="#1-1-4-相关练习" class="headerlink" title="1.1.4 相关练习"></a>1.1.4 相关练习</h4><h5 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h5><blockquote><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p></blockquote><p>自己定义一个比较函数即可，如果两个数字的字符串拼接 <code>sx + xy &lt; sy + sx</code>，则可以认为 sx 小于 sy ，即 sx 应该排在前面。</p><p>至于排序算法的选择，可以用任意排序，冒泡就不再重新写了，这里直接用 c++ 的 sort 函数，如果不用 sort 函数可以不使用额外空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string&amp; x, string&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res += strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></h5><p>在双指针时做过，双指针自然是最好的解法，不过显然用冒泡的思想更加直观。</p><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="1-2-1-算法思想"><a href="#1-2-1-算法思想" class="headerlink" title="1.2.1 算法思想"></a>1.2.1 算法思想</h4><p>选择排序的思想是，双重遍历数组，每一轮遍历都将数组中最小&#x2F;最大的值交换到数组首位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序与冒泡排序时间复杂度和空间复杂度完全一致，但二者有一个非常大的差异就是冒泡排序是稳定的，而选择排序是不稳定的。</p><h4 id="1-2-2-排序的稳定性"><a href="#1-2-2-排序的稳定性" class="headerlink" title="1.2.2 排序的稳定性"></a>1.2.2 排序的稳定性</h4><p>对于排序算法来说，<strong>稳定</strong>是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p>在冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p><p>那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。</p><p>举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。</p><p>当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。同样地，不稳定排序算法也可以经过修改，达到稳定的效果。比如选择排序算法实现稳定排序一种最简单的思路是：新开一个数组，将每轮找出的最小值依次添加到新数组中，这样选择排序算法就变成稳定的了。</p><p>但如果将寻找最小值的比较条件由 arr[minIndex] &gt; arr[j] 修改为 arr[minIndex] &gt;&#x3D; arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。</p><h4 id="1-2-3-算法优化"><a href="#1-2-3-算法优化" class="headerlink" title="1.2.3 算法优化"></a>1.2.3 算法优化</h4><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想，每轮选择时记录最小值和最大值，这样可以把数组需要遍历的范围缩小一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 相等，说明当前遍历范围内所有元素都相等，整个数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 刚已经交换了，所以这里 maxIndex 的值要更新一下</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> lastIndex = arr.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二元选择排序中，需要遍历的数组范围缩小了一倍，但效率并不能提高一倍，这是因为在内层循环中普通选择排序只要做一次比较，而二元选择循环需要做两次比较，因此提升的效率并不是线性的。不过由于在上面的二元选择排序中，我们使用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>来做优化，因此当数组中重复元素很多时，二元选择排序效率将远高于选择排序。</p><h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="1-3-1-算法思想"><a href="#1-3-1-算法思想" class="headerlink" title="1.3.1 算法思想"></a>1.3.1 算法思想</h4><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p><p>插入排序的基本思想就是：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// j 记录当前数字下标</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新当前数字下标</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-算法优化"><a href="#1-3-2-算法优化" class="headerlink" title="1.3.2 算法优化"></a>1.3.2 算法优化</h4><p>我们发现，在上面的插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。</p><p>由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前新插入的数字</span></span><br><span class="line">        <span class="type">int</span> cur = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前面已经有序的数字如果比当前数字大，就往后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序时间复杂度同样是 $O(n^2)$，空间复杂度为 $O(1)$，且插入排序是稳定的排序算法。</p><h4 id="1-3-3-相关练习"><a href="#1-3-3-相关练习" class="headerlink" title="1.3.3 相关练习"></a>1.3.3 相关练习</h4><h5 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></h5><blockquote><p>给定单个链表的头 <code>head</code> ，使用<strong>插入排序</strong>对链表进行排序，并返回排序后链表的头。</p></blockquote><p>单向链表的插入排序比数组困难一些，我们无法从插入的新元素的位置向前遍历寻找插入位置，只能从头开始寻找插入位置，为此我们需要记录链表有序部分的最后一个节点，先判断该节点和当前待插入节点的大小，如果待插入节点比链表有序部分的最后一个节点的值大，那么无需插入，直接向后继续即可，否则从头结点开始寻找插入位置。</p><p>为了方便在头节点前插入节点，事先定义一个哑节点，这是链表题目的常规操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN, head);</span><br><span class="line">        ListNode* last_sorted = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= last_sorted-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                last_sorted = last_sorted-&gt;next;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = dummy, *t = pre-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;val &lt;= cur-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = t-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                last_sorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-时间复杂度为-O-nlogn-的排序"><a href="#2-时间复杂度为-O-nlogn-的排序" class="headerlink" title="2 时间复杂度为 $O(nlogn)$ 的排序"></a>2 时间复杂度为 $O(nlogn)$ 的排序</h2><p>这一类排序是排序中最为重要的算法，因为他们普适性好，效率高，许多编程语言内置的排序函数的实现就综合了这里面的各类算法。</p><h3 id="2-1-希尔排序"><a href="#2-1-希尔排序" class="headerlink" title="2.1 希尔排序"></a>2.1 希尔排序</h3><p>希尔排序本质上是对插入排序的一种优化，虽然现在几乎不被使用，但作为第一批将时间复杂度降到 $O(n^2)$ 以下的排序算法，还是有必要了解一下。</p><h4 id="2-1-1-算法思想"><a href="#2-1-1-算法思想" class="headerlink" title="2.1.1 算法思想"></a>2.1.1 算法思想</h4><p>希尔排序的基本思想是：</p><ul><li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li><li>逐渐缩小间隔进行下一轮排序</li><li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的宏观调控，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li></ul><p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，增量依次递减，最后一个增量必须为 1，所以希尔排序又被称为「缩小增量排序」。</p><p>增量序列的选择会极大地影响希尔排序的效率。本例中，我们采用的增量序列为 $D_m &#x3D; N&#x2F;2$，$D_k &#x3D; D_{k+1} &#x2F; 2$ 。这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> groupStartIndex = <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.<span class="built_in">size</span>(); currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> currentNumber = arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> preIndex = currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h4><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> currentNumber = arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与插入排序非常相似，但多了一层外层的间隔序列循环。</p><h4 id="2-1-3-算法性能"><a href="#2-1-3-算法性能" class="headerlink" title="2.1.3 算法性能"></a>2.1.3 算法性能</h4><p>之前说过，增量序列的选择将直接影响希尔排序的性能，因此它也是希尔排序的核心优化点，学界有不少的大牛做过这方面的研究。比较著名的有 <code>Hibbard</code> 增量序列、<code>Knuth</code> 增量序列、<code>Sedgewick</code> 增量序列。由于希尔排序已经逐渐不被使用，因此这部分内容也不是我们学习的重点。</p><p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。</p><p>我们现在学习希尔排序的意义在于，要理解希尔排序为什么能打破排序算法 $O(n^2)$ 的壁障，理解了这一点就明白了为什么希尔排序能承上启下，引发出之后一系列 $O(n^2)$ 以下的排序算法。</p><p>这可以通过逆序对来理解，所谓逆序对是指：当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。排序算法本质上就是一个消除逆序对的过程。对于随机数组，逆序对的数量是 $O(n^2)$ 级的，如果采用交换相邻元素的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$ 级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$ 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p><p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度为 $O(n^2)$ 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p><h3 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h3><h4 id="2-2-1-算法思想"><a href="#2-2-1-算法思想" class="headerlink" title="2.2.1 算法思想"></a>2.2.1 算法思想</h4><p>我们之前已经学习过优先队列和堆，并且自己动手实现了一个堆，因此堆排序的思想现在并不难理解。我们将该数组初始构建为一个大顶堆，然后每次将堆顶元素交换到数组末尾，剩下的元素调整形成新的大顶堆，重复以上过程即可。我们之前自己动手实现堆的时候已经知道了如何调整数组元素，现在只需要了解如何通过给定数组高效的构建一个大顶堆。</p><p>我们可以把给定数组直接视作一个大顶堆，而不要再开辟额外空间，直接在该数组上调整元素使其成为大顶堆就行了。 对于一个长度为 n 的数组形成的堆，它的最后一个非叶子节点的编号为 <code>n / 2 - 1</code>，我们从最后一个非叶子节点开始向前遍历，每个节点和它的孩子节点比较，并作相应的交换，所以叶子节点不需要调整，直接从最后一个非叶子节点开始即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建大顶堆,从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> root, <span class="type">int</span> heapsize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftchild = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightchild = leftchild + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxindex = root;</span><br><span class="line">        <span class="keyword">if</span>(leftchild &lt; heapsize &amp;&amp; nums[leftchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightchild &lt; heapsize &amp;&amp; nums[rightchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxindex == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root], nums[maxindex]);</span><br><span class="line">        <span class="comment">//保证交换后下面的子树也是一个大顶堆</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(nums, maxindex, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> heapsize = nums.<span class="built_in">size</span>() - <span class="number">1</span>; heapsize &gt; <span class="number">0</span>; --heapsize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[heapsize]);</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-算法性能"><a href="#2-2-2-算法性能" class="headerlink" title="2.2.2 算法性能"></a>2.2.2 算法性能</h4><p>根据数学运算可以推导出初始化建堆的时间复杂度为 $O(n)$，重建堆的时间复杂度为 $O(n\log n)$，所以堆排序总的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p><h4 id="2-2-3-相关练习"><a href="#2-2-3-相关练习" class="headerlink" title="2.2.3 相关练习"></a>2.2.3 相关练习</h4><h5 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">相对名次</a></h5><blockquote><p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都互不相同 。</p><p>运动员将根据得分决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p><ul><li>名次第 1 的运动员获金牌 “Gold Medal” 。</li><li>名次第 2 的运动员获银牌 “Silver Medal” 。</li><li>名次第 3 的运动员获铜牌 “Bronze Medal” 。</li><li>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。</li></ul><p>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况.</p></blockquote><p>比较简单，堆排序记录下标即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxscore = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) ans[maxscore.second] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) ans[maxscore.second] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) ans[maxscore.second] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[maxscore.second] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h5><blockquote><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></blockquote><p>这是一道很简单的题目，排序后数组的中位数一定是多数元素，因此只需要对数组排序即可，自己手写堆排序可以不使用额外空间。</p><p>对于上述结论的证明以及这道题更好的解法——摩尔投票法，参考<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解方法五</a>。</p><h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-算法思想"><a href="#2-3-1-算法思想" class="headerlink" title="2.3.1 算法思想"></a>2.3.1 算法思想</h4><p>快速排序在时间复杂度为 $O(nlogn)$ 级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p><p>快速排序算法的基本思想是：</p><ul><li>从数组中取出一个数，称之为基数（pivot）</li><li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li><li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li></ul><p>依据上面的思路，我们可以先写出快速排序的框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架存在一个严重的问题，就是没有退出递归的边界条件，显然当某个分区内只有一个数字或者没有数字的时候就不需要继续排序了，分区内只有一个数字即 <code>start == end</code>，分区内没有数字即 <code>start &gt; end</code>，因此退出递归的条件是 <code>start &gt;= end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间只有一个数字或者没有数字的时候，退出递归</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现最关键的分区函数，分区函数的目的是选择一个基数，然后将所有小于基数的数都放到基数左边，将所有大于基数的数都放到基数右边，最后返回基数所在的下标。</p><p>因此如何选择基数就成为了一个问题，一般来说有三种选择方案：</p><ul><li>选择第一个数作为基数</li><li>选择最后一个数作为基数</li><li>随机选择一个数作为基数</li></ul><p>这里我们以第一种基数选择方法为例来实现快速排序，但实际上随机选择一个数作为基数的快速排序平均时间复杂度最优，我们将在后面讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> pivot = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始</span></span><br><span class="line">    <span class="type">int</span> left = start + <span class="number">1</span>, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于等于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; arr[pivot]) ++left;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">        <span class="comment">// 交换二者位置，保证左边都是小于基数的数，右边都是大于等于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出上面的while的时候，left == right，这时left和right同时指向的数还没有和基数做判断</span></span><br><span class="line">    <span class="comment">// 因此要加上这一句判断</span></span><br><span class="line">    <span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">    <span class="comment">// 将基数交换到中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(right != pivot) <span class="built_in">swap</span>(arr[pivot], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的分区函数使用了双指针的方法，这也是容易想到的比较好的实现方法。上面的代码中有一个细节，在while循环结束后，还加了一个额外的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br></pre></td></tr></table></figure><p>这是因为在上面的 while 退出的时候，left 和 right 同时指向的数还没有和基数做判断，所以需要额外做一次判断；同时这行代码还解决了 [start, end] 区间内只有两个数字的情况，这种情况下第一个数字做为基数，那么 [left, right] 区间内就只有一个数字，因此不会进入 while 循环，所以需要判断一次。</p><p>另外要注意的是，这里不能用 left 指针来判断，因为 left 指针递加有可能超出数组范围，而 right 指针递减至少也是和 pivot 相等，即指向区间内第一个元素，所以不会出现问题，最后交换和返回也都是用 right 指针更为安全。</p><p>双指针实现比较简单直观，但是要写的代码比较多，也要考虑比较多的特殊情况，更为简单的分区函数实现一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> piovt = start;</span><br><span class="line">    <span class="comment">// ret记录最后基数应该在的位置，初始为我们选择的基数的位置，也就是start</span></span><br><span class="line">    <span class="type">int</span> ret = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = start + <span class="number">1</span>; right &lt;= end; ++right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这个数小于基数，ret向后移动一位然后换位，这样保证ret左边都是小于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(arr[right] &lt; arr[piovt])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="built_in">swap</span>(arr[ret], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把基数放到ret处，返回ret</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[ret]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无需更多的特殊判断，是一种更高效的写法。</p><h4 id="2-3-2-算法分析"><a href="#2-3-2-算法分析" class="headerlink" title="2.3.2 算法分析"></a>2.3.2 算法分析</h4><p>快排的平均时间复杂度为 $O(nlogn)$，最坏情况下的时间复杂度为 $O(n^2)$；空间复杂度与递归的层数有关，最好情况下空间复杂度为 $O(logn)$，最坏情况下为 $O(n^2)$，平均空间复杂度为 $O(logn)$。</p><p>现在我们来分析以下为什么随机选择基数的平均复杂度更低，首先我们要搞清楚上面说的最坏情况是什么情况。理想中的快速排序在第 k 轮遍历中，可以排好 $2^{k-1}$ 个基数，假设我们用刚才实现的方法，即选择数组第一个数作为基数，考虑下面两种情况：</p><ul><li><p>数组为正序，比如 <code>nums = [1, 2, 3, 4, 5, 6]</code>，这时第一次分区将原数组分为了 [0, 0] 和 [1, 5] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一次分区也是同样，因此每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，所以总的比较次数为 $(n-1) + (n-2) + …+1 &#x3D; n(n-1)&#x2F;2$ 次，此时快排的时间复杂度就达到了 $O(n^2)$。</p></li><li><p>数组为逆序，比如 <code>nums = [6, 5, 4, 3, 2, 1]</code>，这时第一次分区将原数组分为了 [0, 4] 和 [5, 5] 两个区间，而 5 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一轮分区时数组变为了 <code>nums = [1, 5, 4, 3, 2, 6]</code> ，我们要在 [0, 4] 区间上继续分区，经过这一轮，将区间 [0, 4] 分为了 [0, 0] 和 [1, 4] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，以此类推，每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，因此这种情况下快排的时间复杂度也是 $O(n^2)$。</p></li></ul><p>所以为了避免这种情况，我们在数组中随机选择一个数作为基数，这样选到数组中最大值或者最小值的概率就很低，自然可以避免最坏情况的发生。</p><h4 id="2-3-3-算法优化"><a href="#2-3-3-算法优化" class="headerlink" title="2.3.3 算法优化"></a>2.3.3 算法优化</h4><p>根据上面的分析，一般来说快速排序前可以对原数组进行“洗牌”，以防止原数组有序的情况，洗牌算法的思想非常简单，从后向前遍历数组，然后随机选择一个数组中的数字与当前元素交换，最终所有元素都被交换一次，就打乱了原数组的顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandIntRange</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">RandIntRange</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(p != i) <span class="built_in">swap</span>(nums[p], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在排序前对原数组进行一个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。显然洗牌算法的时间复杂度为 $O(n)$。实际实现快速排序的时候我们不需要把数组完整洗牌，每次选择基数的时候随机选择一个基数即可。</p><h4 id="2-3-4-快速选择"><a href="#2-3-4-快速选择" class="headerlink" title="2.3.4 快速选择"></a>2.3.4 快速选择</h4><p>基于快速排序的选择算法是面试中的高频考题，我们可以再次回顾一下 TopK 问题。</p><h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p></blockquote><p>之前我们是用堆排序解决的，堆排序的方法时间复杂度为 $O(nlogn)$，空间复杂度为 $O(logn)$。使用基于快速排序的选择算法可以将平均时间复杂度降低至 $O(n)$。</p><p>快速选择的思想非常简单，在快速排序中，每一轮都可以确定区间内一个基数的最终位置，partition 函数会返回这个位置，因此我们从小到大进行快速排序，当确定的基数的位置为 <code>nums.size() - k</code> 时，就得到了第 K 个最大的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机选择基数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select_piovt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> piovt = <span class="built_in">select_piovt</span>(nums, low, high);</span><br><span class="line">        <span class="type">int</span> ret = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = low + <span class="number">1</span>; right &lt;= high; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; piovt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++ret], nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[ret], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = high - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">partition</span>(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target) low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a>2.4 归并排序</h3><h4 id="2-4-1-算法思想"><a href="#2-4-1-算法思想" class="headerlink" title="2.4.1 算法思想"></a>2.4.1 算法思想</h4><p>归并排序也是一种性能很优秀的排序算法，并且由于它是稳定的排序算法，因此也被广泛应用。归并排序的基本思想是对原数组不停的二分，直到每个区间都只有 1 个数字，这时这个区间可以视为一个有序区间，然后再不停的合并两个有序区间即可。</p><p>合并两个有序数组是我们做过的一道题，一般来说可以开辟一个长度为两个区间之和的数组，然后双指针遍历两个数组即可。由此我们可以写出归并排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了节省空间，我们始终在一个额外数组上操作，避免创建很多新的临时变量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间内只有一个数字，开始回溯</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 把[start,mid]的合并结果存到temp的[start,mid]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">    <span class="comment">// 把[mid+1,end]的合并结果存到temp的[mid+1,end]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">// 合并[start, end]区间内两个有序区间</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 第一个区间的指针从start开始</span></span><br><span class="line">    <span class="type">int</span> index1 = start;</span><br><span class="line">    <span class="comment">// 第二个区间的指针从mid+1开始，同时记下第二个区间的开始位置</span></span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">            <span class="comment">// temp数组每次要放的位置是start+(index1-start)+(index2-start2)</span></span><br><span class="line">            <span class="comment">// 展开整理一下就是index1 + index2 - start2</span></span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下没遍历到的元素接到temp末尾</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">        ++index1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">        ++index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把temp合并的结果放回nums对应区间上，这样nums对应区间就变得有序了，便于下次合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-算法分析"><a href="#2-4-2-算法分析" class="headerlink" title="2.4.2 算法分析"></a>2.4.2 算法分析</h4><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$。空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 temp 数组。</p><p>我们在合并数组的时候的判断条件是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[index1] &lt;= nums[index2])</span><br></pre></td></tr></table></figure><p>这保证了归并排序是稳定的。如果没有等号则归并排序不再稳定。</p><h4 id="2-4-3-相关练习"><a href="#2-4-3-相关练习" class="headerlink" title="2.4.3 相关练习"></a>2.4.3 相关练习</h4><h5 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">合并排序的数组</a></h5><blockquote><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p></blockquote><p>因为 A 数组末尾提供了足够的空间，我们使用双指针逆序从两个数组末尾取出数字，把最大的放到A的末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa &gt;= <span class="number">0</span> &amp;&amp; pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[pa] &gt;= B[pb])</span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = A[pa];</span><br><span class="line">                --pa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">                --pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">            --pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h5><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p></blockquote><p>使用暴力法很简单但时间复杂度太高，这道题非常考验对归并排序的理解。</p><p>关键在于归并排序中合并有序数组的时候，如果左边数组中当前指针指向的数字 nums[left] 比右边数组中当前指针指向的数字 nums[right] 小，那么就把 nums[left] 加入答案，同时判断右边数组中有多少数字比 nums[left] 小，这就是 nums[left] 对整个数组逆序对数量的贡献，因为右边数组中比 nums[left] 小的数原本排在了 nums[left] 的右边，就构成了一个逆序对。而右边数组中比 nums[left] 小的数字数量刚好就是右边数组的当前指针 right 相对于右边数组起始位置 mid + 1 的偏移，因为在右边数组当前指针之前的数字都已经加入到了结果中，一定比 nums[left] 小。</p><p>按照上面的思路，我们只需要在归并排序中加一个统计逆序对数量的变量即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">        <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序区间，并统计逆序对数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> index1 = start;</span><br><span class="line">        <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">                ++index1;</span><br><span class="line">                <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">                cnt += index2 - start2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">            <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">            cnt += index2 - start2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后面的数组没有遍历完，说明剩下的所有数字都比前面的大，没有逆序对贡献</span></span><br><span class="line">        <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-时间复杂度为-O-n-的排序"><a href="#3-时间复杂度为-O-n-的排序" class="headerlink" title="3 时间复杂度为 $O(n)$ 的排序"></a>3 时间复杂度为 $O(n)$ 的排序</h2><p>这一类排序算法平均时间复杂度最优，但一般只适用于特定场景，在特定问题下的排序效率将高于其他算法。</p><h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><h4 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h4><p>计数排序的思想很简单，假设一个数组只包含 0 ~ 9 范围内的数字，那我们可以建立一个长度为 10 的数组，统计原数组中 0 ~ 9 各出现了几次，统计完成后再按顺序把数字填到数组中即可，整个过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="1620707085-FdqElS-计数排序"></p><p>但这样排序并不是真正的计数排序，因为我们这样做相当于只是把和原数组中数字相同的值放回了原数组中，而这些值已经不是原来的数字了，这在实际工程中如果待排序的对象有其他属性的话，这样做就会丢掉其他属性，于是我们可以建立一个哈希表，去存储每个数字对应的原来的数字（对象），最后再按顺序放回去即可。</p><p>真正的计数排序使用的方法更为巧妙，统计完计数数组后，遍历原数组，对原数组的每一个元素可以根据计数数组的结果得到它排序后应该在的位置，他应该在的位置就是起始位置加上所有比它小的数字之和，因此直接把该数字放到对应的位置上即可。同时为了处理更一般的情况，而不是只有 0 ~ 9，要先统计计数范围，计数范围就是数组中的最小值到最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> preCounts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置，即前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很好理解，计数排序还有另一种写法，即在统计对应元素所在位置的时候，不统计该元素在结果中起始位置的下标，而是统计最后一个位置的下标，然后遍历原数组的时候从后向前遍历，这样的写法可以避免记录 preCounts，效率更高，一般也常使用这种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数字在结果中的最后一个下标位置 = 比它小的数字数量 + 该数字的数量 - 1</span></span><br><span class="line">    <span class="comment">// 我们预先对counting[0]减去1，这样之后就不需要每次都减了</span></span><br><span class="line">    counting[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; range; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置</span></span><br><span class="line">        counting[i] += counting[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在遍历原数组放到结果数组中相应位置的时候，不逆序遍历也可以得到正确的结果，但只有逆序遍历才能保证计数排序的稳定性。</p><h4 id="3-1-2-算法分析"><a href="#3-1-2-算法分析" class="headerlink" title="3.1.2 算法分析"></a>3.1.2 算法分析</h4><p>从计数排序的实现代码中可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 $O(n + k)$，k 表示数据的范围大小。用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n + k)$。</p><p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。并且由此我们可以发现计数排序的一个致命的缺点，如果对下面的数组使用计数排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, INT_MAX&#125;;</span><br></pre></td></tr></table></figure><p>我们将会创建一个从 1 到 INT_MAX 的计数数组，C++ 中 int 占 4 字节，一个长度为 $2^{31}$ 的数组要占用 8G 的空间。所以计数排序只适用于数据范围不大的场景，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p><p>接下来我们考虑为什么计数排序可以突破 $O(nlogn)$ 的时间复杂度。<strong>因为计数排序不是基于比较的排序算法</strong>。</p><p>根据决策树理论可以推导出<strong>所有基于比较的排序算法最坏情况下都要做 $O(nlogn)$ 次比较</strong>，因此所有基于比较的排序算法无论怎么优化都不可能突破 $O(nlogn)$ 的下界，而基数排序不是基于比较的算法，是利用数字本身的属性进行排序，整个算法中没有出现任何一次比较。</p><h4 id="3-1-3-相关练习"><a href="#3-1-3-相关练习" class="headerlink" title="3.1.3 相关练习"></a>3.1.3 相关练习</h4><h5 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">数组的相对排序</a></h5><blockquote><p>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。</p><p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p></blockquote><p>我们可以按照计数排序的思想，统计每个数字出现的次数，然后根据 arr2 计算每个数字应该在结果中对应的左右一个下标位置，这样就可以把在 arr2 中出现过的数字排好，剩下没有出现过的放到数组末尾，然后再利用其他排序微调。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + countings[arr2[i<span class="number">-1</span>] - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(i + min) != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = map[i + min];</span><br><span class="line">                countings[i] = countings[i] + presum[t] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = countings[i];</span><br><span class="line">                countings[i] = countings[i] + presum[m] + offset - <span class="number">1</span>;</span><br><span class="line">                offset += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[countings[arr1[i] - min]] = arr1[i];</span><br><span class="line">            countings[arr1[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>() + presum[m], res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然这样做显然使问题变得更复杂了，上面用到了哈希表、前缀和等复杂的技巧，对于这道简单题来说是完全没有必要的，我们只要用伪计数排序的思想，统计数字出现的次数，然后按照 arr2 提供的顺序找到计数数组中该数字出现的次数，放到结果数组中即可，之后再遍历一次计数数组把出现次数不为 0 的数按顺序放到结果末尾即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[e - min]) &#123;</span><br><span class="line">                arr1[index] = e;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[e - min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr1[index] = i + min;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-基数排序"><a href="#3-2-基数排序" class="headerlink" title="3.2 基数排序"></a>3.2 基数排序</h3><h4 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h4><p>基数排序是通过对比数字的关键字进行排序的，关键字就称为基数，比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：</p><ul><li>先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系</li><li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li><li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li></ul><p>这就是基数排序的思路，上面的过程我们是从数字的最高位开始比较的，这样的基数排序叫做「最高位优先法」，简称 <code>MSD (Most significant digital)</code>，与之对应的还有「最低位优先法」，简称 <code>LSD (Least significant digital)</code>。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p><p>一般来说 LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p><p>基数排序可以分为以下三个步骤：</p><ul><li>找出数组中最大的数字的位数 maxDigitLength</li><li>获取数组中每个数字的基数</li><li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序</li></ul><p>对基数进行排序最好的办法就是使用计数排序，因为基数只可能在 0 ~ 9 之间，使用计数排序效率会很高，并且还能保证稳定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组中存在负数时，我们可以把计数排序的统计数组改为长度为19，用来统计 -9 ~ 9 出现的次数，但是要注意计算出的基数要加 9，以从 [-9, 9] 映射到计数数组下标 [0, 18]，完整的基数排序算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(value) &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">abs</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix + <span class="number">9</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix + <span class="number">9</span>]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-算法分析"><a href="#3-2-2-算法分析" class="headerlink" title="3.2.2 算法分析"></a>3.2.2 算法分析</h4><p>基数排序需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。所以基数排序的时间复杂度为 $O(d(n + k))$，其中 d 表示最长数字的位数，k 表示每个基数可能的取值范围大小。</p><p>基数排序使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。</p><h4 id="3-2-3-相关练习"><a href="#3-2-3-相关练习" class="headerlink" title="3.2.3 相关练习"></a>3.2.3 相关练习</h4><h5 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p><p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p></blockquote><p>因为要保证线性时间和空间复杂度，因此使用基数排序符合要求，排序后再遍历找到最大差值即可。</p><h5 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h5><blockquote><p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p><p>返回该最大总和 。</p></blockquote><p>排序后拆分即可。使用基数排序会使时间复杂度更低。</p><h3 id="3-3-桶排序"><a href="#3-3-桶排序" class="headerlink" title="3.3 桶排序"></a>3.3 桶排序</h3><h4 id="3-3-1-算法思想"><a href="#3-3-1-算法思想" class="headerlink" title="3.3.1 算法思想"></a>3.3.1 算法思想</h4><p>桶排序的思想是：</p><ul><li>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶</li><li>遍历数组，将每个数字装入桶中</li><li>对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等</li><li>最后按照顺序将所有桶内的数字合并起来</li></ul><p>桶排序一般只能在特定情况下使用，因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。</p><p>影响桶排序的效率的因素主要有两个：</p><ul><li>一个是桶的数量，桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。一般来说设置桶的数量要根据数组的数据量和数组内的最大值和最小值确定，一般用如下公式确定可以保证每个桶内的数字尽量均匀：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个桶的间距</span></span><br><span class="line">gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 桶的数量</span></span><br><span class="line">bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 数组内数字所在的桶的编号</span></span><br><span class="line">index = (nums[i] - min) / gap;</span><br></pre></td></tr></table></figure><ul><li>桶内排序算法，桶内排序算法可以使用插入排序、快速排序等，可以根据实际需要选择。</li></ul><p>基于插入排序的桶排序的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxnum = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minnum = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketnum);</span><br><span class="line">    <span class="comment">// 装桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (x - minnum) / gap;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序并放回原数组</span></span><br><span class="line">    arr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertsort</span>(buckets[i]);</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-算法分析"><a href="#3-3-2-算法分析" class="headerlink" title="3.3.2 算法分析"></a>3.3.2 算法分析</h4><p>我们逐步分析桶排序的时间复杂度和空间复杂度。</p><p>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><p>第二步：装桶的过程需要遍历一轮数组，时间复杂度 $O(n)$，空间复杂度与$O(n)$。</p><p>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 $n&#x2F;k$,</p><ul><li><p>如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n&#x2F;k)^2)$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k)^2)$，即 $O(n^2 &#x2F; k)$。</p></li><li><p>如果采用 $O(n\log n)$ 级排序算法，每个桶内排序的时间复杂度 $O((n&#x2F;k) \log (n&#x2F;k))$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k) \log (n&#x2F;k))$，即 $O(n \log (n&#x2F;k))$。</p></li></ul><p>在桶的数量合适的情况下，时间复杂度 $O(n^2 &#x2F; k)$ 和 $O(n \log (n&#x2F;k))$ 都约等于 $O(n)$。桶内排序的空间复杂度也和具体的排序算法有关，$O(1)$ 或者 $O(n)$。</p><p>第四步：桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><p>综上，桶排序的时间复杂度为 $O(n)$，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快。空间复杂度为 $O(n)$。</p><h4 id="3-3-3-相关练习"><a href="#3-3-3-相关练习" class="headerlink" title="3.3.3 相关练习"></a>3.3.3 相关练习</h4><h5 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p><p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p></blockquote><p>使用桶排序解决这个问题更加巧妙。甚至不需要真正进行排序，只要把所有数字放到对应的桶里，然后记录每个桶的最大值和最小值，最后从左到右遍历桶，用后一个桶的最小值减去前一个桶的最大值，所有这些差值中最大的就是题目所要求的最大间距。具体证明参考<a href="https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/">官方题解方法二</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = (maxVal - minVal) / n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketnum = (maxVal - minVal) / gap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketnum, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (nums[i] - minVal) / gap;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序&lt;/li&gt;
&lt;li&gt;时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序&lt;/li&gt;
&lt;li&gt;时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;排序数组&lt;/a&gt;题目实践这些算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（一）实现基本工具类</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-04-11T12:39:03.000Z</published>
    <updated>2022-04-11T13:36:40.833Z</updated>
    
    <content type="html"><![CDATA[<p>这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。</p><p><em><span id="more"></span></em></p><h3 id="1-三维向量类"><a href="#1-三维向量类" class="headerlink" title="1 三维向量类"></a>1 三维向量类</h3><p>尽管在正规的光线追踪器中使用更多的是四维向量，比如齐次坐标和带有 A 通道的颜色，但是对于我们这个简化的光线追踪器来说，三维向量已经足够了，我们可以使用三维向量表示位置、方向、颜色等，为了区分这三种表示，我们给三维向量类 <code>vec3</code>起两个别名 <code>point3</code> 和 <code>color</code> 以方便之后代码的编写和阅读，但他们实质上没有任何区别，我们没有为了不同的表示构造一个专门的类，这意味着一个颜色和一个位置可以进行相加，这在正常的光线追踪工程实现中是不被允许的，但我们毕竟是简化版本，只要在使用的时候注意即可。</p><p>我们首先在该类中实现一些基本的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  实现三维向量类，用于存储位置、向量、颜色等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类及常用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> e[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec3</span>() : e&#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="type">double</span> e0, <span class="type">double</span> e1, <span class="type">double</span> e2) : e&#123; e0, e1, e2 &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3 <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">        e[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">        e[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">        e[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        e[<span class="number">0</span>] *= t;</span><br><span class="line">        e[<span class="number">1</span>] *= t;</span><br><span class="line">        e[<span class="number">2</span>] *= t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e[<span class="number">0</span>] * e[<span class="number">0</span>] + e[<span class="number">1</span>] * e[<span class="number">1</span>] + e[<span class="number">2</span>] * e[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义vec3的别名，分别用于存储点和颜色，提升代码可读性</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;</span><br><span class="line"><span class="keyword">using</span> color = vec3;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在工程实践中，文件开头的 <code>#pragma once</code> 是必须的，否则可能因为头文件重复包含导致编译错误，定义类时的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也是必须的，同样是为了防止重复编译。</p><p>然后实现一些对向量操作的工具函数，大部分是运算符重载，以让我们可以按照之前的习惯操作三维向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******一些工具函数*******/</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应元素相乘</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向量和标量运算</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">double</span> t, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t * v.e[<span class="number">0</span>], t * v.e[<span class="number">1</span>], t * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>] + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>] + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叉乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">        u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">        u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单位化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">normalize</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用于最后的图像输出，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 注意输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-光线类"><a href="#2-光线类" class="headerlink" title="2 光线类"></a>2 光线类</h3><p>光线类是基于三维向量类的，我们按照图形学中射线的定义来实现一个光线类，给定空间中一个位置和一个方向就可以确定一条射线，再给定时间 t，就可以得到射线上任意一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现光线类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-图像输出"><a href="#3-图像输出" class="headerlink" title="3 图像输出"></a>3 图像输出</h3><p>我们所有渲染结果最终都要输出到一张图片中，我们可以选择任何输出格式，这里使用了非常方便的开源的图像工具 <a href="https://github.com/nothings/stb">stb_image </a>，将结果保存到数组中然后使用 <code>stbi_write_png</code> 函数保存为 PNG 格式图片。我们用一个生成渐变图片的例子来了解图像输出流程。</p><p>首先定义一个 <code>ray_color</code> 函数，根据给定的方向机型简单的线性插值，以混合两种不同的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据归一化的方向的y坐标线性混合白色和蓝色，以得到自上而下的蓝白色渐变效果</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义相机所在位置为 (0, 0, 0)，屏幕（输出的图片）比例为 16 : 9，因此我们的视口比例也要和最终的图片比例一致，然后从屏幕左上角开始遍历，从相机向屏幕投射光线，根据该光线方向通过 <code>ray_color</code> 函数计算插值颜色显示到屏幕上。场景大致如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/fig-1.03-cam-geom.jpg" alt="fig-1.03-cam-geom"></p><p>下面实现主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;BlendColor.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename; </span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，可以刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/BlendColor.png" alt="BlendColor"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（十）噪声纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-10T08:50:28.000Z</published>
    <updated>2022-04-10T08:52:45.330Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候，向规则的事物里添加一些“杂乱无章”的效果往往会有意想不到的效果。而这些“杂乱无章”的效果来源就是噪声。在本节中，我们将会学习如何使用噪声来模拟火焰消融、波光粼粼、云雾飘渺等各种特效。</p><p><em><span id="more"></span></em></p><h3 id="1-消融效果"><a href="#1-消融效果" class="headerlink" title="1 消融效果"></a>1 消融效果</h3><p><strong>消融 (dissolve)</strong> 效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。消融效果的原理非常简单，概括来说就是噪声纹理＋透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了图中被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的结果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Dissolve&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制消融程度，值为1时物体完全消融</span></span><br><span class="line">        _BurnAmount (&quot;Burn Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        <span class="comment">// 模拟烧焦效果时的线宽，值越大，火焰边缘的蔓延范围越广</span></span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span></span><br><span class="line">        <span class="comment">// 主纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 法线纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 火焰边缘的两种颜色值</span></span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 噪声纹理</span></span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭剔除，因为模型消融会使内部构造显现出来</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            fixed _LineWidth;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            fixed4 _BurnFirstColor;</span><br><span class="line">            fixed4 _BurnSecondColor;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            </span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uvMainTex : TEXCOORD0;</span><br><span class="line">                float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">                float3 lightDir : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;</span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                <span class="comment">// 光线从模型空间变换到切线空间，因为用到了法线纹理，要在切线空间计算光照</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                  o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                  <span class="comment">// 为了得到阴影信息，计算世界空间下的顶点位置以及阴影纹理的采样坐标</span></span><br><span class="line">                  o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 对噪声纹理采样</span></span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                <span class="comment">// 采样值和控制消融程度的参数相减传递给clip函数</span></span><br><span class="line">                <span class="comment">// 当结果小于0时该像素会被剔除，从而不显示到屏幕上</span></span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 切线空间的光照方向</span></span><br><span class="line">                float3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                <span class="comment">// 对法线纹理采样</span></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">                <span class="comment">// 反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 在切线空间计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算烧焦的颜色，要在宽度为_LineWidth范围内模拟一个烧焦的颜色变化</span></span><br><span class="line">                <span class="comment">// 首先计算混合系数t，如果t的值为1说明位于消融的边界，t为0时像素为正常的模型颜色</span></span><br><span class="line">                fixed t = <span class="number">1</span> - <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 使用t混合两种烧焦颜色</span></span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line">                <span class="comment">// 使用pow对结果进行处理得到最终的烧焦颜色</span></span><br><span class="line">                burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="comment">// 再次使用t来混和光照颜色和烧焦颜色，使用step函数保证_BurnAmount为0时不显示任何消融效果</span></span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * <span class="built_in">step</span>(<span class="number">0.0001</span>, _BurnAmount));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 投射阴影的Pass</span></span><br><span class="line">        <span class="comment">// 因为用到了透明度测试，因此不能用默认的阴影投射Pass，不然被剔除的部分也会投射阴影造成穿帮</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 正确设置tags</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// 对应的编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">// 使用Unity内置宏定义投射阴影需要的变量，已经包含了各种需要用到的变量</span></span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用Unity内置的宏来计算阴影需要一些特定的输入</span></span><br><span class="line">            <span class="comment">// 比如TRANSFER_SHADOW_CASTER_NORMALOFFSET会使用名称v作为输入结构体，v中需要包含顶点位置和顶点法线</span></span><br><span class="line">            <span class="comment">// 内置的appdata_base结构体提供了这些必要的变量</span></span><br><span class="line">            v2f vert(appdata_base v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 使用内置的宏填充上面声明的各种变量</span></span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 剔除片元后，使用内置的宏计算阴影投射</span></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个 cs 脚本来随着时间控制材质的 _BurnAmount 属性：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BurnHelper</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.01f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> burnSpeed = <span class="number">0.3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> burnAmount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponentInChildren&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer != <span class="literal">null</span>) &#123;</span><br><span class="line">                material = renderer.material;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        burnAmount = Mathf.Repeat(Time.time * burnSpeed, <span class="number">1.0f</span>);</span><br><span class="line">        material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, burnAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/burn.gif" alt="burn"></p><h3 id="2-水波效果"><a href="#2-水波效果" class="headerlink" title="2 水波效果"></a>2 水波效果</h3><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射＋折射计算，得到最后的水面波动效果。在本节中，我们将会使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅耳反射的水面效果。</p><p>首先我们定义一个平面作为水面，类似于之前我们利用反射和折射实现透明玻璃的效果，我们使用一张立方体纹理 (Cubemap) 作为环境纹理，模拟反射；使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。但与之前的实现不同，水波的法线纹理是由一张噪声纹理生成而得，而且会随着时间不断平移变化，模拟波光粼粼的效果。此外，我们没有使用一个定值来混合反射和折射的颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数，我们使用如下公式计算菲涅尔系数：<br>$$<br>fresnel &#x3D; pow(1-max(0,\vec v ·\vec n),4)<br>$$<br>其中 $\vec v$ 和 $\vec n$ 分别对应了视角方向和法线方向，他们之间的夹角越小，得到的菲涅尔系数就越小，反射越弱，折射越强。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Water Wave&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制水面颜色</span></span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 水面波纹材质纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 噪声纹理生成的法线纹理</span></span><br><span class="line">        _WaveMap (&quot;Wave Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 环境纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 控制法线纹理再x和y方向上的平移速度</span></span><br><span class="line">        _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        <span class="comment">// 控制模拟折射时的扭曲程度</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 透明队列，在所有不透明物体之后渲染</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取屏幕图像作为渲染纹理</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _WaveMap;</span><br><span class="line">            float4 _WaveMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            fixed _WaveXSpeed;</span><br><span class="line">            fixed _WaveYSpeed;</span><br><span class="line">            <span class="type">float</span> _Distortion;    </span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 根据裁剪空间坐标计算被抓取的屏幕图像的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                <span class="comment">// 纹理坐标转换</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的变换矩阵，并存储世界空间下的顶点坐标</span></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界坐标</span></span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                <span class="comment">// 根据世界坐标计算世界空间的视角方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                <span class="comment">// 计算法线纹理当前在x和y方向的偏移量</span></span><br><span class="line">                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理采样两次，为了得到两层交叉的水面波动效果</span></span><br><span class="line">                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">                <span class="comment">// 两次采样结果相加并归一化得到切线空间下的法线方向</span></span><br><span class="line">                fixed3 bump = <span class="built_in">normalize</span>(bump1 + bump2);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 利用切线空间的法线方向计算对屏幕图像的采样坐标偏移</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 偏移量乘以z分量是为了得到深度越大折射程度越大的效果</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 经过透视除法后对屏幕图像采样得到模拟的折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 采样得到水波颜色，也要随时间偏移</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">                <span class="comment">// 根据世界空间下的法线方向和视线方向计算得到反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-viewDir, bump);</span><br><span class="line">                <span class="comment">// 利用反射方向对环境贴图采样，并结合水波颜色得到最终的反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔系数</span></span><br><span class="line">                fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(<span class="built_in">dot</span>(viewDir, bump)), <span class="number">4</span>);</span><br><span class="line">                <span class="comment">// 利用菲涅尔系数结合反射颜色和折射颜色</span></span><br><span class="line">                fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要投射阴影，因此关掉FallBack</span></span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了用噪声纹理生成法线纹理，我们在该噪声纹理的属性面板中把纹理类型改为 Normal map，并勾选 Create from grayscale，使其从灰度值生成法线纹理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/image-20220410161026859.png" alt="image-20220410161026859"></p><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water.gif" alt="water"></p><p>此时我们的视线方向和水面法线夹角大，反射强，折射弱，我们更容易看到水面的颜色，而水面的颜色是环境反射颜色和水波本身颜色的结合；当我们减小视线方向和水面法线夹角时，效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water2.gif" alt="water2"></p><p>此时反射弱，折射强，我们不容易看到水面本身的颜色，更容易透过水面看到折射后的扭曲的地面。</p><h3 id="3-再谈全局雾效"><a href="#3-再谈全局雾效" class="headerlink" title="3 再谈全局雾效"></a>3 再谈全局雾效</h3><p>我们之前学习了如何使用深度纹理来实现一种基于屏幕后处理的全局雾效。我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色。这样实现的效果在同一高度下雾的浓度是相同的，但很多时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，这就可以通过使用噪声纹理来实现。</p><p>大部分代码和之前的全局雾效一样，只不过加入了噪声相关的参数和属性，并在 Shader 的片元着色器中对雾效混合系数的计算添加了噪声的影响。</p><p>首先是 cs 脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithNoise</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义噪声纹理的变量</span></span><br><span class="line">    <span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line">    <span class="comment">// 噪声纹理在x和y方向的移动速度，模拟飘渺的效果</span></span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 控制噪声程度，值为0代表不应用噪声，得到和之前一样的均匀雾效</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本可用时，摄像机生成深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            </span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            </span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line">            </span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">            </span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Fog With Noise&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _NoiseTex (&quot;Noise Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _NoiseAmount (&quot;Noise Amount&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        <span class="type">sampler2D</span> _NoiseTex;</span><br><span class="line">        half _FogXSpeed;</span><br><span class="line">        half _FogYSpeed;</span><br><span class="line">        half _NoiseAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 还原像素对应的点在世界空间的位置</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 计算采样坐标偏移</span></span><br><span class="line">            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);</span><br><span class="line">            <span class="comment">// 利用偏移量对噪声纹理采样，结果减去0.5并乘以控制噪声程度的属性得到最终的噪声值</span></span><br><span class="line">            <span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount;</span><br><span class="line">            <span class="comment">// 利用噪声计算雾效混合系数</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise));</span><br><span class="line">            <span class="comment">// 利用雾效混合系数混合雾效颜色和原颜色</span></span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;              </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/fog-16495801644531.gif" alt="fog"></p><h3 id="4-噪声纹理从何而来"><a href="#4-噪声纹理从何而来" class="headerlink" title="4 噪声纹理从何而来"></a>4 噪声纹理从何而来</h3><p>噪声纹理一般属于程序纹理，它们都是由计算机利用某些算法生成的。<a href="https://en.wikipedia.org/wiki/Perlin%E2%80%94noise">Perlin 噪声</a>和<a href="https://en.wikipedia.org/wiki/Worley_noise">Worley 噪声</a>是两种最常使用的噪声类型，上面的全局雾效使用的噪声纹理就是由 Perlin 噪声生成而来。 Perlin 噪声可以用于生成更自然的噪声纹理，而 Worley 噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。更多关于噪声纹理的内容可以查看 <a href="http://adrianb.io/2014/08/09/perlinnoise.html">Understanding Perlin Noise</a> 以及其他博客。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多时候，向规则的事物里添加一些“杂乱无章”的效果往往会有意想不到的效果。而这些“杂乱无章”的效果来源就是噪声。在本节中，我们将会学习如何使用噪声来模拟火焰消融、波光粼粼、云雾飘渺等各种特效。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（九）非真实感渲染</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/</id>
    <published>2022-04-09T11:31:16.000Z</published>
    <updated>2022-04-09T11:33:59.647Z</updated>
    
    <content type="html"><![CDATA[<p>尽管游戏渲染一般都是以照相写实主义（photorealism）作为主要目标，但也有许多游戏使用了非真实感渲染（Non-Photorealistic Rendering,  NPR）的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p><p><em><span id="more"></span></em></p><h3 id="1-卡通风格的渲染"><a href="#1-卡通风格的渲染" class="headerlink" title="1 卡通风格的渲染"></a>1 卡通风格的渲染</h3><p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等。</p><p>要实现卡通渲染有很多方法，其中之一就是使用**基于色调的着色技术 (tone-based shading)**。实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，我们在之前的渐变纹理中实现过这样的效果。卡通风格的高光效果也和我们之前学习的光照不同。在卡通风格中，模型的高光往往是一块块分界明显的纯色区域。</p><p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。在前两节我们曾使用屏幕后处理技术对屏幕图像进行描边。在本节，我们将会使用基于模型的描边方法，这种方法的实现更加简单，而且在很多情况下也能得到不错的效果。</p><h4 id="1-1-渲染轮廓线"><a href="#1-1-渲染轮廓线" class="headerlink" title="1.1 渲染轮廓线"></a>1.1 渲染轮廓线</h4><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近 20 年来，有许多绘制模型轮廓线的方法被先后提出来，在《RTR3》中作者将这些方法分为了 5 类：</p><ul><li>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</li><li>过程式几何轮廓线渲染。这种方法的核心是使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样的平整模型。</li><li>基于图像处理的轮廓线渲染。我们之前使用的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</li><li>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：</li></ul><p>$$<br>(\vec n_0·\vec v&gt;0) \neq (\vec n_1·\vec v&gt;0)<br>$$</p><p>其中 $\vec n_0$ 和 $\vec n_1$ 是两个相邻三角面片的法向量，$\vec v$ 是从视角到该边上任意顶点的方向。上述公式本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器 (Geometry Shader) 的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</p><ul><li>最后一个种类就是混合了上述的几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</li></ul><p>在本节中，我们将会在 Unity 中使用过程式几何轮廓线渲染的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure><p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewNormal.z = <span class="number">-0.5</span>;</span><br><span class="line">viewNormal = <span class="built_in">normalize</span>(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure><h4 id="1-2-添加高光"><a href="#1-2-添加高光" class="headerlink" title="1.2 添加高光"></a>1.2 添加高光</h4><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。类似于 Blinn-Phong 光照的高光计算，我们先计算法线和半程向量的点积，但不进行指数计算，而是将点积结果和一个阈值对比，如果小于该阈值，则高光系数为 0，否则高光系数为 1。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = <span class="built_in">step</span>(threshold, spec);</span><br></pre></td></tr></table></figure><p>step 函数是 CG 的内置函数，它比较参考值和给定值的大小，如果给定值大于参考值返回 1，否则返回 0。</p><p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如下图。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409173101155.png" alt="image-20220409173101155"></p><p>出现这种问题的原因在于，高光区域的边缘不是平滑渐变的，而是由 0 突变到 1 。要想对其进行抗锯齿处理，我们可以在边界处很小一块区域内进行平滑处理：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec - threshold));</span><br></pre></td></tr></table></figure><p>smoothstep 函数是 CG 的内置函数，其中 w 是一个很小的值，当 spec - threshold 小于 -w 时返回 0，当 spec - threshold 大于 w 时返回 1，在 [-w, w] 之间时，在 0 到 1 之间插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界附近，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在下面的实现中，我们选择使用邻域像素之间的近似导数值，这可以通过 CG 的 fwidth 函数来得到。</p><h4 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h4><p>实现代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制漫反射色调的渐变纹理</span></span><br><span class="line">        _Ramp (&quot;Ramp Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制轮廓线宽度，</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _OutlineColor (&quot;Outline Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//计算高光反射时的阈值</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//描边在非真实感渲染中很常用，方便后面调用</span></span><br><span class="line">            NAME &quot;OUTLINE&quot;</span><br><span class="line">            <span class="comment">//剔除掉正面的部分，只渲染背面</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;; </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//模型空间下的顶点和法线变换到视角空间下，为了让描边再观察空间达到最好的效果</span></span><br><span class="line">                float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  </span><br><span class="line">                <span class="comment">//扩张顶点位置</span></span><br><span class="line">                normal.z = <span class="number">-0.5</span>;</span><br><span class="line">                pos = pos + float4(<span class="built_in">normalize</span>(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">                <span class="comment">//变换到裁剪空间下</span></span><br><span class="line">                o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                <span class="comment">//用轮廓线颜色渲染整个背面</span></span><br><span class="line">                <span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>);               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算光照的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//剔除背面</span></span><br><span class="line">            Cull Back</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">        </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _Ramp;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            fixed _SpecularScale;</span><br><span class="line">        </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;; </span><br><span class="line">        </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;</span><br><span class="line">                float3 worldPos : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 worldHalfDir = <span class="built_in">normalize</span>(worldLightDir + worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//阴影和衰减</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">                fixed diff =  <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line">                <span class="comment">//半兰伯特漫反射系数乘以阴影值得到最终的漫反射系数</span></span><br><span class="line">                diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">                <span class="comment">//利用漫反射系数对渐变纹理采样并计算漫反射颜色</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">                <span class="comment">//按照公式计算高光</span></span><br><span class="line">                fixed spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">                fixed w = <span class="built_in">fwidth</span>(spec) * <span class="number">2.0</span>;</span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * <span class="built_in">step</span>(<span class="number">0.0001</span>, _SpecularScale);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409180228375.png" alt="image-20220409180228375"></p><h3 id="2-素描风格的渲染"><a href="#2-素描风格的渲染" class="headerlink" title="2 素描风格的渲染"></a>2 素描风格的渲染</h3><p>另一个非常流行的非真实感渲染是素描风格的渲染。微软研究院的 Praun 等人在 2001 年的 SIGGRAPH 上发表了一篇非常著名的论文。在这篇文章中，他们使用了提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个色调艺术映射 (Tonal Art Map, TAM), 如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409191551680.png" alt="image-20220409191551680"></p><p>从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理 (MipMaps) 。这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果。</p><p>本节将会实现简化版的论文中提出的算法，我们不考虑多级渐远纹理的生成，而直接使用 6 张素描纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Hatching&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 纹理的平铺系数，值越大模型上素描线条越密</span></span><br><span class="line">        _TileFactor (&quot;Tile Factor&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _Hatch0 (&quot;Hatch <span class="number">0</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch1 (&quot;Hatch <span class="number">1</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch2 (&quot;Hatch <span class="number">2</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch3 (&quot;Hatch <span class="number">3</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch4 (&quot;Hatch <span class="number">4</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch5 (&quot;Hatch <span class="number">5</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading/OUTLINE&quot;</span><br><span class="line">        <span class="comment">//渲染素描效果</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _TileFactor;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch0;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch1;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch2;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch3;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch4;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch5;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float3 normal : NORMAL; </span><br><span class="line">                float2 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储混合六张纹理的权重</span></span><br><span class="line">                fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line">                float3 worldPos : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//根据_TileFactor得到纹理坐标</span></span><br><span class="line">                o.uv = v.texcoord.xy * _TileFactor;</span><br><span class="line">                <span class="comment">//计算逐顶点光照，使用漫反射系数计算混合不同纹理的权重</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">//权重初始化为0</span></span><br><span class="line">                o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//把diff缩放到[0,7]</span></span><br><span class="line">                <span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;</span><br><span class="line">                <span class="comment">//把[0,7]均匀的分成七个子区间，判断hatchFactor所处的区间，以决定混合权重</span></span><br><span class="line">                <span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Pure white, do nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">                    o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">                    o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">                    o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">                    o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;            </span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line">                <span class="comment">//留白</span></span><br><span class="line">                fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line">                </span><br><span class="line">                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                                </span><br><span class="line">                <span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409192908015.png" alt="image-20220409192908015"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;尽管游戏渲染一般都是以照相写实主义（photorealism）作为主要目标，但也有许多游戏使用了非真实感渲染（Non-Photorealistic Rendering,  NPR）的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（八）高级屏幕特效</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</id>
    <published>2022-04-09T09:05:49.000Z</published>
    <updated>2022-04-09T09:08:29.931Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中，我们学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。例如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多我们不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。在本节中，我们将学习如何在 Unity 中获取深度纹理和法线纹理来实现特定的屏幕后处理效果。</p><p><em><span id="more"></span></em></p><h3 id="1-获取深度和法线纹理"><a href="#1-获取深度和法线纹理" class="headerlink" title="1 获取深度和法线纹理"></a>1 获取深度和法线纹理</h3><p>虽然在 Unity 里获取深度和法线纹理的代码非常简单，但是我们有必要在这之前首先了解它们背后的实现原理。</p><h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h4><p>深度纹理实际就是一张渲染纹理，只不过他里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是 [0, 1]，而且通常是非线性分布的。这些深度值来自于顶点变换后得到的归一化设备坐标 NDC，回顾之前学习过的投影变换，下图显示了正交投影过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142854239.png" alt="image-20220409142854239"></p><p>下图显示了透视投影过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142931627.png" alt="image-20220409142931627"></p><p>深度值就来自于经过透视除法后的 NDC 中顶点坐标的 z 分量的值，由于 NDC 中 z 分量的范围在 [-1, 1]，因此还要把它映射到 [0, 1] 以存储在纹理中。</p><p>那么 Unity 是怎么得到这样一张深度纹理的呢？在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。通常来讲，当使用延迟渲染路径时，深度纹理理所当然可以访问到，因为延迟渲染会把这些信息渲染到 G-buffer 中 。而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染而得的 。具体实现是，Unity 会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断他们使用的渲染队列是否小于等于 2500（(内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件就把它渲染到深度和法线纹理中，因此，要想让物体能够出现在深度和法线纹理中，就必须正确设置 RenderType 标签。</p><p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度＋法线纹理。当选择前者，即只需要一张单独的深度纹理时， Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass（即 LightMode 被设置为ShadowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass, 那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。如果选择生成一张深度＋法线纹理， Unity 会创建一张和屏幕分辨率相同、精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。</p><p>法线信息的获取在延迟渲染中是可以非常容易就得到的， Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。这个 Pass 被包含在 Unity 内置的一个 Unity Shader 中，我们可以在内置的 <code>builtin_ shaders-xxx/DefaultResources/Camera-DepthNormaITexture.shader</code> 文件中找到这个用于渲染深度和法线信息的 Pass。</p><h4 id="1-2-获取"><a href="#1-2-获取" class="headerlink" title="1.2 获取"></a>1.2 获取</h4><p>在 Unity 中，获取深度纹理是非常简单的，只需要在在脚本中设置摄像机的 <code>depthTextureMode</code> 即可，然后就可以在 Shader 中直接访问特定的纹理属性了。我们可以使用下面的代码获取深度纹理：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br></pre></td></tr></table></figure><p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 <code>_CameraDepthTexture</code> 变量来访问它。</p><p>同理，如果想要获取深度＋法线纹理，我们只需要在代码中这样设置：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure><p>然后在 Shader 中通过声明 <code>_CameraDepthNormalsTexture</code> 变量来访问它。</p><p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度 + 法线纹理：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">camera.depthTextureMode |= DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure><p>当在 Shader 中访问到深度纹理 <code>_CameraDepthTexture</code> 后，我们就可以使用当前像素的纹理坐标对它进行采样，绝大多数情况下直接使用 <code>Tex2D</code> 即可，但在某些平台可能需要一些特殊处理， Unity 为我们提供了一个统一的宏 <code>SAMPLE_DEPTH_TEXTURE</code>，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE (_CameraDepthTexture, i.uv);</span><br></pre></td></tr></table></figure><p>当通过纹理采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使 用的裁剪矩阵。 然而，在我们的计算过程中通常是需要线性的深度值，也就是说，我们需要把投 影后的深度值变换到线性空间下，例如视角空间下的深度值。Unity 提供了两个辅助函数来进行转换，<code>LinearEyeDepth</code> 负责把深度纹理的采样结果转换到视角空间下的深度值，<code>Linear01Depth</code> 则会返回一个范围在 [0, 1] 的线性深度值。转换这部分的推导可以查看《Unity Shader 入门精要》13.1.2 节的内容。</p><p>如果我们需要获取深度＋法线纹理，可以直接使用 tex2D 函数对 <code>_CameraDepthNormalsTexture</code> 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 <code>DecodeDepthNormal</code>，该函数的第一个参数是对深度＋法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是视角空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 <code>DecodeDepthNormal</code> 函数对采样结果解码后，我们就可以得到解码后的深度值和法线。这个深度值是范围在 [0, 1] 的线性深度值（这与单独的深度纹理中存储的深度值不同），而得到的法线则是视角空间下的法线方向。<code>DecodeDepthNormal</code> 函数如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline <span class="type">void</span> DecodeDepthNormal (float4 enc, <span class="keyword">out</span> <span class="type">float</span> depth, <span class="keyword">out</span> float3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.ze);</span><br><span class="line">    normal = DecodeViewNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以自己用 <code>DecodeFloatRG</code> 和 <code>DecodeViewNormalStereo</code> 函数解码。</p><h3 id="2-再谈运动模糊"><a href="#2-再谈运动模糊" class="headerlink" title="2 再谈运动模糊"></a>2 再谈运动模糊</h3><p>在上一节中，我们学习了如何通过混合多张屏幕图像来模拟运动模糊的效果。但是，另一种应用更加广泛的技术则是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。速度缓冲的生成有多种方法，一种方法是把场景中所有物体的速度渲染到一张纹理中。但这种方法的缺点在于需要修改场景中所有物体的 Shader 代码，使其添加计算速度的代码并输出到一个渲染纹理中。</p><p>《GPU Gems3》在<a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch27.html">第 27 章</a>中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角＊投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的，当得到世界空间中的顶点坐标后，我们使用前一帧的视角＊投影矩阵对其进行变换， 得到该位置在前一帧中的 NDC 坐标。然后，我们计算前一帧和当前帧的位置差，生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p><p>我们首先来编写 cs 脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlurWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于要用到摄像机的视角和投影矩阵，因此要定义一个Cmaera类型的变量以获取该脚本所在的摄像机组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊时模糊图像使用的大小</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于保存前一帧的视角*投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当脚本可用时，设置摄像机的状态以获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">        previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line">            <span class="comment">// 给材质传递前一帧的视角 * 投影矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);</span><br><span class="line">            <span class="comment">// 计算当前帧的视角 * 投影矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">// 求逆</span></span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            <span class="comment">// 给材质传递前帧的视角 * 投影矩阵的逆矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">            <span class="comment">// 更新前一帧的视角 * 投影矩阵</span></span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Motion Blur With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="comment">// Unity提供的深度纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        <span class="comment">// 两个矩阵由脚本传递而来</span></span><br><span class="line">        float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">        float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">        half _BlurSize;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            <span class="comment">// 主纹理和深度纹理采样坐标是一样的</span></span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="comment">// 平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 获取当前像素的深度值，通过对深度纹理采样得到</span></span><br><span class="line">            <span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);</span><br><span class="line">            <span class="comment">// 构造该像素的NDC坐标，通过对深度纹理进行反映射得到</span></span><br><span class="line">            <span class="comment">// 因为深度纹理的深度是从NDC的z坐标映射到[0, 1]范围的，所以再映射回去作为z分量</span></span><br><span class="line">            <span class="comment">// NDC的xy分量通过纹理坐标的xy映射而来</span></span><br><span class="line">            float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对NDC进行VP变换的逆变换并将结果除以w分量，以得到世界空间下的顶点坐标</span></span><br><span class="line">            float4 D = mul(_CurrentViewProjectionInverseMatrix, H);</span><br><span class="line">            float4 worldPos = D / D.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前屏幕空间坐标</span></span><br><span class="line">            float4 currentPos = H;</span><br><span class="line">            <span class="comment">// 用计算得到的世界空间坐标乘以前一帧的VP变换矩阵得到前一帧的屏幕空间坐标，同样要记得除以w分量  </span></span><br><span class="line">            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);</span><br><span class="line">            previousPos /= previousPos.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算前一帧和后一帧屏幕坐标的差以得到该像素的速度</span></span><br><span class="line">            float2 velocity = (currentPos.xy - previousPos.xy)/<span class="number">2.0</span>f;</span><br><span class="line">            </span><br><span class="line">            float2 uv = i.uv;</span><br><span class="line">            float4 c = tex2D(_MainTex, uv);</span><br><span class="line">            <span class="comment">// 利用该速度值对该像素的邻域像素进行采样，_BlurSize控制采样距离</span></span><br><span class="line">            <span class="comment">// 采样结果相加后取平均得到模糊效果</span></span><br><span class="line">            uv += velocity * _BlurSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">                float4 currentColor = tex2D(_MainTex, uv);</span><br><span class="line">                c += currentColor;</span><br><span class="line">            &#125;</span><br><span class="line">            c /= <span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;      </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                    </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有运动模糊的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p><p>使用上面的方法得到的运动模糊效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p><h3 id="3-全局雾效"><a href="#3-全局雾效" class="headerlink" title="3 全局雾效"></a>3 全局雾效</h3><p>雾效（Fog）是游戏里经常使用的一种效果。 Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点／片元着色器中实现这些雾效，我们需要在 Shader 中添加 <code>#pragma multi_compile_fog</code> 指令，同时还需要使用相关的内置宏，例如 <code>UNITY_FOG_COORDS</code> 、<code>UNITY_TRANSFER_FOG</code> 和 <code>UNTTY_APPLY_FOG</code> 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p><p>在本节中，我们将会学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染的物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性&#x2F;指数雾效、基于高度的雾效等。</p><p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。尽管我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机的视角＊投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。在本节中，我们将会学习一个快速从深度纹理中重建世界坐标的方法。</p><p>这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</p><h4 id="3-1-重建世界坐标"><a href="#3-1-重建世界坐标" class="headerlink" title="3.1 重建世界坐标"></a>3.1 重建世界坐标</h4><p>我们知道，坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得建像素的世界坐标就是基于这样的思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标。整个过程可以使用下面的代码来表示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;</span><br></pre></td></tr></table></figure><p>其中，<code>_WorldSpaceCameraPos</code> 可以通过内置变量直接访问，<code>linearDepth * interpolatedRay</code> 则可以计算得到该像素相对于摄像机的偏移量，<code>linearDepth</code> 是由深度纹理得到的线性深度值， <code>interpolatedRay</code> 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。<code>linearDepth</code> 的获取我们已经学习过了，因此，现在来看 <code>interpolatedRay</code> 的求法。</p><p><code>interpolatedRay</code> 来源于对近裁剪平面的 4 个角的某个特定向量的插值，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、 FOV、横纵比计算而得，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409154810612.png" alt="image-20220409154810612"></p><p>为了方便计算，我们可以先计算两个辅助向量—— $toTop$ 和 $toRight$，他们是起点位于近裁剪平面中心，分别指向摄像机正上方和正右方的向量，计算公式如下：<br>$$<br>halfHeight &#x3D; Near \times tan(\frac{FOV}{2})    \<br>toTop &#x3D; HalfHeight · camera.up    \<br>toRight &#x3D; HalfHeight · camera.right<br>$$<br>其中，$Near$ 是近裁剪平面的距离，$FOV$ 是竖直方向的视角范围，$camera.up$ 、 $camera.right$ 分别对应了摄像机的正上方和正右方。当得到这两个辅助向量后，我们就可以计算 4 个角相对于摄像机的方向了。以左上角TL为例：<br>$$<br>TL &#x3D; camera.forward · Near + toTop - toRight<br>$$<br>通过看图，上式很容易理解，同理其他三个角的向量：<br>$$<br>TR &#x3D; camera.forward · Near + toTop + toRight    \<br>BL &#x3D; camera.forward · Near - toTop - toRight    \<br>BR &#x3D; camera.forward · Near - toTop + toRight<br>$$<br>注意，上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点到摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409155500256.png" alt="image-20220409155500256"></p><p>因此我们不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到摄像机的偏移量，不过想要把深度值转换成到摄像机的欧式距离也很简单，我们以 TL 点为例，根据相似三角形原理，<strong>TL 所在的射线上</strong>，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即：<br>$$<br>\frac{depth}{dist} &#x3D; \frac{Near}{|TL|}<br>$$<br>由此即可得到 TL 射线上的点距离摄像机的欧氏距离：<br>$$<br>dist &#x3D; depth \times \frac{|TL|}{Near}<br>$$<br>由于 4 个点相互对称，因此其他 3 个向量的模和 TL 相等，即我们可以使用同一个因子：<br>$$<br>scale &#x3D; \frac{|TL|}{|Near|}<br>$$<br>和单位向量相乘，得到它们对应的向量值：<br>$$<br>Ray_{TL} &#x3D; \frac{TL}{|TL|}\times scale \<br>Ray_{TR} &#x3D; \frac{TR}{|TR|}\times scale \<br>Ray_{BL} &#x3D; \frac{BL}{|BL|}\times scale \<br>Ray_{BR} &#x3D; \frac{BR}{|BR|}\times scale<br>$$<br>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到 interpolatedRay，我们就可以直接利用一开始提到的公式重建该像素在世界空间的位置了。</p><h4 id="3-2-雾的计算"><a href="#3-2-雾的计算" class="headerlink" title="3.2 雾的计算"></a>3.2 雾的计算</h4><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原颜色和雾的颜色的混合系数：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 afterFog = f * fogColor + (<span class="number">1</span> - f) * oriColor</span><br></pre></td></tr></table></figure><p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支待三种雾的计算方式，给定距离 z 后，f 的计算方式如下:</p><ul><li>线性：</li></ul><p>$$<br>f &#x3D; \frac{d_{max} - |z|}{d_{max} - d_{min}}<br>$$</p><p>其中 $d_{min}$ 和 $d_{max}$ 分别表示受雾影响的最小距离和最大距离。</p><ul><li>指数：</li></ul><p>$$<br>f &#x3D; e^{-d·|z|}<br>$$</p><p>其中 d 是控制雾的浓度的参数。</p><ul><li>指数平方：</li></ul><p>$$<br>f &#x3D; e^{-(d-|z|)^2}<br>$$</p><p>其中 d 是控制雾的浓度的参数。</p><p>在本节中，我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，用给定一点在世界空间下的高度 y 后替换线性计算公式中的距离 z。</p><h4 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h4><p>首先是 cs 脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要获取摄像机的相关参数，如近裁剪平面的距离、FOV等，同时还需要获取摄像机在世界空间下的前方、上方和右方等方向</span></span><br><span class="line">    <span class="comment">//因此我们用两个变量存储摄像机的Camera组件和Transform组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义模拟雾效的各个参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line">    <span class="comment">//受雾效影响的最小高度和最大高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="comment">//设置相机状态获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//计算近裁剪平面4个角对应的向量</span></span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Fog With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">// 找到对应的顶点的向量，虽然有很多if判断，但实际上我们渲染的四边形只有4个顶点，因此对性能不会有太大影响</span></span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">//得到像素的线性深度</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            <span class="comment">//按照公式计算该像素对应的世界空间坐标</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 按照公式计算雾效系数f，使用_FogDensity控制雾效浓度</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line">            </span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">//利用雾效系数混合原颜色和雾效颜色</span></span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                     </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/fog.gif" alt="fog"></p><h3 id="4-再谈边缘检测"><a href="#4-再谈边缘检测" class="headerlink" title="4 再谈边缘检测"></a>4 再谈边缘检测</h3><p>之前我们使用 Sobel 算子对屏幕图像进行边缘检测，实现描边的效果。但是，这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163748909.png" alt="image-20220409163748909"></p><p>可以看出，物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。在本节中我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163828336.png" alt="image-20220409163828336"></p><p>本节使用 Roberts 算子来进行边缘检测，它使用的卷积核如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163911506.png" alt="image-20220409163911506"></p><p>Roberts 算子的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。我们在实现中取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值（可由参数控制），就认为它们之间存在一条边。</p><p>首先是 cs 脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectNormalsAndDepth</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line">    <span class="comment">//采样距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的深度相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的法线相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//设置摄像机产生深度+法线纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常情况下OnRenderImage函数会在所有不透明和透明物体渲染完后被调用</span></span><br><span class="line">    <span class="comment">//但我们希望边缘检测只对不透明物体描边，因此使用下面的ImageEffectOpaque声明</span></span><br><span class="line">    <span class="comment">//使得OnRenderImage函数在不透明物体渲染完后立即调用</span></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        half4 _Sensitivity;</span><br><span class="line">        <span class="comment">//深度+法线纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">//四个对角线邻域的纹理坐标，在顶点着色器计算出坐标之后插值传递给片元着色器以减少性能开销</span></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用来判断深度+法线纹理上的两个采样点的深度和法线的差异</span></span><br><span class="line">        half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">            <span class="comment">//解码得到两个采样点的法线和深度值</span></span><br><span class="line">            <span class="comment">//法线并没有解码成真正的法线值，直接使用了xy分量</span></span><br><span class="line">            <span class="comment">//这是因为我们只需要两个法线的差异，不需要知道真正的法线是什么</span></span><br><span class="line">            half2 centerNormal = center.xy;</span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">            half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算法线的差异乘以灵敏度</span></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="comment">// 差异的xy分量相加和阈值比较，如果小于该阈值返回1，否则返回0</span></span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">            <span class="comment">// 计算深度差异乘以灵敏度</span></span><br><span class="line">            <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="comment">// 同上对比两个深度值差异是否满足条件</span></span><br><span class="line">            <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将法线和深度差异的结果相乘返回</span></span><br><span class="line">            <span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            edge *= CheckSame(sample1, sample2);</span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line">            </span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM      </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170023348.png" alt="image-20220409170023348"></p><p>只显示描边：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170127466.png" alt="image-20220409170127466"></p><p>当我们增大采样距离，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170051494.png" alt="image-20220409170051494"></p><p>视觉上就是描边更粗了。</p><p>本节实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后， 我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity 提供的 <code>Graphics.DrawMesh</code> 或 <code>Graphics.DrawMeshNow</code> 函数把需要描边的物体再次渲染一遍（在所有不透明物体渲染完毕之后），然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于某个阈值，如果是，就在 Shader 中使用 clip 函数将该像素剔除掉，从而显示出原来的物体颜色。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一节中，我们学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。例如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多我们不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。在本节中，我们将学习如何在 Unity 中获取深度纹理和法线纹理来实现特定的屏幕后处理效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（七）基础屏幕特效</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</id>
    <published>2022-04-07T13:51:44.000Z</published>
    <updated>2022-04-07T13:54:03.101Z</updated>
    
    <content type="html"><![CDATA[<p>屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。</p><p><em><span id="more"></span></em></p><h3 id="1-建立一个基本的屏幕后处理脚本系统"><a href="#1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="1 建立一个基本的屏幕后处理脚本系统"></a>1 建立一个基本的屏幕后处理脚本系统</h3><p>屏幕后处理，顾名思义，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深、模糊等。</p><p>因此想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口——<strong>OnRenderImage</strong> 函数，它的函数声明如下：</p><blockquote><p>MonoBehaviour.OnRenderimage (RenderTexture src, RenderTexture dest)</p></blockquote><p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnReoderlmage 函数中，通常是利用 Grapbics.Blit 函数来完成对渲染纹理的处理。它有 3 种函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为_MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass 。否则，只会调用给定索引的 Pass 。</p><p>在默认情况下，OnRenderlmage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、  Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderlmage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderlmage 函数前添加 ImageEffectOpaque 属性来实现这样的目的，之后我们会遇到这种情况。</p><p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderlmage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p><p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。<br>PostEffectsBase.cs 的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有屏幕后处理效果都需要绑定在某个摄像机上</span></span><br><span class="line"><span class="comment">// 并且我们希望在编辑器状态下也可以执行该脚本来查看效果</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资源和条件是否满足，在start函数中调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平台是否支持渲染纹理和屏幕后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于每个屏幕后处理效果通常都需要指定一个 Shader 来创建一个用于处理渲染纹理的材质</span></span><br><span class="line">    <span class="comment">// 因此基类中也需要提供这样的方法</span></span><br><span class="line">    <span class="comment">// 第一个参数指定了该特效需要使用的Shader，第二个参数则是用于后期处理的材质</span></span><br><span class="line">    <span class="comment">// 该函数检查shader可用性，shader可用则返回一个使用了该shader的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面我们就可以通过继承这个基类来实现一些屏幕后处理效果。</p><h3 id="2-调整屏幕的亮度、饱和度和对比度"><a href="#2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="2 调整屏幕的亮度、饱和度和对比度"></a>2 调整屏幕的亮度、饱和度和对比度</h3><p>首先来编写 C# 脚本，继承上面的基类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该效果需要使用的shader，并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整亮度、饱和度、对比度的参数，Range可以指定参数的变化区间</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义OnRenderImage来实现屏幕特效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查材质是否可用，可用则将上面的参数传递给材质进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果材质不可用则直接显示原图像</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来编写 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Brightness Saturation And Contrast&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 这里的纹理就是脚本中Blit函数的第一个参数传入的纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 三个属性</span></span><br><span class="line">        _Brightness (&quot;Brightness&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片</span></span><br><span class="line">            <span class="comment">// 因此为了防止它对其他物体产生影响，我们需要设置相关的渲染状态</span></span><br><span class="line">            <span class="comment">// 关闭深度写入是为了防止如果在之后渲染透明物体出现错误</span></span><br><span class="line">            <span class="comment">// 这些设置可以认为是屏幕后处理的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">              </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 使用了Unity内置的appdata_img 结构体作为顶点着色器的输入</span></span><br><span class="line">            <span class="comment">// 它只包含了图像处理时必需的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line">                  </span><br><span class="line">                <span class="comment">// 调整亮度</span></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调整饱和度</span></span><br><span class="line">                <span class="comment">// 先得到该像素的亮度值，用每个颜色分量乘以一个特定的系数得到</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                <span class="comment">// 使用该亮度值创建一个饱和度为 0 的颜色值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                <span class="comment">// 使用_Saturation属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 先创建一个对比度为0的颜色</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">// 用_Contrast属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的对比度颜色</span></span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在返回 Unity 中，将 cs 脚本赋给摄像机，然后在摄像机属性面板中的脚本组件中将上面的 Shader 赋给 Bri Sat Con Shader 属性：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png" alt="image-20220407170634205"></p><p>然后调整各个参数就可以调整屏幕效果，原图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170806951.png" alt="image-20220407170806951"></p><p>调整部分参数后：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170829444.png" alt="image-20220407170829444"></p><h3 id="3-边缘检测"><a href="#3-边缘检测" class="headerlink" title="3 边缘检测"></a>3 边缘检测</h3><p>边缘检测是一个常见的屏幕后处理效果，用于实现描边效果。常用的边缘检测算子有：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407171016814.png" alt="image-20220407171016814"></p><p>在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根操作：<br>$$<br>G &#x3D; |G_x| + |G_y|<br>$$<br>当得到梯度 G 后，我们就可以据此来判断哪些像素对应了边缘。</p><p>下面我们使用 Sobel 算子进行边缘检测，cs 脚本和上面类似：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整边缘线强度的参数，当值为0时，边缘会叠加到原图像上，值为1时只显示边缘</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// 边缘颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            <span class="comment">// 将src作为纹理用material对应的shader处理，结果保存到dest纹理中</span></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写 Shader：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Edge Detection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 对应的参数，也可以不定义，因为在这里定义属性是为了显示在材质的属性面板上</span></span><br><span class="line">        <span class="comment">// 但这里我们是脚本自动生成材质，不需要我们创建材质</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            <span class="comment">// xxx_TexelSize是 Unity 内置的访问纹理纹素大小的变量</span></span><br><span class="line">            <span class="comment">// 例如512 * 512 的纹理的纹素大小就是 1/512</span></span><br><span class="line">            <span class="comment">// 因为卷积要对相邻纹素操作，所以要用纹素大小计算得到当前纹素相邻的纹素的位置</span></span><br><span class="line">            <span class="keyword">uniform</span> half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算每个纹理坐标周围的用于卷积的纹理坐标</span></span><br><span class="line">                <span class="comment">// 这一步最好在顶点着色器计算以减少性能开销</span></span><br><span class="line">                <span class="comment">// 因为顶点到片元的线性插值不会影响相邻坐标的结果</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算每个像素的亮度值</span></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前像素的梯度值</span></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="comment">// Sobel算子</span></span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                        <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                        <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                <span class="comment">// 两个方向的滤波结果</span></span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 滤波</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 得到最终滤波结果，这里的edge显然值越小越可能是边缘</span></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到当前像素的梯度值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line">                <span class="comment">// 计算背景分别为原图和纯色下的边缘颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">// 利用_EdgeOnly在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_EdgeOnly 为 0 时的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173137539.png" alt="image-20220407173137539"></p><p>_EdgeOnly 为 1 时的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173211757.png" alt="image-20220407173211757"></p><h3 id="4-高斯模糊"><a href="#4-高斯模糊" class="headerlink" title="4 高斯模糊"></a>4 高斯模糊</h3><p>高斯模糊我们非常熟悉，但还是有一个小技巧需要说明，那就是存储高斯模糊核时不需要全部存储，只需要存储极少的权重即可，因为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173403469.png" alt="image-20220407173403469"></p><p>所以一个 5 * 5 的高斯模糊核我们只需要存储 3 个权重即可。</p><p>并且为了提高性能，我们使用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。同时还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度。</p><p>cs 脚本如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波次数</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两个参数都是出于性能考虑</span></span><br><span class="line">    <span class="comment">// 模糊范围，在高斯核维数不变的情况下，模糊范围越大模糊程度越高，但过高会造成虚影</span></span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="comment">// 下采样倍数越高，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化</span></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第一个版本，最简单的实现</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            // 分配了一块与屏幕图像大小相同的缓冲区，因为有两个Pass，因此需要一个缓冲存储中间结果</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第1个Pass进行竖直方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第2个Pass进行水平方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            // 释放缓冲区</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第二个版本，利用缩放对图像下采样，减少需要处理的像素个数</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            // 声明缓冲区大小是进行缩放，并设置该临时纹理的滤波模式为双线性</span></span><br><span class="line"><span class="comment">//            // 这样在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 最终版本，还考虑了滤波次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 降采样</span></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直方向滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存交替</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shader 代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// CGINCLUDE包含的代码相当于头文件的功能，包含在CGINCLUDE内的代码块不需要写在任何Pass中</span></span><br><span class="line">        <span class="comment">// 在后面的Pass中可以直接用函数名调用这当中的函数</span></span><br><span class="line">        <span class="comment">// 由于我们要用到两个Pass ，并且它们的片元着色器代码是完全相同的，因此这样可以避免代码重复</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 垂直滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//垂直方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 水平滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 水平方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共用的片元着色器</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 模糊核权值</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">            <span class="comment">// 滤波</span></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 Pass 中直接调用上面的函数名即可</span></span><br><span class="line">        <span class="comment">// 为Pass定义了一个名字，这使得其他Shder可以通过改名字来直接使用该Pass</span></span><br><span class="line">        <span class="comment">// 因为高斯模糊很常用，定义名字为了方便其他Shader调用</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205453483.png" alt="image-20220407205453483"></p><h3 id="5-Bloom-效果"><a href="#5-Bloom-效果" class="headerlink" title="5 Bloom 效果"></a>5 Bloom 效果</h3><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205959390.png" alt="image-20220407205959390"></p><p>Bloom 的实现原理非常简单：我们首先根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p><p>首先是 cs 脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和高斯模糊的参数一样</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取较亮区域时使用的阈值大小</span></span><br><span class="line">    <span class="comment">// 尽管在绝大多数情况下，图像的亮度值不会超过1</span></span><br><span class="line">    <span class="comment">// 但如果我们开启了HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1 </span></span><br><span class="line">    <span class="comment">// 因此，在这里我们把 luminanceThreshold 的值规定在[O, 4]范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取阈值传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Shader中第一个Pass来提取图像中的较亮区域</span></span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 使用第二个Pass进行垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//使用第三个Pass进行水平滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将模糊后的较亮区域设为纹理</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0); </span><br><span class="line">            <span class="comment">// 使用第四个Pass将处理后的亮部叠加到原图上 </span></span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 Shader 代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提取亮部区域时的结构体和着色器</span></span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line">        </span><br><span class="line">        v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed luminance(fixed4 color) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">// 用采样得到的亮度值减去_LuminanceThreshold阈值并截取到[0,1]范围内</span></span><br><span class="line">            <span class="comment">// 这样比阈值小的部分就置为0，只剩下了较亮区域</span></span><br><span class="line">            fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="comment">// 和原像素相乘得到提取后的亮部图像</span></span><br><span class="line">            <span class="keyword">return</span> c * val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混合亮部图像和原图时的结构体和着色器</span></span><br><span class="line">        struct v2fBloom &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            </span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">// xy存储主纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;    </span><br><span class="line">            <span class="comment">// zw存储模糊后的亮部图像纹理坐标    </span></span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对zw进行平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 对两个纹理采样直接相加即可</span></span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以直接使用之前的高斯模糊中的Pass</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">        </span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211732586.png" alt="image-20220407211732586"></p><p>Bloom 效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211752023.png" alt="image-20220407211752023"></p><h3 id="6-运动模糊"><a href="#6-运动模糊" class="headerlink" title="6 运动模糊"></a>6 运动模糊</h3><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都棱角分明，缺少运动模糊。而在现在的许多第一人称或者赛车游戏中，运动模糊是一种必不可少的效果。</p><p>运动模糊实现的一种方法是使用<strong>累积缓存</strong>记录多张连续图像，然后取平均作为运动模糊图像，但是这种方法对于性能的消耗很大，因为想要获取多帧连续图像意味着要渲染一个场景多次。另一种广泛应用的方法是创建和使用<strong>速度缓存</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p><p>这一节我们使用类似于第一种方法来实现运动模糊，但不需要在一帧中把场景渲染多次，只要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图上，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累积缓存的方法相比性能更好，但模糊效果可能会略有影响。</p><p>为此，我们先编写一个脚本让摄像机运动：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line">        <span class="keyword">if</span> (pingpong) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>) &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写运动模糊的脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义运动模糊在混合图像时使用的混合参数</span></span><br><span class="line">    <span class="comment">// blurAmount 的值越大，运动拖尾的效果就越明显</span></span><br><span class="line">    <span class="comment">// 为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在0.0到0.9范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义保存之前图像叠加的结果的纹理</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line">    <span class="comment">// 我们在该脚本不运行时，即调用 OnDisable 函数时立即销毁之前叠加的结果</span></span><br><span class="line">    <span class="comment">// 这是因为我们希望在下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前accumulationTexture是否满足条件按，不满足则创建满足条件的纹理并初始化为当前帧图像</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个函数表明我们需要进行一个渲染纹理的恢复操作</span></span><br><span class="line">            <span class="comment">// 恢复操作发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下</span></span><br><span class="line">            <span class="comment">// 我们要用accumulationTexture混合当前图像，因此不能提前清空</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line">            <span class="comment">// 把当前屏幕图像叠加到accumulationTexture</span></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            <span class="comment">// 把结果显示到屏幕上</span></span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shader 代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Motion Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount (&quot;Blur Amount&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 采样RGB，并将其A通道设为_BlurAmount</span></span><br><span class="line">        <span class="comment">// 以便在后面混合时可以使用它的透明通道进行混合</span></span><br><span class="line">        fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回采样值</span></span><br><span class="line">        <span class="comment">// 这是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响</span></span><br><span class="line">        half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理RGB通道</span></span><br><span class="line">        <span class="comment">// 更新RGB时我们需要设置它的A通道来混合图像，但又不希望A通道的值写入渲染纹理中</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理A通道，保证A通道还是原来的值</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Blur Amount 设置为 0 时的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p><p>Blur Amount 设置为 1 时的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p><p>明显看到了运动模糊。当然这只是一种简单的实现，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。之后我们会学习如何利用深度纹理重建速度来模拟运动模糊效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（六）动画</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/</id>
    <published>2022-04-07T07:52:30.000Z</published>
    <updated>2022-04-07T07:56:11.087Z</updated>
    
    <content type="html"><![CDATA[<p>在本节中，我们将会学习如何向 Unity Shader 中引入时间变量，以实现各种动画效果。并分别学习纹理动画和顶点动画，并动手实现一些简单的动画效果。</p><p><em><span id="more"></span></em></p><h3 id="1-Unity-Shder-中的内置时间变量"><a href="#1-Unity-Shder-中的内置时间变量" class="headerlink" title="1 Unity Shder 中的内置时间变量"></a>1 Unity Shder 中的内置时间变量</h3><p>动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我们方便地在 Shader 中访问运行时间，实现各种动画效果。下表给出了这些内置的时间变量：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>_Time</td><td>float4</td><td>t 是自该场景加载开始所经过的时间，4 个分量的值分别是 (t&#x2F;20, t, 2t, 3t)</td></tr><tr><td>_SinTime</td><td>float4</td><td>t 是时间的正弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td></tr><tr><td>_CosTime</td><td>float4</td><td>t 是时间的余弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td></tr><tr><td>unity_DeltaTime</td><td>float4</td><td>dt 是时间增量，4 个分量的值分别是 (dt, 1&#x2F;dt, smoothDt, 1&#x2F;smoothDt)</td></tr></tbody></table><h3 id="2-纹理动画"><a href="#2-纹理动画" class="headerlink" title="2 纹理动画"></a>2 纹理动画</h3><p>纹理动画在游戏中的应用非常广泛。尤其在各种资源都比较局限的移动平台上，我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p><h4 id="2-1-序列帧动画"><a href="#2-1-序列帧动画" class="headerlink" title="2.1 序列帧动画"></a>2.1 序列帧动画</h4><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样，因此，要制作一张出色的序列帧纹理所需要的美术工程狱也比较大。</p><p>要想实现序列帧动画，我们先要提供一张包含了关键帧图像的图像。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom.png" alt="boom"></p><p>上述图像包含了 8 x 8 张关键帧图像，它们的大小相同，而且播放顺序为从左到右、从上到下。要序列帧动画的精髓在于，我们需要在每个时刻计算该时刻下应该播放的关键帧的位置，并对该关键桢进行纹理采样。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Image Sequence Animation&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 包含了所有关键帧图像的纹理</span></span><br><span class="line">        _MainTex (&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 该纹理在水平和垂直方向上包含的关键帧图像的个数</span></span><br><span class="line">        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        <span class="comment">// 控制动画播放速度</span></span><br><span class="line">        _Speed (&quot;Speed&quot;, Range(<span class="number">1</span>, <span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 由于序列帧图像通常是透明纹理，我们需要设置 Pass 的相关状态，以渲染透明效果</span></span><br><span class="line">        <span class="comment">// 由于序列帧图像通常包含了透明通道， 因此可以被当成是一个半透明对象</span></span><br><span class="line">        <span class="comment">// 因此这里的标签设置使用半透明标配设置</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            <span class="comment">// 半透明标配设置，关闭深度写入，开启颜色混合</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">              </span><br><span class="line">            struct a2v &#123;  </span><br><span class="line">                float4 vertex : POSITION; </span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;  </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;  </span><br><span class="line">                v2f o;  </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// _Time.y 就是该场景加载后所经过的时间，和速度相乘得到模拟时间，向下取整</span></span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed); </span><br><span class="line">                <span class="comment">// 对关键帧纹理采样相当于得到当前时间下关键帧图像所在的行列位置</span></span><br><span class="line">                <span class="comment">// 使用时间除以水平方向关键帧数量得到行索引</span></span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount);</span><br><span class="line">                <span class="comment">// 余数为列索引</span></span><br><span class="line">                <span class="type">float</span> column = time - row * _HorizontalAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用行列索引值来构建真正的采样坐标</span></span><br><span class="line">                <span class="comment">// 由于序列帧图像包含了许多关键帧图像，这意味着采样坐标需要映射到每个关键帧图像的坐标范围内</span></span><br><span class="line">                <span class="comment">// 因此我们先把原纹理坐标 i.uv 按行数和列数进行等分，得到每个子图像内的纹理坐标范围：</span></span><br><span class="line"><span class="comment">//                half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);</span></span><br><span class="line">                <span class="comment">// 然后使用当前的行列数对上面的结果进行偏移，得到当前子图像的纹理坐标：</span></span><br><span class="line"><span class="comment">//                uv.x += column / _HorizontalAmount;</span></span><br><span class="line">                <span class="comment">// 要注意对竖直方向坐标偏移要用减法，因此纹理坐标竖直方向的顺序是从下到上增大</span></span><br><span class="line">                <span class="comment">// 而序列帧纹理中播放顺序是从上到下的</span></span><br><span class="line"><span class="comment">//                uv.y -= row / _VerticalAmount;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将上面的过程整合起来可以写成下面的代码：</span></span><br><span class="line">                half2 uv = i.uv + half2(column, -row);</span><br><span class="line">                uv.x /=  _HorizontalAmount;</span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用纹理坐标采样</span></span><br><span class="line">                fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">                c.rgb *= _Color;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom-16493016674141.gif" alt="boom"></p><h4 id="2-2-滚动背景"><a href="#2-2-滚动背景" class="headerlink" title="2.2 滚动背景"></a>2.2 滚动背景</h4><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层（layers）来模拟一种视差效果。而这些背景的实现往往就是利用了纹理动画。接下来我们将实现一个包含了两层的无限滚动的 2D 游戏背景。纹理资源来自 <a href="http://opengameart.org/">OpenGameArt</a>  网站。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Scrolling Background&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 第一层纹理（较远的）</span></span><br><span class="line">        _MainTex (&quot;Base Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 第二层纹理（）较近的</span></span><br><span class="line">        _DetailTex (&quot;<span class="number">2</span>nd Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 两层纹理的水平滚动速度</span></span><br><span class="line">        _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Scroll2X (&quot;<span class="number">2</span>nd layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 控制纹理整体亮度</span></span><br><span class="line">        _Multiplier (&quot;Layer Multiplier&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _DetailTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _DetailTex_ST;</span><br><span class="line">            <span class="type">float</span> _ScrollX;</span><br><span class="line">            <span class="type">float</span> _Scroll2X;</span><br><span class="line">            <span class="type">float</span> _Multiplier;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 先得到原本的纹理坐标，然后使用 _Time.y 在水平方向上对纹理坐标进行偏移</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 使用偏移后的纹理坐标采样</span></span><br><span class="line">                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用第二层纹理的透明通道混合两张纹理</span></span><br><span class="line">                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line">                c.rgb *= _Multiplier;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/rollbg.gif" alt="rollbg"></p><h3 id="3-顶点动画"><a href="#3-顶点动画" class="headerlink" title="3 顶点动画"></a>3 顶点动画</h3><p>如果一个游戏中所有的物体都是静止的，这样枯燥的世界恐怕很难引起玩家的兴趣。顶点动画可以让我们的场景变得更加生动有趣。在游戏中，我们常常使用顶点动画来模拟飘动的旗帜、湍流的小溪等效果。</p><h4 id="3-1-流动的河流"><a href="#3-1-流动的河流" class="headerlink" title="3.1 流动的河流"></a>3.1 流动的河流</h4><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Water&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于控制水流波动幅度</span></span><br><span class="line">        _Magnitude (&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 用于控制波动频率</span></span><br><span class="line">         _Frequency (&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span></span><br><span class="line">         <span class="comment">// 波长的倒数，值越大，波长越小</span></span><br><span class="line">         _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = <span class="number">10</span></span><br><span class="line">         <span class="comment">// 水流速度</span></span><br><span class="line">         _Speed (&quot;Speed&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失</span></span><br><span class="line">        <span class="comment">// 我们需要在物体的模型空间下对顶点位置进行偏移，因此，在这里需要取消对该Shader的批处理操作</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 关闭剔除模式，为了让模型的每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot; </span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 在模型空间计算顶点位移量，只对顶点的x方向进行位移</span></span><br><span class="line">                float4 <span class="keyword">offset</span>;</span><br><span class="line">                <span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">                <span class="comment">// 把位移量加到模型定点上，再转换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/water.gif" alt="water"></p><h4 id="3-2-广告牌"><a href="#3-2-广告牌" class="headerlink" title="3.2 广告牌"></a>3.2 广告牌</h4><p>另一种常见的顶点动画就是广告牌技术（Billboarding）。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p><p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要 3 个基向量。广告牌技术使用的基向量通常就是表面法线（normal）、指向上的方向（up）以及指向右的方向（right）。除此之外，我们还需要指定一个锚点（anchor location），这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。</p><p>广告牌技术的难点在于，如何根据需求来构建 3 个相互正交的基向量。计算过程通常是，我们首先会通过初始计算得到目标的表面法线（例如就是视角方向）和指向上的方向，而两者往往是不垂直的。但是，两者其中之一是固定的，例如当模拟草丛时，我们希望广告牌的指向上的方向永远是 (0, 1, 0)，而法线方向应该随视角变化；而当模拟粒子效果时，我们希望广告牌的法线方向是固定的，即总是指向视角方向，指向上的方向则可以变化。</p><p>我们假设法线是固定的，首先，根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向：<br>$$<br>right &#x3D; up \times normal<br>$$<br>对其归一化后，再有法线方向和指向右的方向计算出正交的指向上的方向：<br>$$<br>up’&#x3D;noraml \times right<br>$$<br>这样就可以得到用于旋转的 3 个正交基了，下图描述了上面的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407151550507.png" alt="image-20220407151550507"></p><p>如果指向上的方向是固定的，计算过程也是类似的。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Billboard&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度</span></span><br><span class="line">        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 我们需要使用物体的模型空间下的位置来作为铀点进行计算</span></span><br><span class="line">        <span class="comment">// 因此同样要关闭批处理</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 同样关闭剔除使每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _VerticalBillboarding;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 模型空间的原点作为锚点</span></span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 获取模型空间下的视线位置</span></span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 视线方向作为法线方向</span></span><br><span class="line">                float3 normalDir = viewer - center;</span><br><span class="line">                <span class="comment">// 用_VerticalBillboarding控制垂直方向上的约束度</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为1，意味着法线方向固定为视线方向</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为0，意味着向上方向固定为(0,1,0)，因此法线方向y坐标置0</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                <span class="comment">// 最后对法线进行归一化</span></span><br><span class="line">                normalDir = <span class="built_in">normalize</span>(normalDir);</span><br><span class="line">                <span class="comment">// 得到粗略的向上方向，为了防止法线方向和向上方向平行，加一个判断</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 按照上面的公式计算，right方向计算完后别忘了归一化</span></span><br><span class="line">                float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">                upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据顶点位置相对于锚点的偏移量和三个正交基计算新的顶点位置</span></span><br><span class="line">                float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//最后把模型空间顶点变换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Vertical Restraints 设置为 1 时，相当于法线方向固定为视线方向，因此我们看到的星星都是正对我们的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407152955176.png" alt="image-20220407152955176"></p><p>当 Vertical Restraints 设置为 0 时，相当于固定向上方向为（0, 1, 0），可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407153107919.png" alt="image-20220407153107919"></p><p>需要说明的是，在上面的例子中，我们使用的是 Unity 自带的四边形 (Quad) 来作为广告牌，而不能使用自带的平面 (Plane) 。这是因为，我们的代码是建立在一个竖直摆放的多边形的基础上的，也就是说，这个多边形的项点结构需要满足在模型空间下是竖直排列的。只有这样，我们才能使用 v.vertex 来计算得到正确的相对于中心的位置偏移量。</p><h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><p>顶点动画虽然非常灵活，但有一些事情需要格外注意：</p><ul><li>如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。这时，我们可以通过 SubShader 的 DisableBatching 标签来强制取消对该 Unity Shader 的批处理。然而，取消批处理会带来一定的性能下降，增加了 Draw Call,  因此我们应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算。在上面的广告牌的例子中，为了避免显式使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</li><li>如果我们想要对包含了顶点动画的物体添加阴影，像之前一样使用内置的 Diffuse 等包含的阴影 Pass 来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，我们讲过 Unity 的阴影绘制需要调用一个 ShadowCaster Pass, 而如果直接使用这些内置的 ShadowCaster Pass，这个 Pass 中并没有进行相关的顶点动画，因此 Unity 会仍然按照之前的顶点计算阴影，所以此时需要我们自己提供计算阴影的 Pass，在这个 Pass 中，我们将进行同样的顶点变换过程。需要注意的是，在前面的其他动画实现中，涉及半透明物体我们使用的 FallBack 都是 Transparent&#x2F;VertexLit ，而 Transparent&#x2F;VertexLit 没有定义 ShadowCaster Pass, 因此也就不会产生阴影。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在本节中，我们将会学习如何向 Unity Shader 中引入时间变量，以实现各种动画效果。并分别学习纹理动画和顶点动画，并动手实现一些简单的动画效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
  <entry>
    <title>【Unity Shader】（五）高级纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-07T02:44:40.000Z</published>
    <updated>2022-04-07T02:46:17.464Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们学习过关于基础纹理的内容，这些纹理包括法线纹理、渐变纹理和遮罩纹理等。这些纹理尽管用处不同，但它们都属于低维（ 一维或二维）纹理。这一节我们将学习一些更复杂的纹理，但都是我们曾经在图形学中学到过的。包括使用立方体纹理（Cubemap）实现环境映射，以及强大的渲染纹理（Render Texture），最后学习程序纹理（Procedure Texture）。</p><p><em><span id="more"></span></em></p><h3 id="1-立方体纹理"><a href="#1-立方体纹理" class="headerlink" title="1 立方体纹理"></a>1 立方体纹理</h3><p>在图形学中我们已经学过环境映射，使用的就是展开的立方体纹理，在 Unity 中，立方体纹理可以通过直接而导入获得，也可以通过脚本生成获得。获得环境的立方体纹理之后，就可以使用该纹理对物体进行渲染，使得物体能够反射周围环境。</p><h4 id="1-1-反射"><a href="#1-1-反射" class="headerlink" title="1.1 反射"></a>1.1 反射</h4><p>想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Reflection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制反射颜色</span></span><br><span class="line">        _ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制材质的反射程度</span></span><br><span class="line">        _ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 环境映射纹理</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _ReflectColor;</span><br><span class="line">            fixed _ReflectAmount;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                <span class="comment">// 计算世界空间下的反射方向</span></span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));        </span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);        </span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用反射方向对立方体纹理采样</span></span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用lerp函数混合漫反射颜色和环境反射颜色</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406210422338.png" alt="image-20220406210422338"></p><h4 id="1-2-折射"><a href="#1-2-折射" class="headerlink" title="1.2 折射"></a>1.2 折射</h4><p>我们也可以用环境贴图模拟折射，虽然对于透明物体，折射应该是两次，一次是光线进入物体内部，另一次是光线从物体内部出去，这样才能被我们所看到，但模拟两次折射比较复杂并且会大幅降低 Shader 性能，因此大多数情况下在实时渲染中我们只模拟一次折射，虽然这是不对的，但是渲染效果看起来并不差，在实时渲染中，“只要看起来它是对的，那么它就是对的”，因此我们可以用一次折射来得到想要的效果。</p><p>类似于反射，我们只要用光线折射方向对环境纹理采样即可，折射方向的计算我们也在图形学中学过，可以利用折射率和角度的关系得到。和反射一样，我们也可以通过计算折射的函数直接得到折射方向。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractColor (&quot;Refraction Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractAmount (&quot;Refraction Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 介质的透射比，即两种介质的折射率的比值</span></span><br><span class="line">        _RefractRatio (&quot;Refraction Ratio&quot;, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _RefractColor;</span><br><span class="line">            <span class="type">float</span> _RefractAmount;</span><br><span class="line">            fixed _RefractRatio;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用refract函数计算世界空间下的折射方向</span></span><br><span class="line">                <span class="comment">// 第一个参数是入射光方向，第二个参数是表面法线，都要归一化</span></span><br><span class="line">                <span class="comment">// 第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值</span></span><br><span class="line">                o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用折射方向对环境纹理采样</span></span><br><span class="line">                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将漫反射和折射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211252780.png" alt="image-20220406211252780"></p><h4 id="1-3-菲涅尔效果"><a href="#1-3-菲涅尔效果" class="headerlink" title="1.3 菲涅尔效果"></a>1.3 菲涅尔效果</h4><p>在图形学中我们已经学过菲涅尔效应，菲涅尔项的物理计算非常复杂，但在图形学中有一个著名的近似公式，回顾当时学习的对菲涅尔项的近似公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211852604.png" alt="image-20220406211852604"></p><p>其中 $cos\theta$ 是视线和表面法线的夹角余弦，也可以写成点积形式，这一节我们用该公式进行菲涅尔项的渲染。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Fresnel&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 菲涅尔反射系数，相当于公式中的R0</span></span><br><span class="line">        _FresnelScale (&quot;Fresnel Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _FresnelScale;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                  fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                  fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                  fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                  SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔项</span></span><br><span class="line">                fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 将菲涅尔项和漫反射、反射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当菲涅尔系数为 1 时，得到的就是完整的环境反射效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212521693.png" alt="image-20220406212521693"></p><p>当菲涅尔系数为 0 时，就会得到一个具有边缘光照效果的漫反射物体：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212617407.png" alt="image-20220406212617407"></p><h3 id="2-渲染纹理"><a href="#2-渲染纹理" class="headerlink" title="2 渲染纹理"></a>2 渲染纹理</h3><p>在之前的学习中， 一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即渲染目标纹理（Render Target Texture, RTT），而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是多重渲染目标（Multiple Render Target, MRT），这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p><p>Unity 为渲染目标纹理定义了一种专门的纹理类型——渲染纹理（Render Texture）。在 Unity 中使用渲染纹理有两种方式：</p><ul><li>一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。 使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性。</li><li>另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderimage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，之后我们可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li></ul><h4 id="2-1-镜子效果"><a href="#2-1-镜子效果" class="headerlink" title="2.1 镜子效果"></a>2.1 镜子效果</h4><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。</p><p>我们搭建的场景如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214409944.png" alt="image-20220406214409944"></p><p>白色部分是一个镜子，现在我们还没有使用渲染纹理渲染镜子，要想让镜子显示场景信息，我们要在镜子上安一个虚拟摄像机，并新建一个渲染纹理叫做 Mirror Texture，然后将该摄像机的渲染目标改为渲染纹理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214616872.png" alt="image-20220406214616872"></p><p>然后编写 Shader，用渲染纹理渲染镜子，是一个非常简单的二维平面渲染：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Mirror&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="comment">// 水平翻转 x</span></span><br><span class="line">                o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为该材质选择渲染纹理，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214900520.png" alt="image-20220406214900520"></p><h4 id="2-2-玻璃效果"><a href="#2-2-玻璃效果" class="headerlink" title="2.2 玻璃效果"></a>2.2 玻璃效果</h4><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass 。当我们在 Shader 中定义了一个 GrabPass 后， Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p><p>需要注意的是，在使用 GrabPass 的时候，我们需要额外小心物体的渲染队列设置。正如之前所说， GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即”Queue”&#x3D;”Transparent”）。这样才可以保证当渲染该物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p><p>在本节中，我们将会使用 GrabPass 来模拟一个玻璃效果。我们首先使用一张法线纹理来修改模型的法线信息，然后使用了之前的反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用了 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Glass Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;    <span class="comment">//玻璃的材质纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;    <span class="comment">//玻璃的法线纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    <span class="comment">//环境纹理</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span>            <span class="comment">//用于控制模拟折射时图像的扭曲程度</span></span><br><span class="line">        <span class="comment">//用于控制折射程度，值为0时该玻璃只包含反射，值为1时该玻璃只包含折射</span></span><br><span class="line">        _RefractAmount (&quot;Refract Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 一定要在设置为透明队列</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个抓取屏幕的Pass</span></span><br><span class="line">        <span class="comment">// 字符串表示抓取得到的屏幕图像将会被存入哪个纹理中，后需要使用这个名字</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        <span class="comment">// 渲染玻璃所需的 Pass</span></span><br><span class="line">        Pass &#123;        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            <span class="type">float</span> _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            <span class="comment">// 对应上面抓取屏幕存入的纹理名称</span></span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            <span class="comment">// 得到该纹理的纹素大小，用于对屏幕图像的采样坐标进行偏移</span></span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float2 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 通过顶点在裁剪空间下的坐标计算被抓取的屏幕图像空间的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;        </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取切线空间的法线</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));    </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用法线坐标和_Distortion属性以及纹素大小计算对屏幕图像采样坐标的偏移</span></span><br><span class="line">                <span class="comment">// _Distortion属性的值越大，偏移就越大，玻璃背后的物体的扭曲程度也就越大</span></span><br><span class="line">                <span class="comment">// 另外，使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反映顶点局部空间下的法线方向</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 使用偏移和之前计算的屏幕图像空间的采样坐标获得校正后的的屏幕图像空间采样坐标</span></span><br><span class="line">                <span class="comment">// 乘以z分量是为了让变形程度随着摄像机距离而发生变化，显得更加真实</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 对屏幕图像空间采样坐标做透视除法之后得到真正的屏幕坐标，再对屏幕图像采样得到折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将切线空间法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 计算反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-worldViewDir, bump);</span><br><span class="line">                <span class="comment">// 主纹理采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                <span class="comment">// 环境纹理采样并混合主纹理颜色得到反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line">                <span class="comment">// 最终颜色是反射颜色和折射颜色和线性组合，线性系数由之前定义的折射程度控制</span></span><br><span class="line">                fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407101029198.png" alt="image-20220407101029198"></p><h3 id="3-程序纹理"><a href="#3-程序纹理" class="headerlink" title="3 程序纹理"></a>3 程序纹理</h3><p>程序纹理（Procedural Texture）指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素， 例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p><h4 id="3-1-实现简单的程序纹理"><a href="#3-1-实现简单的程序纹理" class="headerlink" title="3.1 实现简单的程序纹理"></a>3.1 实现简单的程序纹理</h4><p>我们使用一个 C# 脚本生成波点纹理：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让脚本能在编辑器模式下运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个材质，这个材质将使用该脚本生成的程序纹理</span></span><br><span class="line">    <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该程序纹理的各种参数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">    <span class="comment">// 纹理尺寸</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背景颜色    </span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 波点颜色</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">    <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊因子，用于模糊圆形波点的边界</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个Texture2D的纹理变量用于保存生成的纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断材质是否为空，如果为空就从该脚本所在的物体上获取材质</span></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            material = renderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用_UpdateMaterial()函数生成程序纹理</span></span><br><span class="line">        _UpdateMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保材质不为空，然后生成程序纹理并设置为该物体的材质的主纹理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">            material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">        Color mixColor = Color.white;</span><br><span class="line">        mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">        mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">        mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">        mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">        <span class="keyword">return</span> mixColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成程序纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">        Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义圆与圆之间的距离</span></span><br><span class="line">        <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">        <span class="comment">// 圆的半径</span></span><br><span class="line">        <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">// 边缘模糊系数</span></span><br><span class="line">        <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">                <span class="comment">// 计算每个像素的颜色，初始化为背景颜色</span></span><br><span class="line">                Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 画 9 个园</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// 计算当前圆的圆心</span></span><br><span class="line">                        Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算当前像素和圆心的距离</span></span><br><span class="line">                        <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 模糊边界</span></span><br><span class="line">                        Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 混合颜色</span></span><br><span class="line">                        pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在定义属性时，每个属性都使用了 get&#x2F;set 的方法，为了在面板上修改属性时仍可以执行 set 函数，还需要使用一个开源插件 SetProperty ，这使得当我们修改了材质属性时，可以执行_UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p><p>SetPropertyAttribute.cs 文件很简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2014 Luminary LLC</span></span><br><span class="line"><span class="comment">// Licensed under The MIT License (See LICENSE for full text)</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetPropertyAttribute</span> : <span class="title">PropertyAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetPropertyAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将该脚本赋给一个立方体，在该立方体的属性面板中会出现调整我们之前定义的程序纹理属性的组件：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103059433.png" alt="image-20220407103059433"></p><p>我们调整这些参数就可以生成不同的程序纹理，Shader 使用之前的单张纹理 Shader，不同参数得到的纹理效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103158038.png" alt="image-20220407103158038"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103455297.png" alt="image-20220407103455297"></p><h4 id="3-2-Unity-的程序材质"><a href="#3-2-Unity-的程序材质" class="headerlink" title="3.2 Unity 的程序材质"></a>3.2 Unity 的程序材质</h4><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做程序材质 (Procedural Materials) 。这类材质和我们之前使用的那些材质在本原上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 Substance Designer 的软件在 Unity 外部生成的。</p><p>Substance Designer 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。 我们可以从 Unity 的资源商店或网络中获取到很多免费或付费的 Substance 材质。这些材质都是以 sbsar 为后缀的，我们可以直接把这些材质像其他资源一样拖入 Unity 项目中。然后生成各种各样的程序纹理。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407104339828.png" alt="image-20220407104339828"></p><p>可以看出，程序材质的自由度很高，而且可以和 Shader 配合得到非常出色的视觉效果，它是一种非常强大的材质类型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们学习过关于基础纹理的内容，这些纹理包括法线纹理、渐变纹理和遮罩纹理等。这些纹理尽管用处不同，但它们都属于低维（ 一维或二维）纹理。这一节我们将学习一些更复杂的纹理，但都是我们曾经在图形学中学到过的。包括使用立方体纹理（Cubemap）实现环境映射，以及强大的渲染纹理（Render Texture），最后学习程序纹理（Procedure Texture）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Unity Shader" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Unity-Shader/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Shader" scheme="https://lz328.github.io/LycTechStack.github.io/tags/Shader/"/>
    
    <category term="CG/HLSL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/CG-HLSL/"/>
    
  </entry>
  
</feed>
