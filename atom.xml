<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-05-23T08:20:35.725Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【光栅化渲染器】（五）相机</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-05-23T08:19:01.000Z</published>
    <updated>2022-05-23T08:20:35.725Z</updated>
    
    <content type="html"><![CDATA[<p>上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。</p><p><em><span id="more"></span></em></p><p>MVP 矩阵中， M 矩阵负责改变模型在世界空间的位置和姿态，V 矩阵需要相机位置和相机的三个向量（up、right、front）来确定，P 矩阵跟视场大小、宽高比和远近平面位置有关。因此相机类主要负责管理确定 V 和 P 矩阵的参数。</p><p>这里相机类的实现可以参考之前光线追踪器中的相机类，只需要给定相机的位置、lookat 位置和在世界空间的 up 方向就可以确定相机的三个向量 up、right 和 front；对于相机旋转，我们使用欧拉角，由于大部分第一人称游戏也不支持滚转角旋转，因此我们也只实现俯仰角和偏航角，具体计算方法也很简单，以（0, 0, -1）为默认观察方向：</p><ul><li>对于每一个 front 向量，将其投影到 XOZ  平面（即把 y 置 0 再单位化）</li><li>front 向量和投影向量的夹角即为俯仰角，需要注意俯仰角不能超过 90 度否则整个视野会倒过来</li><li>投影向量与（0, 0, -1）的夹角为偏航角</li></ul><p>由此我们可以写出相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line">    <span class="comment">// 视场和宽高比</span></span><br><span class="line">    <span class="type">float</span> Fov;</span><br><span class="line">    <span class="type">float</span> Aspect;</span><br><span class="line">    <span class="comment">// 远近平面距离</span></span><br><span class="line">    <span class="type">float</span> Near;</span><br><span class="line">    <span class="type">float</span> Far;</span><br><span class="line">    <span class="comment">// 俯仰和偏航角</span></span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(</span><br><span class="line">        glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">        glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3 lookat = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        <span class="type">float</span> fov = <span class="number">60.0f</span>,</span><br><span class="line">        <span class="type">int</span> w = <span class="number">800</span>,</span><br><span class="line">        <span class="type">int</span> h = <span class="number">600</span>,</span><br><span class="line">        <span class="type">float</span> n = <span class="number">0.3f</span>,</span><br><span class="line">        <span class="type">float</span> f = <span class="number">100</span></span><br><span class="line">    ) :</span><br><span class="line">        <span class="built_in">Position</span>(position), <span class="built_in">WorldUp</span>(up), <span class="built_in">Fov</span>(glm::<span class="built_in">radians</span>(fov)), <span class="built_in">Aspect</span>((<span class="type">float</span>)w / h), <span class="built_in">Pitch</span>(<span class="number">0</span>), <span class="built_in">Yaw</span>(<span class="number">0</span>), <span class="built_in">Near</span>(n), <span class="built_in">Far</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(lookat - Position);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Front 向量计算欧拉角</span></span><br><span class="line">        <span class="function">glm::vec3 <span class="title">WorldFront</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        glm::vec3 FrontXZ = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(Front.x, <span class="number">0</span>, Front.z));</span><br><span class="line">        <span class="type">float</span> yd = glm::<span class="built_in">dot</span>(WorldFront, FrontXZ);</span><br><span class="line">        <span class="type">float</span> pd = glm::<span class="built_in">dot</span>(Front, FrontXZ);</span><br><span class="line">        <span class="keyword">if</span> (yd &gt; <span class="number">1.0</span>)</span><br><span class="line">            yd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (yd &lt; <span class="number">-1</span>)</span><br><span class="line">            yd = <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &gt; <span class="number">1.0</span>)</span><br><span class="line">            pd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &lt; <span class="number">-1</span>)</span><br><span class="line">            pd = <span class="number">-1.0</span>;</span><br><span class="line">        Yaw = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(yd));</span><br><span class="line">        Pitch = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(pd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">ViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetViewMatrix</span>(Position, Front, Right, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">PerspectiveMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPerspectiveMatrix</span>(Fov, Aspect, Near, Far);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateFov</span><span class="params">(<span class="type">float</span> fov = <span class="number">60.0f</span>)</span> </span>&#123;</span><br><span class="line">        Fov = glm::<span class="built_in">radians</span>(fov);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateAspect</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        Aspect = (<span class="type">float</span>)w / h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改俯仰角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotatePitch</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Pitch += angle;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0</span>)</span><br><span class="line">            Pitch = <span class="number">89.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0</span>)</span><br><span class="line">            Pitch = <span class="number">-89.0</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更改偏航角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateYaw</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Yaw += angle;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &gt; <span class="number">360</span>)</span><br><span class="line">            Yaw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &lt; <span class="number">0</span>)</span><br><span class="line">            Yaw = <span class="number">360</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 更新相机三个向量，根据俯仰角和偏航角计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = -<span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = -<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>相机应该作为全局变量，以便于之后的裁剪等算法获取相机相关的参数，因此我们在 <code>Global.h</code> 中加入全局变量的定义，将渲染管线以及之后要实现的材质等也设置为全局对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">Camera* camera;</span><br><span class="line">Draw* dw;</span><br><span class="line">Material* currentMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;camera.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setViewMatrix</span>(camera-&gt;<span class="built_in">ViewMatrix</span>());</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setProjectMatrix</span>(camera-&gt;<span class="built_in">PerspectiveMatrix</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw-&gt;<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制，渲染管线流程</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到和之前一样的结果说明正确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/camera.png" alt="camera"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（四）纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/</id>
    <published>2022-05-22T10:21:49.000Z</published>
    <updated>2022-05-23T08:20:42.365Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。</p><p><em><span id="more"></span></em></p><h3 id="1-OpenGL-中的纹理"><a href="#1-OpenGL-中的纹理" class="headerlink" title="1 OpenGL 中的纹理"></a>1 OpenGL 中的纹理</h3><p>首先来看 OpenGL 中如何使用纹理有关的操作，可以参考官方教程：[纹理 - LearnOpenGL CN](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;06 Textures&#x2F;)</p><h3 id="2-实现纹理类"><a href="#2-实现纹理类" class="headerlink" title="2 实现纹理类"></a>2 实现纹理类</h3><p>然后我们自己手动实现一个简单的纹理类，纹理环绕方式使用 GL_REPEAT 的方式，即超过 1.0 的纹理坐标就直接重复，纹理过滤的方式采用最近邻方式，加载图片还是使用简单强大的 stbi 库，纹理类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 图片纹理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> channels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>() : <span class="built_in">width</span>(<span class="number">-1</span>), <span class="built_in">height</span>(<span class="number">-1</span>), <span class="built_in">channels</span>(<span class="number">-1</span>), <span class="built_in">data</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; Path) &#123;</span><br><span class="line">        <span class="built_in">LoadTexture</span>(Path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; Path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">        data = <span class="built_in">stbi_load</span>(Path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理采样，使用重复寻址方式,等同于OpenGL的GL_REPEAT</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">Sample2D</span><span class="params">(<span class="type">const</span> glm::vec2&amp; texcoord)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> x = texcoord.x - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.x);</span><br><span class="line"><span class="type">float</span> y = texcoord.y - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.y);</span><br><span class="line">x = x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetColor</span>(x * (width - <span class="number">1</span>), y * (height - <span class="number">1</span>)) / <span class="number">255.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取颜色，对不同通道纹理图片分别处理，以便于加载法线、高度纹理等</span></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width || y &lt; <span class="number">0</span> || y &gt;= height)</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">switch</span> (channels) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor1</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor2</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor3</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor4</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = y * width + x;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">2</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">3</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">4</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), *(data + xy + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改 Shader 类，加入纹理成员，并修改片元着色器，将颜色改为纹理采样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        texture = <span class="keyword">new</span> <span class="built_in">Texture</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 ModelMatrix;</span><br><span class="line">    glm::mat4 ViewMatrix;</span><br><span class="line">    glm::mat4 ProjectMatrix;</span><br><span class="line">    Texture* texture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">        V2F o;</span><br><span class="line">        <span class="comment">// 变换到世界空间</span></span><br><span class="line">        o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line">        <span class="comment">// 变换到裁剪空间</span></span><br><span class="line">        o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line">        <span class="comment">// 法线变换</span></span><br><span class="line">        o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">        o.texcoord = a2v.texcoord;</span><br><span class="line">        o.color = a2v.color;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (texture-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec4 color = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord);</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">        ModelMatrix = model;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">        ViewMatrix = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">        ProjectMatrix = project;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTexture</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        texture-&gt;<span class="built_in">LoadTexture</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在 Draw 类中加入纹理图片路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">        FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">        shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">        shader-&gt;<span class="built_in">setTexture</span>(TexturePath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;texture_box2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(0,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box.png" alt="texture_box"></p><h3 id="3-透视纹理映射"><a href="#3-透视纹理映射" class="headerlink" title="3 透视纹理映射"></a>3 透视纹理映射</h3><p>可以看出当立方体的面不正对我们的时候，纹理出现了变形。这是因为我们对顶点插值时使用的插值参数是通过顶点间的 x, y 坐标求出的，但是透视投影之后纹理坐标并不跟投影点 x , y 坐标线性相关。这种直接插值纹理坐标的方式被称为<strong>仿射映射</strong>，解决办法是做<strong>透视映射</strong>，具体可以查看<a href="https://blog.csdn.net/popy007/article/details/5570803">深入探索透视纹理映射</a>这篇文章。</p><p>总之实际的做法就是在透视除法时，将除了屏幕坐标之外的所有值都除以 w 值，然后再进行插值，这样就可以得到正确的纹理映射关系，最后在扫描线函数中，调用片元着色器之前再乘以 w 恢复即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录下原本的 w</span></span><br><span class="line">    v.w = v.windowPos.w;</span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他属性也要除以 w，以便于正确插值，之后在片元着色器之前再乘以原本的 w 恢复</span></span><br><span class="line">    v.worldPos /= v.w;</span><br><span class="line">    v.normal /= v.w;</span><br><span class="line">    v.texcoord /= v.w;</span><br><span class="line">    v.color /= v.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            v.worldPos *= v.w;</span><br><span class="line">            v.normal *= v.w;</span><br><span class="line">            v.texcoord *= v.w;</span><br><span class="line">            v.color *= v.w;</span><br><span class="line"></span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box2.png" alt="texture_box2"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box3.png" alt="texture_box3"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（三）变换与深度测试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-21T10:28:14.000Z</published>
    <updated>2022-05-23T08:21:00.151Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。</p><p><em><span id="more"></span></em></p><h3 id="1-Mesh-类"><a href="#1-Mesh-类" class="headerlink" title="1 Mesh 类"></a>1 Mesh 类</h3><p>网格（Mesh）是用于保存三维模型的数据结构，通常来说一个网格包含一系列顶点数据和索引，用它们就能绘制出一系列多边形。同时网格还包含该模型所使用的材质信息（贴图、光照等）。上一章中我们是直接用顶点来画图形的，相当于手动创建了一个 Mesh，但是当模型比较复杂的时候，就需要一个类来管理模型的 Mesh，于是我们创建一个 Mesh 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 网格类，基础单位是三角形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; VBO;        <span class="comment">// 存放顶点数据</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; EBO;    <span class="comment">// 存放顶点索引顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> <span class="type">int</span>&amp; vNum, <span class="type">const</span> <span class="type">int</span>&amp; iNum) &#123;</span><br><span class="line">        VBO.<span class="built_in">resize</span>(vNum);</span><br><span class="line">        EBO.<span class="built_in">resize</span>(iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">        :<span class="built_in">VBO</span>(mesh.VBO), <span class="built_in">EBO</span>(mesh.EBO) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        VBO = mesh.VBO;</span><br><span class="line">        EBO = mesh.EBO;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddMesh</span>(mesh);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向网格中加入其它网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> offset = VBO.<span class="built_in">size</span>();</span><br><span class="line">        VBO.<span class="built_in">insert</span>(VBO.<span class="built_in">end</span>(), mesh.VBO.<span class="built_in">begin</span>(), mesh.VBO.<span class="built_in">end</span>());</span><br><span class="line">        EBO.<span class="built_in">reserve</span>(EBO.<span class="built_in">size</span>() + mesh.EBO.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            EBO.<span class="built_in">push_back</span>(mesh.EBO[i] + offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向网格中添加一一个三角形片面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v1);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v2);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v3);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后我们就可以在 Draw 类中将之前画三角形的函数 <code>DrawTriangle</code> 改为更一般的画网格的函数 <code>DrawMesh</code> 了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">// 顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><p>接下来是重头戏，三维变换。虽然对三维坐标变换已经有过深入的理论学习，但是在实践之前还是有必要再复习一次，把理论和实际结合起来。之前的笔记参考<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>。</p><p>首先梳理一下整个从三维模型到屏幕上的图像变换过程：</p><ul><li>模型定点定义在模型空间，需要将所有模型的顶点转换到世界空间</li><li>世界空间中有各种模型和观察整个场景的相机，因此要将世界空间变换到相机空间，也称观察空间</li><li>观察空间中的顶点位置还是三维坐标，因此要进行投影变换将所有物体顶点变换到裁剪空间，得到二维位置以及深度</li><li>裁剪空间经过透视除法变换到标准设备坐标系</li><li>标准设备坐标系最后经过视口变换到屏幕空间中</li></ul><p>于是首先是世界空间到观察空间的变换，也就是将世界空间原点移动到相机位置，然后将世界空间的三个坐标轴和相机的 right、up、front 三个方向对齐。平移矩阵很好写出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165556253.png" alt="image-20220521165556253"></p><p>坐标轴对齐也很简单，要将 A 空间的坐标轴和 B 空间的坐标轴对齐，只需要将 A 空间下 B 空间的坐标轴按行排列即可，因此只要将世界坐标系下的相机的三个方向按行排列，就是从世界空间到相机空间的变换矩阵：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165545686.png" alt="image-20220521165545686"></p><p>于是整个视角变换矩阵即为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165714434.png" alt="image-20220521165714434"></p><p>我们在 <code>math.h</code> 中加入视角变换矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视角变换矩阵，也称观察矩阵</span></span><br><span class="line"><span class="comment">// V = R*T</span></span><br><span class="line"><span class="comment">// T = [  1 , 0 , 0 , -eyex          R = [  Right , 0 </span></span><br><span class="line"><span class="comment">//        0 , 1 , 0 , -eyey                   UP  , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 1 , -eyez               - Front , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 0 ,   1   ]                 0   , 1 ]</span></span><br><span class="line"><span class="comment">//V =  [  Right  ,  - Right·eye</span></span><br><span class="line"><span class="comment">//          UP   ,  - UP·eye</span></span><br><span class="line"><span class="comment">//       -Front  ,   Front·eye</span></span><br><span class="line"><span class="comment">//         0     ,       1        ]</span></span><br><span class="line"><span class="comment">// OpenGL中观察空间是右手系，+z 轴指向屏幕外，为了让朝向保持不变，对Front向量取反</span></span><br><span class="line"></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">(glm::vec3 pos, glm::vec3 front, glm::vec3 right, glm::vec3 up)</span> </span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = right.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">0</span>] = right.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">0</span>] = right.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">0</span>] = -glm::<span class="built_in">dot</span>(right, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">1</span>] = up.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = up.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">1</span>] = up.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">1</span>] = -glm::<span class="built_in">dot</span>(up, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">2</span>] = -front.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">2</span>] = -front.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -front.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = glm::<span class="built_in">dot</span>(front, pos);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是透视投影矩阵，之前的笔记有详细推导，这里就不再赘述了，顺便再附上两篇透视投影的详细推导和理解的文章：</p><ul><li><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">OpenGL投影矩阵(Projection Matrix)构造方法</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影</a></li></ul><p>这里我们使用的透视投影矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172401734.png" alt="image-20220521172401734"></p><p>其中 r &#x3D; -l, t &#x3D; -b，因此投影矩阵最终为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172445502.png" alt="image-20220521172445502"></p><p>其中，r 是屏幕半宽，t 是屏幕半高，f 是远平面距离，n 是近平面距离。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视投影 参数 fov(弧度) aspect near far</span></span><br><span class="line"><span class="comment">//M = [   1/aspect*tan(fov/2),       0      ,         0      ,       0</span></span><br><span class="line"><span class="comment">//               0  ,         1/tan(fov/2)  ,         0      ,       0 </span></span><br><span class="line"><span class="comment">//               0  ,                0      ,  - (f+n)/(f-n) ,  -2fn/(f-n)</span></span><br><span class="line"><span class="comment">//               0  ,                0      ,         -1     ,       0     ]</span></span><br><span class="line"><span class="comment">// 投影之后从右手系变成了左手系，+Z指向屏幕内</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; fovy, <span class="type">const</span> <span class="type">float</span>&amp; aspect, <span class="type">const</span> <span class="type">float</span>&amp; n, <span class="type">const</span> <span class="type">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> tanHalfFov = <span class="built_in">tan</span>(fovy * <span class="number">0.5f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span> / (aspect * tanHalfFov);</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span> / (tanHalfFov);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -(f + n) / (f - n);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-1.0f</span>;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = (<span class="number">-2.0f</span> * n * f) / (f - n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过透视投影后，所有坐标都在 [-w, w] 之间，还需要经过透视除法将其变换到 NDC：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 透视除法在顶点着色器变换到裁剪空间之后，视口变换之前进行，因此修改画网格的函数，加入透视除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">//顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3 构建模型"></a>3 构建模型</h3><p>到此为止我们已经可以渲染一个三维物体了，我们使用 Mesh 构建一个立方体。一个立方体由 6 个面组成，每个面又可以分为两个三角形，于是我们写出三个函数：分别是构建三角形，构建平面和构建立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个三角形</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateTriangle</span><span class="params">(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//逆时针的三角形</span></span><br><span class="line">    <span class="comment">//顶点顺序 0 1 2</span></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(p1, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(p2, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(p3, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建一个平面，顶点顺序为左上 左下 右下 右上</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreatePlane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; leftTop, <span class="type">const</span> glm::vec3&amp; leftBottom, <span class="type">const</span> glm::vec3&amp; rightBottom, <span class="type">const</span> glm::vec3&amp; rightTop, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(leftTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(rightTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(rightBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">3</span>].position = glm::<span class="built_in">vec4</span>(leftBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">3</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个逆时针三角形</span></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    result.EBO[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建立方体</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateBox</span><span class="params">(<span class="type">const</span> glm::vec3&amp; center, <span class="type">float</span> radius)</span> </span>&#123;</span><br><span class="line">    Mesh result;</span><br><span class="line"></span><br><span class="line">    Mesh front = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(front);</span><br><span class="line"></span><br><span class="line">    Mesh left = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(left);</span><br><span class="line"></span><br><span class="line">    Mesh right = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(right);</span><br><span class="line"></span><br><span class="line">    Mesh back = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(back);</span><br><span class="line"></span><br><span class="line">    Mesh up = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(up);</span><br><span class="line"></span><br><span class="line">    Mesh down = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(down);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的颜色更加标准了，所有分量范围都在 [0 ,1]，因此需要修改对应的 <code>FrameBuffer</code> 中的写颜色函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>saturate</code> 函数在 math.h 中定义，作用是将输入值截断在 [0, 1] 范围内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">saturate</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数绘制立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;box.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">30.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box.png" alt="box"></p><p>可以看出透视关系不正确，这是因为没有做深度测试的原因，因此我们需要实现深度测试。</p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4 深度测试"></a>4 深度测试</h3><p>我们首先需要在 FrameBuffer 类中加入深度缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Width, Height;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; depthBuffer;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        <span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重设缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">            *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时重置深度缓冲</span></span><br><span class="line">        depthBuffer.<span class="built_in">assign</span>(Width * Height, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将颜色写入对应位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入深度，Z-Buffer 中深度范围是 [0,1]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">float</span>* p = depthBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + y * Width + x) = depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取深度</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> *(depthBuffer.<span class="built_in">data</span>() + y * Width + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正常深度测试应该在片元着色器之后，但是为了避免不必要的计算，可以在扫描线算法中加入深度测试，也相当于实现了 Early-Z 算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box-16531280264721.png" alt="box"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（二）框架搭建</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-05-20T03:33:30.000Z</published>
    <updated>2022-05-23T08:21:17.571Z</updated>
    
    <content type="html"><![CDATA[<p>上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。</p><p><em><span id="more"></span></em></p><h3 id="1-统一管理全局变量"><a href="#1-统一管理全局变量" class="headerlink" title="1 统一管理全局变量"></a>1 统一管理全局变量</h3><p>首先我们使用一个头文件 <code>Global.h</code> 来统一管理我们用到的所有头文件、全局变量和类声明，为了之后使用方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-FrameBuffer-类"><a href="#2-FrameBuffer-类" class="headerlink" title="2 FrameBuffer 类"></a>2 FrameBuffer 类</h3><p>和光线追踪器中一样，我们使用一个 unsigned char 数组来存放像素，但这次我们使用 RGBA 四个通道。为了保证整个代码结构清晰，我们封装一个 <code>FrameBuffer</code> 类来管理颜色缓冲，后续还可以加入深度缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> Width, Height;</span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line"><span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设缓冲区大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">*(p + i) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + i + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + i + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + i + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> xy = (y * Width + x);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">*(p + xy * <span class="number">4</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-管理顶点数据"><a href="#3-管理顶点数据" class="headerlink" title="3 管理顶点数据"></a>3 管理顶点数据</h3><p>顶点是我们光栅化渲染器的输入数据，所以理所应当用一个类来管理。一个顶点包含的数据有：模型坐标、顶点颜色、顶点法线、纹理坐标。注意位置坐标使用的是四维齐次坐标，在模型空间和世界空间的坐标都是 x, y, z 加上恒为 1 的 w，所以要用四维向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 顶点Vertex类和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VERTEX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 position;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex = glm::<span class="built_in">vec2</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos, <span class="number">1.0f</span>), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; v) :<span class="built_in">position</span>(v.position), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-渲染管线思路"><a href="#4-渲染管线思路" class="headerlink" title="4 渲染管线思路"></a>4 渲染管线思路</h3><p>输入输出都定义完了，接下来开始一步一步实现渲染管线。通常的 OpenGL 渲染管线流程如下：</p><ol><li>输入顶点数据和图元类型（点、直线、三角形等基本图元）</li><li>顶点着色器对顶点进行处理，将坐标变换到世界坐标，计算纹理坐标和顶点颜色等，输出到中间结构体（v2f）</li><li>对 v2f 进行图元装配过程，也就是为每个三角形指定顶点数据与索引</li><li>将顶点变换到摄像机的观察空间</li><li>进行投影，将顶点变换到裁剪空间</li><li>进行裁剪和面剔除工作，将看不见的图元进行裁剪，剔除背向面，减少后续计算量</li><li>执行齐次除法，将顶点变换到 NDC（标准设备坐标）</li><li>执行视口变换，最终将顶点转换到屏幕坐标（从三维变成二维）</li><li>光栅化，计算图形在屏幕上最终覆盖的像素点</li><li>用顶点数据插值，在像素点位置生成新的 v2f</li><li>逐像素运行片元着色器，进行纹理采样、光照计算等，输出该点最终颜色值（RGBA）</li><li>执行透明度测试-&gt;模板测试-&gt;深度测试，丢弃掉一些片元</li><li>执行混合操作</li></ol><h3 id="5-V2F-类"><a href="#5-V2F-类" class="headerlink" title="5 V2F 类"></a>5 V2F 类</h3><p>上述过程中，一个重要的结构体是 v2f，因此首先我们需要定义一个 v2f 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> V2F_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2F_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V2F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 worldPos;</span><br><span class="line">glm::vec4 windowPos;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">glm::mat3 TBN;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">V2F</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _wPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal,</span><br><span class="line"><span class="type">const</span> glm::mat3&amp; _tbn</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">worldPos</span>(_wPos), <span class="built_in">windowPos</span>(_pPos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal), <span class="built_in">TBN</span>(_tbn) &#123;&#125;</span><br><span class="line"><span class="built_in">V2F</span>(<span class="type">const</span> V2F&amp; v) :</span><br><span class="line"><span class="built_in">worldPos</span>(v.worldPos), <span class="built_in">windowPos</span>(v.windowPos), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal), <span class="built_in">TBN</span>(v.TBN), <span class="built_in">Z</span>(v.Z) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个顶点之间的插值</span></span><br><span class="line"><span class="function"><span class="type">static</span> V2F <span class="title">lerp</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> <span class="type">float</span>&amp; factor)</span> </span>&#123;</span><br><span class="line">V2F result;</span><br><span class="line">result.windowPos = <span class="built_in">Lerp</span>(v1.windowPos, v2.windowPos, factor);</span><br><span class="line">result.worldPos = <span class="built_in">Lerp</span>(v1.worldPos, v2.worldPos, factor);</span><br><span class="line">result.color = <span class="built_in">Lerp</span>(v1.color, v2.color, factor);</span><br><span class="line">result.normal = <span class="built_in">Lerp</span>(v1.normal, v2.normal, factor);</span><br><span class="line">result.texcoord = <span class="built_in">Lerp</span>(v1.texcoord, v2.texcoord, factor);</span><br><span class="line"></span><br><span class="line">result.TBN = v1.TBN;</span><br><span class="line"></span><br><span class="line">result.Z = <span class="built_in">Lerp</span>(v1.Z, v2.Z, factor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>V2F 中一个重要的操作就是插值，为此我们新建一个 <code>math.h</code> 文件来存放需要用到的数学操作，首先是线性插值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v1, <span class="type">const</span> glm::vec3&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec2&amp; v1, <span class="type">const</span> glm::vec2&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; f1, <span class="type">const</span> <span class="type">float</span>&amp; f2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * f1 + factor * f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-Shader-类"><a href="#6-Shader-类" class="headerlink" title="6 Shader 类"></a>6 Shader 类</h3><p>有了上面这些准备，现在我们可以用顶点着色器来对顶点进行处理了。先从简单的情况开始，我们首先渲染一个二维图形，因为画二维图形不需要三维到二维的变换，所以三个变换矩阵都置为单位矩阵，实际上等于没做变换直接输出。片元着色器也是直接将调用点的颜色进行输出即可。我们同样封装一个 <code>Shader</code> 类来管理顶点和片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">V2F o;</span><br><span class="line"><span class="comment">// 变换到世界空间</span></span><br><span class="line">o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line"><span class="comment">// 变换到裁剪空间</span></span><br><span class="line">o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line"><span class="comment">// 法线变换</span></span><br><span class="line">o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">o.texcoord = a2v.texcoord;</span><br><span class="line">o.color = a2v.color;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">ModelMatrix = model;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">ViewMatrix = view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">ProjectMatrix = project;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="7-视口变换"><a href="#7-视口变换" class="headerlink" title="7 视口变换"></a>7 视口变换</h3><p>现在我们可以在主函数中定义是三个顶点，由于 OpenGL 的 NDC 的坐标范围是[-1,1)，而我们目前并没有做任何的坐标变换，因此我们直接定义 NDC 下的顶点坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br></pre></td></tr></table></figure><p>现在我们得到了处理后的顶点，但还在 NDC 当中，需要进一步转化为屏幕空间中的坐标，即需要进行视口变换。视口变换做的操作是将 X, Y 坐标从 [-1,1) 映射到屏幕坐标 [0,w) 和 [0,h) 上，同时将原点从屏幕中间移到左下角。注意，在 OpenGL 中，左下角是原点，右上角是 (w,h) ，而 DirectX 中左上角是原点。在我们的 <code>math.h</code> 中定义视口变换矩阵，该矩阵是一个缩放+平移的矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glm 的矩阵是行矩阵，而我们一般使用的是列矩阵，所以存放的时候要转置</span></span><br><span class="line"><span class="comment">// 行矩阵做变换是右乘 v * M  ，列矩阵是左乘 M * v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视口变换矩阵  ox oy是左下角的坐标  从[-1,1]的 NDC 变换到屏幕坐标 [0,0],[w,h]</span></span><br><span class="line"><span class="comment">// Vp = [  w/2 ,   0  ,  0  , ox+w/2 ,</span></span><br><span class="line"><span class="comment">//0  ,  h/2 ,  0  , oy+h/2 ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  1  ,   0    ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  0  ,   1   ]</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewPortMatrix</span><span class="params">(<span class="type">int</span> ox, <span class="type">int</span> oy, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">result[<span class="number">0</span>][<span class="number">0</span>] = width / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">0</span>] = ox + (width / <span class="number">2.0f</span>);</span><br><span class="line">result[<span class="number">1</span>][<span class="number">1</span>] = height / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">1</span>] = oy + (height / <span class="number">2.0f</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br></pre></td></tr></table></figure><h3 id="8-光栅化"><a href="#8-光栅化" class="headerlink" title="8 光栅化"></a>8 光栅化</h3><p>接下来需要计算我们的三角形覆盖了哪些屏幕像素，这里使用经典的扫描线算法。其思想很简单，从三角形最上面的点开始往下逐步画横线，两个交点之间的区域就是覆盖的区域。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162253946.png" alt="image-20220519162253946"></p><p>朝向下侧的三角形原理也是一样的，只不过是对称过来了。有了这两种三角形，不难发现任意三角形都能最多分为一个平顶和一个平底三角形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162338364.png" alt="image-20220519162338364"></p><p>于是我们得到一般三角形的光栅化方法：</p><ol><li>根据三个顶点的 y 坐标判定是否有两个相等，有则判断是平底还是平顶三角形，直接画</li><li>找到 y 值在中间的点，划分出上下两个三角形，画两个</li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扫描线算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader.<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改上一节的主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line">FrameBuffer FrontBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">Resize</span>(SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染并写出图片</span></span><br><span class="line">FrontBuffer.<span class="built_in">ClearColorBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line"></span><br><span class="line">std::string filepath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\test.png&quot;</span>;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), SCR_WIDTH, SCR_HEIGHT, <span class="number">4</span>, FrontBuffer.colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test.png" alt="test"></p><h3 id="9-Draw-类"><a href="#9-Draw-类" class="headerlink" title="9 Draw 类"></a>9 Draw 类</h3><p>我们成功渲染出了二维图形，不过目前我们的渲染流程全都写在主函数中，需要一定的封装，于是我们定义一个 <code>Draw</code> 类来封装渲染过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRAW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> Width;</span><br><span class="line"><span class="type">int</span> Height;</span><br><span class="line">FrameBuffer* FrontBuffer;</span><br><span class="line">Shader* shader;</span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line"><span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">~<span class="built_in">Draw</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">shader = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setModelMatrix</span>(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setViewMatrix</span>(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setProjectMatrix</span>(project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">Resize</span>(w, h);</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">ClearColorBuffer</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), Width, Height, <span class="number">4</span>, FrontBuffer-&gt;colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F o1 = shader-&gt;<span class="built_in">VertexShader</span>(v1);</span><br><span class="line">V2F o2 = shader-&gt;<span class="built_in">VertexShader</span>(v2);</span><br><span class="line">V2F o3 = shader-&gt;<span class="built_in">VertexShader</span>(v3);</span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">****************** 扫描线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后主函数就变得非常简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;test.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line">dw.<span class="built_in">Init</span>();</span><br><span class="line"><span class="comment">// 三角形三个顶点</span></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="comment">// 设定背景并画三角形，这次有透明效果</span></span><br><span class="line">dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">dw.<span class="built_in">DrawTriangle</span>(V1, V2, V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出图片</span></span><br><span class="line">std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test-16530173154901.png" alt="test"></p><p>到此为止整个渲染器的框架就搭建完成，之后只需要在这个框架上添加算法和各种功能即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（一）环境配置</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-19T03:46:26.000Z</published>
    <updated>2022-05-23T08:21:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。</p><p><em><span id="more"></span></em></p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h3><p>我们使用 GLFW 和 GLAD 来显示最终渲染的图片，这些可以参照<a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/#glfw">LearnOpenGL CN</a>上的教程来进行配置。</p><p>使用 GLM 作为数学库，下载地址：<a href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm · GitHub</a></p><p>也可以使用和光线追踪器中一样的 STB 图像库来输出图片。</p><h3 id="2-OpenGL-基础"><a href="#2-OpenGL-基础" class="headerlink" title="2 OpenGL 基础"></a>2 OpenGL 基础</h3><p>下面是一个简单的 OpenGL 程序，但展示了所有 OpenGL 程序的通用流程和框架，包含详细注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些回调函数</span></span><br><span class="line"><span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line"><span class="comment">// 这里我们在改变窗口大小的时候也改变视口大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测是否按下 ESC 键，如果按下则将WindowShouldClose属性设置为true，这样既可退出渲染循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像设置</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器代码，存放在字符串中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW，并配置版本信息等</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GLFW 创建一个窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 用来来管理OpenGL的函数指针，使其在不同版本不同硬件上能够正确运行</span></span><br><span class="line">    <span class="comment">// 因此在使用 OpenGL 函数前需要先初始化 GLAD</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并编译顶点着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并编译片元着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将着色器代码链接为一个着色器程序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 检查链接错误</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ；链接完成后即可删除着色器对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个三角形</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点缓冲区VBA和顶点数组缓冲区VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 绑定顶点数组缓冲</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">// 绑定顶点缓冲，顶点缓冲是GL_ARRAY_BUFFER类型</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 将上面的顶点数据复制到顶点缓冲中</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 链接顶点属性，即告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除缓冲区绑定，非必要</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 是否按下ESC关闭窗口</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置清空屏幕缓冲所用的颜色</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 用设置的颜色清空颜色缓冲，可选的还有深度缓冲和模板缓冲</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双缓冲渲染，屏幕显示前缓冲区，渲染在后缓冲进行，因此每一帧交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果如图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20220519114457379.png" alt="image-20220519114457379"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】渲染加速技术总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T09:05:35.000Z</published>
    <updated>2022-05-18T09:07:36.914Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：</p><ul><li>空间管理（BVH、BSP 树、八叉树、场景图）</li><li>裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）</li><li>层次细节技术（LOD）</li><li>点渲染</li></ul><p><em><span id="more"></span></em></p><h2 id="1-空间管理"><a href="#1-空间管理" class="headerlink" title="1 空间管理"></a>1 空间管理</h2><p>空间数据结构（Spatial Data Structures）是将几何体组织在 N 维空间中的一系列数据结构，而且我们可以很容易地将二维和三维的一些概念扩展到高维之中。这些空间数据结构可以用于很多实时渲染相关操作的加速查询中，如场景管理，裁减算法、相交测试、光线追踪、以及碰撞检测等。</p><p>空间数据结构的组织通常是层次结构的。宽泛地说，即最顶层包含它之下的层次，后者又包含更下层的层次，以此类推。因此，这种结构具有嵌套和递归的特点。用层次结构的实现方式对访问速度的提升很有帮助，复杂度可以从 O(n) 提升到 O(log n)。但同时，使用了层次结构的大多数空间数据结构的构造开销都比较大，虽然也可以在实时过程中进行渐进更新，但是通常需要作为一个预处理的过程来完成。</p><p>一些常见的空间数据结构包括：</p><ul><li>层次包围盒（Bounding Volume Hierachy，BVH）</li><li>二元空间分割树（Binary Space Partitioning，BSP）</li><li>四叉树（QuadTree）</li><li>kd 树（k-dimensional tree）</li><li>八叉树（Octree）</li><li>场景图（Scene Graphs）</li></ul><p>其中，BSP 树和八叉树都是基于空间细分（Space Subdivision）的数据结构，这说明它们是对整个场景空间进行细分并编码到数据结构中的。例如，所有叶子节点的空间集合等同于整个场景空间，而且叶子节点不相互重叠。</p><p>层次包围盒不是空间细分结构，是对物体进行细分的结构，它仅将几何物体周围的空间包围起来，所以包围层次不需要包围所有的空间，但包围盒之间可以重叠。</p><p>而场景图是一种比较高层次的，相较渲染性能更关注模型关系的数据结构。</p><h3 id="1-1-层次包围盒-BVH"><a href="#1-1-层次包围盒-BVH" class="headerlink" title="1.1 层次包围盒 BVH"></a>1.1 层次包围盒 BVH</h3><p>对于三维场景的实时渲染来说，层次包围体（Bounding Volume Hierarchy，BVH）是最常使用的一种空间数据结构。例如，层次包围体经常用于层次视锥裁减。使用 BVH 的场景以层次树结构进行组织，包含一个根节点（root）、一些中间节点（internal nodes），以及一些叶子节点（leaves）。顶部的节点是根，其无父节点。叶子节点（leaf node）包含需渲染的实际几何体，且其没有子节点。</p><p>相比之下，中间节点包含指向它子节点的指针。因此，只要根节点不是这颗树唯一的一个节点，那么它就是一个内部节点。树中的每一个节点，包括叶子节点，都有一个包围体可以将其子树中的所有几何体包围起来，这就是包围体层次的命名来源，同时，也说明了根节点有一个包含整个场景的包围体。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154315059.png" alt="image-20220518154315059"></p><p>关于 BVH 的理论详述可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>中的“交点计算加速”部分。而 BVH 的代码实现可以在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/">【RayTracer】（十）实现 BVH</a>中查看。</p><h3 id="1-2-BSP-树"><a href="#1-2-BSP-树" class="headerlink" title="1.2 BSP 树"></a>1.2 BSP 树</h3><p>BSP 树（二叉空间分割树，全称 Binary Space Partitioning Tree）是一种常用于判别对象可见性的空间数据结构。类似于画家算法，BSP 树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。</p><p>其中，BSP 是 Binary SpacePartitioning（二叉空间划分法）的缩写。这种方法递归地将空间使用超平面划分为凸面体集合。而这种子划分引出了借助于称之为 BSP 树的树形数据结构的场景表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154653690.png" alt="image-20220518154653690"></p><p>BSP 树是一棵二叉树，每个节点表示一个有向超平面，其将当前空间划分为前向（front）和背向（back）两个子空间，分别对应当前节点的左子树和右子树。BSP 树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。而 BVH 与之不同，因为 BVH 通常不包含任何形式的排序。</p><h4 id="1-2-1-BSP-树的构建"><a href="#1-2-1-BSP-树的构建" class="headerlink" title="1.2.1 BSP 树的构建"></a>1.2.1 BSP 树的构建</h4><ul><li>从空树开始，每次选择一个面片作为节点插入树中</li><li>每次插入一个新节点，从树的根节点开始遍历<ul><li>如果新节点面片与当前结点片面相交，将新面片分割成两个面片</li><li>新节点在当前节点前向空间，插入左子树</li><li>新节点在当前节点背向空间，插入右子树</li><li>当前节点为空，直接插入新节点</li></ul></li><li>直到所有面片都被插入树中</li></ul><p>简单来说，若要创建 BSP 树，需递归将一个平面空间一分为二，并将几何体归类到这两个空间中来完成。</p><h4 id="1-2-2-BSP-树的遍历"><a href="#1-2-2-BSP-树的遍历" class="headerlink" title="1.2.2 BSP 树的遍历"></a>1.2.2 BSP 树的遍历</h4><p>从根节点开始，判断输入位置与当前分割平面的“前”、“后”关系，“前”则遍历左子树，“后”则遍历右子树，递归到叶子节点终止。</p><p>用平面方程 <code>Ax + By + Cz + D = 0</code> 判断前后位置，可用<code>D(x0, y0, z0) = Ax0 + By0 + Cz0 + D</code>  进行判别，其中：</p><ul><li>D &gt; 0：在平面前面</li><li>D &#x3D; 0：在平面上</li><li>D &lt; 0：在平面后面</li></ul><h4 id="1-2-3-BSP-树的种类"><a href="#1-2-3-BSP-树的种类" class="headerlink" title="1.2.3 BSP 树的种类"></a>1.2.3 BSP 树的种类</h4><p>在计算机图形学中，BSP 树有两大类别，分别是为轴对齐（Axis-Aligned）BSP 树和多边形对齐（Polygon-Aligned）BSP 树。下面分别进行介绍。</p><h4 id="1-2-4-轴对齐-BSP-树"><a href="#1-2-4-轴对齐-BSP-树" class="headerlink" title="1.2.4 轴对齐 BSP 树"></a>1.2.4 轴对齐 BSP 树</h4><p>轴对齐 BSP 树可以按如下方式来创建。首先，将整个场景包围在一个 AABB（轴对齐包围盒，Axis-Aligned Bounding Box）中，然后以递归的方式将这个包围盒分为若干个更小的盒子。</p><p>现在，考虑一下任何递归层次的盒子。选取盒子的一个轴，生成一个与之垂直的平面，将盒子一分为二。有一些方法可以将这个分割平面固定，从而将这个盒子分为完全相同的两部分，而也有其他的一些方法，允许这个平面在位置上有一些变化。与分割平面相交的物体，要么存储在这个层次上，成为两个子集中的一员，要么被这个平面分割为两个不同的物体。</p><p>经过这个过程，每个子集就处于一个比较小的盒子中，重复这个平面分割的过程，就可以对每个 AABB 进行递归细分，直到满足某个标准才终止这个分割过程。而这个标准，通常是用户定义的树最大深度，或者是盒子里面所包含的几何图元数量，需低于用户定义的某个值。</p><p>分割平面的轴线和位置对提高效率至关重要。一种分割包围盒的方法就是轴进行循环。即在根节点，沿着 x 轴对盒子进行分割，然后再沿着 y 轴对其子盒子进行分割，最后沿 z 轴对其孙盒子进行分割。这样，就完成了一个循环周期。<strong>使用这种分割策略的 BSP 树常被称为 k-d 树。</strong>而另一种常见策略是找到盒子的最长边，沿着这条边的方向对盒子进行分割。</p><p>下图显示了一个 BSP 树的分割过程，可以直观理解上述过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155441829.png" alt="image-20220518155441829"></p><p>值得一提的是，从前到后的粗排序（Rough Front-to-Back Sorting）是轴对齐 BSP 树的一种应用示例，这种方法对于遮挡剔除算法非常有用。而在视点的另一侧进行遍历，可以得到从后向前的粗排序（Rough Fack-to-Gront Sorting）,这对于透明排序非常有用。且还可以用来测试射线和场景几何体相交的问题，只需将视点位置换为射线原点即可，另外还可以用于视锥裁剪。</p><h4 id="1-2-5-多边形对齐-BSP-树"><a href="#1-2-5-多边形对齐-BSP-树" class="headerlink" title="1.2.5 多边形对齐 BSP 树"></a>1.2.5 多边形对齐 BSP 树</h4><p>多边形对齐 BSP 树（Polygon-aligned BSP tree）是 BSP 树的另一大类型，其中将多边形作为分隔物，对空间进行平分。也就是说，在根节点处，选取一个多边形，用这个多边形所在平面将场景中剩余多边形分为两组。对于与分割平面相交的多边形来说，沿着其中的交线将这个多边形分为两部分。然后，在分割平面的每个半空间中，选取另外一个多边形作为分隔物，只对这个分隔物所在平面的多边形进行继续分割，直到所有的多边形都在 BSP 树中为止。下图是一个多边形对齐 BSP 树的示意图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155804963.png" alt="image-20220518155804963"></p><p>需要注意，多边形对齐 BSP 树的创建是一个非常耗时的过程，这些树通常只需计算一次，可以存储起来进行重用。另外，因为完全不平衡树的效率非常低，所以多边形对齐 BSP 树分割时最好是形成平衡树，即每个叶子节点的深度相同或者相差一个层次的树。</p><p>多边形对齐 BSP 树的一个典型性质就是对于一个给定的视点来说，可以对该结构按照从后往前（或者从前往后）的顺序进行严格遍历，而轴对齐的 BSP 通常只能给出粗略的排序顺序。所以，基于多边形对齐 BSP 树的此性质，建立了严格的前后顺序，可以配合画家算法来绘制整个场景，而无需 Z 缓冲。多边形对齐 BSP 树的其他应用也包括相交测试和碰撞检测等。</p><h3 id="1-3-八叉树"><a href="#1-3-八叉树" class="headerlink" title="1.3 八叉树"></a>1.3 八叉树</h3><h4 id="1-3-1-普通八叉树"><a href="#1-3-1-普通八叉树" class="headerlink" title="1.3.1 普通八叉树"></a>1.3.1 普通八叉树</h4><p>八叉树（octree），或称八元树，是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><p>简单来说，八叉树的空间划分方式很简单，即递归地进行规整地 1 分为 8 的操作。如下图，把一个立方体分割为八个同样大小的小立方体，然后递归地分割出更的小立方体。这个就是八叉树的命名来源。这种分割方式可以得到比较规则的结构，从而使得查询变得高效。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160027641.png" alt="image-20220518160027641"></p><p>相似地，四叉树是把一个二维的正方形空间分割成四个小正方形。而八叉树是四叉树的三维空间推广。</p><h4 id="1-3-2-松散八叉树"><a href="#1-3-2-松散八叉树" class="headerlink" title="1.3.2 松散八叉树"></a>1.3.2 松散八叉树</h4><p>松散八叉树（Loose Octrees）的基本思想和普通八叉树一样，但是每个长方体的大小选择比较宽松。如果一个普通长方体的边长为 a，那么可以用 ka 来代替，其中 k &gt; 1，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160218107.png" alt="image-20220518160218107"></p><p>上图是一个普通八叉树和松散八叉树的比较。图中黑色的原点表示长方形的中心点（第一次细分）。在左图中，星形物体刺穿了一个普通八叉树的一个分割平面。这时，一种选择就是将这个星型物体放在最大的长方形中（根节点的长方体）。而右图所示为一个 k&#x3D;1.5 的松散八叉树，也就是将细分的长方体放大了 50%，如果将这些长方体稍微移动，就可以保证区分出们。这样，这个星形多边形就完全位于左上角的长方形之中。</p><h3 id="1-4-场景图"><a href="#1-4-场景图" class="headerlink" title="1.4 场景图"></a>1.4 场景图</h3><p>BVH、BSP 树和八叉树都是使用某种形式的树来作为基本的数据结构，它们的具体区别在于各自是如何进行空间分割和几何体的存储，且他们均是以层次的形式来保存几何物体。然而三维场景的绘制不仅仅是几何体。对动画，可见性，以及其他元素的控制，往往需要通过场景图（Scene Graphs）来完成。</p><p>场景图被誉为“当今最优秀且最为可重用的数据结构之一“。Wiki 中对场景图的定义是：</p><blockquote><p>场景图（Scene Graph）是组织和管理三维虚拟场景的一种数据结构，是一个有向无环图（Directed Acyclic Graph， DAG）。</p></blockquote><p>场景图是一个面向用户的树结构，可以通过纹理、变换、细节层次、渲染状态（例如材质属性）、光源以及其他任何合适的内容进行扩充。它由一棵以深度优先遍历来渲染整个场景的树来表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160821493.png" alt="image-20220518160821493"></p><p>开源的场景图有 Open Scene Graph 和 OpenSG 等。</p><h2 id="2-裁剪技术"><a href="#2-裁剪技术" class="headerlink" title="2 裁剪技术"></a>2 裁剪技术</h2><p>裁剪（Culling）的字面意思是“从大量事物中进行删除”。在计算机图形学中，相对应的就是裁剪技术（Culling Techniques）所要做的工作——“从大量游戏事物中进行删除”。所谓的“大量事物”就是需要绘制的整个场景，删除的是对最终图像没有贡献的场景部分，然后将剩余场景发送到渲染管线。因此，在渲染方面通常使用“可见性裁剪 (Visibility Culling)”这个术语。但其实，裁剪也可以用于程序的其他部分，如碰撞检测（对不可见物体进行不十分精确的计算）、物理学计算，以及人工智能（AI）领域。</p><p>与渲染相关的裁剪技术，常见的有：</p><ul><li><strong>背面裁剪（Backface Culling）</strong>：将背向视点的物体删除，是一种非常简单直观的操作，只能一次对一个单一多边形进行操作。</li><li><strong>视锥裁剪（View Frustum Culling）</strong>：将视锥之外的多边形删除，相对而言，这种操作比背面裁剪稍微复杂。</li><li><strong>遮挡剔除（Occlusion Culling）</strong>：将被其他物体遮挡的物体进行删除，这种操作在三者中最为复杂，因为其需要聚集一个或者多个物体，同时还需使用其他物体的位置信息。</li></ul><p>理论上，裁剪操作可以发生在渲染管线的任何一个阶段，而且对于一些遮挡裁剪算法来说，甚至可以预先计算出来。对于在硬件中实现的裁剪算法来说，有时只需启动&#x2F;禁止或者设置一些裁剪函数即可。而为了进行完全控制，我们可以在应用程序阶段在（CPU 上）实现一些裁剪算法。裁剪通常可以使用几何计算来实现，但也不局限于此。</p><p>下图展示了三种裁剪技术：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161245851.png" alt="image-20220518161245851"></p><h3 id="2-1-背面裁剪"><a href="#2-1-背面裁剪" class="headerlink" title="2.1 背面裁剪"></a>2.1 背面裁剪</h3><p>假设你正在观察一个场景中不透明的球体。大约有一半的球体是不可见的。那么，可以从中这个例子里得到一个众所周知的结论，那就是，对不可见的内容不需要进行渲染，因为它们对最终的渲染图像没有贡献。不需要对球体的背面进行处理，这就是背面裁剪的基本思想。对于一组物体来说，还可以一次性地进行背面裁剪，这也称为聚集背面裁剪（Clustered Backface Culling）。</p><p>背面裁剪有屏幕空间和观察空间两种方法，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161502669.png" alt="image-20220518161502669"></p><p>左图为屏幕空间背面裁剪，使用叉乘运算。根据右手定则可以判断出三角形和四边形是正面，七边形是背面，背面的多边形无需进行光栅化。</p><p>右图为观察空间背面裁剪，使用点乘运算。根据表面法线和视线夹角判断正面还是背面。</p><h3 id="2-2-层次视锥裁剪"><a href="#2-2-层次视锥裁剪" class="headerlink" title="2.2 层次视锥裁剪"></a>2.2 层次视锥裁剪</h3><p>众所周知，只需对完全或者部分在视锥中的图元进行渲染。一种加快渲染速度的方法便是将每个物体的包围体与视锥进行比较，如果包围体位于视锥之外，那么便不需要渲染包围体中的几何体。由于这些计算在 CPU 上进行，因此包围体中的几何体不需要通过管线中的几何和光栅阶段。相反，如果包围体在视锥内或者与视锥相交，那么包围体中的内容就是可见的，所以必须发送到渲染管线中去。</p><p>利用空间数据结构，可以分层地来应用这种裁剪。例如，对于层次包围盒 BVH 来说，从根节点进行前序遍历（Preorder Transversal），就可以完成这一任务。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161828374.png" alt="image-20220518161828374"></p><p>视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围盒中，而且几乎所有包围盒都是以层次形式聚集在一起。</p><p>除了层次包围盒，其他的空间数据结构同样也可以用于视锥裁剪，包括上文提到的八叉树和 BSP 树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围盒。</p><h3 id="2-3-入口裁剪"><a href="#2-3-入口裁剪" class="headerlink" title="2.3 入口裁剪"></a>2.3 入口裁剪</h3><p>对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪（Protal Culling）。入口裁剪算法的基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪，只对穿过入口能看到的几体体进行渲染。当遍历入口的时候，就减小视锥，使得与入口尽可能紧密贴合。因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展，且需将位于视锥之外的入口丢弃。</p><p>入口裁剪方法以某种方式对场景进行预处理，可以是自动形式，也可以是手动形式，可以将场景分割为一系列单元（Cells），其通常对应于建筑物中的房间或者走廊；房间的门和窗口称为入口（Protals）。单元中的每个物体和单元的墙面可以存储在一个与单元关联的数据结构中，还可以将邻接单元和链接这些单元的入口信息保存在一个临接图中。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162241213.png" alt="image-20220518162241213"></p><h3 id="2-4-细节裁剪"><a href="#2-4-细节裁剪" class="headerlink" title="2.4 细节裁剪"></a>2.4 细节裁剪</h3><p>细节裁剪（Detail Culling）是一种通过牺牲质量换取速度的技术。其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。</p><p>考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪（Screen-Size Culling）。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。</p><p>细节裁剪还可以作为一种简化的 LOD 技术来实现，其中一个 LOD 是整个模型，另外一个 LOD 是空物体。</p><h3 id="2-5-遮挡剔除"><a href="#2-5-遮挡剔除" class="headerlink" title="2.5 遮挡剔除"></a>2.5 遮挡剔除</h3><p>可见性问题可以通过 Z 缓冲器的硬件构造来实现，即使可以使用 Z 缓冲器正确解决可见性问题，但其中 Z 缓冲并不是在所有方面都不是一个很“聪明”的机制。例如，假设视点正沿着一条直线观察，其中，在这条直线上有 10 个球体，虽然这 10 个球体进行了扫描转换，同时与 Z 缓冲器进行了比较并写入了颜色缓冲器和 Z 缓冲器，但是这个从这个视点渲染出的图像只会显示一个球体，即使所有 10 个球体都将被光栅化并与 Z 缓冲区进行比较，然后可能写入到颜色缓冲区与 Z 缓冲区。下图中间部分显示了在给定视点处场景的深度复杂度，深度复杂度指的是对每个像素重写的次数。对于有 10 个球体的情形，最中间的位置，深度复杂度为 10，因为在这个地方渲染了 10 个球体（假设背面裁剪是关闭的），而且这意味着其中有 9 次像素写入是完全没有必要的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162730519.png" alt="image-20220518162730519"></p><p>像上图这样无聊极端的场景，现实生活中很难找到，但其描述的这种密集性很高的模型的情形，在现实生活中却很常见，如热带雨林，发动机，城市，以及摩天大楼的内部。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162841447.png" alt="image-20220518162841447"></p><p>左图和中图为视锥裁剪后的图示，右图所示为遮挡剔除和视锥裁剪后的图示。</p><p>有两种主要形式的遮挡裁剪算法，分别是基于点的遮挡裁剪和基于单元的遮挡裁剪。如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162926792.png" alt="image-20220518162926792"></p><p>左图所示为基于点的可见性，右图所示为基于单元的可见性，其中单元是一个长方形，从中可以看出，从视点左边看上去，有些圆被遮挡了，但是从右边看上去，这些圆却是可见的，因为可以从单元的某个位置到这些圆画一些射线，这些射线没有和任何遮挡物相交。</p><h4 id="2-5-1-硬件遮挡查询"><a href="#2-5-1-硬件遮挡查询" class="headerlink" title="2.5.1 硬件遮挡查询"></a>2.5.1 硬件遮挡查询</h4><p>现代  GPU 可以以一种特殊的渲染模式来支持遮挡剔除。通过硬件遮挡查询（Hardware Occlusion Queries），我们能够直接获得所提交的物体是否被绘制到场景中。<br>简单来说，硬件遮挡查询的基本思想是，当和 Z 缓冲器中内容进行比较时，用户可以通过查询硬件来找到一组多边形是否可见的，且这些多边形通常是复杂物体的包围体（如长方体）。如果其中没有多边形可见，那么便可将这个物体裁剪掉。硬件实现对查询的多边形进行光栅化，并且将其深度和 Z 缓冲器进行比较。</p><h4 id="2-5-2-层次-Z-缓冲"><a href="#2-5-2-层次-Z-缓冲" class="headerlink" title="2.5.2 层次  Z 缓冲"></a>2.5.2 层次  Z 缓冲</h4><p>层次 Z-缓冲算法（Hierarchical Z-Buffering，HZB）对遮挡剔除的研究有着显著的影响。尽管其在 CPU 上很少使用，但该算法是 GPU 上做 Z-Culling（深度裁剪）的基础。</p><p>层次  Z-缓冲算法用八叉树来维护场景模型，并将画面的 Z 缓冲器作为图像金字塔（也称为 Z-金字塔，Z-pyramid），该算法因此在图像空间中进行操作。其中，八叉树能够对场景的遮挡区域进行层次剔除，而  Z-金字塔则可以对单个基元和边界体积进行层次 Z 缓冲。因此  Z-金字塔可以作为此算法的遮挡表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163313731.png" alt="image-20220518163313731"></p><p>使用  HZB 算法的遮挡裁剪示例，显示了一个复杂的场景（右下），相应的  Z-pyramid（左图），以及八叉树细分（右上）。通过从前到后遍历八叉树并裁剪遇到的八叉树节点，此算法可以仅访问可见的八叉树节点及其子节点（右上角的节点），的容器只对可见包围体中的多边形进行渲染。在这个例子中，遮挡八叉树节点的裁剪可以将深度复杂度从 84 降低到了 2.5。</p><h2 id="3-层次细节技术"><a href="#3-层次细节技术" class="headerlink" title="3 层次细节技术"></a>3 层次细节技术</h2><p>细节层次（Level of Detail，LOD）的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。这是一个已经在各种游戏中广泛使用的基本优化技术。</p><p>例如，一个包含一百万个三角形的汽车，其中所包含的细节信息比较丰富。当视点靠近物体时，可以使用详细的细节表示，而当视点远离物体时，比如仅需覆盖 200 个像素，则完全无需渲染出一百万个三角形，相反，我可以使用诸如只有 1000 个三角形的简化模型。而由于距离的原因，简化后的模型与细节较丰富的模型看上去其实很接近。以这种方式，可以显著地提高渲染的性能开销。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163650813.png" alt="image-20220518163650813"></p><p>通常情况下，雾效会与 LOD 一起使用。这样我们可以完全跳过对一些物体的渲染，直接用不透明的雾来进行遮挡。</p><p>一般情况下，完整的 LOD 算法包含 3 个主要部分：</p><ul><li><strong>生成 Generation</strong>：生成不同细节的模型表示，可以使用算法，也可以手工制作具有不同数量的三角形模型</li><li><strong>选择 Selection</strong>：基于某种准则选取一个层次细节模型，比如屏幕上的评估面积</li><li><strong>切换 Switching</strong>：从一个细节层次转换到另一个细节层次</li></ul><h3 id="3-1-LOD-的切换方法"><a href="#3-1-LOD-的切换方法" class="headerlink" title="3.1 LOD 的切换方法"></a>3.1 LOD 的切换方法</h3><p>当从一个 LOD 切换到另一个 LOD 的时候，忽然的模型替换往往会引起观察者的注意。这种现象被称为突越（Poping）。这里有几种不同的 LOD 切换方法，有着不同的特性。</p><h4 id="3-1-1-离散几何-LOD"><a href="#3-1-1-离散几何-LOD" class="headerlink" title="3.1.1 离散几何 LOD"></a>3.1.1 离散几何 LOD</h4><p>离散几何 LOD 是最简单的 LOD 算法，不同的表示是不同图元数量的同一模型，但这种方法突越现象严重。</p><h4 id="3-1-2-混合-LOD"><a href="#3-1-2-混合-LOD" class="headerlink" title="3.1.2 混合 LOD"></a>3.1.2 混合 LOD</h4><p>在概念上，完全可能存在一种直观的方法，从一个 LOD 切换到另一个 LOD，只需要在较短的时间内在两个 LOD 之间执行一个线性混合，这种方法无疑可以得到一种比较平滑的切换，但是这种混合操作的代价较高。渲染两个 LOD 要比一个 LOD 需要更大开销，因此也就违背了 LOD 的初衷。但 LOD 切换通常发生在较短时间内容，在同一时间也不是对场景中所有物体进行切换，所以依然可以从中获益。</p><h4 id="3-1-3-透明-LOD"><a href="#3-1-3-透明-LOD" class="headerlink" title="3.1.3 透明 LOD"></a>3.1.3 透明 LOD</h4><p>完全避免突越现象的一种简单方法便是使用 alpha LOD。其中并没有使用同一物体很多不同细节的实例，而且每个物体只有一个实例。随着 LOD 选取度量值（如与物体之间的距离）的增大，物体整体透明度也随之增大（也就是 alpha 值减小），当完全透明时，物体最终就会消失。这种方法的优点是，比离散几何 LOD 方法上感觉更连续一些，可以避免突跃现象。此外，由于物体最终会完全消失而不需要进行渲染，可以得到很好的加速效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164303220.png" alt="image-20220518164303220"></p><p>使用 Alpha LOD 对图中的圆锥体进行渲染，当距离圆锥体较远时，就提高它的透明度，直到最后消失。直线左边的图像是从同一距离处进行的观察，而直线右边的图像是左边图像不同尺寸的情形。</p><h4 id="3-1-4-连续-LOD-和几何形变-LOD"><a href="#3-1-4-连续-LOD-和几何形变-LOD" class="headerlink" title="3.1.4  连续 LOD 和几何形变 LOD"></a>3.1.4  连续 LOD 和几何形变 LOD</h4><p>连续细节层次（Continuous Level of Detail , CLOD）的基本思想是基于 LOD 选取值来精确决定可见多边形的数量。在 100m 远处，模型包含 1000 个多边形，当移动的到 101m 的地方时，模型减少到 998 个多边形。</p><p>几何形变层次细节（Geomorph LODs）是基于简化生成的一组离散模型，且其中模型顶点之间的链接关系保持不变。关于GLODs 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/">【计算机图形学】（九）几何</a>中的表面简化方法。</p><h3 id="3-2-LOD-的选取方法"><a href="#3-2-LOD-的选取方法" class="headerlink" title="3.2 LOD 的选取方法"></a>3.2 LOD 的选取方法</h3><p>给定一个物体不同细节层次，必须做一个选择，决定渲染或者混合其中的哪一个层次，这就是 LOD 选择（LOD selection）的任务。有几种不同的 LOD 选择方案，这些方案也可以用于遮挡剔除算法。</p><h4 id="3-2-1-基于距离的-LOD-选取"><a href="#3-2-1-基于距离的-LOD-选取" class="headerlink" title="3.2.1 基于距离的 LOD 选取"></a>3.2.1 基于距离的 LOD 选取</h4><p>原理如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164744364.png" alt="image-20220518164744364"></p><h4 id="3-2-2-基于投影面积的-LOD-选取"><a href="#3-2-2-基于投影面积的-LOD-选取" class="headerlink" title="3.2.2 基于投影面积的 LOD 选取"></a>3.2.2 基于投影面积的 LOD 选取</h4><p>基于投影面积的 LOD 选取，顾名思义，即投影面积越大，就选取细节越丰富的 LOD。</p><h4 id="3-2-3-基于滞后的-LOD-选取"><a href="#3-2-3-基于滞后的-LOD-选取" class="headerlink" title="3.2.3 基于滞后的 LOD 选取"></a>3.2.3 基于滞后的 LOD 选取</h4><p>若用于确定 LOD 度量标准围绕某个值 ri 在画面之间是变化的，那么就会出现不必要的突跃现象，也就会在不同的 LOD 之间来回快速切换。对此，可以引入一个围绕 ri 值的滞后来解决这个问题。如下图，这是一个基于距离的 LOD，可以应用于任何类型，当 r 增大时，使用上一行的 LOD 距离；当 r 减小时，使用下面一行的 LOD 距离。  </p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164927013.png" alt="image-20220518164927013"></p><h2 id="4-点渲染"><a href="#4-点渲染" class="headerlink" title="4 点渲染"></a>4 点渲染</h2><p>点渲染的基本思想是用一个大的点集来表示物体表面并予以渲染。在随后的通道中，使用高斯滤波来填充渲染点之间的间隙。而高斯滤波器的半径取决于表面上点的密度和屏幕上的投影密度。知道有这种渲染方法即可，不必深究。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间管理（BVH、BSP 树、八叉树、场景图）&lt;/li&gt;
&lt;li&gt;裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）&lt;/li&gt;
&lt;li&gt;层次细节技术（LOD）&lt;/li&gt;
&lt;li&gt;点渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】非真实感渲染总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T07:32:47.000Z</published>
    <updated>2022-05-18T07:34:00.662Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中的非真实感渲染技术进行概括总结和扩展。主要内容包括：</p><ul><li>非真实感渲染（NPR）的基本思想</li><li>卡通渲染</li><li>轮廓描边方法总结</li><li>其他风格的 NPR 渲染技术</li></ul><p><em><span id="more"></span></em></p><h3 id="1-非真实感渲染概述"><a href="#1-非真实感渲染概述" class="headerlink" title="1 非真实感渲染概述"></a>1 非真实感渲染概述</h3><p>非真实感渲染（Non-Photorealistic Rendering，NPR），亦被称为风格化渲染（Stylistic Rendering），是致力于为数字艺术提供多种表达方式的一种渲染流派。与传统的追求照片真实感的真实感渲染（Photorealistic Rendering）计算机图形学不同，非真实感渲染旨在模拟艺术式的绘制风格，也用于尝试新的绘制风格。</p><p>NPR 的目的之一就是创建类似技术示意图、技术图纸相关的图像，而另一个应用领域便是对绘画风格和自然媒体（如铅笔、钢笔、墨水、木炭、水彩画等）进行模拟。这是一个涉及内容非常之多的应用领域，为了捕捉各种媒体的真实效果，人们已经提出了各种不同的算法。</p><h3 id="2-卡通渲染"><a href="#2-卡通渲染" class="headerlink" title="2 卡通渲染"></a>2 卡通渲染</h3><p>卡通渲染（Toon Rendering）作为一种特殊形式的非真实感渲染方法，近年来倍受关注。这种渲染风格能够给人以独特的感染力与<br>童趣。这种风格很受欢迎的原因之一是 McCloud 的经典著作《Understanding Comics》中所讲述到的“通过简化进行增强（Amplification Through Simplification）”。通过简化并剔除所包含的混杂部分，可以突出于主题相关的信息，而大部分观众都会认同那些用简单风格描绘出来的卡通形象。</p><p>可以将最<strong>卡通渲染基本的三个要素</strong>概括为：</p><ul><li>锐利的阴影（Sharp shadows）</li><li>少有或没有高亮的点（Little or no highlight）</li><li>对物体轮廓进行描边（Outline around objects）</li></ul><p>卡通渲染有许多不同的实现方法：</p><ul><li>对于含有纹理但没有光照的模型来说，可以通过对纹理进行量化来近似具有实心填充颜色的卡通风格。</li><li>对于明暗处理，有两种最为常见的方法，一种是用实心颜色填充多边形区域。但这种方式实用价值不大。另一种是使用 2-tone 方法来表示光照效果和阴影区域。也称为硬着色方法（Hard Shading），可以通过将传统光照方程元素重新映射到不同的调色板上来实现。此外，一般用黑色来绘制图形的轮廓，可以达到增强卡通视觉效果的目的。</li></ul><p>具体的着色方法，可以理解为在 Fragment shader 中测试每个像素漫反射 diffuse 中的 NdotL 值，让漫反射形成一个阶梯函数，不同的 NdotL 区域对应不同的颜色。下图显示了不同的漫反射强度值的着色部分阶梯指定了不同的像素颜色。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518150810699.png" alt="image-20220518150810699"></p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中实现了一个简单的 NPR 渲染。</p><h3 id="3-轮廓描边方法总结"><a href="#3-轮廓描边方法总结" class="headerlink" title="3 轮廓描边方法总结"></a>3 轮廓描边方法总结</h3><p>轮廓描边的渲染方法可以分为以下五种：</p><ul><li>基于视点方向的描边</li><li>基于过程几何方法的描边</li><li>基于图像处理的描边</li><li>基于轮廓边缘检测的描边</li><li>混和轮廓描边</li></ul><h4 id="3-1-基于视点方向的描边"><a href="#3-1-基于视点方向的描边" class="headerlink" title="3.1 基于视点方向的描边"></a>3.1 基于视点方向的描边</h4><p>基于视点方向的描边方法，即表面角描边（Surface Angle Silhouetting），其基本思想是使用视点方向（view point）和表面法线（surface normal）之间的点乘结果得到轮廓线信息。如果此点乘结果接近于零，那么可以断定这个表面极大概率是侧向（Edge-on）的视线方向，而我们就将其视做轮廓边缘，进行描边。在实际应用中，通常使用一张一维纹理，也就是使用视角方向与顶点法向的点乘对该纹理进行采样。<br>需要注意，这种技术仅适用于一些特定的模型，这些模型必须保证法线与轮廓边缘之间存在一定关系。诸如立方体这样的模型，此方法并不太适用，因为往往无法得到轮廓边缘。但我们可以通过显式地绘制出折缝边缘，来正确地表现出这类比较明显的特征。</p><h4 id="3-2-基于过程几何方法的描边"><a href="#3-2-基于过程几何方法的描边" class="headerlink" title="3.2 基于过程几何方法的描边"></a>3.2 基于过程几何方法的描边</h4><p>基于过程几何方法生成的描边，即过程几何描边（Procedural Geometry Silhouetting），基本思想是先渲染正向表面（frontfaces），再渲染背向表面（backfaces），从而使得轮廓边缘可见，达到描边的目的。</p><p>有多种方法用来渲染背向表面，且各有优缺点。但它们都是先渲染正向表面，然后打开正向表面裁剪（culling）开关，同时关闭背向裁剪开关。这样这个 pass 中的渲染结果便只会显示出背向表面。</p><p>一种基于过程几何方法生成的描边的方法是仅仅渲染出背向表面的边界线（而不是面），使用偏置（Biasing）或者其他技术来确保这些线条恰好位于正向表面之前。这样就可以将除轮廓边缘之外的其他所有线条全部隐藏起来。这种方法非常适合单像素宽的线条，但如果线条的宽度超过这个值，那么通常会出现无法连接独立线段的情况，从而造成明显的缝隙。</p><p>另一种渲染较宽描边线条的方法是直接将背面表面本身渲染成黑色。但没有任何偏置操作，背向表面就会保持不可见，所以需要做的就是通过偏置将这些背向表面沿屏幕 Z 方向向前移动，这样，便只有背向表面的三角形边缘是可见的，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518151628850.png" alt="image-20220518151628850"></p><h4 id="3-3-基于图像处理的描边"><a href="#3-3-基于图像处理的描边" class="headerlink" title="3.3 基于图像处理的描边"></a>3.3 基于图像处理的描边</h4><p>基于图像处理生成轮廓描边（Silhouetting by Image Processing），即通过在各种缓冲区上执行图像处理技术，来实现非真实渲染的方法。可以将其理解为一种后处理操作。通过寻找相邻 Z 缓冲数值的不连续性，就可以确定大多数轮廓线的位置。同样，借助邻接表面法线向量的不连续性，可以确定出分界线（往往也是轮廓线）边缘的位置。此外，利用环境色对场景进行绘制，也可以用来检测前两种方法可能会漏掉的边缘。</p><h4 id="3-4-基于轮廓边缘检测的描边"><a href="#3-4-基于轮廓边缘检测的描边" class="headerlink" title="3.4 基于轮廓边缘检测的描边"></a>3.4 基于轮廓边缘检测的描边</h4><p>可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的具体介绍。</p><h4 id="3-5-混合轮廓描边"><a href="#3-5-混合轮廓描边" class="headerlink" title="3.5 混合轮廓描边"></a>3.5 混合轮廓描边</h4><p>混和轮廓描边（Hybrid Silhouetting），即结合了图像处理方法和几何要素方法，来渲染轮廓的方法。<br>这种方法的具体思想是：首先，找到一系列轮廓边缘的列表。其次，渲染出所有物体的三角形和轮廓边缘，同时为他们指定一个不同的 ID 值（也就是说，赋予不同的颜色）。接着读取该 ID 缓冲器并从中判断出可见的轮廓边缘，随之对这些可见线段进行重叠检测，并将它们连接起来形成平滑的笔划路径。最后就可以对这些重建起来的路径进行风格化笔划渲染，其中，这些笔划本身可以用很多方法来进行风格化处理，包括变细、火焰、摆动、淡化等效果，同时还有深度和距离信息。如下图是使用混合轮廓描边方法生成的图像，其中可以将找到的轮廓边缘连接起来作为笔划进行渲染：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152106468.png" alt="image-20220518152106468"></p><h3 id="4-其他风格的-NPR-技术"><a href="#4-其他风格的-NPR-技术" class="headerlink" title="4 其他风格的 NPR 技术"></a>4 其他风格的 NPR 技术</h3><p>除了卡通渲染这种比较受欢迎的模拟风格之外，还存在其他各式各样的风格。NPR 效果涵盖的范围非常广泛，RTR3 中主要谈了 3 种不同的其他风格的 NPR 渲染技术：</p><ul><li>纹理调色板（Palette of Textures）</li><li>色调艺术图（Tonal Art Maps，TAM）</li><li>嫁接（Graftals）</li></ul><h4 id="4-1-纹理调色板（Palette-of-Textures）"><a href="#4-1-纹理调色板（Palette-of-Textures）" class="headerlink" title="4.1 纹理调色板（Palette of Textures）"></a>4.1 纹理调色板（Palette of Textures）</h4><p>纹理调色板（palette of textures）由 Lake 等人讨论提出，基本思想是通过漫反射着色项（diffuse shading term）的不同，来选择应用于物体表面上的不同纹理。随着漫反射项逐渐变暗，可以选用相应更暗的纹理，而为了能够产生手绘的效果，可以使用屏幕空间坐标来采样纹理。同时，为了增强绘制效果，可以在屏幕空间上的所有表面上运用纸纹理。随着物体的运动，他们就可以在纹理之间进行穿梭。原因在于这个纹理是在屏幕空间中实现的。此外，也可以在世界空间中运用这个纹理，这样就能够得到一个与屏幕空间完全不同的效果。</p><p>下图是使用纹理调色板、纸纹理，以及轮廓边缘绘制生成的一幅图像：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152605870.png" alt="image-20220518152605870"></p><h4 id="4-2-色调艺术图（Tonal-Art-Maps）"><a href="#4-2-色调艺术图（Tonal-Art-Maps）" class="headerlink" title="4.2 色调艺术图（Tonal Art Maps）"></a>4.2 色调艺术图（Tonal Art Maps）</h4><p>通过在纹理之间进行切换形成的硬着色效果和卡通着色效果之间的一种混合，Praun 等人提出了一种可以实时生成笔划纹理分级细化图的方法，并可以将其以平滑的方式运用到物体表面上。第一步是生成即时使用的纹理，称为色调艺术图（Tonal Art Maps，TAM）,主要思想是将笔划绘制为分级细分图层次。下图是使用 TAM 渲染的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152848606.png" alt="image-20220518152848606"></p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的素描风格就使用了简化的 TAM 算法。</p><h4 id="4-3-嫁接（Graftals）"><a href="#4-3-嫁接（Graftals）" class="headerlink" title="4.3  嫁接（Graftals）"></a>4.3  嫁接（Graftals）</h4><p>嫁接（Graftals）的基本思想，是将几何或者贴花纹理应用到物体表面，从而产生某种特殊效果。可以通过所需要的细节层次，物体表面相对视点的方位或者其他因素，对纹理进行控制。这种方法可以用来模拟钢笔或者画刷的笔刷，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152954390.png" alt="image-20220518152954390"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中的非真实感渲染技术进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非真实感渲染（NPR）的基本思想&lt;/li&gt;
&lt;li&gt;卡通渲染&lt;/li&gt;
&lt;li&gt;轮廓描边方法总结&lt;/li&gt;
&lt;li&gt;其他风格的 NPR 渲染技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】基于图像的渲染技术总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T06:47:58.000Z</published>
    <updated>2022-05-18T06:51:09.216Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中基于图像的渲染技术进行概括总结和扩展。以综述形式为主，许多内容已经实现过或学习过，其他概念只需了解即可，主要内容包括：</p><ul><li>谱渲染 The Rendering Spectrum</li><li>固定视角的渲染 Fixed-View Rendering</li><li>天空盒 Skyboxes</li><li>光场渲染 Light Field Rendering</li><li>精灵与层 Sprites and Layers</li><li>公告板 Billboarding</li><li>粒子系统 Particle System</li><li>颜色校正 Color Correction</li><li>色调映射 Tone Mapping</li><li>镜头眩光和泛光 Lens Flare and Bloom</li><li>景深 Depth of Field</li><li>运动模糊 Motion Blur</li><li>体渲染 Volume Rendering</li></ul><p><em><span id="more"></span></em></p><h3 id="1-谱渲染"><a href="#1-谱渲染" class="headerlink" title="1 谱渲染"></a>1 谱渲染</h3><p>众所周知，渲染的目的就是在屏幕上渲染出物体，至于如何达到结果，主要依赖于用户的选择，白猫黑猫，抓到老鼠的就是好猫。而用多边形将三维物体显示在屏幕上，并非是进行三维渲染的唯一方法，也并非是最合适的方法。多边形具有从任何视角以合理的方式表示对象的优点，当移动相机的时候，物体的表示可以保持不变。但是，当观察者靠近物体的时候，为了提高显示质量，往往希望用比较高的细节层次来表示模型。与之相反，当物体位于比较远的地方时，就可以用简化形式来表示模型。这就是细节层次技术 (Level Of Detail,LOD)。使用 LOD 技术主要目的是为了加快场景的渲染速度。还有很多技术可以用来表示物体逐渐远离观察者的情形，比如，可以用图像而不是多边形来表示物体，从而减少开销，加快渲染速度。另外，单张图片可以很快地被渲染到屏幕上，用来表示物体往往开销很小。</p><p>Lengyel 于 1998 在《The Convergence of Graphics and Vision》一文中提出了一种表示渲染技术连续性的方法，名为 The Rendering Spectrum  渲染谱，如下图所示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135741473.png" alt="image-20220518135741473"></p><p>下面是论文中更具体的图示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135757327.png" alt="image-20220518135757327"></p><p>可以将渲染谱理解为渲染的金字塔。从左到右，由简单到复杂，由二维图像到几何模型，从外观特征到物理渲染。</p><h3 id="2-固定视角的渲染"><a href="#2-固定视角的渲染" class="headerlink" title="2 固定视角的渲染"></a>2 固定视角的渲染</h3><p>固定视角的渲染（Fixed-View Rendering）技术，通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量渲染时间与性能。<br>对于复杂的几何和着色模型，每帧去重新渲染整个场景很可能是昂贵的。可以通过限制观看者的移动能力来对渲染进行加速。 最严格的情况是相机固定在位置和方位，即根本不移动。而在这种情况下，很多渲染可以只需做一次。<br>例如，想象一个有栅栏的牧场作为静态场景，一匹马穿过它。牧场和栅栏渲染仅一次，存储其颜色和 Z 缓冲区。每帧将这些 buffer 复制到可显示的颜色和 Z 缓冲中。为了获得最终的渲染效果，马本身是需要渲染的。如果马在栅栏后面，存储和复制的 z 深度值将把马遮挡住。请注意，在这种情况下，马不能投下阴影，因为场景无法改变。可以进行进一步的处理，例如，可以确定出马影子的区域，根据需求进行处理。关键是对于要显示的图像的颜色何时或如何设置这点上，是没有限制的。固定视角的特效（Fixed-View Effects）可以通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量时间。</p><h3 id="3-天空盒"><a href="#3-天空盒" class="headerlink" title="3 天空盒"></a>3 天空盒</h3><p>对于一些远离观众的物体，观众移动时几乎没有任何视差效果。换言之，如果你移动一米，甚至一千米，一座遥远的山本身看起来通常不会有明显的不同。当你移动时，它可能被附近的物体挡住视线，但是把那些物体移开，山本身看起来也依旧一样。天空盒就属于这种类型的物体。</p><p>环境贴图（environment map）可以代表本地空间入射光亮度。虽然环境贴图通常用于模拟反射，但它们也可以直接用来表示环绕环境的远处物体。任何独立于视图的环境地图表示都可以用于此目的；立方体贴图（cubic maps）是最为常见的一种环境贴图。环境贴图放置在围绕着观察者的网格上，并且足够大以包含场景中所有的对象。且网格的形状并不重要，但通常是立方体贴图。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518140529046.png" alt="image-20220518140529046"></p><h3 id="4-光场渲染"><a href="#4-光场渲染" class="headerlink" title="4 光场渲染"></a>4 光场渲染</h3><p>所谓光场（Light Field），可以理解为空间中任意点发出的任意方向的光的集合。而光场渲染（Light Field Rendering），可以理解为在不需要图像的深度信息或相关性的条件下，通过相机阵列或由一个相机按设计的路径移动，把场景拍摄下来作为输出图像集。对于任意给定的新视点，找出该视点邻近的几个采样点进行简单的重新采样和插值，就能得到该视点处的视图。</p><h3 id="5-精灵与层"><a href="#5-精灵与层" class="headerlink" title="5 精灵与层"></a>5 精灵与层</h3><p>最基本的基于图像的渲染的图元之一便是精灵（sprite）。精灵（sprite）是在屏幕上移动的图像，例如鼠标光标。精灵不必具有矩形形状，而且一些像素可以以透明形式呈现。对于简单的精灵，屏幕上会显示一个一对一的像素映射。存储在精灵中的每个像素将被放在屏幕上的像素中。可以通过显示一系列不同的精灵来生成动画。</p><p>更一般的精灵类型是将其渲染为应用于总是面向观看者的多边形的图像纹理。图像的 Alpha 通道可以为 sprite 的各种像素提供全部或部分透明度。这种类型的精灵可以有一个深度，所以在场景本身，可以顺利地改变大小和形状。一组精灵也可以用来表示来自不同视图的对象。对于大型物体，这种用精灵来替换的表现效果会相当弱，因为从一个精灵切换到另一个时，会很容易穿帮。也就是说，如果对象的方向和视图没有显着变化，则给定视图中的对象的图像表示可以对多个帧有效。而如果对象在屏幕上足够小，存储大量视图，即使是动画对象也是可行的策略。</p><p>考虑场景的一种方法是将其看作一系列的层（layers），而这种思想也通常用于二维单元动画。每个精灵层具有与之相关联的深度。通过这种从前到后的渲染顺序，我们可以渲染出整个场景而无需 Z 缓冲区，从而节省时间和资源。</p><h3 id="6-公告板"><a href="#6-公告板" class="headerlink" title="6 公告板"></a>6 公告板</h3><p>我们将根据观察方向来确定多边形面朝方向的技术叫做公告板（Billboarding）。而随着观察角度的变化，公告板多边形的方向也会根据需求随之改变。与 alpha 纹理和动画技术相结合，可以用公告板技术表示许多不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，能量盾（Energy Shields），水蒸气痕迹，以及云朵等。比如下图的树：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141422780.png" alt="image-20220518141422780"></p><p>给定表面的法线向量 n 和近似向上方向的向量 u，通过创建一组由三个相互垂直的向量，就可以确定公告板的方向。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141522323.png" alt="image-20220518141522323"></p><p>其中，左图是互相垂直的 u 和 n。中图是 r 向量通过 u 和 n 的叉乘得到，因此同时垂直于 u 和 n，而在右图中，对固定向量 n 和 r 进行叉乘就可以得到与他们都垂直的的向上向量  u’。</p><p>有三种不同类型的 Billboard，分别是：</p><ul><li><strong>Screen-Aligned Billboard  对齐于屏幕的公告板</strong>：这里的 n 是镜头视平面法线的逆方向，u 是镜头的 up 方向</li><li><strong>World-Oriented Billboard  面向世界的公告板</strong>：不能直接使用镜头的 up 做 up，因为镜头旋转了，并且所画的 billboard 原本是应该相对世界站立的，按 Screen-Aligned 的做法就会随镜头旋转，所以此时应该 r &#x3D; u * n(u 是其在世界上的 up，n 是镜头视线方向的逆方向)，最后再计算一次 u‘ &#x3D; r * n，即 u’ 才是最后的 up，即非物体本身相对世界的 up，亦非镜头的 up。</li><li><strong>Axial Billboard  轴向公告板</strong></li></ul><p>所以公告板技术是一种看似简单其实较为复杂的技术,它的实现变种较多。归其根本在于：</p><ul><li>View Oriented &#x2F; View plane oriented 的不同</li><li>Sphere&#x2F; Axial 的不同</li><li>Camera up &#x2F; World up 的不同</li></ul><p>如 View Oriented 和 View plane oriented 的不同，得到的公告板效果就完全不同：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142041015.png" alt="image-20220518142041015"></p><p>下图是使用公告板技术渲染的云层：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142105766.png" alt="image-20220518142105766"></p><p>另外还有一种特殊的公告板技术：替代物（Impostors），替代物是通过从当前视点将一个复杂物绘制到一幅图像纹理上来创建的，其中的图像纹理用于映射到公告板上，渲染过程与替代物在屏幕上覆盖的像素点数成正比，而不是与顶点数或者物体的复杂程度成正比。替代物可以用于物体的一些实例上或者渲染过程的多帧上，从而使整体性能获得提升。</p><p>使用 Imposters 的一个问题是渲染的图像必须持续地面向观察者。如果远处的物体正在改变方向，则必须重新计算 Imposters 的朝向。而为了模拟更像他们所代表的三角形网格的远处物体，D´ecoret 等人提出了公告板云（Billboard Clouds）的想法，即一个复杂的模型通常可以通过一系列的公告板集合相互交叉重叠进行表示。我们知道，一个真实物体可以用一个纸模型进行模拟，而公告板云可以比纸模型更令人信服，比如公告板云可以添加一些额外的信息，如法线贴图、位移贴图和不同的表面材质。另外，裂纹沿裂纹面上的投影也可以由公告板进行处理。而  D´ecoret 等人也提出了一种在给定误差容限内对给定模型进行自动查找和拟合平面的方法。</p><h3 id="7-粒子系统"><a href="#7-粒子系统" class="headerlink" title="7 粒子系统"></a>7 粒子系统</h3><p>粒子系统（Particle System）是一组分散的微小物体集合，其中这些微小物体按照某种算法运动。粒子系统的实际运用包括模拟火焰，烟，爆炸，流水，树木，瀑布，泡沫，旋转星系和其他的一些自然现象。粒子系统并不是一种渲染形式，而是一种动画方法，这种方法的思想是在粒子的生命周期内控制他们的产生，运动，变化和消失。</p><p>除了爆炸，瀑布，泡沫以及其他现象以外，还可以使用粒子系统进行渲染。例如，可以使用粒子系统来创建树木模型，也就是表示树木的几何形状，当视点距离模型较近时，就会产生更多的粒子来生成逼真的视觉效果。下图是用粒子系统渲染的树木：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142415857.png" alt="image-20220518142415857"></p><h3 id="8-图像处理"><a href="#8-图像处理" class="headerlink" title="8 图像处理"></a>8 图像处理</h3><p>图像处理的过程，一般在像素着色器中进行，因为在像素着色器中，可以很好地将渲染过程和纹理结合起来，而且在 GPU 上跑像素着色器，速度和性能都可以满足一般所需。<br>一般而言，首先需要将场景渲染成 2D 纹理或者其他图像的形式，再进行图像处理，这里的图像处理，往往指的是后处理（post effects）。而下文将介绍到的颜色校正（Color Correction）、色调映射（Tone Mapping）、镜头眩光和泛光（Lens Flare and Bloom）、景深（Depth of Field）、运动模糊（Motion Blur），一般而言都是后处理效果。</p><h3 id="9-颜色校正"><a href="#9-颜色校正" class="headerlink" title="9 颜色校正"></a>9 颜色校正</h3><p>色彩校正(Color correction)是使用一些规则来转化给定的现有图像的每像素颜色到其他颜色的一个过程。颜色校正有很多目的，例如模仿特定类型的电影胶片的色调，在元素之间提供一致的外观，或描绘一种特定的情绪或风格。一般而言，通过颜色校正，游戏画面会获得更好的表现效果。</p><p>颜色校正通常包括将单个像素的 RGB 值作为输入，并向其应用算法来生成一个新的 RGB。颜色校正的另一个用途是加速视频解码，如 YUV 色彩空间到 RGB 色彩空间的转换。基于屏幕位置或相邻像素的更复杂的功能也可行，但是大多数操作都是使用每像素的颜色作为唯一的输入。</p><p>对于一个计算量很少的简单转换，如亮度的调整，可以直接在像素着色器程序中基于一些公式进行计算，应用于填充屏幕的矩形。而对于复杂的计算函数，一个通常使用的方法是使用查找表（Look-Up Table，LUT）。由于从内存中提取数值经常要比复杂的计算速度快很多，所以使用查找表进行颜色校正操作，速度提升是很显著的。</p><h3 id="10-色调映射"><a href="#10-色调映射" class="headerlink" title="10 色调映射"></a>10 色调映射</h3><p>计算机屏幕具有特定的亮度范围，而真实图像具有更巨大的亮度范围。色调映射（Tonemapping），也称为色调复制（tone reproduction），便是将宽范围的照明级别拟合到屏幕有限色域内的过程。色调映射与表示高动态范围的  HDR 和  HDRI 密切相关：</p><ul><li>HDR，是 High-Dynamic Range（高动态范围）的缩写</li><li>HDRI 是 High-Dynamic Range Image 的缩写，即 HDR 图像，高动态范围图像</li><li>实际过程中，HDR 和 HDRI 两者经常会被混用，都当做高动态范围成像的概念使用，这也是被大众广泛接受的</li></ul><p>本质上来讲，色调映射要解决的问题是进行大幅度的对比度衰减以将场景亮度变换到可以显示的范围，同时要保持图像细节与颜色等表现原始场景的重要信息。</p><p>根据应用的不同，色调映射的目标可以有不同的表述。在有些场合，生成“好看”的图像是主要目的，而在其它一些场合可能会强调生成尽可能多的细节或者最大的图像对比度。在实际的渲染应用中可能是要在真实场景与显示图像中达到匹配，尽管显示设备可能并不能够显示整个的亮度范围。</p><p>简单来说，整个 Tone Mapping 的过程就是首先要根据当前的场景推算出场景的平均亮度，再根据这个平均亮度选取一个合适的亮度域，再将整个场景映射到这个亮度域得到正确的结果。</p><p>具体关于色调映射算法可以查看：</p><ul><li><a href="https://blog.csdn.net/qq_37363005/article/details/103593541">Tone Mapping—色调映射算法</a></li><li><a href="https://blog.csdn.net/qq_21842097/article/details/121035017">色调映射（Tone Mapping）</a></li></ul><h3 id="11-镜头眩光和泛光"><a href="#11-镜头眩光和泛光" class="headerlink" title="11 镜头眩光和泛光"></a>11 镜头眩光和泛光</h3><p>镜头眩光（Lens flare）是由于眼睛的晶状体或者相机的透镜直接面对强光所产生的一种现象，由一圈光晕（halo）和纤毛状的光环（ciliary corona）组成。光晕的出现是因为透镜物质（如三棱镜）对不同波长光线折射数量的不过而造成的，看上去很像是光周围的一个圆环，外圈是红色，内圈是紫红色。纤毛状的光环源于透镜的密度波动，看起来像是从一个点发射出来的光线。Lens flare 是近来较为流行的一种图像效果，自从我们认识到它是一种实现真实感效果的技术后，计算机便开始模拟此效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143849029.png" alt="image-20220518143849029"></p><p>泛光（Bloom）效果，是由于眼睛晶状体和其他部分的散光而产生，在光源附近出现的一种辉光。在现实世界中，透镜无法完美聚焦是泛光效果的物理成因；理想透镜也会在成像时由于衍射而产生一种名为艾里斑的光斑。在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">【Unity Shader】（七）基础屏幕特效</a>中实现过 Bloom 效果。<br>常见的一个误解便是将 HDR 和 Bloom 效果混为一谈。Bloom 可以模拟出 HDR 的效果，但是原理上和 HDR 相差甚远。HDR 实际上是通过映射技术，来达到整体调整全局亮度属性的，这种调整是颜色，强度等都可以进行调整，而 Bloom 仅仅是能够将光照范围调高达到过饱和，也就是让亮的地方更亮。不过 Bloom 效果实现起来简单，性能消耗也小，却也可以达到不错的效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143939832.png" alt="image-20220518143939832"></p><h3 id="12-景深"><a href="#12-景深" class="headerlink" title="12 景深"></a>12 景深</h3><p>在光学领域，特别是摄影摄像领域，景深（Depth of field，DOF），也叫焦点范围（focus range）或有效焦距范围（effective focus），是指场景中最近和最远的物体之间出现的可接受的清晰图像的距离。换言之，景深是指相机对焦点前后相对清晰的成像范围。在相机聚焦完成后，在焦点前后的范围内都能形成清晰的像，这一前一后的距离范围，便叫做景深。</p><p>景深通常由物距、镜头焦距，以及镜头的光圈值所决定（相对于焦距的光圈大小）。除了在近距离时，一般来说景深是由物体的放大率以及透镜的光圈值决定。固定光圈值时，增加放大率，不论是更靠近拍摄物或是使用长焦距的镜头，都会减少景深的距离；减少放大率时，则会增加景深。如果固定放大率时，增加光圈值（缩小光圈）则会增加景深；减小光圈值（增大光圈）则会减少景深。</p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/">【RayTracer】（七）景深效果</a>中有代码实现。</p><h3 id="13-运动模糊"><a href="#13-运动模糊" class="headerlink" title="13 运动模糊"></a>13 运动模糊</h3><p>实现运动模糊的方法大致分  3 种：</p><ul><li>直接渲染模糊本身。通过在对象移动之前和之后添加几何体来完成，并通过次序无关的透明，避免 Alpha 混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/">【RayTracer】（九）运动模糊</a>中的实现就是使用的这种方法。</li><li>基于累积缓冲区（accumulationbuffer），通过平均一系列图像来创建模糊。</li><li>基于速度缓冲器（velocity buffer）。目前这个方法最为主流。创建此缓冲区，需插入模型三角形中每个顶点的屏幕空间速度。通过将两个建模矩阵应用于模型来计算速度，一个用于最后一帧，一个用于当前模型。顶点着色器程序计算位置的差异，并将该向量转换为相对的屏幕空间坐标。</li></ul><p>运动模糊对于由摄像机运动而变得模糊的静态物体来说比较简单，因为往往这种情况下不需要速度缓冲区。如果需要的是摄像机移动时的运动感，可以使用诸如径向模糊（radial blur）之类的固定效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518144557566.png" alt="image-20220518144557566"></p><h3 id="14-体渲染"><a href="#14-体渲染" class="headerlink" title="14 体渲染"></a>14 体渲染</h3><p>体渲染（Volume Rendering），又称立体渲染，体绘制，是一种用于显示离散三维采样数据集的二维投影的技术。体渲染技术中的渲染数据一般用体素（Volumeric Pixel，或  Voxel）来表示，每个体素表示一个规则空间体。例如，要生成人头部的医学诊断图像（如 CT 或 MRI），同时生成 256 x256 个体素的数据集合，每个位置拥有一个或者多个值，则可以将其看做三维图像。因此，体渲染也是基于图像的渲染技术中的一种。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中基于图像的渲染技术进行概括总结和扩展。以综述形式为主，许多内容已经实现过或学习过，其他概念只需了解即可，主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谱渲染 The Rendering Spectrum&lt;/li&gt;
&lt;li&gt;固定视角的渲染 Fixed-View Rendering&lt;/li&gt;
&lt;li&gt;天空盒 Skyboxes&lt;/li&gt;
&lt;li&gt;光场渲染 Light Field Rendering&lt;/li&gt;
&lt;li&gt;精灵与层 Sprites and Layers&lt;/li&gt;
&lt;li&gt;公告板 Billboarding&lt;/li&gt;
&lt;li&gt;粒子系统 Particle System&lt;/li&gt;
&lt;li&gt;颜色校正 Color Correction&lt;/li&gt;
&lt;li&gt;色调映射 Tone Mapping&lt;/li&gt;
&lt;li&gt;镜头眩光和泛光 Lens Flare and Bloom&lt;/li&gt;
&lt;li&gt;景深 Depth of Field&lt;/li&gt;
&lt;li&gt;运动模糊 Motion Blur&lt;/li&gt;
&lt;li&gt;体渲染 Volume Rendering&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】全局光照总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T05:47:51.000Z</published>
    <updated>2022-05-18T05:48:41.302Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中全局光照相关知识进行概括总结和扩展。主要内容包括：</p><ul><li>全局光照概述</li><li>光线投射、光线追踪和路径追踪的区别</li><li>环境光遮蔽</li></ul><p><em><span id="more"></span></em></p><h3 id="1-全局光照"><a href="#1-全局光照" class="headerlink" title="1 全局光照"></a>1 全局光照</h3><p>全局光照 (Global Illumination，GI)，是指既考虑场景中直接来自光源的光照（Direct Light）又考虑经过场景中其他物体反射后的光照（Indirect Light）的一种渲染技术。使用全局光照能够有效地增强场景的真实感。<br>可以理解为：全局光照    &#x3D;  直接光照(Direct Light) +  间接光照(Indirect Light)</p><p>虽说实际应用中只有漫反射全局照明的模拟算法被称为全局照明算法，但其实理论上说反射、折射、阴影都属于全局光照的范畴，因为模拟它们的时候不仅仅要考虑光源对物体的直接作用还要考虑物体与物体之间的相互作用。也是因为，镜面反射、折射、阴影一般不需要进行复杂的光照方程求解，也不需要进行迭代的计算。因此，这些部分的算法已经十分高效，甚至可以做到实时。不同于镜面反射，光的漫反射表面反弹时的方向是近似“随机”，因此不能用简单的光线跟踪得到反射的结果，往往需要利用多种方法进行多次迭代，直到光能分布达到一个基本平衡的状态。</p><p>经过几十年的发展，全局光照现今已有多种实现方向，常见的全局光照主要流派列举如下：</p><ul><li>Ray tracing  光线追踪</li><li>Path tracing  路径追踪</li><li>Photon mapping  光子映射</li><li>Point Based Global Illumination  基于点的全局光照</li><li>Radiosity  辐射度</li><li>Metropolis light transport  梅特波利斯光照传输</li><li>Spherical harmonic lighting  球谐光照</li><li>Ambient occlusion  环境光遮蔽</li><li>Voxel-based Global Illumination  基于体素的全局光照</li><li>Light Propagation Volumes Global Illumination</li><li>Deferred Radiance Transfer Global Illumination</li><li>Deep G-Buffer based Global Illumination</li></ul><p>而其中的每种流派，又可以划分为 N 种改进和衍生算法。<br>如光线追踪（Ray Tracing）派系，其实就是一个框架，符合条件的都可称为光线追踪，其又分为递归式光线追踪（Whitted-style Ray Tracing），分布式光线追踪（Distribution Ray Tracing），蒙特卡洛光线追踪（Monte Carlo Ray Tracing）等。<br>而路径追踪（Path tracing）派系，又分为蒙特卡洛路径追踪（Monte Carlo Path Tracing），双向路径追踪（Bidirectional Path Tracing），能量再分配路径追踪（Energy Redistribution Path Tracing）等。<br>其中有些派系又相互关联，如路径追踪，就是基于光线追踪，结合了蒙特卡洛方法而成的一种新的派系。</p><h3 id="2-光线投射、光线追踪和路径追踪的区别"><a href="#2-光线投射、光线追踪和路径追踪的区别" class="headerlink" title="2 光线投射、光线追踪和路径追踪的区别"></a>2 光线投射、光线追踪和路径追踪的区别</h3><p>关于光线追踪和路径追踪可以查看之前的笔记：</p><ul><li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a></li><li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a></li><li><a href="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/">RayTracer 系列</a>前半部分实现的是光线追踪，后半部分加入蒙特卡洛后最终实现的是一个路径追踪器</li></ul><p>这里总结一下光线追踪、光线投射和路径追踪的区别：</p><ul><li><strong>光线追踪 Ray Tracing</strong>：这其实是个框架，而不是个方法。符合这个框架的都叫 ray tracing。这个框架就是从视点发射 ray，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。</li><li><strong>光线投射 Ray Casting</strong>：它就是 ray tracing 的第一步，发射光线，与物体相交。这个可以做的很快，也可以用来做遮挡、阴影等。</li><li><strong>路径追踪 Path Tracing</strong>：路径追踪就是 ray tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据 BRDF 计算颜色。运算量也不小。还有一些小分类，比如 Bidirectional path tracing。</li></ul><h3 id="3-环境光遮蔽"><a href="#3-环境光遮蔽" class="headerlink" title="3 环境光遮蔽"></a>3 环境光遮蔽</h3><p>环境光遮蔽（Ambient Occlusion，简称 AO）是全局光照明的一种近似替代品，可以产生重要的视觉明暗效果，通过描绘物体之间由于遮挡而产生的阴影， 能够更好地捕捉到场景中的细节，可以解决漏光，阴影漂浮等问题，改善场景中角落、锯齿、裂缝等细小物体阴影不清晰等问题，增强场景的深度和立体感。<br>可以说，环境光遮蔽在直观上给玩家的主要感觉体现在画面的明暗程度上，未开启环境光遮蔽特效的画面光照稍亮一些；而开启环境光遮蔽特效之后， 局部的细节画面尤其是暗部阴影会更加明显一些。</p><p>Ambient Occlusion 的细分种类有：</p><ul><li>SSAO-Screen space ambient occlusion</li><li>SSDO-Screen space directional occlusion</li><li>HDAO-High Definition Ambient Occlusion</li><li>HBAO+-Horizon Based Ambient Occlusion+</li><li>AAO-Alchemy Ambient Occlusion</li><li>ABAO-Angle Based Ambient Occlusion</li><li>PBAO</li><li>VXAO-Voxel Accelerated Ambient Occlusion</li></ul><p>一般而言，Ambient Occlusion 最常用方法是 SSAO，如 Unreal Engine 4 中的 AO，即是用 SSAO 实现。关于 SSAO 的原理可以查看这篇文章简要了解：<a href="https://zhuanlan.zhihu.com/p/46633896">环境遮罩之SSAO原理</a></p><p>总的来说 SSAO 是在屏幕空间进行的环境光遮蔽计算，以牺牲部分渲染效果和精度的代价，来换取高时效性，适用于游戏等实时渲染领域。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中全局光照相关知识进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局光照概述&lt;/li&gt;
&lt;li&gt;光线投射、光线追踪和路径追踪的区别&lt;/li&gt;
&lt;li&gt;环境光遮蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】延迟渲染总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-16T08:56:09.000Z</published>
    <updated>2022-05-16T09:18:24.669Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中延迟渲染相关知识进行概括总结和扩展。主要内容包括：</p><ul><li>延迟渲染的概念、G-buffer、延迟渲染的过程</li><li>延迟渲染 vs 正向渲染、延迟渲染 vs Z-Prepass</li><li>延迟渲染的优缺点、延迟渲染透明物体、延迟渲染与 MSAA</li><li>延迟渲染的改进：延迟光照（Light Pre-Pass &#x2F; Deferred Lighting）、分块延迟渲染（Tile-Based Deferred Rendering）</li><li>延迟渲染 vs 延迟光照</li></ul><p><em><span id="more"></span></em></p><h3 id="1-延迟渲染（Deferred-Rendering）"><a href="#1-延迟渲染（Deferred-Rendering）" class="headerlink" title="1 延迟渲染（Deferred Rendering）"></a>1 延迟渲染（Deferred Rendering）</h3><p>在计算机图形学中，延迟渲染（Deferred Rendering），又称延迟着色（Deferred Shading），是将着色计算延迟到深度测试之后进行处理的一种渲染方法。<strong>延迟渲染技术的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给我们渲染拥有大量光源的场景提供了很多可能性。</strong></p><p>我们知道，正向渲染（Forward Rendering），或称正向着色（Forward Shading），是渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。</p><p>传统的正向渲染思路是，先进行着色，再进行深度测试。其主要缺点就是光照计算跟场景复杂度和光源个数有很大关系。假设有 n 个物体，m 个光源，且每个每个物体受所有光源的影响，那么复杂度就是 O(m*n)。</p><p>正向渲染简单直接，也很容易实现，但是同时它对程序性能的影响也很大，因为对每一个需要渲染的物体，程序都要对每个光源下每一个需要渲染的片元进行迭代，如果旧的片元完全被一些新的片元覆盖，最终无需显示出来，那么其着色计算花费的时间就完全浪费掉了。</p><p>而延迟渲染的提出，就是为了解决上述问题而诞生（尤其是在场景中存在大量光源的情况下）。延迟渲染给我们优化拥有大量光源的场景提供了很多可能性，因为它能够在渲染拥有成百上千光源的场景的同时还能够保持能让人接受的帧率。下面这张图展示了一个基于延迟着色渲染出的场景，这个场景中包含了 1000 个点光源，对于目前的硬件设备而言，用传统的正向渲染来实现将是极其耗时的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516150601199.png" alt="image-20220516150601199"></p><p><strong>可以将延迟渲染理解为先将所有物体都绘制到屏幕空间的缓冲（即  G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元的着色而产⽣的不必要的开销。</strong>也就是说延迟渲染基本思想是，先执行深度测试，再进行着色计算，将本来在物空间（三维空间）进行的光照计算放到了像空间（二维空间）处理。相较于正向渲染 O(m*n) 的复杂度，经典的延迟渲染复杂度为 O(n+m)。</p><h3 id="2-几何缓冲区（G-buffer）"><a href="#2-几何缓冲区（G-buffer）" class="headerlink" title="2 几何缓冲区（G-buffer）"></a>2 几何缓冲区（G-buffer）</h3><p>G-Buffer，全称 Geometric Buffer，几何缓冲区。它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用的材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。下图展示了一个典型的 G-Buffer 布局：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151041625.png" alt="image-20220516151041625"></p><p>下图是一帧中 G-Buffer 中存储的部分内容可视化结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151116425.png" alt="image-20220516151116425"></p><p>G-Buffer 是一个宏观的概念，并不是一整个缓冲区，而是由多个缓冲区共同组成，或者由多张纹理共同组成，比如后文会提到的 MRT，就是将不同的信息渲染到多个纹理，这些纹理被称为渲染目标（Render Targte，RT），这些 RT 共同组成了 G-Buffer。</p><h3 id="3-延迟渲染的过程"><a href="#3-延迟渲染的过程" class="headerlink" title="3 延迟渲染的过程"></a>3 延迟渲染的过程</h3><p>可以将延迟渲染理解为两个 Pass 的过程：</p><p>1、<strong>几何处理阶段（Geometry Pass）</strong>。这个阶段中，我们获取对象的各种几何信息，并将第二步（也就是渲染）所需的各种数据储存到多个渲染目标中；</p><p>2、<strong>光照处理阶段（Lighting Pass）</strong>。在这个 pass 中，我们只需渲染出一个屏幕大小的二维矩形，使用第一步在 G-buffer 中存储的数据对此矩阵的每一个片元计算场景的光照；光照计算的过程还是和正向渲染一样，只是现在我们需要从对应的 G-buffer 而不是顶点着色器（和一些 uniform 变量）那里获取输入变量了。</p><p>下图展示了延迟渲染的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151507237.png" alt="image-20220516151507237"></p><p>延迟渲染方法一个很大的好处就是能保证在 G-buffer 中的片元和在屏幕上呈现的像素所包含的片元信息是一样的，因为深度测试已经最终将这里的片元信息作为最顶层的片元。这样保证了对于在光照处理阶段中处理的每一个像素都只处理一次，所以我们能够省下很多无用的渲染调用。除此之外，延迟渲染还允许我们做更多的优化，从而渲染更多的光源。</p><p>在几何处理阶段中填充 G-buffer 非常高效，因为我们直接储存位置，颜色，法线等对象信息到帧缓冲中，这个过程几乎不消耗处理时间。</p><p>对于多个光源的情况，不同的光源对场景的影响不同，所以 G-Buffer 中存储的片元信息也可能不同，因此我们可以对每个光源创建一个屏幕空间包围矩形，然后用光照 shader 渲染这个矩形，最后融合起来即可。</p><p>而在此基础上使用多渲染目标（Multiple Render Targets, MRT）技术，我们可以在一个 Pass 之内完成所有渲染工作。渲染目标就是指纹理，也就是将渲染结果存到纹理中而不是输出到屏幕上，之后再用这些纹理进行各种后处理，在 Unity Shader 部分中我们早就已经这样做过了，这也是极其常见的做法。多渲染目标就是指将各种信息（位置、法线、反射率等）分别存入一张纹理中，然后结合多张纹理的信息进行着色计算，实际上和 G-Buffer 的效果一样，也可以说这些纹理组成了 G-Buffer，而且存入纹理中的信息还可以反复使用，用来实现各种更高级的效果。</p><h3 id="4-延迟渲染-vs-正向渲染"><a href="#4-延迟渲染-vs-正向渲染" class="headerlink" title="4 延迟渲染 vs 正向渲染"></a>4 延迟渲染 vs 正向渲染</h3><p>这是一个经常被问起的话题，因此这里对二者的特性做一个总结。</p><h4 id="4-1-正向渲染"><a href="#4-1-正向渲染" class="headerlink" title="4.1 正向渲染"></a>4.1 正向渲染</h4><ul><li>正向渲染（Forward Rendering），先执行着色计算，再执行深度测试</li><li>正向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n*m)</li><li>正向渲染中光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景</li><li>Forward Rendering 的核心伪代码可以表示为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For each light:</span><br><span class="line">For each object affected by the light: </span><br><span class="line">framebuffer += object * light</span><br></pre></td></tr></table></figure><ul><li>Forward Rendering 的管线流程如下图所示：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516152551865.png" alt="image-20220516152551865"></p><h4 id="4-2-延迟渲染"><a href="#4-2-延迟渲染" class="headerlink" title="4.2 延迟渲染"></a>4.2 延迟渲染</h4><ul><li>延迟渲染（Deferred Rendering），先执行深度测试，再执行着色计算</li><li>延迟渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n+m)</li><li>Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化</li><li>Deferred Rendering 的核心伪代码可以表示如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For each object:</span><br><span class="line">    Render to multiple render targets </span><br><span class="line">For each light:</span><br><span class="line">    Apply light as a 2D postprocess</span><br></pre></td></tr></table></figure><ul><li>Deferred Rendering 的管线流程如图所示：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516152925120.png" alt="image-20220516152925120"></p><h4 id="4-3-延迟渲染-vs-Z-Prepass"><a href="#4-3-延迟渲染-vs-Z-Prepass" class="headerlink" title="4.3 延迟渲染 vs Z-Prepass"></a>4.3 延迟渲染 vs Z-Prepass</h4><p>延迟渲染和之前学过的 Early-Z 非常相似，二者的区别可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/">【Real-Time Rendering】模板测试和深度测试</a>的最后部分。</p><h3 id="5-延迟渲染的优缺点"><a href="#5-延迟渲染的优缺点" class="headerlink" title="5 延迟渲染的优缺点"></a>5 延迟渲染的优缺点</h3><p>总结一下延迟渲染的优缺点。</p><h4 id="5-1-延迟渲染的优点"><a href="#5-1-延迟渲染的优点" class="headerlink" title="5.1 延迟渲染的优点"></a>5.1 延迟渲染的优点</h4><ul><li>Deferred Rendering 最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化</li><li>复杂度仅 O(n+m)</li><li>只渲染可见的像素，节省计算量</li><li>用更少的 shader</li><li>对后处理支持良好</li><li>在大量光源的场景优势尤其明显</li></ul><h4 id="5-2-延迟渲染的缺点"><a href="#5-2-延迟渲染的缺点" class="headerlink" title="5.2 延迟渲染的缺点"></a>5.2 延迟渲染的缺点</h4><ul><li>内存开销大</li><li>读写 G-buffer 的内存带宽用量是性能瓶颈</li><li>对透明物体的渲染存在问题，在这点上需要结合正向渲染。后面细说。</li><li>对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好。后面细说。</li></ul><h3 id="6-延迟渲染透明物体"><a href="#6-延迟渲染透明物体" class="headerlink" title="6 延迟渲染透明物体"></a>6 延迟渲染透明物体</h3><p>延迟渲染要渲染透明物体需要与前向渲染结合。首先，我们需要明确一个问题，为什么延迟渲染不适用于透明物体？</p><p>因为延迟渲染只计算了离视野最近的物体像素，并对其进行光照计算和着色。因此，这会导致：</p><ul><li>透明物体和不透明物体重叠，且透明物体在后时，仅渲染不透明物体，效果正确</li><li>透明物体和不透明物体重叠，且透明物体在前时，仅渲染透明物体，效果错误，看不到透明物体后面的物体</li><li>透明物体之间重叠时，仅渲染最前面的透明物体，效果错误</li></ul><p>解决以上问题一个常见的思路是：<strong>使用延迟渲染的框架，分别渲染不透明物体，透明物体背面，透明物体正面，再把三者按照 alpha 合并。</strong></p><p>在这种情况下，我们可以基本保证第二种情况的正确；而对于第三种情况，由于延迟渲染仅对离相机最近的像素进行光照&#x2F;着色计算，我们依然只能计算（特别地，若最近的像素透明度为0，我们忽略这一像素）最近的透明物体的光照。<strong>对于这种情况，采取的解决方案是写入 G-Buffer 时仅混合物体颜色，在延迟渲染过程中，依然只计算最近物体的光照，但把混合后的颜色作为最近物体的基本颜色进行光照计算。</strong></p><h3 id="7-延迟渲染与-MSAA"><a href="#7-延迟渲染与-MSAA" class="headerlink" title="7 延迟渲染与 MSAA"></a>7 延迟渲染与 MSAA</h3><p>为什么延迟渲染中不支持 MSAA？这又是一个经常被问起的话题，延迟渲染不支持 MSAA 的说法实际上并不准确，准确的说是延迟渲染对 MSAA 的支持并不好，或者说在延迟渲染中做 MSAA 不方便。</p><p>首先来回顾 MSAA 的原理，MSAA 是在 SSAA 的基础上发展来的硬件抗锯齿技术。SSAA 是理论上效果最好的抗锯齿方案，以 4x 为例（下同），4xSSAA 对于每个像素计算 4 个子像素，将 4 个子像素的颜色求平均值，便能获得抗锯齿后的颜色。实际上 SSAA 等于暴力渲染了 4 倍分辨率的图像，在目前的硬件条件下这种性能开销是不可接受的，因此在 SSAA 的基础上发展出了 MSAA。</p><p>MSAA 与 SSAA 的区别在于像素着色器（Pixel Shader）的运行次数。MSAA 同样对于每个像素进行了 4 次子采样（Sample），但是只在像素中心位置运行一次像素着色，然后根据有多少 Sample 被三角形覆盖而对颜色进行一个加权处理，也就是像素中有多少子像素被三角形覆盖，就用该像素的颜色乘以被覆盖的子像素的比例，相比于 SSAA 每个子像素单独计算颜色，效率大幅提升。</p><p>下面以一个例子来看 MSAA 的具体过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516161128767.png" alt="image-20220516161128767"></p><p>在前向渲染中，三角形的绘制是依次进行的。绘制蓝色三角形时，MSAA 的具体执行步骤如下：</p><ol><li>光栅化阶段，对四个 X 位置的 Sample 执行三角形覆盖判断，在一个四倍分辨率大小的 coverage mask 中记录每个 Sample 被覆盖的情况；</li><li>像素着色阶段，在像素中心圆点处执行像素着色器。该点的位置、深度、法线、纹理坐标等信息由三角形三个顶点重心插值得到。图中计算得到像素颜色为紫色；</li><li>对四个 Sample 执行模板测试与深度测试，并将测试通过的 Sample 数据写入四倍分辨率的模板缓冲与深度缓冲。每个 Sample 都拥有自己的深度值，依然是重心插值得到；</li><li>上图中左下两个 Sample 通过了深度测试，并且 coverage mask 为 1，因此将紫色复制到这两个 Sample 对应的颜色缓冲中（依然是每个 Sample 一个颜色，颜色缓冲也需要四倍大小）。其他两个 Sample 暂为背景色；</li><li>重复上述流程绘制第二个黄色三角形，将像素着色获得的黄色复制到右上角的 Sample 中；</li><li>所有绘制结束之后，通过一个对高层透明的 pass，将四个 Sample 的颜色混合获得最终输出的像素颜色。</li></ol><p>可以看到在 MSAA 流程中所使用的所有缓冲区都变成了原来的四倍大小，这也是为什么 MSAA 增加了非常多的显存和带宽消耗。上述流程中第 4 步如果改成对每个 Sample 单独进行像素着色，MSAA 就变成了 SSAA。</p><p>理通了 MSAA 的具体流程，接下来回答问什么延迟渲染不好做 MSAA：</p><p>延迟渲染的光照计算阶段使用的输入是 G-Buffer，如果还像前向渲染一样，在光照计算以后执行 MSAA，会得到错误的结果。具体来说，使用单倍 G-Buffer 来进行计算，会因为得不到三角形的覆盖信息而无法判定应该将该像素的颜色值复制到哪几个子 Sample 上，也不会出现同一个像素的子 Sample 会被不同面片覆盖的情况，因为 G-Buffer 就是一张图，已经不知道该点被几个三角形覆盖了。而使用多倍大小的 G-Buffer 的话，又无法通过顶点插值获取中心处原始像素的位置、深度、法线、纹理坐标等数据，因为原始三个顶点的信息已经没有了。更重要的是，在多倍大小的 G-Buffer 上我们是没办法判断哪几个子 Sample 是与中心像素在同一三角形上的，如果试图使用四个子 Sample 的数据插值获得中心像素，对深度和法线进行插值会导致意料之外的后果。上面两个原因综合起来，就是“丢失的其他像素信息导致无法使用 MSAA” 这种说法的来源了。</p><p><strong>总结起来，延迟渲染对 MSAA 支持不友好的原因在于：</strong></p><ul><li>MSAA 本质上是一种发生在光栅化阶段的技术，也就是几何阶段后，着色阶段前，用这个技术需要用到场景中的几何信息</li><li>延迟渲染因为需要节省光照计算的原因，事先把所有信息都放在了 G-Buffer 上，着色计算的时候已经丢失了几何信息</li></ul><p>如果要在延迟渲染中使用 MSAA，需要将 G 缓存的 MRT 以多重采样的形式保存使得每个样本的信息不被丢失从而可以进行解析操作。而如果直接对 G 缓存中的属性比如法线和深度进行解析的话则可能产生错误结果，比如说如果一个给定像素中的样本在 G 缓存中有着不同的深度值，那么取均值后的结果可能和场景真实的几何信息无关，法线同理。正确的做法是对每个样本进行光照计算后再解析，对每个样本的光照结果取均值。因此需要保证像素着色器逐样本执行然后将每个样本输出写入多重采样RT。如下图所示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516162715482.png" alt="image-20220516162715482"></p><p>事实上，从 DirectX 10 开始就已经允许在高达 8 个 MRT 的情况下使用 MSAA 了。</p><h3 id="8-延迟渲染的改进"><a href="#8-延迟渲染的改进" class="headerlink" title="8 延迟渲染的改进"></a>8 延迟渲染的改进</h3><p>上文提到过，延迟渲染的性能瓶颈在于读写 G-buffer 的内存带宽，因此延迟渲染的改进也主要是从这方面入手，下面简单介绍一些降低延迟渲染存取带宽的改进方案。最简单也是最容易想到的就是将存取的 G-Buffer 数据结构最小化，这也就衍生出了 Light Pre-Pass，即延迟光照（Deferred Lighting）方法。另一种方式是将多个光照组成一组，然后一起处理，这种方法衍生出了分块延迟渲染（Tile-Based Deferred Rendering）。</p><h4 id="8-1-延迟光照"><a href="#8-1-延迟光照" class="headerlink" title="8.1 延迟光照"></a>8.1 延迟光照</h4><p>Light Pre-Pass 即 Deferred Lighting（延迟光照），旨在减少传统 Defferred Rendering 使用 G-buffer 时占用的过多开销，延迟光照的具体的思路是：</p><ol><li>渲染场景中不透明（opaque ）的几何体。将法线向量 n 和镜面扩展因子（specular spread factor）m 写入缓冲区。这个 n&#x2F;m-buffer 缓冲区是一个类似 G-Buffer 的缓冲区，但包含的信息更少，更轻量，可以用单个输出颜色缓冲区存储，因此不需要 MRT 支持。</li><li>渲染光照。计算漫反射和镜面着色方程，并将结果写入不同的漫反射和镜面反射累积缓冲区。这个过程可以在一个单独的 pass 中完成（使用 MRT），或者用两个单独的 pass。环境光照明可以在这个阶段使用一个 full-screen pass 进行计算。</li><li>对场景中的不透明几何体进行第二次渲染。从纹理中读取漫反射和镜面反射值，对前面步骤中漫反射和镜面反射累积缓冲区的值进行调制，并将最终结果写入最终的颜色缓冲区。若在上一阶段没有处理环境光照明，则在此阶段应用环境光照明。</li><li>使用非延迟渲染方法渲染半透明几何体。</li></ol><p>总结来说相当于把每个像素的光照计算结果也存入纹理中，最后着色时对光照结果进行调制或者后处理。相对于传统的 Deferred Render，使用 Light Pre-Pass 可以对每个不同的几何体使用不同的 shader 进行渲染，所以每个物体的 material properties 将有更多变化。</p><p>传统的 Deferred Render 的第二步是遍历每个光源，这样就增加了光源设置的灵活性，而 Light Pre-Pass 第三步使用的其实是 forward rendering，所以可以对每个 mesh 设置其材质，这两者是相辅相成的，有利有弊。</p><p>另一个 Light Pre-Pass 的优点是在使用 MSAA 上很有利。虽然并不是完全使用上了 MSAA（除非使用 DX10 以上的特性），但是由于使用了 Z 值和 Normal 值，就可以很容易找到边缘，并进行采样。</p><h4 id="8-2-分块延迟渲染"><a href="#8-2-分块延迟渲染" class="headerlink" title="8.2 分块延迟渲染"></a>8.2 分块延迟渲染</h4><p>作为传统 Defferred Rendering 的另一种主要改进，分块延迟渲染（Tile-Based Deferred Rendering，TBDR）旨在合理分摊开销。实验数据表明 TBDR 在大量光源存在的情况下明显优于上述的 Light Pre-Pass。</p><p>我们知道，延迟渲染的瓶颈在于读写 G-buffer，在大量光源下，具体的瓶颈将会在于每个光源对 G-buffer 的读取及与颜色缓冲区混合。这里的问题是，每个光源，即使它们的影响范围在屏幕空间上有重叠，因为每个光源是在不同的绘制中进行，所以会重复读取 G-buffer 中相同位置的数据，计算后以相加混合方式写入颜色缓冲。光源越多，内存带宽用量越大。</p><p>而分块延迟渲染的主要思想则是把屏幕分拆成细小的栅格，例如每 32 × 32 像素作为一个分块（tile），然后计算每个分块会受到哪些光源影响，把那些光源的索引储存在分块的光源列表里。最后，逐个分块进行着色，对每个像素读取 G-buffer 和光源列表及相关的光源信息。因此，G-buffer 的数据只会被读取 1 次且仅 1 次，写入 color buffer 也是 1 次且仅 1 次，大幅降低内存带宽用量。不过，这种方法需要计算光源会影响哪些分块，这个计算又称为光源剔除（light culling），可以在 CPU 或 GPU（通常以 compute shader 实现）中进行。用 GPU 计算的好处是，GPU 计算这类工作比 CPU 更快，也可以减少 CPU 和 GPU 之间的数据传输。此外，还可以计算每个分块的深度范围（depth range），作更有效的剔除。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516164106531.png" alt="image-20220516164106531"></p><p>总结来说，分块延迟渲染将屏幕分成一个个小块 tile 并计算每个分块的深度范围。然后根据深度范围和分块大小，可以求得每个 tile 的 bounding volume。对每个 tile 的 bounding volume 和光源进行求交点，这样就得到了对该 tile 有作用的光源的序列。最后根据得到的序列计算所在 tile 的光照效果。</p><p>对比传统 Deferred Rendering，之前是对每个光源求其作用区域 light volume，然后决定其作用的 pixel，也就是说每个光源要求取一次。而使用 TBDR，只要遍历每个 pixel，让其所属 tile 与光线求交，来计算作用其上的光源，并利用 G-Buffer 进行着色。这样做一方面减少了所需考虑的光源个数，另一方面与传统的 Deferred Rendering 相比减少了存取的带宽。</p><h3 id="9-延迟渲染-vs-延迟光照"><a href="#9-延迟渲染-vs-延迟光照" class="headerlink" title="9 延迟渲染 vs 延迟光照"></a>9 延迟渲染 vs 延迟光照</h3><p>关于延迟着色和延迟光照，经常会被弄混，这里简单区分一下。</p><ul><li>延迟渲染需要更大的 G-Buffer 来完成对 Deferred 阶段的前期准备，而且一般需要硬件有 MRT 的支持，可以说是硬件要求更高。</li><li>延迟光照需要两个几何体元的绘制过程来完成整个渲染操作：G-Pass 与 Shading pass。这个既是劣势也是优势：由于延迟渲染中的 Deffered 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作；而延迟光照却可以在 Shading 阶段得到物体的材质信息进而使这一问题的处理变得较简单。</li><li>两种方法的上述操作均是只能完成对不透明物体的渲染，而透明或半透明的物体则需额外的传统 Pass 来完成。</li></ul><p>延迟渲染的流程图如下，根据 G-Buffer 中的信息直接计算光照和着色：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516165141752.png" alt="image-20220516165141752"></p><p>延迟光照的流程图如下，提前计算光照并存入纹理，在着色时直接对纹理采样得到光照结果，不再计算光照，只进行其他后处理，从这个流程上来说，Light Pre-Pass 这个名称更为合适：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516165158816.png" alt="image-20220516165158816"></p><p><strong>无论是正向渲染，延迟渲染、延迟光照、分块延迟渲染，都属于不同的渲染路径（Rendering Path）。</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中延迟渲染相关知识进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟渲染的概念、G-buffer、延迟渲染的过程&lt;/li&gt;
&lt;li&gt;延迟渲染 vs 正向渲染、延迟渲染 vs Z-Prepass&lt;/li&gt;
&lt;li&gt;延迟渲染的优缺点、延迟渲染透明物体、延迟渲染与 MSAA&lt;/li&gt;
&lt;li&gt;延迟渲染的改进：延迟光照（Light Pre-Pass &amp;#x2F; Deferred Lighting）、分块延迟渲染（Tile-Based Deferred Rendering）&lt;/li&gt;
&lt;li&gt;延迟渲染 vs 延迟光照&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】BRDF总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-16T06:55:13.000Z</published>
    <updated>2022-05-16T06:56:26.456Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中 BRDF 相关知识进行概括总结和扩展。主要内容包括：</p><ul><li>BRDF 前置知识：数学、辐射度量学</li><li>BRDF 的定义、理解和性质</li><li>BRDF 模型分类</li><li>基于物理的 BRDF</li><li>BRDF 引申</li></ul><p><em><span id="more"></span></em></p><h3 id="1-BRDF-前置知识"><a href="#1-BRDF-前置知识" class="headerlink" title="1 BRDF 前置知识"></a>1 BRDF 前置知识</h3><p>BRDF 需要的前置数学和辐射度量学的相关内容，可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/">【计算机图形学】（十二）辐射度量学基础</a>，这里不再赘述。</p><h3 id="2-BRDF-的定义、理解和性质"><a href="#2-BRDF-的定义、理解和性质" class="headerlink" title="2 BRDF 的定义、理解和性质"></a>2 BRDF 的定义、理解和性质</h3><h4 id="2-1-BRDF-的定义"><a href="#2-1-BRDF-的定义" class="headerlink" title="2.1 BRDF 的定义"></a>2.1 BRDF 的定义</h4><p>BRDF 的定义可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a>第一部分。为了更进一步加深理解，这里再进行一个总结。</p><p>可以将给一个表面着色的过程，理解为给定入射的光线数量和方向，计算出指定方向的出射光亮度（radiance）。在计算机图形学领域，BRDF（Bidirectional Reflectance Distribution Function，译作双向反射分布函数）是一个用来描述表面如何反射光线的方程。顾名思义，BRDF 就是一个描述光如何从给定的两个方向（入射光方向 $l$ 和出射方向 $v$）在表面进行反射的函数。</p><p>BRDF 的精确定义是出射辐射率的微分（differential outgoing radiance）和入射辐照度的微分（differential incoming irradiance）之比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516100712194.png" alt="image-20220516100712194"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516100727310.png" alt="image-20220516100727310"></p><p>一个最常见的疑问是，BRDF 为什么要取这样的定义。BRDF 为什么被定义为辐射率（radiance）和辐照度（irradiance）之比，而不是 radiance 和  radiance 之比，或者 irradiance 和 irradiance 之比呢？</p><p>首先，我们分别重温它们的定义：</p><ul><li>辐照度（Irradiance，又译作辉度，辐射照度），表示单位时间内到达单位面积的辐射通量，也就是辐射通量对于面积的密度，通常用符号 $E$ 表示，单位 $W&#x2F;m^2$ ，瓦特每平方米。</li><li>辐射率（Radiance，又译作光亮度），表示每单位立体角每单位投影面积的辐射通量，通常用符号 $L$ 表示,单位是 $W·sr^{-1}·m^{-2}$，瓦特每球面弧度每平方米。</li></ul><p>那么关于这个问题，我们可以这样理解：因为照射到入射点的不同方向的光，都可能从指定的反射方向出射，所以当考虑入射时，需要对面积进行积分。而辐照度 irradiance 正好表示单位时间内到达单位面积的辐射通量。所以 BRDF 函数，选取入射时的辐照度 Irradiance，和出射时的辐射率 Radiance，可以简单明了地描述出<strong>入射光线经过某个表面反射后如何在各个出射方向上分布</strong>。而直观来说，<strong>BRDF 的值给定了入射方向和出射方向能量的相对量</strong>。</p><h4 id="2-2-BRDF-的非微分形式"><a href="#2-2-BRDF-的非微分形式" class="headerlink" title="2.2 BRDF 的非微分形式"></a>2.2 BRDF 的非微分形式</h4><p>当光源类型不是面光源，而是诸如点光源或方向光源时，BRDF 定义可以用非微分形式表示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516101214326.png" alt="image-20220516101214326"></p><p>其中：</p><ul><li>$E(l)$ 是光源从入射方向 $l$ 投影到平面法线方向的光的辐照度（irradiance）</li><li>$L_o(v)$ 是在视线 $v$ 的方向上产生的出射辐射率（radiance）</li></ul><h4 id="2-3-BRDF-与着色方程"><a href="#2-3-BRDF-与着色方程" class="headerlink" title="2.3 BRDF 与着色方程"></a>2.3 BRDF 与着色方程</h4><p>根据 BRDF 定义，可以很容易写出用 n 个非面光源来拟合一般的着色方程：<br>$$<br>L_o(v) &#x3D; \sum_{k&#x3D;1}^{n} f(l_k, v) \otimes E_{L_k}cos\theta_{i_k}<br>$$<br>其中，k 是每个非面光源编号，符号 $\otimes$ 表示分段向量乘法，$E_{L_k}$ 表示着色点接收到的第 k 个非面光源入射的光的能量，即辉度（irradiance），因为 BRDF 和辉度都是 RGB 向量，所以需要对应的进行向量乘法再累加起来。</p><p>同理可以得到对于面光源的积分形式的着色方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516102543469.png" alt="image-20220516102543469"></p><p>含义同上，只是将累加变成了各个方向的积分。这在之前的笔记中有详细解释，这里不再赘述。</p><p>考虑到入射和出射方向都拥有两个自由度（通常参数化是使用两个角度：相对于表面法线的仰角 $\theta$ 和关于法线的旋转角度 $\phi$），一般情况下，BRDF 是拥有四个标量变量的函数。特别地，各向同性 BRDF（Isotropic BRDF）是一个重要的特殊情况，这样的 BRDF 在入射和出射方向围绕表面法线变化（保持相同的相对夹角）时保持不变。所以，各向同性 BRDF 是关于三个标量的函数。</p><h4 id="2-4-BRDF-可视化"><a href="#2-4-BRDF-可视化" class="headerlink" title="2.4 BRDF 可视化"></a>2.4 BRDF 可视化</h4><p>一种理解 BRDF 的方法就是在输入方向保持恒定的情况下对它进行可视化表示，如下图。对于给定方向的入射光来说，图中显示了出射光的能力分布：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516103729812.png" alt="image-20220516103729812"></p><p>在交点附近球形部分是漫反射分量，因此出射光来任何方向上的反射概率相等。椭圆部分是一个反射波瓣（Reflectance Lobe）。它形成了镜面分量。显然，这些波瓣位于入射光的反射方向上，波瓣厚度对应反射的模糊性。根据互易原理，可以将这些相同的可视化形成认为是每个不同入射光方向对单个出射方向的贡献量大小。</p><h4 id="2-5-BRDF-的性质"><a href="#2-5-BRDF-的性质" class="headerlink" title="2.5 BRDF 的性质"></a>2.5 BRDF 的性质</h4><p>BRDF 的性质包括：非负性、可逆性、线性、能量守恒，具体可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/">【计算机图形学】（十四）材质</a>的第七部分。</p><h3 id="3-BRDF-的模型分类"><a href="#3-BRDF-的模型分类" class="headerlink" title="3 BRDF 的模型分类"></a>3 BRDF 的模型分类</h3><p>BRDF 模型可以分为如下几类：</p><ul><li><strong>经验模型（Empirical Models）</strong>：使用基于实验提出的公式对 BRDF 做快速估计</li><li><strong>数据驱动的模型（Data-driven Models）</strong>：采集真实材质表面在不同光照角度和观察角将 BRDF 按照实测数据建立查找表，记录在数据库中，以便于快速的查找和计算</li><li><strong>基于物理的模型（Physical-based Models）</strong>：根据物体表面材料的几何以及光学属性建立反射方程，从而计算 BRDF，实现极具真实感的渲染效果。</li></ul><h4 id="3-1-BRDF-经验模型"><a href="#3-1-BRDF-经验模型" class="headerlink" title="3.1 BRDF 经验模型"></a>3.1 BRDF 经验模型</h4><p>关于  BRDF 的经验模型，有如下几个要点：</p><ul><li>经验模型提供简洁的公式以便于反射光线的快速计算</li><li>经验模型不考虑材质特性，仅仅提供一个反射光的粗糙近似</li><li>经验模型不一定满足物理定律，比如可逆性或能量守恒定律</li><li>经验模型因为其简洁和高效性被广泛运用</li></ul><p>常见的 BRDF 经验模型有：</p><ul><li>Lambert 漫反射模型</li><li>Phong 模型</li><li>Blinn-Phong 模型</li></ul><h4 id="3-2-数据驱动的-BRDF-模型"><a href="#3-2-数据驱动的-BRDF-模型" class="headerlink" title="3.2 数据驱动的 BRDF 模型"></a>3.2 数据驱动的 BRDF 模型</h4><p>数据驱动的 BRDF 模型可以理解为，度量一个大的 BRDF 材质集合，并将其记录为高维向量，利用降维的方法从这些数据中计算出一个低维模型，这样基于查表的方式，可以直接找到渲染结果，省去大量的实时计算。</p><p>需要注意的是，由于这些数据由于采集自真实材质，即便渲染出来的结果很真实，但缺点是没有可供调整效果的参数，无法基于这些数据修改成想要的效果，另外部分极端角度由于仪器限制，无法获取到数据，而且采样点密集，数据量非常庞大，所以并不适合游戏等实时领域，一般可用在电影等离线渲染领域，也可以用来做图形学研究，衡量其他模型的真实程度。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516104422175.png" alt="image-20220516104422175"></p><h4 id="3-3-基于物理的-BRDF-模型"><a href="#3-3-基于物理的-BRDF-模型" class="headerlink" title="3.3 基于物理的 BRDF 模型"></a>3.3 基于物理的 BRDF 模型</h4><p><strong>基于物理的渲染 (PBR, Physically-based rendering)</strong> 是计算机图形学中用数学建模的方式模拟物体表面各种材质散射光线的属性从而渲染照片真实图片的技术，是近年来是实时渲染领域的大趋势。<br>基于物理的 BRDF 模型通过包含材质的各种几何及光学性质来尽可能精确的近似现实世界中的材料。<strong>而一个基于物理的 BRDF 要必须满足至少如下两条 BRDF 的特性：能量守恒、亥姆霍兹光路可逆性（Helmholtz Recoprpcity Rule）。</strong></p><p>常见的基于物理的  BRDF 模型有：</p><ul><li>Cook-Torrance BRDF 模型</li><li>Ward BRDF 模型</li></ul><p>下文将先介绍基于物理的 BRDF 常常用到到的菲涅尔反射，次表面散射和微平面理论等理论，然后分别概括这两种基于物理的 BRDF 模型。</p><h3 id="4-基于物理的-BRDF"><a href="#4-基于物理的-BRDF" class="headerlink" title="4 基于物理的 BRDF"></a>4 基于物理的 BRDF</h3><h4 id="4-1-前置知识"><a href="#4-1-前置知识" class="headerlink" title="4.1 前置知识"></a>4.1 前置知识</h4><p>前置知识包含次表面散射、菲涅尔项和微表面理论，具体可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/">【计算机图形学】（十四）材质的</a>第四、五部分。这里挑重点进行补充和总结。</p><p>菲涅耳方程（Fresnel equations）是一组用于描述光在两种不同折射率的介质中传播时的反射和折射的光学方程。方程中所描述的反射被称作“菲涅耳反射”。菲涅尔反射（Fresnel Reflectance）或者菲涅尔效果（Fresnel Effect），即当光入射到折射率不同的两个材质的分界面时，一部分光会被反射，而我们所看到的光线会根据我们的观察角度以不同强度反射的现象。菲涅尔反射能够真实地模拟真实世界中的反射。在真实世界中，除了金属之外，其它物质均有不同程度的菲涅尔反射效果。</p><p>简单来说，视线垂直于表面时，反射较弱，而当视线并非垂直表面时，夹角越小，反射越明显。对于粗糙表面来说，在接近平行方向的高光反射也会增强但不够达到 100% 的强度。为何如此是因为影响菲涅尔效应的关键参数在于每个微平面的法向量和入射光线的角度，而不是宏观平面的法向量和入射光线的角度。因此我们在宏观层面看到的实际上是微平面的菲涅尔效应的一个平均结果。</p><p>根据菲涅尔反射，若你看向一个圆球，那么圆球中心的反射会较弱，而靠近边缘是反射会较强，如下图所示。另外需注意，这种关系也受折射率影响。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516105824543.png" alt="image-20220516105824543"></p><p>微表面理论假设表面是由不同方向的微小细节表面，也就是微平面（microfacets）组成。每一个微小的平面都会根据它的法线方向在一个方向上反射光线。表面法线朝向光源方向和视线方向中间的微表面会反射可见光。然而，不是所有的表面法线和半角法线（half normal）相等的微表面都会反射光线，因为其中有些会被遮挡，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516105922147.png" alt="image-20220516105922147"></p><p>我们用法线分布函数（Normal Distribution Function，简写为 NDF）—— D(h) 来描述组成表面一点的所有微表面的法线分布概率。可以这样理解：向 NDF 输入一个朝向 h，NDF 会返回朝向是 h 的微表面数占微表面总数的比例，比如有 8% 的微表面朝向是 h，那么就有 8% 的微表面可能将光线反射到观察方向，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516110118379.png" alt="image-20220516110118379"></p><p>仅红色微平面的表面法线和半程向量 h 对齐，能参与从入射光线方向到视线方向的光线反射。</p><p>NDF 的定义公式为：<br>$$<br>D(h) &#x3D; \frac{\alpha^2}{\pi((n·h)^2(\alpha^2-1)+1)^2}<br>$$<br>在微观层面上不规则的表面会造成光的漫反射。例如，模糊的反射是由于光线的散射造成的。而反射的光线并不均匀，因此我们得到的高光反射是模糊的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516110240348.png" alt="image-20220516110240348"></p><h4 id="4-2-Cook-Torrance-BRDF-模型"><a href="#4-2-Cook-Torrance-BRDF-模型" class="headerlink" title="4.2 Cook-Torrance BRDF 模型"></a>4.2 Cook-Torrance BRDF 模型</h4><p>Cook-Torrance 模型作为图形学中最早的基于物理的 BRDF 模型，由 Cook 和 Torrance 提出，是 Torrance-Sparrow 模型的一个应用版本。现今，Cook-Torrance 模型已经成为基于物理着色的标准模型之一。Cook-Torrance 模型将物理学中的菲涅尔反射引入了图形学，实现了比较逼真的效果。</p><p>Cook-Torrance 微平面着色模型（Cook-Torrance microfacet specular shading model），即 Microfacet Specular BRDF，定义为：<br>$$<br>f(l,v) &#x3D; \frac{F(l,h)G(l,v,h)D(h)}{4(n·h)(n·v)}<br>$$<br>其中：</p><ul><li>$F(l,h)$ 为菲涅尔反射函数，表示根据入射方向和观察方向，能够参与光的反射的微表面有多少光会被反射</li><li>$G(l,v,h)$ 为阴影遮罩函数（Geometry Factor，几何因子），即未被 shadow 或 mask 的比例，因为微表面凹凸不平，那么当入射光线贴着表面入射时，表面上就会有一部分微表面被其他微表面遮挡住而产生阴影，类似于环境光遮蔽，G 就是用来描述法线方向是半程向量的微表面中有多少微表面会因为互相遮挡而不被看到</li><li>$D(h)$ 是法线分布函数，即法线和半程向量一致的微表面的比例，表示有多少微表面会被看到，只有微表面的法线方向在光线入射方向和观察方向的半程向量方向才会被看到</li></ul><h4 id="4-3-Ward-BRDF-模型"><a href="#4-3-Ward-BRDF-模型" class="headerlink" title="4.3 Ward BRDF 模型"></a>4.3 Ward BRDF 模型</h4><p>一般情况下，我们可以将 BRDF 分为两类：</p><ul><li>各项同性（Isotropic）的 BRDF：反射不受与给定表面法向夹角的约束，随机表面微结构</li><li>各向异性（Anisotropic）的 BRDF：反射比随着与某个给定的表面法向之间的夹角而变化，图案的表面微结构，包括金属丝，绸缎，毛发等</li></ul><p>Phong 和 Cook-Torrance BRDF 模型都不能处理各项异性的效果，Ward 模型却可以。</p><p>Ward 模型介绍了更一般的表面法向表达方式：通过椭圆体（ellipsoids）这种允许各向异性反射的形式来表达。然而，由于没有考虑菲涅耳因子（Fresnel factor）和几何衰减因子（geometric attenuation factor），该模型更像是一种经验模型，但还是属于基于物理的 BRDF 模型。各向同性的 Ward 模型定义为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111305718.png" alt="image-20220516111305718"></p><h3 id="5-BRDF-引申"><a href="#5-BRDF-引申" class="headerlink" title="5 BRDF 引申"></a>5 BRDF 引申</h3><p>有不少与  BRDF 类似的函数：</p><ul><li>BSSRDF：Bidirectional Surface Scattering Reflectance Distribution，双向表面散反射分布函数</li><li>SBRDF(SVBRDF): spatially varying BRDF(spatial BRDF)，空间 BRDF</li><li>BTDF：Bidirectional Transmittance Distribution Function，双向透射分布函数</li><li>BSDF : Bidirectional Scattering Distribution Function，双向散射分布函数</li></ul><h4 id="5-1-BSSRDF"><a href="#5-1-BSSRDF" class="headerlink" title="5.1 BSSRDF"></a>5.1 BSSRDF</h4><p>BRDF 只是更一般方程的一种近似，这个方程就是 BSSRDF（Bidirectional scattering-surface reflectance distribution function，双向表面散反射分布函数）。BSSRDF 描述了出射辐射率与入射通量之间的关系，BSSRDF 函数通过把<strong>入射和出射位置作为函数的输入</strong>，描述了沿入射方向从物体表面的一点到另外一点，最后顺着出射方向出去的光线的相对量。注意，这个函数还考虑了物体表面的一点到另外一点，顺着出射方向出去的光线相对量，即光线从一点进入，并在内部发生了各种次表面散射，再从另一点出去，而 BRDF 只考虑了表面上的同一点。这个函数还考虑了物体表面不一致的情况，因为随着位置的变化，反射系数也会发生变化。在实时绘制中，物体表面上的位置可以用来获取颜色纹理、光泽度，以及凹凸纹理图等信息。</p><p>下图对比了 BRDF（上） 和 BSSRDF（下） 的渲染效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111833838.png" alt="image-20220516111833838"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111851009.png" alt="image-20220516111851009"></p><h4 id="5-2-SBRDF-SVBRDF"><a href="#5-2-SBRDF-SVBRDF" class="headerlink" title="5.2 SBRDF (SVBRDF)"></a>5.2 SBRDF (SVBRDF)</h4><p>一个捕获基于空间位置 BRDF 变化的函数被称为空间变化的 BRDF（Spatially Varying BRDF，SVBRDF）或称空间 BRDF，空间双向反射分布函数（Spatial BRDF，SBRDF）。</p><h4 id="5-3-BTDF-与-BSDF"><a href="#5-3-BTDF-与-BSDF" class="headerlink" title="5.3 BTDF 与 BSDF"></a>5.3 BTDF 与 BSDF</h4><p>即使一般的 BSSRDF 函数，无论其多么复杂，仍然忽略了现实世界中非常重要的一些变量，比如说光的偏振。此外，也没有处理穿过物体表面的光线传播，只是对反射情况进行了处理。为了处理光线传播的问题，对物体表面定义了两个 BRDF 和两个 BTDF（T 表示传播 “Transmittance”），每侧各有一个，这样就组成了 BSDF（S 表示散射“Scattering”）。</p><p>而在实践中，这些更复杂的函数很少使用，BRDF 和 SVBRDF 足以胜任一般情况下表面渲染的效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中 BRDF 相关知识进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRDF 前置知识：数学、辐射度量学&lt;/li&gt;
&lt;li&gt;BRDF 的定义、理解和性质&lt;/li&gt;
&lt;li&gt;BRDF 模型分类&lt;/li&gt;
&lt;li&gt;基于物理的 BRDF&lt;/li&gt;
&lt;li&gt;BRDF 引申&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】程序噪声总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T07:24:30.000Z</published>
    <updated>2022-05-15T07:25:56.380Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇提到过，程序纹理基本上都是通过噪声纹理来实现的，不同的噪声纹理适合制作不同的效果，如云雾、水波、大理石、能量波等。这一节对常见的程序噪声算法进行总结，主要包括：</p><ul><li>Value Noise</li><li>Gradient Noise（Perlin Noise、Simplex Noise）</li><li>Voronoi Noise 和 Worley Noise</li><li>Fractal Brownian Motion</li><li>Curl Noise</li><li>White Noise</li></ul><p><em><span id="more"></span></em></p><h3 id="1-噪声概述"><a href="#1-噪声概述" class="headerlink" title="1 噪声概述"></a>1 噪声概述</h3><p>对于图形学而言，噪声通常会用作程序化效果生成（如地形、水面、云层等），其最开始在图形学中引进，是为了代替贴图给物件添加纹理以解决电脑内存不足的问题（不过噪声的计算通常比贴图采样要慢一点，因此现在通常是直接使用噪声贴图来代替 shader 的随机数计算），但是并不是所有的噪声都是有用的，只有那些数据具有一定的连贯性的噪声才算是有用的噪声，而如果噪声不连贯的话，在进行贴图采样后，得到的结果就会呈现一种混乱的状态，这种对于程序化生成而言并没有什么作用，因此图形学中的一个理想的噪声应该具备如下几个特性：</p><ul><li>伪随机（不变性）：所谓的噪声只是看起来随机而已，实际上，需要保证在同样的输入下，肯定能够得到同样的输出，否则可能出现渲染的结果随着时间或者观察位置而变化，这就不够物理了，而且结果不可控也跟实际需要不符合。</li><li>只返回一个 float 值，不管输入是几维的，只返回一个 float。</li><li>噪声通常是带限的（band-limited），噪声频率过高通常会导致锯齿（镜头旋转等情况下常见），因此通常其频率范围都是有限的，不过对于一些平缓（大尺寸）变化的情形需要一些低频噪声，而对于一些细节变化则需要一些高频噪声。</li><li>噪声需要具有一定的连续性，比如某些情况下需要计算噪声的导数，甚至需要计算高阶微分，因此对于噪声的连续性有一定的要求。</li><li>四方连续，为了保证 tiling 时不会出现肉眼可辩的缝隙，需要保证上下左右四个方向都是连续的（如果使用了大量 tiling 可能会导致重复纹样，而解决重复的做法就是将 tiling 尺寸设得足够大，虽然可能会引入其他问题，但是这个问题可以通过其他方式来规避）。</li></ul><h3 id="2-Value-Noise"><a href="#2-Value-Noise" class="headerlink" title="2 Value Noise"></a>2 Value Noise</h3><p>Value Noise 是最简单的一类噪声，其实现算法非常简单，以 2D 为例，我们在一个规整的 2D 网格上的每个顶点（如下图中的每个红色小圆点）放置一个随机数（通常范围在 [0, 1] 之间），之后使用线性插值填充每个小方格，得到的结果就是 Value Noise。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-442ada94477d7682.png" alt="19200103-442ada94477d7682"></p><h3 id="3-Gradient-Noise"><a href="#3-Gradient-Noise" class="headerlink" title="3 Gradient Noise"></a>3 Gradient Noise</h3><p>Value Noise 是通过对周边顶点的随机 Value 进行插值来得到噪声贴图的，而 Gradient Noise 的实现原理与 Value Noise 类似，不同的是，这里是通过对周边顶点的 Gradient（梯度，可以理解为某个点的速度，常用向量来表示）进行插值来输出噪声贴图。</p><p>对梯度进行插值，这里有一个问题需要解决，那就是对向量的插值，得到的结果肯定还是向量，而前面说过，噪声的输出结果应该是一个浮点数，那么要怎么实现这二者的转换呢？这里的做法是将当前像素点到对应顶点的连线作为一个向量，与这个顶点的梯度进行点乘，就得到了对应的浮点数，之后再对这个浮点数应用与 Value Noise 一样的插值算法，就能得到对应的噪声结果了。</p><p>根据插值顶点选取算法的不同，这里又有不同的细分，Perlin Noise 与前面的 Value Noise 类似，都是选取周边四个顶点（如果是 3D 的，就是周边 8 个顶点，以此类推）的数据进行插值，而 Simplex Noise 则不同，选取的是等边三个顶点的数据（如果是 3D，选取的就是正四面体的四个顶点进行插值），下面来看这两种噪声的实现细节。</p><h4 id="3-1-Perlin-Noise"><a href="#3-1-Perlin-Noise" class="headerlink" title="3.1 Perlin Noise"></a>3.1 Perlin Noise</h4><p>Perlin Noise 非常常见，关于 Perlin  Noise 可以查看之前在光线追踪中的实现：<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>。</p><h4 id="3-2-Simplex-Noise"><a href="#3-2-Simplex-Noise" class="headerlink" title="3.2 Simplex Noise"></a>3.2 Simplex Noise</h4><p>实际上，Simplex 噪声跟 Perlin 噪声都是 Ken Perlin 发明的，后者是对前者的优化替代，Simplex 实际上是一种算法，既可以用于实现 Value Noise，同样也可以用于实现 Gradient Noise，不过由于 Gradient Noise 的应用范围更广，因此这里我们就直接跳过 Value Noise 部分，只介绍用于实现 Gradient Noise 的部分。</p><p>Simplex Noise 与 Perlin Noise 的区别在于其插值时所选取的周边顶点的算法不同，具体而言，是选取此像素所从属的 grid 中的正三角形（等边三角形）的三个顶点（即将 Perlin Noise 中的插值正方形沿着对角线一分为二，选取当前像素所在的那个正三角形的三个顶点，对应到 3D 空间，Perlin 使用的是立方体的 8 个顶点，而 Simplex 使用的则是连接相邻三个面的对角线组成的四面体转换后的正立方体的四个顶点）作为插值的数据源。</p><p>相对 Perlin Noise，Simplex 的实现更为简洁，其成本也更低。与前面计算某个像素对应的噪声值需要通过对周边顶点数据进行插值不同，Simplex 采用的是衰减函数，比如根据某个顶点到此像素的距离来计算此顶点数据对于此像素的贡献，之后将周边顶点的贡献进行累加就得到了最终的输出结果。</p><p>前面说到，Simplex 噪声来自于正三角形（正四面体）的数据衰减，那么这个正三角形是怎么来的呢？我们知道，一个 2D 平面，既可以使用正方形进行无缝平铺，这种 tiling 方式对应的就是前面 Value &#x2F; Perlin Noise 的计算基础，同时也可以使用正三角形进行平铺，而这对应的则是 Simplex 噪声的实现基础，这里的一个问题就是这二者是如何转换的，毕竟我们平常使用的基本上都是 grid，也就是正方形的平铺方式。这个转换过程可以参考：</p><ul><li><a href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a>中的 2.2 节</li><li><a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise - Wikipedia</a></li></ul><h3 id="4-Voronoi-Noise-和-Worley-Noise"><a href="#4-Voronoi-Noise-和-Worley-Noise" class="headerlink" title="4 Voronoi Noise 和 Worley Noise"></a>4 Voronoi Noise 和 Worley Noise</h3><p>Voronoi Noise 与 Worley Noise 在形态上十分相似，在图形学中的应用也基本一致，比如同样用于进行云层创建，水底焦散现象模拟等，那同样的噪声为什么会有两个名字呢？实际上图形学中最开始使用的是 Voronoi 噪声，只是这种噪声的实现算法消耗比较高，后面 Steven Worley 对齐进行了改进，提出了以其名字命名的 Worley 噪声。下面我们一起来看一下这两种噪声的实现算法。</p><p>Voronoi 噪声是通过在空间中生成随机分布的多个特征点，之后对于每个需要计算的像素，对所有的特征点进行遍历，找到距离其最近的特征点，以其对应的特征值作为此像素的值进行输出。下图展示了 Voronoi 噪声的生成过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-6ee079fe186022e5.gif" alt="19200103-6ee079fe186022e5"></p><p>Voronoi 噪声的思路很简单，但是由于需要对每个特征点进行遍历，整个算法的复杂度就变得很高了，为了降低计算的消耗，Worley 噪声就应运而生了。</p><p>Worley 噪声是通过将空间（2D &#x2F; 3D）划分成一个个的 cell（正方形 &#x2F; 立方体），在每个 cell 中的随机位置随机生成一个特征点，之后对于每个待计算的像素，搜寻周边的 cell，找到距离其最近的噪点，之后以距离此噪点的距离作为当前像素的噪声结果，就得到了对应的 Worley 噪声。相对于 Voronoi 噪声，Worley 算法的改进点在于将搜寻范围从所有特征点限定在了周边的若干个 cell 之中，理论上最正确的搜索范围是周边 25 个 cell，但实际上如果噪声函数选取得当，使用九宫格进行搜索也能得到正确的结果。下图展示了 Worley 噪声的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-e8fe35196eb9ddd9.png" alt="19200103-e8fe35196eb9ddd9"></p><p>如果将搜索范围换成 9 个 cell，会发现结果会存在异常，这是因为在某些随机函数作用下，九宫格搜索会漏掉一些正确解导致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-bdec0bdd9617cdd0.png" alt="19200103-bdec0bdd9617cdd0"></p><h3 id="5-Fractal-Brownian-Motion"><a href="#5-Fractal-Brownian-Motion" class="headerlink" title="5 Fractal Brownian Motion"></a>5 Fractal Brownian Motion</h3><p>有时候单一频率的噪声不足以满足需求，会需要使用多级噪声累加的结果来实现程序化生成，这种方式我们称之为分形布朗运动（Fractal Brownian Motion，简称 FBM），也称为 Turbulence，简单来说就是将多个不同频率的噪声按照不同的振幅进行混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>中有 Turbulence 应用于 Perlin Noise 的代码实现。还可以将 FBM 应用于 Worley 噪声，得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a89ea620cfe2aad9.png" alt="19200103-a89ea620cfe2aad9"></p><h3 id="6-Curl-Noise"><a href="#6-Curl-Noise" class="headerlink" title="6 Curl Noise"></a>6 Curl Noise</h3><p>Curl 噪声在图形学中有着广泛的应用，比如可以用于对粒子位置进行调制，使之产生卷曲的效果；比如可以对烟雾水流效果进行调制，生成湍流扰动效果等。相对于其他的流体模拟算法，Curl Noise 的生成算法算是十分简单的，但是应用起来效果却并没有减色多少。</p><p>Curl 噪声中的 Curl 可以看成是跟加减乘除号同等的一种运算符号，其输入数据是一个向量，经过 curl 运算之后，就得到了一个 divergence free（无散度）的向量场，这里先介绍下什么是向量的 divergence，即散度：<br>$$<br>div\ \vec a &#x3D; \nabla · \vec a &#x3D; \frac{\partial a_x}{\partial x} + \frac{\partial a_y}{\partial y} + \frac{\partial a_z}{\partial z}<br>$$<br>散度指的是向量三个分量在对应坐标轴方向上的偏微分之和，从物理上来说，指的是一个向量场在某个给定的位置散开或者说收敛的程度，日常生活中常见的流体比如水流，空气，烟雾等都是 divergence-free（无散）的。curl 噪声从物理上来说，可以用来表征用于对向量进行转向的力的大小。</p><p>下面我们来介绍一下 Curl 噪声的实现算法，对一个潜在的 3D 向量场 $\Psi$ 而言，令：<br>$$<br>\vec \Psi &#x3D; (\Psi_1, \Psi_2, \Psi_3)<br>$$<br>由此我们可以计算出其 Curl Velocity 算子：<br>$$<br>\vec v(x,y,z) &#x3D; (\frac{\partial \Psi_3}{\partial y} - \frac{\partial \Psi_2}{\partial z},<br>\frac{\partial \Psi_1}{\partial z} - \frac{\partial \Psi_3}{\partial x},<br>\frac{\partial \Psi_2}{\partial x} - \frac{\partial \Psi_1}{\partial y})<br>$$<br>2D 情况较为简单：<br>$$<br>\vec v(x,y) &#x3D; (\frac{\partial \Psi}{\partial y},-\frac{\partial \Psi}{\partial x})<br>$$<br>根据流体力学可知，上述速度场都是无散的，即：<br>$$<br>\nabla·\vec v &#x3D; 0<br>$$<br>具体来说，假设我们以二维 Perlin 噪声作为向量场，那么最终的 Curl 噪声就可以用如下公式表示：<br>$$<br>\vec v(x,y) &#x3D; (\frac{PerlinNoise(x,y)}{\partial y},-\frac{PerlinNoise(x,y)}{\partial x})<br>$$<br>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">curlNoise</span><span class="params">(vec2 uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> eps = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="type">float</span> x = uv.x;</span><br><span class="line">    <span class="type">float</span> y = uv.y;</span><br><span class="line">    <span class="comment">//Find rate of change in X direction</span></span><br><span class="line">    <span class="type">int</span> firstOctave = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> accumOctaves = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> revertPerlin = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> n1 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y + eps), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n2 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y - eps), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> a = (n1 - n2)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find rate of change in Y direction</span></span><br><span class="line">    <span class="type">float</span> n3 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x + eps, y), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n4 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x - eps, y), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> b = (n3 - n4)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Curl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec2</span>(a, -b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-d8bc4eb896a6a039.png" alt="19200103-d8bc4eb896a6a039"></p><p>将之用速度向量来表示，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a5f536670231116e.png" alt="19200103-a5f536670231116e"></p><p>其中灰色部分表示的是原始的 Perlin 噪声，而白色箭头表示的则是 Curl 噪声向量的方向与大小。</p><p>提高噪声频率得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-ef43d7f381fca207.png" alt="19200103-ef43d7f381fca207"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-7b5e9e3939c7b8ce.png" alt="19200103-7b5e9e3939c7b8ce"></p><h3 id="7-White-Noise"><a href="#7-White-Noise" class="headerlink" title="7 White Noise"></a>7 White Noise</h3><p>白噪声（White Noise）是一种在各个频率上的强度都十分均匀的噪声，这种噪声并不平滑，而自然界的各种纹理实际上都是连续的，因此通常不适合用于贴图生成。</p><p>实际上，所谓的白噪声并不是特指的某一种噪声，而是一种信号的统计模型。在离散采样中，白噪声具有如下特点：</p><ul><li>各个采样点之间完全没有数值上的联系</li><li>信号的均值为0，方差有限。</li></ul><p>实现白噪声最简单的算法就是直接使用一个随机数作为返回值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-c17c41b69b51b075.png" alt="19200103-c17c41b69b51b075"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇提到过，程序纹理基本上都是通过噪声纹理来实现的，不同的噪声纹理适合制作不同的效果，如云雾、水波、大理石、能量波等。这一节对常见的程序噪声算法进行总结，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value Noise&lt;/li&gt;
&lt;li&gt;Gradient Noise（Perlin Noise、Simplex Noise）&lt;/li&gt;
&lt;li&gt;Voronoi Noise 和 Worley Noise&lt;/li&gt;
&lt;li&gt;Fractal Brownian Motion&lt;/li&gt;
&lt;li&gt;Curl Noise&lt;/li&gt;
&lt;li&gt;White Noise&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】纹理总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T03:09:44.000Z</published>
    <updated>2022-05-15T09:35:29.304Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中纹理相关知识进行概括总结。主要内容包括：</p><ul><li><p>纹理管线（Texture Pipeline）</p></li><li><p>纹理缓存（Texture Caching）</p></li><li><p>纹理压缩（Texture Compression）</p></li><li><p>体纹理（Volume Texture）</p></li><li><p>立方体贴图（Cube Map）</p></li><li><p>程序纹理（Procedural Texturing）</p></li><li><p>凹凸贴图（Bump Mapping）及其改进</p></li></ul><p><em><span id="more"></span></em></p><h3 id="1-纹理管线"><a href="#1-纹理管线" class="headerlink" title="1 纹理管线"></a>1 纹理管线</h3><p>简单来说，纹理（Texturing）是一种针对物体表面属性进行“建模”的高效技术。图像纹理中的像素通常被称为纹素（Texels），以区别于屏幕上的像素。根据 Kershaw 的术语，通过将投影方程（projector function）运用于空间中的点 ，从而得到一组称为参数空间值（parameter-spacevalues）的关于纹理的数值。这个过程就称为贴图（Mapping，也称映射 ）,也就是纹理贴图（Texture Mapping，也称纹理映射 ）这个词的由来。纹理贴图可以用一个通用的纹理管线来进行描述。<strong>纹理贴图过程的初始点是空间中的一个位置。这个位置可以基于世界空间，但是更常见的是基于模型空间。因为若此位置是基于模型空间的，当模型移动时，其纹理才会随之移动。</strong></p><p>下图展示了单个纹理的通用管线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515094736104.png" alt="image-20220515094736104"></p><ul><li>第一步。通过将投影方程（projector function）运用于空间中的点   ，从而得到一组称为参数空间值（parameter-space values）的关于纹理的数值，即 uv 坐标，在（0, 1）范围内。</li><li>第二步。在使用这些新值访问纹理之前，可以使用一个或者多个映射函数（corresponder function）将参数空间值（parameter-space values  ）转换到纹理空间，即对 uv坐标进行平移和缩放以映射到纹理空间中。</li><li>第三步。使用这些纹理空间值（texture-space locations）从纹理中获取相应的值（obtain value）。例如，可以使用图像纹理的数组索引来检索像素值。</li><li>第四步。再使用值变换函数（value transform function）对检索结果进行值变换，最后使用得到的新值来改变表面属性，如材质或者着色法线等等。</li></ul><p>下图通过一个例子描述了上述过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095022930.png" alt="image-20220515095022930"></p><h4 id="1-1-投影函数"><a href="#1-1-投影函数" class="headerlink" title="1.1 投影函数"></a>1.1 投影函数</h4><p>作为纹理管线的第一步，<strong>投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。</strong></p><p>在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数计算得到投影结果，而是直接使用在美术建模过程中，已经存储在模型顶点数据中的投影结果。</p><h4 id="1-2-映射函数"><a href="#1-2-映射函数" class="headerlink" title="1.2 映射函数"></a>1.2 映射函数</h4><p><strong>映射函数（The Corresponder Function）的作用是将参数空间坐标（parameter-space coordinates）转换为纹理空间位置（texture space locations）。</strong>我们知道图像会出现在物体表面的 (u,v) 位置上，且  uv 值的正常范围在 [0, 1) 范围内。超出这个值域的纹理，其显示方式便可以由映射函数（The Corresponder Function）来决定。</p><p>在  OpenGL 中，这类映射函数称为“封装模式（Warapping Mode）”，在 Direct3D 中，这类函数叫做“寻址模式（Texture Addressing Mode）”。最常见的映射函数有以下几种：</p><ul><li>重复寻址模式，wrap (DirectX)，repeat (OpenGL)。图像在表面上重复出现。</li><li>镜像寻址模式，mirror。图像在物体表面上不断重复，但每次重复时对图像进行镜像或者反转。</li><li>夹取寻址模式，clamp (DirectX)，clamp to edge (OpenGL)。夹取纹理寻址模式将纹理坐标夹取在 [0.0, 1.0] 之间，也就是说，在[0.0, 1.0] 之间就是把纹理复制一遍，然后对于 [0.0, 1.0] 之外的内容，将边缘的内容沿着 u 轴和 v 轴进行延伸。</li><li>边框颜色寻址模式，border (DirectX)，clamp to border (OpenGL)。边框颜色寻址模式就是在 [0.0, 1.0] 之间绘制纹理，然后 [0.0, 1.0] 之外的内容就用边框颜色填充。</li></ul><p>下图展示了上述四种寻址模式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095836855.png" alt="image-20220515095836855"></p><p>另外，每个纹理轴可以使用不同的映射函数。例如在 u 轴使用重复寻址模式，在 v 轴使用取寻址模式。</p><h3 id="2-纹理缓存"><a href="#2-纹理缓存" class="headerlink" title="2 纹理缓存"></a>2 纹理缓存</h3><p>一个复杂的应用程序可能需要相当数量的纹理。快速纹理存储器的数量因系统而异，但你会发现它们永远不够用。于是有了各种各样的纹理缓存（texture caching）技术，但我们一直在上传纹理到内存的开销和纹理单次消耗的内存量之间寻求一个好的平衡点。比如，一个由纹理贴图的多边形对象，初始化在离相机很远的位置，程序也许会只加载 mipmap 中更小的子纹理，就可以很完美的完成这个对象的显示了。</p><p>一些基本的建议是——<strong>保持纹理在不需要放大再用的前提下尽可能小，并尝试基于多边形将纹理分组。</strong>即便所有纹理都一直存储在内存中，这种预防措施也可能会提高处理器的缓存性能。</p><p>常见的缓存策略有以下几种，许多都和操作系统中的缓存策略一致：</p><ul><li><strong>最近最少使用策略（Least Recently Used ,LRU）</strong>。LRU 是纹理缓存方案中常用的一种策略，其原理为：加载到图形加速器的内存中的每个纹理都被给出一个时间戳，记录最后一次访问以渲染图像的时间。当需要空间来加载新的纹理时，首先卸载最旧时间戳的纹理。一些 API 还允许为每个纹理设置一个优先级：如果两个纹理的时间戳相同，则优先级较低的纹理首先被卸载。 设置优先级可以帮助避免不必要的纹理交换。</li><li><strong>最近最常使用策略（Most Recently Used，MRU）</strong>。MRU 如其名称一样，总是替换掉使用的最少的纹理缓存。鉴于如果在当前帧中载入纹理，会发生抖动（Thrashing）的情况。所谓抖动就是纹理数据集远大于缓存空间，这样就会出现频繁替换纹理缓存的现象，就称为抖动。这时，LRU 策略是一种非常不好的策略，因为在每帧画面中会对每张纹理图像进行交换。在这种情况下，可以采用 MRU 策略，直到在画面中没有纹理交换时为止，再然后切换回 LRU。</li><li><strong>预取策略（Prefetching）</strong>。加载纹理花费显着的时间，特别是在需将纹理转换为硬件原生格式时。 纹理加载在每个框架可以有很大的不同。在单个帧中加载大量纹理使得难以保持恒定的帧速率。一种解决方案是使用预取（prefetching），在将来需要预期的情况下，预计未来的需求然后加载纹理，将加载过程分摊在多帧中。</li><li><strong>裁剪图策略（Clipmap）</strong>。对于飞行模拟和地型模拟系统，图像数据集可能会非常巨大。传统的方法是将这些图像分解成更小的硬件可以处理的瓦片地图（tiles）。Tanner 等人提出了一种一种称为裁剪图（clipmap）的改进数据结构。其思想是，将整个数据集视为一个 mipmap，但是对于任何特定视图，只需要 mipmap 的较低级别的一小部分即可。支持  DirectX 10 的  GPU 就能够实现 clipmap 技术。</li></ul><h3 id="3-纹理压缩"><a href="#3-纹理压缩" class="headerlink" title="3 纹理压缩"></a>3 纹理压缩</h3><p>直接解决内存和带宽问题和缓存问题的一个解决方案是固定速率纹理压缩（Fixed-rate Texture Compression）。通过硬件解码压缩纹理，纹理可以需要更少的纹理内存，从而增加有效的高速缓存大小。至少这样的纹理使用起来更高效，因为他们在访问时消耗更少的内存带宽。</p><p>纹理压缩算法种类繁多，但基本的共同点是：把纹理按 4x4 个单元（纹素）大小划分为块。每个块对应一张四色查找表，表中存有两个标准 RGB565 格式表示的 16 位颜色，另外使用标准插入算法在插入两个新的颜色值，由此构成四色查找表。4x4 大小的纹理块中每个单元（像素点）用两个 bit 表示，每一个都代表四色查找表中的一种颜色。<strong>可以看出，实质上是利用每个单元（像素点）中的两个 bit 来索引四色查找表中的颜色值。</strong></p><p>这些压缩技术可以应用于立方体或体积图，以及二维纹理。<strong>而其主要缺点是它们是有损的压缩。</strong> 也就是说，原始图像通常不能从压缩版本检索。 仅使用四个或八个内插值来表示 16 个像素。 如果一个瓦片贴图有更大的数值，相较压缩前就会有一些损失。 在实践中，如果正常使用这些压缩方案，一般需给出可接受的图像保真度。</p><h3 id="4-体纹理"><a href="#4-体纹理" class="headerlink" title="4 体纹理"></a>4 体纹理</h3><p>体纹理（volume texture），也称为三维纹理（3D texture），是传统二维纹理（2D texture）在逻辑上的扩展。二维纹理是一张简单的位图图片，用于为三维模型提供表面点的颜色值；而<strong>一个三维纹理，可以被认为由很多张 2D 纹理组成，用于描述三维空间数据的图片。</strong>三维纹理通过三维纹理坐标进行访问。</p><p>虽然体纹理具有更高的储存要求，并且滤波成本更高，但它们具有一些独特的优势：</p><ul><li>使用体纹理，可以跳过为三维网格确定良好二维参数的复杂过程，因为三维位置可以直接用作纹理坐标，从而避免了二维参数化中通常会发生的变形和接缝问题。</li><li>体纹理也可用于表示诸如木材或大理石的材料的体积结构。使用三维纹理实现出的这些模型，看起来会很逼真，浑然天成。</li></ul><p>体纹理的缺点也很明显：</p><ul><li>使用体纹理作为表面纹理会非常低效，因为三维纹理中的绝大多数样本都没起到作用。</li></ul><h3 id="5-立方体贴图"><a href="#5-立方体贴图" class="headerlink" title="5 立方体贴图"></a>5 立方体贴图</h3><p>立方体贴图（cube map）也称立方体纹理（cube texture），是一种特殊的纹理技术，它用 6 幅二维纹理图像构成一个以原点为中心的纹理立方体，这每个 2D 纹理是一个立方体（cube）的一个面。对于每个片段，<strong>纹理坐标 (s, t, r) 被当作方向向量看待，每个纹素(texel)都表示从原点所看到的纹理立方体上的图像。</strong></p><p>下图以两种方式展示了立方体贴图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100701571.png" alt="image-20220515100701571"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100722640.png" alt="image-20220515100722640"></p><p><strong>可以使用三分量纹理坐标向量来访问立方体贴图中的数据，该矢量指定了从立方体中心向外指向的光线的方向。</strong>选择具有最大绝对值的纹理坐标对应的相应的面。例如给定矢量（-3.2, 5.1, -8.4），选择绝对值最大的 -8.4 所在的 -Z 面，然后将其他两维除以最大的绝对值，就映射到了（-1, 1），然后再映射到（0, 1）范围就可以在 -Z 面上得到一个纹理坐标了。</p><h3 id="6-程序纹理"><a href="#6-程序纹理" class="headerlink" title="6 程序纹理"></a>6 程序纹理</h3><p>给定纹理空间位置，进行图像查找是生成纹理值的一种方法。另一种方法是对函数进行求值，从而得到一个程序贴图纹理（procedural texture）。</p><p>程序贴图纹理也称为过程纹理，是用计算机算法生成的，旨在创建用于纹理映射的自然元素（例如木材，大理石，花岗岩，金属，石头等）的真实表面或三维物体而创建的纹理图像。通常，会使用分形噪声（fractal noise）和湍流扰动函数（turbulence functions）这类“随机性”的函数来生成程序贴图纹理。</p><p>程序纹理通常用于离线渲染应用程序，而图像纹理在实时渲染中更为常见。这是由于在现代 GPU 中的图像纹理硬件有着极高效率，其可以在一秒钟内执行数十亿个纹理访问。然而，GPU 架构正在朝着更便宜的计算能力和（相对）更昂贵的存储器访问而发展。这将使程序纹理在实时应用程序中更常见，尽管它们不可能完全替代图像纹理。</p><p>关于程序纹理中常见的噪声，之后有专门的文章总结。</p><h3 id="7-凹凸贴图及其改进"><a href="#7-凹凸贴图及其改进" class="headerlink" title="7 凹凸贴图及其改进"></a>7 凹凸贴图及其改进</h3><p>与凹凸贴图相关的改进技术包括：位移贴图、法线贴图、视差贴图、浮雕贴图等，除了位移贴图方法以外，其他的几种改进一般都是通过修改每像素着色方程来实现，关键思想是访问纹理来修改表面的法线，而不是改变光照方程中的颜色分量。物体表面的几何法线保持不变，我们修改的只是着色方程中使用的法线值。他们比单独的纹理有更好的三维感官，但是显然还是比不上实际的三维几何体。下面将分别说明这几种方法。</p><h4 id="7-1-凹凸贴图"><a href="#7-1-凹凸贴图" class="headerlink" title="7.1 凹凸贴图"></a>7.1 凹凸贴图</h4><p><strong>凹凸贴图是通过改变表面光照方程的法线，而不是表面的几何法线，或对每个待渲染的像素在计算照明之前都要加上一个从高度图中找到的扰动，来模拟凹凸不平的视觉特征</strong>，如褶皱、波浪等等。<br>Blinn 于 1978 年提出了凹凸贴图方法。使用凹凸贴图，是为了给光滑的平面，在不增加顶点的情况下，增加一些凹凸的变化。他的原理是通过法向量的变化，来产生光影的变化，从而产生凹凸感。<strong>实际上并没有几何顶点上的变化。</strong>所以下图中球体边缘还是光滑的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515104558734.png" alt="image-20220515104558734"></p><h4 id="7-2-位移贴图"><a href="#7-2-位移贴图" class="headerlink" title="7.2 位移贴图"></a>7.2 位移贴图</h4><p>移位贴图（Displacement Mapping）也有人称为置换贴图，或称高度纹理贴图（Heightfield Texturing）。这种方法类似于法线贴图，<strong>移位贴图的每一个纹素中存储了一个向量，这个向量代表了对应顶点的位移。</strong>注意，此处的纹素并不是与像素一一对应，而是与顶点一一对应，因此，纹理的纹素个数与网格的顶点个数是相等的。在 Vertex Shader 阶段，获取每个顶点对应的纹素中的位移向量，施加到局部坐标系下的顶点上，然后进行世界视点投影变换即可。<strong>位移贴图真正改变了顶点位置。</strong></p><h4 id="7-3-法线贴图"><a href="#7-3-法线贴图" class="headerlink" title="7.3 法线贴图"></a>7.3 法线贴图</h4><p>法线贴图（Normal mapping）是凸凹贴图（Bump mapping）技术的一种应用。简单来说，<strong>Normal Map 直接将正确的 Normal 值保存到一张纹理中去，那么在使用的时候直接从贴图中取即可。</strong>为了使法线贴图能应用于不同的物体，所以法线贴图中存储的法线值一般是表面顶点切线空间下的法线值，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，相比于存储模型空间下的法线值，切线空间下的法线值是一个相对值，可以应用到不同的模型上而不至于出错。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105351266.png" alt="image-20220515105351266"></p><p>上图展示了基于法线贴图的凹凸映射，左侧为法线贴图，每个颜色通道实际上是表面法线坐标。红色通道是 x 偏差; 红色越多，正常点越多。 绿色是 y 偏差，蓝色是 z。 右边是使用法线贴图生成的图像。 请注意立方体顶部的扁平外观，<strong>法线贴图显然没有改变几何形状。</strong></p><h4 id="7-4-视差贴图"><a href="#7-4-视差贴图" class="headerlink" title="7.4 视差贴图"></a>7.4 视差贴图</h4><p>视差贴图（Parallax Mapping），又称为 Offset Mapping，或 virtual displacement mapping，视差贴图是一种改进的 Bump Mappin 技术，相较于普通的凹凸贴图，视差贴图技术得到凹凸效果得会更具真实感（如石墙的纹理将有更明显的深度）。<strong>视差贴图是通过替换渲染多边形上的顶点处的纹理坐标来实现的</strong>，而这个替换依赖于一个关于切线空间中的视角（相对于表面法线的角度）和在该点上的高度图的方程。简单来说，Parallax Mapping 利用  Height Map 进行了近似的  Texture Offset。如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105943878.png" alt="image-20220515105943878"></p><h4 id="7-5-浮雕贴图"><a href="#7-5-浮雕贴图" class="headerlink" title="7.5 浮雕贴图"></a>7.5 浮雕贴图</h4><p>浮雕贴图（Relief Mapping），有人把它誉为凹凸贴图的极致。我们知道，Parallax Mapping 是针对  Normal Mapping 的改进，利用  HeightMap 进行了近似的 Texture Offset。而 Relief Mapping 是精确的 Texture Offset，所以在表现力上比较完美。</p><p>Parallax Mapping 能够提供比 Bump Mapping 更多的深度，尤其相比于小视角下，但是如果想提供更深的深度，Parallax Mapping 就无能为力了，Relief Mapping 则可以很好的胜任。相较于 Parallax Mapping，浮雕贴图可以实现更深的凹凸深度，并且还可以做出自阴影和闭塞效果。当然算法也稍稍有点复杂，具体细节可以参考这篇中文文献：<a href="https://www.ixueshu.com/document/3dc4369a761ca0d6318947a18e7f9386.html">Relief mapping：凹凸贴图的极致</a>，而如果要用一句话概括  Relief Mapping，将会是：“在 Shader 里做光线追踪”。</p><p>下图是法线贴图和浮雕贴图的对比，浮雕贴图可以实现自阴影：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110338598.png" alt="image-20220515110338598"></p><p>下图是视差贴图和浮雕贴图的对比，浮雕贴图可以实现更深的凹凸深度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110121700.png" alt="image-20220515110121700"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中纹理相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;纹理管线（Texture Pipeline）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纹理缓存（Texture Caching）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纹理压缩（Texture Compression）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;体纹理（Volume Texture）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;立方体贴图（Cube Map）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序纹理（Procedural Texturing）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;凹凸贴图（Bump Mapping）及其改进&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】模板测试和深度测试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-14T03:34:55.000Z</published>
    <updated>2022-05-14T03:36:33.273Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习渲染管线的时候，没有对混合阶段的各种测试展开细说，本篇将详细介绍模板测试和深度测试有关的知识，主要内容包括：</p><ul><li>渲染管线终极版</li><li>模板测试</li><li>深度测试</li><li>Early-Z 和 Z-Prepass</li></ul><p><em><span id="more"></span></em></p><h3 id="1-渲染管线终极版"><a href="#1-渲染管线终极版" class="headerlink" title="1 渲染管线终极版"></a>1 渲染管线终极版</h3><p>之前的学习中我们已经对渲染管线有了一个整体流程上的认识，但具体细节和阶段内部的顺序并没有过多关注，在学习模板测试和深度测试有关的内容之前，有必要为之前的渲染管线加上一些“细节”，以便于后续的理解。</p><p>下图展示了整个渲染管线的流程，包含了各阶段内部和操作内部的顺序以及流程细节，可以作为最终版放在脑中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/RenderPipeline.png" alt="RenderPipeline"></p><p>图中：</p><ul><li>绿色的阶段都是完全可编程的</li><li>蓝色的阶段可配置，但不可编程</li><li>黄色的阶段完全固定</li><li>虚线为可选阶段</li></ul><h3 id="2-模板测试（Stencil-Test）"><a href="#2-模板测试（Stencil-Test）" class="headerlink" title="2 模板测试（Stencil Test）"></a>2 模板测试（Stencil Test）</h3><p>模板测试简单来说就是根据模板缓冲区的数值决定该像素的颜色值，最简单的比如只有模板缓冲为 1 的像素才显示，为 0 则不显示，类似于一个 mask 操作，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/X911U-WnXlnLJg_9klfTcg.png" alt="X911U-WnXlnLJg_9klfTcg"></p><p>模板缓冲区与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值（通常是 8 位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。模板测试发生在透明度测试（alpha test）之后，深度测试（depth test）之前。如果模板测试通过，则相应的像素点更新，否则不更新。</p><p>模板测试可以定义不同的比较方式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160835251.png" alt="image-20220513160835251"></p><p>还可以定义更新缓冲值的方式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160947277.png" alt="image-20220513160947277"></p><p>总的来说模板测试就是对当前模板缓冲值（stencil Buffer Value）和模板参考值（reference Value）使用特定的比较操作进行比较来决定是否渲染该像素，模板测试后可以根据测试结果，按照特定方式更新模板缓冲区的值。</p><p>模板测试可以与其他测试或图形算法结合实现许多效果，比如：描边、多边形填充、反射区域控制等。</p><h3 id="3-深度测试（Z-Test）"><a href="#3-深度测试（Z-Test）" class="headerlink" title="3 深度测试（Z Test）"></a>3 深度测试（Z Test）</h3><p>深度测试发生在模板测试之后，透明度混合之前。所谓深度测试，就是针对当前对象在屏幕上（更准确的说是frame buffer）对应的像素点，将对象自身的深度值与当前该像素点缓存的深度值进行比较，如果通过了，本对象在该像素点才会将颜色写入颜色缓冲区，否则否则不会写入颜色缓冲。</p><p><strong>深度缓冲（Z-Buffer）</strong>就像颜色缓冲（储存所有的片段颜色）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24 或 32 位 float 的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。一般来说，深度缓冲区中存储的深度值为 0 到 1 范围的浮点值，且为非线性。深度值在各个空间的变化如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513171312423.png" alt="image-20220513171312423"></p><p><strong>深度写入（Z-Write）</strong>包括两种状态：ZWrite On 与 ZWrite Off。当我们开启深度写入的时候，通过深度测试则将新的深度值写入深度缓存；反之，如果关闭深度写入，那么深度就不会写入深度缓冲区。</p><p>深度测试对深度缓冲区和颜色缓冲区的写入情况有以下四种：</p><ul><li>深度测试通过，深度写入开启：写入深度缓冲区，写入颜色缓冲区；</li><li>深度测试通过，深度写入关闭：不写深度缓冲区，写入颜色缓冲区；</li><li>深度测试失败，深度写入开启：不写深度缓冲区，不写颜色缓冲区；</li><li>深度测试失败，深度写入关闭：不写深度缓冲区，不写颜色缓冲区；</li></ul><p>一般来说，深度测试可以自定义比较方式，默认为小于等于，即深度小于等于缓冲区中的深度时则通过测试，并且深度写入默认开启。深度测试的流程图如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/f9z_wixRyJvq5jVawaFuPA.png" alt="f9z_wixRyJvq5jVawaFuPA"></p><p>深度测试不仅可以解决遮挡问题，还可以应用于很多效果，比如：阴影贴图、透明渲染、粒子渲染、切边效果、X光等。</p><h3 id="4-Early-Z-和-Z-Prepass"><a href="#4-Early-Z-和-Z-Prepass" class="headerlink" title="4 Early-Z 和 Z-Prepass"></a>4 Early-Z 和 Z-Prepass</h3><h4 id="4-1-Early-Z"><a href="#4-1-Early-Z" class="headerlink" title="4.1 Early-Z"></a>4.1 Early-Z</h4><p>在正常的渲染管线中，深度测试在所有测试完成后才进行，片元着色器计算的所有片元经过深度测试后会有一大部分被舍弃，这相当于进行了很多无用的计算，而实际上在进入片元着色器之前我们就已经知道了所有顶点的深度，因此完全可以提前进行深度测试，将深度大的片元提前舍弃，不去计算，这样就可以节省很多的计算量，这就是 Early-Z 的思想。上面的渲染管线图中给出了 Early-Z 在整个管线中的位置。</p><p>但是有一些情况下，Early-Z 会失效或使用 Early-Z 会造成错误：</p><ul><li>开启了透明度测试（Alpha Test ），这时如果提前进行深度测试，可能导致透明物体后的片元没有通过深度测试而渲染不出来</li><li>进行手动剔除（discard）操作，这时提前通过深度测试筛选出来的片元也可能会被手动剔除而造成错误</li><li>片元着色器中手动修改 GPU 插值得到的深度，这时提前通过深度剔除片元很大可能会造成错误</li><li>开启了透明度混合（Alpha Blend），开启透明度混合一般会关闭深度写入，所以 Early-Z 不生效</li><li>关闭深度测试时 Early-Z 自然也不生效</li></ul><p>Early-Z 进行的操作和原本逐像素处理阶段的 Z-Test（为了 Early-Z 区别，这个阶段也会被称为 Late-Z）操作完全一样，现代的 GPU 已经都开始包含这样的硬件设计。但是 Early-Z 有以下两个主要的缺点：</p><ul><li>一旦进行了手动写入深度值、开启 alpha test 或者丢弃像素等上述操作，那么 GPU 就会关闭 Early-Z 直到下次清空 Z-Buffer 后才会重新开启（不过现在的 GPU 也在逐渐优化，使其更智能的开关 Early-Z）。之所以 GPU  会选择关闭 Early-Z 是因为上述那些操作可能会在片元着色器与 Late-Z 阶段之间修改深度缓存中的深度值，导致提前的 Early-Z 结果不正确。我们也可以在 fragment shader 中使用 <code>layout(early_fragment_tests)</code> 来强制打开 Early-Z。</li><li>Early-Z 的优化效果并不稳定，最理想条件下所有绘制顺序都是由近及远，那么 Early-Z 可以完全避免过度绘制。但是相反的状态下，由远及近绘制物体， Early-Z 则会起不到任何效果。所以有些时候为了完全发挥 Early-Z 的功效，我们会在每帧绘制时对场景的物体按照到摄像机的距离由远及近进行排序。这个操作会在 CPU 端进行，当场景复杂到一定程度，频繁的排序将会占用 CPU 的大量计算资源。</li></ul><h4 id="4-2-Z-Prepass"><a href="#4-2-Z-Prepass" class="headerlink" title="4.2 Z-Prepass"></a>4.2 Z-Prepass</h4><p>Z-Prepass 是一种软件技术。它主要是配合 Early-Z 使用，来减少上面提到的 Early-Z 的第二个缺点——效果不稳定。Z-Prepass 的做法是将场景做两个 pass 的绘制。第一个 pass 仅写入深度，不做任何复杂的片元计算，不输出任何颜色。第二个 pass <strong>关闭深度写入</strong>，并将<strong>深度比较函数设为“相等”</strong>。</p><p>本节一开始就提到， Early-Z 的出现是因为经过大量运算的片元，很大概率会在之后被丢弃掉。那么对于第一个 pass 由于只写入深度，不在片元做任何计算，所以即便之后会被丢弃，也并不可惜。也就是说无论场景中的物体以怎样的顺序绘制，我们都可以以很小的代价提前绘制好当前场景的深度缓存。那么在第二个 pass 时，Early-Z 就可以用这个深度缓存中的值和当前深度值进行比较，只绘制深度相等的片元，任何其他的片元都可以直接丢弃，因此第二个 pass 要把深度比较函数设为“相等”。同时当前的深度缓存已经是完全正确的结果了，因此第二个 pass 也不需要对深度缓存做任何更新，便可以关闭深度写入。</p><p>Z-Prepass 必须配合 Early-Z 才能发挥效果，如果没有 Early-Z 的话，第二个 pass 的深度测试依旧在片元着色器之后，因此所有片元都会在片元阶段进行复杂计算。Z-Prepass 的思想和延迟渲染管线（defered render pipeline，之后会专门总结）有些相似，差别在于：</p><ul><li>第一，Z-Prepass 的第一个 pass 只计算深度，并且结果直接存储在深度缓存。而延迟渲染会同时计算更多其他的屏幕空间数据，并将这些数据存储在额外的 frame buffer 中，需要更大的缓存（也就是G-Buffer）。</li><li>第二，Z-Prepass 的第二个 pass 依旧需要对全场景的各个物体进行绘制（至少顶点阶段是如此），而延迟渲染的第二个 pass 类似于后处理，本质上只绘制了一个屏幕大小的矩形。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前学习渲染管线的时候，没有对混合阶段的各种测试展开细说，本篇将详细介绍模板测试和深度测试有关的知识，主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渲染管线终极版&lt;/li&gt;
&lt;li&gt;模板测试&lt;/li&gt;
&lt;li&gt;深度测试&lt;/li&gt;
&lt;li&gt;Early-Z 和 Z-Prepass&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】图形渲染和视觉处理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/</id>
    <published>2022-05-13T07:42:45.000Z</published>
    <updated>2022-05-16T08:01:48.398Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中与图形渲染基础和视觉处理相关的知识进行概括总结。主要内容包括：</p><ul><li>光照与材质</li><li>着色</li><li>抗锯齿总结</li><li>透明渲染</li><li>伽马校正</li></ul><p><em><span id="more"></span></em></p><h3 id="1-光照与材质"><a href="#1-光照与材质" class="headerlink" title="1 光照与材质"></a>1 光照与材质</h3><h4 id="1-1-光源特性"><a href="#1-1-光源特性" class="headerlink" title="1.1 光源特性"></a>1.1 光源特性</h4><p>光被不同地模拟为几何光线，电磁波或光子（具有一些波特性的量子粒子）。无论如何处理，光都是电磁辐射能，即通过空间传播的电磁能。光源发光，而不是散射或吸收光。根据渲染目的，光源可以以许多不同的方式来表示。光源可以分为三种不同类型：<strong>平行光源、点光源和聚光灯。</strong></p><h4 id="1-2-光的散射与吸收"><a href="#1-2-光的散射与吸收" class="headerlink" title="1.2 光的散射与吸收"></a>1.2 光的散射与吸收</h4><p><strong>从根本上来说，所有的光物质相互作用都是两种现象的结果：散射（scattering）和吸收（absorption）。</strong></p><p>散射（scattering）发生在当光线遇到任何种类的光学不连续性（optical discontinuity）时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。散射不会改变光量，它只是使其改变方向。光的散射（scattering）一般又分为反射（reflection）和折射（refraction）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110002009.png" alt="image-20220513110002009"></p><p>吸收（absorption）发生在物质内部，其会导致一些光转变成另一种能量并消失。吸收会减少光量，但不会影响其方向。</p><h4 id="1-3-镜面反射和漫反射"><a href="#1-3-镜面反射和漫反射" class="headerlink" title="1.3 镜面反射和漫反射"></a>1.3 镜面反射和漫反射</h4><p><strong>镜面反射光表示在表面反射的光。而漫反射光表示经历透射（transmission），吸收（absorption）和散射（scattering）的光。</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110116016.png" alt="image-20220513110116016"></p><h4 id="1-4-颜色"><a href="#1-4-颜色" class="headerlink" title="1.4 颜色"></a>1.4 颜色</h4><p>入射光（Incoming illumination）通过表面辉度（irradiance）来度量。而出射光（outgoing light）通过出射率（exitance）来度量。<strong>出射率除以辉度可以作为材质的衡量特性。对于不发光的表面，该比率为 0 到 1 之间。出射率和辉度的比率对于不同的光颜色是不同的，所以其表示为 RGB 矢量，也就是我们通常说的颜色。</strong></p><h4 id="1-5-表面与散射分布"><a href="#1-5-表面与散射分布" class="headerlink" title="1.5 表面与散射分布"></a>1.5 表面与散射分布</h4><p>镜面反射项的方向分布取决于表面粗糙度（roughness，其反义词是 smoothness，光滑度）。反射光线对于更平滑的表面更加紧密，并且对于较粗糙的表面更加分散。我们可以看到下图中的这种依赖关系，它显示了不同粗糙度的两个表面的反射效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110421641.png" alt="image-20220513110421641"></p><h3 id="2-着色"><a href="#2-着色" class="headerlink" title="2 着色"></a>2 着色</h3><p>可以查看以前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a></p><h3 id="3-抗锯齿方法总结"><a href="#3-抗锯齿方法总结" class="headerlink" title="3 抗锯齿方法总结"></a>3 抗锯齿方法总结</h3><p>抗锯齿，也称反走样。它是一种消除显示器输出的画面中图物边缘出现凹凸锯齿的技术，那些凹凸的锯齿通常因为高分辨率的信号以低分辨率表示或无法准确运算出 3D 图形坐标定位时所导致的走样（aliasing）而产生的，抗锯齿技术能有效地解决这些问题。</p><p>关于抗锯齿的原理可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/">【计算机图形学】（四）反走样</a>，下面将常见的抗锯齿类型进行总结介绍，也包括  RTR 中没有讲到的，最近几年新提出的常见抗锯齿类型。</p><h4 id="3-1-超级采样抗锯齿（SSAA）"><a href="#3-1-超级采样抗锯齿（SSAA）" class="headerlink" title="3.1 超级采样抗锯齿（SSAA）"></a>3.1 超级采样抗锯齿（SSAA）</h4><p>超级采样抗锯齿（Super-Sampling Anti-Aliasing，简称  SSAA）是比较早期的抗锯齿方法，比较消耗资源，但简单直接。这种抗锯齿方法先把图像映射到缓存并把它放大，再用超级采样把放大后的图像像素进行采样，一般选取 2 个或 4 个邻近像素，把这些采样混合起来后，生成的最终像素，这样每个像素拥有邻近像素的特征，像素与像素之间的过渡色彩，就变得近似，使得图形的边缘色彩过渡趋于平滑。再把最终像素还原回原来大小的图像，并保存到帧缓存也就是显存中，替代原图像存储起来，最后输出到显示器，显示出一帧画面。这样就等于把一幅模糊的大图，通过细腻化后再缩小成清晰的小图。比如在 1024x768 分辨率上开启 2xSSAA，GPU 会先渲染 2048x1536 图像，再“塞进”1024x768 的屏幕中，将画面精细度提升一倍，毫无疑问会改善边缘锯齿情况。超级采样抗锯齿中使用的采样法一般有两种：</p><ul><li>OGSS，顺序栅格超级采样（Ordered Grid Super-Sampling，简称  OGSS），采样时选取  2 个邻近像素</li><li>RGSS，旋转栅格超级采样（Rotated Grid Super-Sampling，简称  RGSS），采样时选取  4 个邻近像素</li></ul><p>另外，作为概念上最简单的一种超采样方法，全场景抗锯齿（Full-Scene Antialiasing, FSAA）以较高的分辨率对场景进行绘制，然后对相邻的采样样本进行平均，从而生成一幅新的图像。</p><h4 id="3-2-多重采样抗锯齿（MSAA）"><a href="#3-2-多重采样抗锯齿（MSAA）" class="headerlink" title="3.2 多重采样抗锯齿（MSAA）"></a>3.2 多重采样抗锯齿（MSAA）</h4><p>多重采样抗锯齿（Multi Sampling Anti-Aliasing，简称  MSAA），是一种特殊的 SSAA，MSAA 首先来自于 OpenGL。具体是 MSAA 只对  Z 缓存（Z-Buffer）和模板缓存 (Stencil Buffer) 中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。这样的话，相比 SSAA 对画面中所有数据进行处理，MSAA 对资源的消耗需求大大减弱，不过在画质上可能稍有不如  SSAA。</p><h4 id="3-3-高分辨率抗锯齿（HRAA）"><a href="#3-3-高分辨率抗锯齿（HRAA）" class="headerlink" title="3.3 高分辨率抗锯齿（HRAA）"></a>3.3 高分辨率抗锯齿（HRAA）</h4><p>高分辨率抗锯齿方法(High Resolution Anti-Aliasing，简称 HRAA)，也称 Quincunx 方法，出自 NVIDIA 公司。“Quincunx”意思是 5 个物体的排列方式，其中 4 个在正方形角上，第五个在正方形中心，也就是梅花形。此方法中，采样模式是五点梅花状，其中四个样本在像素单元的角上，最后一个在中心。</p><h4 id="3-4-可编程过滤抗锯齿（CFAA）"><a href="#3-4-可编程过滤抗锯齿（CFAA）" class="headerlink" title="3.4 可编程过滤抗锯齿（CFAA）"></a>3.4 可编程过滤抗锯齿（CFAA）</h4><p>可编程过滤抗锯齿（Custom Filter Anti-Aliasing，简称 CFAA）简单地说就是扩大取样面积的 MSAA，比方说之前的 MSAA 是严格选取物体边缘像素进行缩放的，而 CFAA 则可以通过驱动和谐灵活地选择对影响锯齿效果较大的像素进行缩放，以较少的性能牺牲换取平滑效果。显卡资源占用也比较小。</p><h4 id="3-5-形态抗锯齿（MLAA）"><a href="#3-5-形态抗锯齿（MLAA）" class="headerlink" title="3.5 形态抗锯齿（MLAA）"></a>3.5 形态抗锯齿（MLAA）</h4><p>形态抗锯齿（Morphological Anti-Aliasing，简称 MLAA），是 AMD 推出的完全基于 CPU 处理的抗锯齿解决方案。与 MSAA 不同， MLAA 将跨越边缘像素的前景和背景色进行混合，用第 2 种颜色来填充该像素，从而更有效地改进图像边缘的变现效果。</p><h4 id="3-6-快速近似抗锯齿（FXAA）"><a href="#3-6-快速近似抗锯齿（FXAA）" class="headerlink" title="3.6 快速近似抗锯齿（FXAA）"></a>3.6 快速近似抗锯齿（FXAA）</h4><p>快速近似抗锯齿 (Fast Approximate Anti-Aliasing，简称 FXAA)  ，是传统 MSAA (多重采样抗锯齿) 效果的一种高性能近似。是最简单的、高效率的抗锯齿方式，FXAA 对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p><h4 id="3-7-时间性抗锯齿（TAA）"><a href="#3-7-时间性抗锯齿（TAA）" class="headerlink" title="3.7 时间性抗锯齿（TAA）"></a>3.7 时间性抗锯齿（TAA）</h4><p>时间性抗锯齿（Temporal Anti-Aliasing，简称 TAA），将 MSAA、时间滤波以及后期处理相结合，用于呈现更高的视觉保真度。与 CG 电影中所采用的技术类似，TXAA 集 MSAA 的强大功能与复杂的解析滤镜于一身，可呈现出更加平滑的图像效果。此外，TXAA 还能够对帧之间的整个场景进行抖动采样，以减少闪烁情形，闪烁情形在技术上又称作时间性锯齿。</p><p>Temporal AA 严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p><p>简单来说，Temporal AA 是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p><h4 id="3-8-多帧采样抗锯齿（MFAA）"><a href="#3-8-多帧采样抗锯齿（MFAA）" class="headerlink" title="3.8 多帧采样抗锯齿（MFAA）"></a>3.8 多帧采样抗锯齿（MFAA）</h4><p>多帧采样抗锯齿（Multi-Frame Sampled Anti-Aliasing，MFAA）是 NVIDIA 公司根据 MSAA 改进出的一种抗锯齿技术。可以将 MFAA 理解为 MSAA 的优化版，能够在得到几乎相同效果的同时提升性能上的表现。MFAA 与 MSAA 最大的差别就在于在同样开启 4 倍效果的时候 MSAA 是真正的针对每个边缘像素周围的 4 个像素进行采样，MFAA 则是仅仅只是采用交错的方式采样边缘某个像素周围的两个像素。</p><h4 id="3-9-深度学习超采样（DLSS）"><a href="#3-9-深度学习超采样（DLSS）" class="headerlink" title="3.9 深度学习超采样（DLSS）"></a>3.9 深度学习超采样（DLSS）</h4><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p><h4 id="3-10-图示抗锯齿"><a href="#3-10-图示抗锯齿" class="headerlink" title="3.10 图示抗锯齿"></a>3.10 图示抗锯齿</h4><p>下图展示了不同采样方法的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513113600088.png" alt="image-20220513113600088"></p><h3 id="4-透明渲染"><a href="#4-透明渲染" class="headerlink" title="4 透明渲染"></a>4 透明渲染</h3><h4 id="4-1-透明渲染算法"><a href="#4-1-透明渲染算法" class="headerlink" title="4.1 透明渲染算法"></a>4.1 透明渲染算法</h4><p>透明渲染是是图形学里面的常见问题之一，可以从《Real-Time Rendering》中总结出如下两个算法：</p><ul><li>Screen-Door Transparency 方法。基本思想是用棋盘格填充模式来绘制透明多边形，也就是说，以每隔一个像素绘制一点方式的来绘制一个多边形，这样会使在其后面的物体部分可见，通常情况下，屏幕上的像素比较紧凑，以至于棋盘格的这种绘制方式并不会露馅。同样的想法也用于剪切纹理的抗锯齿边缘，但是在子像素级别中的，这是一种称为 alpha 覆盖（alpha to coverage）的特征。screen-door transparency 方法的优点就是简单，可以在任何时间任何顺序绘制透明物体，并不需要特殊的硬件支持（只要支持填充模式）。缺点是透明度效果仅在 50% 时最好，且屏幕的每个区域中只能绘制一个透明物体。</li><li>Alpha 混合（Alpha Blending）方法。这个方法比较常见，其实就是按照 Alpha 混合向量的值来混合源像素和目标像素。当在屏幕上绘制某个物体时，与每个像素相关联的值有 RGB 颜色和 Z 缓冲深度值，以及另外一个成分 alpha 分量，这个 alpha 值也可以根据需要生成并存储，它描述的是给定像素的对象片段的不透明度的值。alpha 为 1.0 表示对象不透明，完全覆盖像素所在区域; 0.0 表示像素完全透明。为了使对象透明，在现有场景的上方，以小于 1 的透明度进行绘制即可。每个像素将从渲染管线接收到一个  RGBA 结果，并将这个值和原始像素颜色相混合。</li></ul><h4 id="4-2-透明排序"><a href="#4-2-透明排序" class="headerlink" title="4.2 透明排序"></a>4.2 透明排序</h4><p>要将透明对象正确地渲染到场景中，通常需要对物体进行排序。下面分别介绍两种比较基本的透明排序方法（画家算法和深度缓冲）和两种高级别的透明排序算法（加权平均值算法和深度剥离）。</p><h5 id="4-2-1-画家算法和深度缓冲"><a href="#4-2-1-画家算法和深度缓冲" class="headerlink" title="4.2.1  画家算法和深度缓冲"></a>4.2.1  画家算法和深度缓冲</h5><p>可查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">【计算机图形学】（五）深度缓冲</a></p><h5 id="4-2-2-加权平均值算法（Weighted-Average）"><a href="#4-2-2-加权平均值算法（Weighted-Average）" class="headerlink" title="4.2.2 加权平均值算法（Weighted Average）"></a>4.2.2 加权平均值算法（Weighted Average）</h5><p>使用简单的透明混合公式来实现无序透明渲染的算法，它通过扩展透明混合公式，来实现无序透明物件的渲染，从而得到一定程度上逼真的结果。</p><p>NVIDIA 公司的 Louis Bavoil 在此基础上提出了新的算法，使用物体的不透明度作为加权值的加权平均值算法。此算法的主要思想如下：</p><p>对于某个位置的像素点，如果所有的不透明物件是相同的颜色，那么渲染的结果与它们的渲染顺序无关。那么，对于不相同颜色值的情况，如果我们用某一个颜色来替换这些颜色，比如这些颜色的平均值。对于这种情况，我们使用各个颜色的不透明度作为权重来计算出它们的加权平均值作为最终颜色替换这些颜色，这样渲染就与顺序无关。</p><p>此算法的优点很明显，效率高，速度快，只需要对物体进行一次的渲染，然后加上一次全屏的后处理。但是缺点也是同样的明显，透明结果只是一个近似值，而不是确切的正确结果。然而，它的效果仍然远远好过不做任何处理的简单透明混合，而且高效性也使得它有一定的应用空间。</p><h5 id="4-2-3-深度剥离算法（Depth-Peeling）"><a href="#4-2-3-深度剥离算法（Depth-Peeling）" class="headerlink" title="4.2.3 深度剥离算法（Depth Peeling）"></a>4.2.3 深度剥离算法（Depth Peeling）</h5><p>深度剥离是一种对深度值进行排序的技术。它的原理比较直观，标准的深度检测使场景中的 Z 值最小的点输出到屏幕上，就是离我们最近的顶点。但还有离我们第二近的顶点，第三近的顶点存在。要想显示它们，可以用多遍渲染的方法。深度剥离的每次渲染都需要一个深度缓冲，一个 Shadow Map 纹理和一个颜色缓冲，算法流程如下：</p><ul><li>首先使用深度缓冲正常渲染，就可以得到离我们最近的顶点及其深度值，同时将所有深度值拷贝到 Shadow Map 纹理中</li><li>第二次渲染打开深度纹理的比较功能，使得深度值比较大的颜色通过测试，这样就把所有深度值小于前一次渲染的顶点全部剥离掉，剩下的顶点都是比上一次渲染离我们更远的顶点，再加上深度缓冲本身的取最小深度的功能，就可以得到比上一次渲染离我们更远的顶点中离我们最近的顶点的颜色</li><li>重复第二步操作，就把所有顶点颜色按照深度一层一层剥离出来，最后按照从后往前的顺序进行渲染，这样就可以得到正确的结果了。</li></ul><p>这种方法与渲染物体的顺序无关，并且得到的结果保证正确，但缺点也很明显，需要剥离 N 次才能完成，就需要 N 个 Pass，N 是深度复杂度，因此性能是严重的瓶颈，另外如何确定 N 也是个问题。</p><h3 id="5-伽马校正"><a href="#5-伽马校正" class="headerlink" title="5 伽马校正"></a>5 伽马校正</h3><p>查看之前笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/">【RayTracer】（四）漫反射材质</a>中的第三部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中与图形渲染基础和视觉处理相关的知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;光照与材质&lt;/li&gt;
&lt;li&gt;着色&lt;/li&gt;
&lt;li&gt;抗锯齿总结&lt;/li&gt;
&lt;li&gt;透明渲染&lt;/li&gt;
&lt;li&gt;伽马校正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】GPU管线</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-05-13T02:46:21.000Z</published>
    <updated>2022-05-13T02:47:22.923Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中 GPU 渲染管线和可编程着色器的相关知识进行概括总结。主要内容包括：</p><ul><li>GPU 管线概述</li><li>可编程着色模型</li><li>思维导图</li></ul><p><em><span id="more"></span></em></p><h3 id="1-GPU-管线"><a href="#1-GPU-管线" class="headerlink" title="1 GPU 管线"></a>1 GPU 管线</h3><p>GPU 管线和上一节概念上的图形渲染管线不完全相同，现代 GPU 实现了图形渲染管线中的几何和光栅化阶段。其被分为一些不同程度的可配置性和可编程性的硬件阶段，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513100149647.png" alt="image-20220513100149647"></p><p>其中，不同颜色代表了不同程度的自定义属性：</p><ul><li>绿色的阶段都是完全可编程的</li><li>黄色的阶段可配置，但不可编程</li><li>蓝色的阶段完全固定</li></ul><p>GPU 实现的渲染管线和概念上的图形渲染管线的功能阶段在结构上略有不同。以下是对  GPU 渲染管线的一个流程概览：</p><ul><li><strong>顶点着色器（The Vertex Shader）</strong>是完全可编程的阶段，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改、创建、忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置等。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。</li><li><strong>几何着色器（The Geometry Shader）</strong>位于顶点着色器之后，允许 GPU 高效地创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片元着色器。</li><li><strong>裁剪（Clipping）</strong>属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。</li><li><strong>屏幕映射（Screen Mapping）</strong>、<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段是固定功能阶段。</li><li><strong>像素着色器（Pixel Shader，Direct3D 中的叫法）</strong>常常又称为片段着色器，<strong>片元着色器（Fragment Shader，OpenGL 中的叫法）</strong>，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。</li><li><strong>合并阶段（The Merger Stage）</strong>处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改（Color Modifying），Z 缓冲（Z-buffer），混合（Blend），模板（Stencil）和相关缓存的处理。</li></ul><h3 id="2-可编程着色模型"><a href="#2-可编程着色模型" class="headerlink" title="2 可编程着色模型"></a>2 可编程着色模型</h3><p>早期的着色模型可以用汇编语言直接编程，但 DX10 之后，汇编就只在调试输出阶段可见，改用高级着色语言。目前的着色语言都是 C-like 的着色语言，比如 HLSL，CG 和 GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言。这样的安排可以兼容不同的硬件实现。这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机。这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。<strong>着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。</strong></p><p>Shader 程序可以在程序加载或运行时离线编译。和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。一个编译过的  Shader 作为字符串或者文本来存储，并通过驱动程序传递给  GPU。</p><h4 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h4><p>顶点着色器是完全可编程的阶段，是专门处理传入的顶点信息的着色器，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作。顶点着色器一般不处理附加信息，也就是说，顶点着色器提供了修改，创建，或者忽略与每个多边形顶点相关的值的方式，例如其颜色，法线，纹理坐标和位置。通常，<strong>顶点着色器程序将顶点从模型空间（Model Space）变换到齐次裁剪空间（Homogeneous Clip Space）</strong>，并且，一个顶点着色器至少且必须输出此变换位置。</p><p>顶点着色器既不能创建也不能消除顶点，并且由一个顶点生成的结果不能传递到另一个顶点。由于每个顶点都被独立处理，所以  GPU 上的任何数量的着色器处理器都可以并行地应用到传入的顶点流上。</p><p>顶点着色器的输出可以以许多不同的方式来使用，通常是随后用于每个实例三角形的生成和光栅化，然后各个像素片段被发送到像素着色器，以便继续处理。而在 Shader Model 4.0 中，数据也可以发送到几何着色器（Geometry Shader）或输出流（Streamed Output）或同时发动到像素着色器和几何着色器两者中。</p><h4 id="2-2-几何着色器"><a href="#2-2-几何着色器" class="headerlink" title="2.2 几何着色器"></a>2.2 几何着色器</h4><p>几何着色器的输入是单个对象及对象相关的顶点，而对象通常是网格中的三角形，线段或简单的点。另外，扩展的图元可以由几何着色器定义和处理。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513102855674.png" alt="image-20220513102855674"></p><p>上图所示，几何着色器程序的输入是一个单独的类型：点，线段，三角形。两个最右边的图元，包括与线和三角形对象相邻的顶点也可被使用。</p><p>几何着色器需要图元作为输入，在处理过程中他可以将这个图元整个丢弃或者输出一个或更多的图元（也就是说它可以产生比它得到的更多或更少的顶点），这个能力被叫做几何增长（growing geometry）。几何着色器可以改变新传递进来的图元的拓扑结构，且几何着色器可以接收任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p><p>当我们未添加几何着色器时，默认的行为是将输入的三角形直接输出。我们添加了几何着色器之后，可以在几何着色器中修改输出的图形，我们可以输出我们想要输出的任何图形。</p><blockquote><p>GPU 管线的标准使用方式是发送数据到顶点着色器，然后对所得到的三角形进行光栅化处理，并在像素着色器中处理它们。数据总是通过管线传递，无法访问中间结果。流输出的想法在  Shader Model 4.0 中被引入。在顶点着色器（以及可选的几何着色器中）处理顶点之后，除了将数据发送到光栅化阶段之外，也可以输出到流，也就是一个有序数组中进行处理。事实上，可以完全关掉光栅化，然后管线纯粹作为非图形流处理器来使用。以这种方式处理的数据可以通过管线回传，从而允许迭代处理。这种操作特别适用于模拟流动的水或其他粒子特效。</p></blockquote><h4 id="2-3-像素着色器"><a href="#2-3-像素着色器" class="headerlink" title="2.3 像素着色器"></a>2.3 像素着色器</h4><p>像素着色器(Pixel Shader，Direct3D 中的叫法)，常常又称为片元着色器(Fragment Shader, OpenGL 中的叫法)，用于进行逐像素计算颜色的操作，让复杂的着色方程在每一个像素上执行。像素着色器是光栅化阶段的主要步骤之一。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。</p><p>像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片元着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片元着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。</p><p>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在 Shader Model 4.0 中，共有 16 个向量（每个向量含 4 个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出 32 个向量到像素着色器中。</p><h4 id="2-4-合并阶段"><a href="#2-4-合并阶段" class="headerlink" title="2.4 合并阶段"></a>2.4 合并阶段</h4><p>作为光栅化阶段名义上的最后一个阶段，合并阶段（The Merging Stage）是将像素着色器中生成的各个片段的深度和颜色与帧缓冲结合在一起的地方。这个阶段也就是进行模板缓冲（Stencil-Buffer）和 Z 缓冲（Z-buffer）操作的地方。最常用于透明处理（Transparency）和合成操作（Compositing）的颜色混合（Color Blending）操作也是在这个阶段进行的。虽然合并阶段不可编程，但却是高度可配置的。在合并阶段可以设置颜色混合来执行大量不同的操作。最常见的是涉及颜色和 Alpha 值的乘法，加法，和减法的组合。其他操作也是可能的，比如最大值，最小值以及按位逻辑运算。</p><h4 id="2-5-特效"><a href="#2-5-特效" class="headerlink" title="2.5 特效"></a>2.5 特效</h4><p>GPU 渲染管线中的可编程阶段有顶点、几何和像素着色器三个部分，他们需要相互结合在一起使用。正因如此，不同的团队研发出了不同的特效语言，例如 HLSL FX，CgFX，以及 COLLADA FX，来将他们更好的结合在一起。</p><p>一个效果文件通常会包含所有执行一种特定图形算法的所有相关信息，而且通常定义一些可被应用程序赋值的全局参数。例如，一个单独的  effect file 可能定义渲染塑料材质需要的  vs（顶点着色器）和  ps（像素着色器），它可能暴露一些参数例如塑料颜色和粗糙度，这样渲染每个模型的时候可以改变效果而仅仅使用同一个特效文件。一个效果文件中能存储很多 techniques。这些 techniques 通常是一个<br>相同特效的变体。</p><p>下图展示了一些特效文件带来的材质和后处理效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104314983.png" alt="image-20220513104314983"></p><h3 id="3-思维导图"><a href="#3-思维导图" class="headerlink" title="3 思维导图"></a>3 思维导图</h3><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104353817.png" alt="image-20220513104353817"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中 GPU 渲染管线和可编程着色器的相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU 管线概述&lt;/li&gt;
&lt;li&gt;可编程着色模型&lt;/li&gt;
&lt;li&gt;思维导图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】图形渲染管线</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-05-12T09:41:09.000Z</published>
    <updated>2022-05-12T09:43:20.381Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中图形渲染管线的相关知识进行概括总结。主要内容包括：</p><ul><li>图形渲染管线整体架构</li><li>图形渲染管线各阶段工作</li><li>思维导图</li></ul><p><em><span id="more"></span></em></p><h2 id="1-知识总结"><a href="#1-知识总结" class="headerlink" title="1 知识总结"></a>1 知识总结</h2><h3 id="1-1-图形渲染管线架构"><a href="#1-1-图形渲染管线架构" class="headerlink" title="1.1 图形渲染管线架构"></a>1.1 图形渲染管线架构</h3><p>在概念上可以将图形渲染管线分为三个阶段：</p><ul><li>应用程序阶段（The Application Stage）</li><li>几何阶段（The Geometry Stage）</li><li>光栅化阶段（The Rasterizer Stage）</li></ul><p>如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152034788.png" alt="image-20220512152034788"></p><p>图形渲染管线的每个阶段也可能是一条管线，比如上图中几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</p><h3 id="1-2-应用程序阶段"><a href="#1-2-应用程序阶段" class="headerlink" title="1.2 应用程序阶段"></a>1.2 应用程序阶段</h3><p>应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。</p><p>正因应用程序阶段是软件方式实现，因此不能像几何和光栅化阶段那样继续分为若干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在 CPU 设计上，称这种形式为超标量体系（superscalar）结构，因为它可以在同一阶段同一时间做不同的几件事情。</p><p><strong>应用程序阶段通常实现的方法</strong>有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p><p><strong>应用程序阶段的主要任务</strong>：在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元，rendering primitives，如点、线、矩形等）输入到绘制管线的下一个阶段。</p><p>对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段——几何阶段。</p><h3 id="1-3-几何阶段"><a href="#1-3-几何阶段" class="headerlink" title="1.3 几何阶段"></a>1.3 几何阶段</h3><p>几何阶段主要负责大部分多边形操作和顶点操作。可以将这个阶段进一步划分成如下几个功能阶段：</p><ul><li>模型视点变换 Model &amp; View Transform</li><li>顶点着色 Vertex Shading</li><li>投影 Projection</li><li>裁剪 Clipping</li><li>屏幕映射 Screen Mapping</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152716026.png" alt="image-20220512152716026"></p><p>几个注意点：</p><ul><li>根据具体实现，这些阶段可以和管线阶段等同，也可以不等同。在一些情况下，一系列连续的功能阶段可以形成单个管线阶段（和其他管线阶段并行运行）。在另外情况下，一个功能阶段可以划分成其他更细小的管线阶段。</li><li>几何阶段执行的是计算量非常高的任务，在只有一个光源的情况下，每个顶点大约需要 100 次左右的精确的浮点运算操作。</li></ul><h4 id="1-3-1-模型和视图变换"><a href="#1-3-1-模型和视图变换" class="headerlink" title="1.3.1 模型和视图变换"></a>1.3.1 模型和视图变换</h4><p>在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中。<strong>模型变换的变换对象一般是模型的顶点和法线</strong>。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p><p>为了便于投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向 Z 轴负方向，y 轴指向上方,x 轴指向右边。在视点变换后，实际位置和方向就依赖于当前的 API。我们称上述空间为相机空间或者观察空间。</p><p>下图显示了模型和视图变换的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512153245093.png" alt="image-20220512153245093"></p><p>在左图中，摄像机根据用户指定的位置进行放置和定位。在右图中，视点变换从 原点沿着 Z 轴负方向对相机重新定位，这样可以使裁剪和投影操作更简单、更快速。可视范围是一个平截椎体，因此可以认为它是透视模式。</p><p><strong>【总结】</strong>模型和视图变换阶段分为模型变换和视图变换。模型变换的目的是将模型变换到适合渲染的空间当中，而视图变换的目的是将摄像机放置于坐标原点，方便后续步骤的操作。</p><h4 id="1-3-2-顶点着色"><a href="#1-3-2-顶点着色" class="headerlink" title="1.3.2 顶点着色"></a>1.3.2 顶点着色</h4><p>为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些描述。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p><p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shading equation）。通常，这些计算中的一部分在几何阶段期间在模型的顶点上执行（vertex shading），而其他计算可以在逐像素光栅化（per-pixel rasterization）期间执行。可以在每个顶点处存储各种属性数据，诸如顶点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。<strong>顶点着色的结果（可以是颜色，向量，纹理坐标或任何其他种类的着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</strong></p><p>着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型空间、观察空间、法线空间等）并在那里执行计算，也可以得到正确的结果。这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p><p><strong>【总结】</strong>顶点着色阶段的目的在于确定模型上顶点处材质的光照效果。</p><h4 id="1-3-3-投影"><a href="#1-3-3-投影" class="headerlink" title="1.3.3 投影"></a>1.3.3 投影</h4><p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是 (-1,- 1,-1) 和 (1,1,1) 的单位立方体（unit cube）内，这个单位立方体通常也被称为规范立方体（Canonical View Volume，CVV）。</p><p>目前，主要有两种投影方法，即：</p><ul><li>正交投影（orthographic projection，或称  parallel projection）</li><li>透视投影（perspective projection）</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512154019834.png" alt="image-20220512154019834"></p><p>正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。而在透视投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</p><p>正交投影和透视投影都可以通过 4 x 4 的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。</p><p><strong>【总结】</strong>投影的目的在于将模型顶点变换到归一化的设备坐标系中，便于后续处理。</p><h4 id="1-3-4-裁剪"><a href="#1-3-4-裁剪" class="headerlink" title="1.3.4 裁剪"></a>1.3.4 裁剪</h4><p>只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。</p><p>不难理解，一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p><ul><li>当图元完全位于视体内部，那么它可以直接进行下一个阶段</li><li>当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染</li><li>当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理</li></ul><p>裁剪的过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512160053289.png" alt="image-20220512160053289"></p><p>投影变换后，只对单位立方体内的图元（相应的是视锥内可见图元）继续进行处理，因此，将单位立方体之外的图元剔除掉，保留单位立方体内部的图元，同时沿着单位立方体将与单位立方体相交的图元裁剪掉，于是就会产生新的图元，同时舍弃旧的图元。</p><p><strong>【总结】</strong>裁剪阶段的目的，就是对部分位于视体内部的图元进行裁剪操作以只保留在视体内的部分。</p><h4 id="1-3-5-屏幕映射"><a href="#1-3-5-屏幕映射" class="headerlink" title="1.3.5 屏幕映射"></a>1.3.5 屏幕映射</h4><p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的 x 和 y 坐标变换到了屏幕坐标系中，屏幕坐标系连同 z 坐标一起称为窗口<br>坐标系。<br>假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2， y2），其中  x1 &lt; x2，y1 &lt; y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中 z 坐标不受影响。新的 x 和 y 坐标称为屏幕坐标系，与 z 坐标一起（-1 ≦ z ≦ 1）进入光栅化阶段。<br>屏幕映射过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163021922.png" alt="image-20220512163021922"></p><p><strong>【总结】</strong>屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p><h3 id="1-4-光栅化阶段"><a href="#1-4-光栅化阶段" class="headerlink" title="1.4 光栅化阶段"></a>1.4 光栅化阶段</h3><p>给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。这个过个过程叫光珊化（rasterization）或扫描变换（scan conversion），即从二维顶点所处的屏幕空间（所有顶点都包含 Z 值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。</p><p>与几何阶段相似，该阶段细分为几个功能阶段：</p><ul><li>三角形设定（Triangle Setup）阶段</li><li>三角形遍历（Triangle Traversal）阶段</li><li>像素着色（Pixel Shading）阶段</li><li>融合（Merging）阶段</li></ul><p>如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163755234.png" alt="image-20220512163755234"></p><h4 id="1-4-1-三角形设定"><a href="#1-4-1-三角形设定" class="headerlink" title="1.4.1 三角形设定"></a>1.4.1 三角形设定</h4><p>三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。<strong>该过程在专门为其设计的硬件上执行</strong>。</p><h4 id="1-4-2-三角形遍历"><a href="#1-4-2-三角形遍历" class="headerlink" title="1.4.2 三角形遍历"></a>1.4.2 三角形遍历</h4><p>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成<strong>片元（fragment）</strong>。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。<strong>每个片元的属性均由三个三角形顶点的数据插值而生成，这些属性包括片元的深度，以及来自几何阶段的着色数据等。</strong><br><strong>【总结】</strong>找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。</p><h4 id="1-4-3-像素着色"><a href="#1-4-3-像素着色" class="headerlink" title="1.4.3 像素着色"></a>1.4.3 像素着色</h4><p><strong>所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。</strong>纹理贴图操作就是在这阶段进行的。像素着色阶段是在可编程 GPU 内执行的，在这一阶段有大量的技术可以使用，其中最常见，<br>最重要的技术之一就是纹理贴图（Texturing），将会在之后进行总结。</p><p><strong>【总结】</strong>像素着色阶段的主要目的是计算所有需逐像素操作的过程。</p><h4 id="1-4-4-融合"><a href="#1-4-4-融合" class="headerlink" title="1.4.4 融合"></a>1.4.4 融合</h4><p>每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。<strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。</strong>不像其它着色阶段，通常运行该阶段的 GPU 子单元并非完全可编程的，但其高度可配置，可支持多种特效。</p><p>此外，这个阶段还负责可见性问题的处理。对于大多数图形硬件来说，这个过程是通过 <strong>Z 缓冲（Z-Buffer）</strong>算法来实现的。Z 缓冲算法非常简单，具有 O(n) 复杂度（n 是需要绘制的像素数量），只要对每个图元计算出相应的像素 z 值，就可以使用这种方法，大概内容是：Z 缓冲器和颜色缓冲器形状大小一样，每个像素都存储着一个 z 值，这个 z 值是从相机到最近图元之间的距离。每次将一个图元绘制为相应像素时，需要计算像素位置处图元的 z 值，并与同一像素处的 z 缓冲器内容进行比较。如果新计算出的 z 值，远远小于 z 缓冲器中的 z 值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近。这样，像素的 z 值和颜色就由当前图元对应的值和颜色进行更新。反之，若计算出的 z 值远远大于 z 缓冲器中的 z 值，那么 z 缓冲器和颜色缓冲器中的值就无需改变。</p><p>除了颜色缓冲器用来存储颜色，z 缓冲器用来存储每个像素的  z 值，还有其他缓冲器可以用来过滤和捕获片段信息：</p><ul><li><strong>alpha 通道（alpha channel）</strong>和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值。 可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片断未能通过测试，它将不再进行进一步的处理。alpha 测试经常用于不影响深度缓存的全透明片段的处理。</li><li><strong>模板缓冲器（stencil buffer）</strong>是用于记录所呈现图元位置的离屏缓存。每个像素通常与占用 8 个位。图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和 Z 缓存的渲染。举个例子，假设在模板缓冲器中绘制出了一个实心圆形，那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个 mask 的操作。模板缓冲器是制作特效的强大工具。而在管线末端的所有这些功能都叫做光栅操作（raster operations ，ROP）或混合操作（blend operations）。</li><li><strong>帧缓冲器（frame buffer）</strong>通常包含一个系统所具有的所有缓冲器，但有时也可以认为是颜色缓冲器和 z 缓冲器的组合。</li><li><strong>累计缓冲器（accumulation buffer）</strong>，是 1990 年，Haeberli 和 Akeley 提出的一种缓冲器，是对帧缓冲器的补充。这个缓冲器可以用一组操作符对图像进行累积。例如，为了产生运动模糊（motion blur），可以对一系列物体运动的图像进行累积和平均。此外，其他的一些可产生的效果包括景深（e depth of field），反走样（antialiasing）和软阴影（soft shadows）等。</li></ul><p>而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了<strong>双缓冲（double buffering）</strong>机制，这意味着屏幕绘制是在一个后置缓冲器（backbuffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换。注意，只有当不影响显示的时候，才进行交换。</p><p><strong>【总结】</strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。此外，融合阶段还负责可见性问题（Z 缓冲相关）的处理。</p><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>图形渲染管线的主要功能就是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。在概念上可以将图形渲染管线分为三个阶段：应用程序阶段、几何阶段、光栅化阶段。</p><p><strong>应用程序阶段</strong>的主要任务，是将需要绘制图元输入到绘制管线的下一个阶段，以及实现一些软件方式来实现的方法。主要方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法。对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段，即几何阶段。</p><p><strong>几何阶段</strong>首先对模型的顶点和法线进行矩阵变换，并将模型置于观察空间中（模型和视图变换），然后根据材质、纹理、以及光源属性进行顶点光照的计算（顶点着色阶段），接着将该模型投影变换到一个单位立方体内，并舍弃所有立方体之外的图元（投影阶段），而为了得到所有位于立方体内部的图元，接下来对与单位立方体相交的图元进行裁剪（裁剪阶段），然后将顶点映射到屏幕上的窗口中（屏幕映射阶段）。在对每个多边形执行完这些操作后，将最终数据传递到光栅，这样就来到了管线中的最后一个阶段，光栅化阶段。</p><p><strong>光栅化阶段</strong>中，所有图元会被光栅化，进而转换为屏幕上的像素。首先，计算三角形表面的差异和三角形表面的其他相关数据（三角形设定阶段），然后，找到哪些采样点或像素在三角形中（三角形遍历阶段），接着计算所有需逐像素计算操作（像素着色阶段），然后，合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，可见性问题可通过 Z 缓存算法解决，随同的还有可选的 alpha 测试和模版测试（融合阶段）。所有对象依次处理，而最后的图像显示在屏幕上。</p><h2 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2 思维导图"></a>2 思维导图</h2><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg" alt="图形渲染管线思维导图"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中图形渲染管线的相关知识进行概括总结。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形渲染管线整体架构&lt;/li&gt;
&lt;li&gt;图形渲染管线各阶段工作&lt;/li&gt;
&lt;li&gt;思维导图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（七）模板和RTTI</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/</id>
    <published>2022-05-11T08:08:23.000Z</published>
    <updated>2022-05-11T08:12:51.045Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第七章重点梳理。主要内容包括：</p><ul><li>模板（Template）</li><li>执行期类型识别（Runtime Type Identification，RTTI）</li></ul><p><em><span id="more"></span></em></p><h3 id="1-模板（Template）"><a href="#1-模板（Template）" class="headerlink" title="1 模板（Template）"></a>1 模板（Template）</h3><h4 id="1-1-模板的实例化"><a href="#1-1-模板的实例化" class="headerlink" title="1.1 模板的实例化"></a>1.1 模板的实例化</h4><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++ 标准才要求实例化他们。其原因，有两点：</p><ul><li>空间和时间效率的考虑，如果模板类中有 100 个成员函数，对某个特定类型只有 2 个函数会被使用，针对另一个特定类型只会使用 3 个，那么如果将剩余的 195 个函数实例化将浪费大量的时间和空间。</li><li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li></ul><h4 id="1-2-模板的名称决议"><a href="#1-2-模板的名称决议" class="headerlink" title="1.2 模板的名称决议"></a>1.2 模板的名称决议</h4><p>对于一个模板类来说，需要明确两个范围：一个是定义模板的范围（scope of the template definition），另一个是实例化模板的范围（scope of the template instantiation）。</p><p>下面来举例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeRules</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        _member = <span class="built_in">foo</span>( _val );  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>( _member );  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _val;  </span><br><span class="line">    type _member;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope of the template instantiation  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;  </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ScopeRules&lt; <span class="type">int</span> &gt; sr0;  </span><br><span class="line"><span class="comment">/*(1)*/</span>sr0.<span class="built_in">invariant</span>();</span><br><span class="line"><span class="comment">/*(2)*/</span>sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></table></figure><p>对于上面的语句（1），将会调用哪一个 <code>foo()</code> 函数呢？答案是 <code>double foo ( double )</code>，这是一个完全反直觉的答案，原因在于 <code>invariant()</code> 函数调用了一个外部函数 <code>foo()</code> ，但传入的参数是模板类中固定类型的成员 <code>_val</code>，无论模板被实例化为什么类型，其中的 <code>_val</code> 都是 int 型，也就是说它完全与实例化模板的参数的类型无关，此时对于外部函数名称的决议会在定义模板的范围内进行，在上面的例子中，定义模板的范围内只有一个 <code>foo()</code> 函数的声明，所以即使 <code>_val</code> 是 int 型，也会调用 double 作为参数的 <code>foo()</code> 函数。</p><p>而对于语句（2），会调用 <code>int foo( int )</code>，因为 <code>type_dependent()</code> 函数将与实例化模板的参数类型有关的成员作为参数传给了外部函数，此时就无法在定义模板类的范围内决议使用哪个 <code>foo()</code> 函数，所以要推迟到模板被实例化之后再决议，因此会在实例化模板的范围内寻找合适的函数，上面的例子中，实例化模板的范围中有两个声明的 <code>foo()</code> 函数，所以会选择和模板类型匹配的 <code>foo(int)</code> 函数进行调用。</p><p>总结一下，在模板中，一个非成员名称的决议在于它适不适合在当前决议，当它完全与实例化模板的参数类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，于是将被推迟到实例化这个模板的时候才决议。</p><h3 id="2-执行期类型识别（Runtime-Type-Identification）"><a href="#2-执行期类型识别（Runtime-Type-Identification）" class="headerlink" title="2 执行期类型识别（Runtime Type Identification）"></a>2 执行期类型识别（Runtime Type Identification）</h3><p>在一开始学习多态的时候就已经了解过 RTTI，这里最后进行总结：</p><ol><li>RTTI  只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI 的，这是因为 RTTI 的实现是通过 vptr 来获取存储在虚函数表中的 <code>type_info*</code> ，事实上为非多态类提供 RTTI 也没有多大意义</li><li>对指针进行 <code>dynamic_cast</code> 失败会返回 NULL，而对引用的话，失败会抛出 <code>bad_cast exception</code>，这是由于指针可以被赋值为 0，以表示 no object，但是引用不行</li><li><code>typeid</code> 可以返回 <code>const type_info&amp;</code>，用以获取类型信息。虽然第一点指出 RTTI 只支持多态类，但 <code>typeid</code> 和 <code>type_info</code> 同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的 <code>type_info</code> 对象是静态取得（所以不能叫“执行期类型识别”），而多态类的是在执行期获得。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第七章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板（Template）&lt;/li&gt;
&lt;li&gt;执行期类型识别（Runtime Type Identification，RTTI）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（六）关于执行期</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/</id>
    <published>2022-05-11T07:17:16.000Z</published>
    <updated>2022-05-11T07:19:14.225Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第六章重点梳理。主要内容包括：</p><ul><li>执行期对象的构造与析构</li><li>详解 new 和 delete</li></ul><p><em><span id="more"></span></em></p><h3 id="1-对象的构造与析构"><a href="#1-对象的构造与析构" class="headerlink" title="1 对象的构造与析构"></a>1 对象的构造与析构</h3><p>一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    Point point; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// point.Point::Point() 一般被安插在这儿      </span></span><br><span class="line">    </span><br><span class="line">    ...      </span><br><span class="line">             </span><br><span class="line">    <span class="comment">// point.Point::~Point() 一般被安插在这儿 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方</strong>，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。</p><h4 id="1-1-全局对象（Global-Objects）"><a href="#1-1-全局对象（Global-Objects）" class="headerlink" title="1.1 全局对象（Global Objects）"></a>1.1 全局对象（Global Objects）</h4><p>一个全局对象，C++ 保证它在 <code>main()</code> 第一次使用它之前将其构造，而在 <code>main()</code> 结束之前，将之析构掉。C++ 程序中所有的 global objects 都被放置在程序的 data segment (数据段) 中，如果明确指定给它一个值， object 将以该值为初值。否则 object 所配置到的内存内容为 0.</p><p>虽然全局对象在编译期被即被置为 0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是静态初始化。所谓静态初始化，是因为全局变量被放在 data segment，data segment 是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为 0，存储在数据段，而等到程序激活时，就可以通过构造函数对在数据段的全局对象进行初始化了.</p><blockquote><p>以下引用自原书：</p><p>静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置于 try 块中，我们知道一个没有得到 catch 的异常默认的调用 <code>terminate()</code> 函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…</p><p>Lippman 甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。</p></blockquote><h4 id="1-2-局部静态对象（Local-Static-Objects）"><a href="#1-2-局部静态对象（Local-Static-Objects）" class="headerlink" title="1.2 局部静态对象（Local Static Objects）"></a>1.2 局部静态对象（Local Static Objects）</h4><p>下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Matrix&amp;  <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> Matrix mat_identity;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>static</code> 语意保证了 mat_identity 对象在整个程序周期都存在，而不会在函数 <code>identity()</code>退出时被析构，所以：</p><ul><li>mat_identity 的构造函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li><li>mat_identity 的析构函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li></ul><p>那么 mat_identity 的构造函数和析构函数到底在什么时候被调用？答案是：mat_identity 的构造函数只有在  <code>identity()</code> 第一次被调用时才被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。</p><h4 id="1-3-对象数组（Array-of-Objects）"><a href="#1-3-对象数组（Array-of-Objects）" class="headerlink" title="1.3 对象数组（Array of Objects）"></a>1.3 对象数组（Array of Objects）</h4><p>对于定义的一个对象数组，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际上背后做的工作是：</p><ol><li>分配充足的内存以存储 10 个 Point 对象；</li><li>为每个 Point 对象调用它们的默认构造函数（如果有的话，且不论是合成的还是显式定义的）。编译器一般以一个或多个函数来完成这个任务。当数组的生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。而关于具体细节，不必要死扣了，每个编译器肯定都有些许差别。</li></ol><h3 id="2-new-和-delete"><a href="#2-new-和-delete" class="headerlink" title="2 new 和 delete"></a>2 new 和 delete</h3><p>C++ 中一个经常容易混淆的问题是关于：operator new、new expression 和 placement operator new。这一节来详细讨论这三者的区别和联系。</p><h4 id="2-1-operator-new-和-new-expression"><a href="#2-1-operator-new-和-new-expression" class="headerlink" title="2.1 operator new 和 new expression"></a>2.1 operator new 和 new expression</h4><p>首先要明确，operator new 是一个运算符，和 +、-、*、% 等一样，是可以被重载的，而 new expression 不可以被重载，new expression 是对 operator new 的又一层封装。</p><p>C 语言中 <code>malloc</code> 函数我们非常熟悉，函数原型为 <code>void* malloc(size_t size)</code> ，参数 size 为要分配的字节数，返回值是 void*，通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址，失败会返回 NULL，但是申请成功后并不进行初始化，每个数据都是随机值。</p><p>operator new 是对 malloc 的封装，因此功能和 malloc 完全一样，只有一点细微的不同，operator new 在内存申请失败时会抛出异常，除此之外完全相同，也就是说，operator new 只用于分配内存。</p><p>而当我们使用非常熟悉的 new expression，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>实际上包含了两个步骤：</p><ul><li>调用 operator new 分配内存</li><li>调用合适的构造函数初始化这块内存，如果不是自定义的类，那么初始化就是简单的赋值操作</li></ul><p>由此可见， new expression 是对 operator new 的又一层封装。</p><p>我们当然也可以直接使用 operator new，比如只想分配内存的时候，完全可以替代 C 语言中的 <code>malloc</code> 操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T* newelements = <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line"><span class="comment">// 等同于T* pa = (T*)malloc(sizeof(T));</span></span><br><span class="line"><span class="comment">// static_cast表示明确的显式转换，可以告诉编译器和阅读程序的人这样的转换是故意为之</span></span><br></pre></td></tr></table></figure><p>STL 中重载有两个版本的 operator new，分别为单个对象和数组对象服务，单个对象版本提供给分配单个对象的 <code>new</code> 表达式调用，数组版提供给分配数组的 <code>new[]</code> 表达式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;     <span class="comment">// allocate an object</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// allocate an array</span></span><br></pre></td></tr></table></figure><p>我们可以分别重载这两个版本，来自定义单个对象或对象数组的内存分配方式。当我们自己在重载 operator new 时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个 <code>void*</code> 类型和第一个参数的类型必须为 <code>size_t</code>。</p><p>同样的，operator delete 和 delete expression 的关系和上述 operator new 和 new expression 的关系完全一样，delete expression 会先调用析构函数，再调用 operator delete 释放内存。operator delete 的功能和 C 中的 <code>free</code> 完全一样，是对 <code>free</code> 的封装。</p><p>需要注意的是，在类中重载的 operator new 和 operator delete 必须是静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个 this 指针来存取对象成员。另外，new expression 默认调用的是单参数的 operator new，即上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p><h4 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h4><p>有下面两种关于 delete expression 的情况，第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// p为什么能delete两次，而程序运行的时候还不报错。</span></span><br></pre></td></tr></table></figure><p>第二种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> ;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">5</span>;     <span class="comment">//delete后为什么还可以对*p进行再赋值？</span></span><br></pre></td></tr></table></figure><p>在回答这两个问题之前，我们先想想 <code>delete p</code>  这一语句意味着什么？p 指向一个地址，以该地址为起始地址保存有一个 <code>int</code> 变量（虽然该变量并没有进行初始化，因此默认为 0），<code>delete p </code> 之后 p 所指向的地址空间被释放，也就是说这个 int 变量的生命结束，但是 p 仍是一个合法的指针，它仍指向原来的地址，而且该地址仍代表着一个合法的程序空间。与 <code>delete</code> 之前唯一不同的是，你已经丧失了那块程序空间的所有权。但你依然可以通过指针对这块空间进行操作，因为你还保留有这块空间的“钥匙” p。</p><p>此时通过指针 p 对这块空间进行操作虽然从语法上来说是合法的，但是暗藏着很大的逻辑错误。不论是对一块已经释放的内存再度 <code>delete</code>，还是再度给它赋值，都暗含着很大的危险，因为当你 <code>delete</code> 后，就代表着将这块内存归还，而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度 <code>delete</code> 还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，完全取决于编译器够不够“聪明”。</p><p>上述情况下的指针 p 被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。避免野指针的一个好方法是，当一个指针变为野指针的时候，马上赋值为 <code>NULL</code>，其缘由在于，你可以很容易的判断一个指针是否为 <code>NULL</code>，却难以抉择其是否为野指针。而且，<code>delete </code> 一个空指针，不会做任何操作，因此总是安全的。</p><h4 id="2-3-placement-operator-new-和-placement-new-expression"><a href="#2-3-placement-operator-new-和-placement-new-expression" class="headerlink" title="2.3 placement operator new 和 placement new expression"></a>2.3 placement operator new 和 placement new expression</h4><p>placement new expression 的功能是对已经存在的空间进行初始化，即用来在指定地址上构造对象，因此它并不分配内存，仅仅是对指定地址调用构造函数。</p><p>而 placement operator new 是对 operator new 的重载，它的功能就是返回给定的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 p 指针指向的内存已经存在，不需要再分配内存，因此只要返回这个指针即可。</p><p>placement new expression 先调用 placement operator new 返回指针 p，然后调用构造函数初始化这个指针指向的内存，这样也就完成了对已经存在的空间进行初始化的工作。</p><p>需要注意的是，通过 placement new expression 构建的一个对象，如果你使用 delete 来删除对象，那么其内存也会被回收，如果想保留内存而只析构对象，好的办法是显式调用其析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* pa = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="comment">// 使用 placement new expression 初始化内存</span></span><br><span class="line"><span class="built_in">new</span>(pa) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 显式调用析构函数析构对象</span></span><br><span class="line">pa-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// 此时内存还在，手动使用delete释放内存，如果直接使用delete则其自动先调用析构，再释放内存</span></span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上并没有 placement new expression 这么一说，上面的说法只是为了便于理解，从头到尾都只有一个 new expression，并且 new expression 永远都只进行以下两个步骤：</p><ul><li>调用一个合适参数的 operator new 来分配内存，可以是普通的 operator new，也可以是 operator new[]，还可以是 placement  operator new</li><li>调用一个合适参数的构造函数初始化 operator new 分配的内存</li></ul><h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><p>operator new、new expression 和 placement operator new 三者的关系现在非常明了，总结如下：</p><ul><li>operator new 相当于 malloc 分配内存，区别在于申请失败时抛出异常而不是返回空指针</li><li>placement operator new 将给定的指针直接返回，相当于返回一块已经存在的内存</li><li>new expression 首先调用合适的 operator new 分配内存（可能是新分配的，也可能是已经存在的），然后调用构造函数初始化这块内存</li><li>operator delete 相当于 free 释放内存</li><li>delete expression 首先调用析构函数，然后调用 operator delete 释放内存</li></ul><h4 id="2-5-内存池"><a href="#2-5-内存池" class="headerlink" title="2.5 内存池"></a>2.5 内存池</h4><p>关于内存池技术有必要的话可以再做深入学习，这里只做简单了解即可。</p><p>利用默认的内存管理操作符 new 和 delete 在堆上分配和释放内存会有一些额外的开销。</p><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。</p><p>可见，如果程序频繁地使用 new 和 delete 在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。</p><p>C++ 引入了内存池（Memory Pool）来提高内存管理和运行效率。内存池是一种高效的内存分配方式，其工作原理是先向系统一次性申请比较大的空间，当我们每次去申请空间时就直接使用内存池里的空间，而省略了申请和释放的两个动作开销，也减少了系统内存碎片，从而提高了系统效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第六章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行期对象的构造与析构&lt;/li&gt;
&lt;li&gt;详解 new 和 delete&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（五）对象复制和析构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/</id>
    <published>2022-05-09T08:37:15.000Z</published>
    <updated>2022-05-11T07:16:51.387Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第五章重点梳理。主要内容包括：</p><ul><li>关于对象复制操作（Copy Assignment Operator）</li><li>关于对象析构（Destruction）</li><li>几点类的设计原则</li></ul><p><em><span id="more"></span></em></p><h3 id="1-关于-Copy-Assignment-Operator"><a href="#1-关于-Copy-Assignment-Operator" class="headerlink" title="1 关于 Copy Assignment Operator"></a>1 关于 Copy Assignment Operator</h3><p>Copy Assignment Operator 是指类中对 <code>operator=</code> 的重载，用来将一个对象指定给另一个对象。如果我们希望不允许将该类的对象指定给另一个对象，只需要将 <code>operator=</code> 设定为 private，并且不提供函数体即可。</p><p>当然大部分情况下，类的设计者可以选择不显式提供 copy assignment operator，使用默认的逐成员复制（类似于拷贝构造函数），因为这样既方便，效率又高。copy assignment operator 和拷贝构造函数一样，只在有用（nontrivial）的时候会真正被编译器产生或合成出来，而其他情况下由于保持有 bitwise copy semantics，不需要以函数调用的形式进行复制，也就无须合成。在四种情况下 copy assignment operator 会被视为 nontrivial 而被合成出来：</p><ul><li>当 class 中包含一个对象成员而后者的类声明有一个 copy assignment operator 时，因为需要调用对象成员的 copy assignment operator</li><li>当 class 继承自一个 base class 而后者存在有一个 copy assignment operator 时，因为需要调用基类的 copy assignment operator</li><li>当 class 声明了一个或多个 virtual functions 时，因为我们一定不能直接拷贝等号右边对象的 vptr，因为等号左边可能是基类对象，而右边是派生类对象</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时（不论虚基类有没有 copy assignment operator）</li></ul><h3 id="2-关于析构（Destruction）"><a href="#2-关于析构（Destruction）" class="headerlink" title="2 关于析构（Destruction）"></a>2 关于析构（Destruction）</h3><p>如果 class 没有显式定义析构函数，那么只有在 class 内包含的 member object（或是 class 自己的 base class）拥有析构函数时，编译器才会自动合成一个析构函数，否则，析构函数会被视为不需要，也就不需被合成（当然更不需要被调用）。析构函数的扩展和执行顺序类似于之前构造函数的执行顺序，并且与构造函数的顺序完全相反：</p><ol><li>构造函数本身首先被执行</li><li>如果有对象成员，且其有析构函数，按照它们声明顺序的相反顺序调用它们的析构函数</li><li>如果有 vptr，则重设 vptr，指向适当的基类的虚函数表</li><li>如果有任何直接的（上一层） nonvirtual base classes 拥有 destructor，它们会以其声明顺序的相反顺序被调用</li><li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个类是继承链最尾端 (most-derived) 的类，那么它们会以其原来的构造顺序的相反顺序被调用</li></ol><p>对于如下类继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/image-20220509161840825.png" alt="image-20220509161840825"></p><p>那么一个 PVertex 对象的构造过程是：首先构造一个 Point 对象，然后变成一个 Vertex 和一个 Point3d 对象，然后变成一个 Vertex3d 对象，最后变成一个 PVertex 对象；而一个 PVertex 对象的析构过程正相反：依次变成一个 Vertex3d 对象、一个 Vertex 对象、 一个 Point3d 对象，最后成为一个 Point 对象。</p><p>所以对象的构造是一个逐步进化的过程，从构建一个最基础的对象开始，一步步构建成一个目标对象，而对象的析构则是相反的逐步退化的过程。</p><h3 id="3-几点类的设计原则"><a href="#3-几点类的设计原则" class="headerlink" title="3 几点类的设计原则"></a>3 几点类的设计原则</h3><ul><li><p><strong>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。</strong>或许你可以通过其派生类来初始化它的数据成员（假如 non-static data member 为 publish 或 protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的 data member 应当被初始化，且只在其构造函数或其 member function 中初始化。</p></li><li><p><strong>只在有必要的时候才使用虚函数，不要滥用虚函数</strong>。虚函数意味着不小的成本，编译器很可能给你的类带来一连串的膨胀效应：</p><ul><li>每一个对象要多负担一个 vptr</li><li>给每一个构造函数（不论是显式的还是编译器合成的），插入一些代码来初始化 vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前</li><li>生成或合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对 vptr 的初始化代码</li><li>如果类原本具有 bitwise copy 语意，将失去该语义，然后是上面所述，更大的对象、没有那么高效的构造函数、没有那么高效的复制操作</li></ul></li><li><p><strong>不能决定一个虚函数是否需要 const ，那么就不要 const。</strong></p></li><li><p><strong>不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义，但还是必须实现该纯虚析构函数，否则所有的派生类都将遇到链接错误。这是因为，每一个派生类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显式的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义，所以当编译器看到一个其基类的析构函数声明，就去调用它的实体，而不管它有没有被定义。</p></li><li><p><strong>决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个基类的构造函数含有对虚函数的调用，当其派生类的构造函数调用基类的构造函数时，其中调用的虚函数是基类中的实体，而不是派生类中的实体。这是由 vptr 初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因为构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象，析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第五章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于对象复制操作（Copy Assignment Operator）&lt;/li&gt;
&lt;li&gt;关于对象析构（Destruction）&lt;/li&gt;
&lt;li&gt;几点类的设计原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
