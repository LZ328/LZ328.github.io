<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-06-13T03:33:04.591Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【高质量实时渲染】实时光线追踪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-06-09T08:03:44.000Z</published>
    <updated>2022-06-13T03:33:04.591Z</updated>
    
    <content type="html"><![CDATA[<p>随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。</p><p><em><span id="more"></span></em></p><h3 id="1-实时光线追踪基本思路"><a href="#1-实时光线追踪基本思路" class="headerlink" title="1 实时光线追踪基本思路"></a>1 实时光线追踪基本思路</h3><p>NVIDIA 在 2018 年推出了 RTX 系列显卡，采用 Turing 架构，引入了专门处理光线追踪的 RT Core，使得光线追踪这种计算开销极大的算法能够实时运行。</p><p>实时光线追踪和离线光线追踪使用的算法完全一致，都是采样光线，计算交点，然后循环迭代，RTX 20 系列支持每秒 100 亿根光线的处理，这个数字看似很多，但实际上还要除以屏幕的分辨率，通常就是几千万个像素，还要除以帧率，因此最终实际上目前真正的实时光线追踪只能达到每帧每个像素采样一根光线。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142644271.png" alt="image-20220609142644271"></p><p>可想而知这样得出的结果是噪声非常严重的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142722281.png" alt="image-20220609142722281"></p><p>因此实时光线追踪的重点实际上不是光线追踪，而是如何对 1 SPP 的 RTRT 结果进行降噪，使其达到和离线光线追踪一样的效果。下图展示了现在的实时光线追踪降噪技术所能达到的效果，非常不可思议：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142901751.png" alt="image-20220609142901751"></p><p>简单来说，实时光线追踪会首先生成一张 1 SPP 的 noisy 结果，然后对单帧进行图像空间降噪（Spatial Denoising），之后再联合前一帧图像（任何时候都假设前一帧已经没有噪声）进行时域降噪（Temporal Denoising），最终得到一帧没有噪声的结果。</p><h3 id="2-Spatial-Denoising"><a href="#2-Spatial-Denoising" class="headerlink" title="2 Spatial Denoising"></a>2 Spatial Denoising</h3><h4 id="2-1-联合双边滤波"><a href="#2-1-联合双边滤波" class="headerlink" title="2.1 联合双边滤波"></a>2.1 联合双边滤波</h4><p>单帧图像空间降噪简单的自然是使用低通滤波，比如高斯模糊，这样可以去掉高频的噪声，但同时也会丢掉图像中高频的信息，也就是一些细节，因此为了保留图像细节一般使用双边滤波（Bilateral Filtering）进行降噪。</p><p>双边滤波只是对高斯滤波的改进，高斯滤波只考虑了像素之间的距离作为权值的衰减因素，而为了保留高频信息，双边滤波还考虑了颜色，当两个像素的颜色差异过大时，权值也进一步变小，这样就可以保留原图中的边缘等高频信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609143945517.png" alt="image-20220609143945517"></p><p>上式中后一项是对颜色的距离进行了一个计算，这样相当于两个高斯分布的乘积作为一个像素周围其他像素的权值。</p><p>更进一步，既然可以考虑颜色，那么自然也可以考虑更多的因素，<strong>联合双边滤波（Joint Bilateral Filtering）</strong>就是将许多不同因素作为影响权值衰减的因素，除了像素之间的距离、颜色之外，还可以利用 G-Buffer 中存储的每个像素的深度、法线、反射率等等，因此联合双边滤波非常适合用来做 RTRT 的图像降噪，因为 G-Buffer 中的信息在渲染时就可以顺便得到，几乎不需要任何额外开销。</p><p>需要说明的是，上面是以高斯滤波为例的，实际上双边滤波或者联合双边滤波中的衰减系数不一定要是高斯分布的，可以是指数分布、余弦分布等等，只要能够描述衰减关系就可以。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144749719.png" alt="image-20220609144749719"></p><p>下面以一个例子来说明联合双边滤波的作用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144824808.png" alt="image-20220609144824808"></p><p>这是一张噪声很大的渲染结果，我们使用联合双边滤波考虑深度、法线、颜色的影响，于是在对点 B 进行滤波时，可能会将点 A 和点 C 的贡献加入到点 B，但是因为点 A 和点 B 的深度差异比较大，因此点 A 的贡献就会变小，而点 C 和点 B 的法线差异比较大，因此点 C 的贡献也会变小。而点 D 和点 E 的深度和法线相差不大，但颜色相差很大，因此权值也会变小，这样就可以得到比较好的滤波效果。</p><h4 id="2-2-大范围滤波优化"><a href="#2-2-大范围滤波优化" class="headerlink" title="2.2 大范围滤波优化"></a>2.2 大范围滤波优化</h4><p>这里还有一个问题需要讨论，因为使用联合双边滤波，我们的滤波核范围通常很大，不是通常的 5 * 5 或者 7 * 7，如果滤波核是 128 * 128，那么对每个像素进行滤波都要访问它周围一万多个像素，会非常耗时，因此需要对大滤波核的滤波进行优化，通常使用以下两种方法：</p><ul><li>Separate Passes：也就是将 128 * 128 的一次滤波分为 1 * 128 和 128 * 1 两次滤波，这样就可以大幅降低复杂度，只需要访问 256 次就可以完成之前访问一万多次的工作：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609145638690.png" alt="image-20220609145638690"></p><p>这么做可行的原因在于二维高斯分布本身就是两个一维高斯分布的乘积，因此也自然可以将一次二维滤波拆成两次一维滤波。但是对于双边滤波和联合双边滤波，不再是简单的二维高斯分布，因此不满足这样的特性，理论上不能使用这个方法，不过工业界依然使用这样的方法，在滤波核不是特别大的时候不会看出什么问题。</p><ul><li>Progressively Growing Sizes：这种方法将一个大的滤波拆分成多次小的滤波，但是每次小的滤波所取得周围像素的间隔会逐渐增大，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150034090.png" alt="image-20220609150034090"></p><p>将一个 64 * 64 的滤波拆分成了 5 次 5 * 5 的滤波，第一次在像素周围 5 * 5 的区域进行，第二次取的像素之间都会间隔 2 个像素，第三次间隔 4 个像素，直到第 5 次，间隔 16 个像素，整个区域刚好就是 64 * 64，这样将 64 * 64 变成了 5 * 5 * 5，同样大幅降低了复杂度。</p><h4 id="2-3-异常像素移除"><a href="#2-3-异常像素移除" class="headerlink" title="2.3 异常像素移除"></a>2.3 异常像素移除</h4><p>异常像素移除（Outlier Removal）是在进行滤波之前做的一项工作，所谓异常像素（outlier）是指在噪声图像中会有一些非常亮的像素，如果不去除，那在滤波的时候这些非常亮的像素就会扩散到周围一定的区域造成异常：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150605655.png" alt="image-20220609150605655"></p><p>去除他们的方法非常简单，对每一个像素，取它周围一定区域，通常是 7 * 7，然后求出这个区域内颜色的均值和方差，根据均值和方差可以确定一个范围：<br>$$<br>[\mu-k\sigma,\mu+k\sigma]<br>$$<br>将不在这个范围内的像素颜色截断在这个范围内即可。</p><h3 id="3-Temporal-Denoising"><a href="#3-Temporal-Denoising" class="headerlink" title="3 Temporal Denoising"></a>3 Temporal Denoising</h3><h4 id="3-1-Motion-Vector"><a href="#3-1-Motion-Vector" class="headerlink" title="3.1 Motion Vector"></a>3.1 Motion Vector</h4><p>时域滤波是实时光线追踪能够实现的重要原因之一，基本思想就是假设前一帧总是没有噪声的，于是可以将这一帧的像素所显示的位置对应到前一帧的那个像素找到，将它的颜色和这一帧像素的颜色线性融合起来，实现非常好的降噪效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151126653.png" alt="image-20220609151126653"></p><p>对于第 i 帧的一个像素，我们可以从 G-Buffer 中得到该像素对应的世界空间位置，如果没有 G-Buffer，还可以通过屏幕坐标逆变换得到世界空间坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151336724.png" alt="image-20220609151336724"></p><p>然后我们在渲染的过程中一定知道这两帧之间物体是怎样移动的，因为我们掌控整个渲染过程，也就知道整个场景的变化过程，于是将当前帧的位置进行场景变换的逆变换，得到前一帧中该点的位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151431056.png" alt="image-20220609151431056"></p><p>再利用前一帧的各种矩阵将该点投影到屏幕上，就得到了前一帧中对应的像素坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151532403.png" alt="image-20220609151532403"></p><p>将该像素的颜色和当前帧的颜色进行融合：<br>$$<br>color_i &#x3D; \alpha color_i + (1-\alpha)color_{i-1}<br>$$<br>因为前一帧是没有噪声的图片，所以会让前一帧的颜色的权值更大，一般来说 $\alpha$ 取 0.1 到 0.2，也就是说当前帧的颜色有 80% 到 90% 取决于前一帧。</p><p>于是整个实时光线追踪去噪的过程可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151859574.png" alt="image-20220609151859574"></p><p>其中带有 - 的表示滤波后的图片，带有 ~ 的表示没有滤波的图片，什么都没有的表示没有噪声的图片。上面的公式表示先对当前帧进行单帧的 Spatial Denoising，再联合前一帧进行 Temporal Denoising。</p><p>下图是 1 SPP 的 RTRT 结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152103914.png" alt="image-20220609152103914"></p><p>使用了上述去噪方法后得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152123879.png" alt="image-20220609152123879"></p><p>这里的图片相比于有噪声的结果看起来变亮了很多，但实际上并没有，只是因为 RTRT 得出的有噪声的结果中像素的颜色很大，经过色调映射显示出来就会显得很暗，去噪的过程一定是能量守恒的。</p><p>下面是离线光线追踪的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152151531.png" alt="image-20220609152151531"></p><p>可以看到除了一些物体接触的地方的阴影没有渲染出来之外，实时光线追踪的结果和离线结果非常接近。</p><h4 id="3-2-Temporal-的问题"><a href="#3-2-Temporal-的问题" class="headerlink" title="3.2 Temporal 的问题"></a>3.2 Temporal 的问题</h4><p>时域去噪方法效果很好，但存在很多问题：</p><ul><li>切换场景的时候，时域去噪会失效，因为前后两帧几乎没有任何对应关系：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152409311.png" alt="image-20220609152409311"></p><ul><li>当我们在一个场景中的倒退的时候也会有问题，因为倒退的时候会有更多场景中的景象进入视野，于是就会出现当前帧的某个地方在上一帧中还没出现：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152546782.png" alt="image-20220609152546782"></p><ul><li>还有当物体移动的时候，会对其他物体造成遮挡，前后两帧中遮挡关系不一样，导致同一个位置会对应到不同的物体上，造成拖影现象：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152716311.png" alt="image-20220609152716311"></p><ul><li>以及由于光源移动造成的阴影拖影现象，虽然物体没有动，但是因为光照关系变了导致这一点的着色结果变了，从而使得后一帧融合了前一帧的颜色会显示出前一帧的拖影：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153019170.png" alt="image-20220609153019170"></p><h4 id="3-3-Clamping"><a href="#3-3-Clamping" class="headerlink" title="3.3 Clamping"></a>3.3 Clamping</h4><p>解决上述问题的一个最简单的方法是将前一帧对应的像素的颜色截断到当前帧像素周边一定范围内颜色的均值附近，利用上面的异常像素移除的方法就可以实现，然后再融合到当前像素上，这样可以一定程度解决前后帧颜色不对应的情况，但对于切换场景等情况也无能为力。此外由于将没有噪声的颜色截断到了有噪声的颜色范围内，一定会引入新的噪声。</p><h3 id="4-SVGF"><a href="#4-SVGF" class="headerlink" title="4 SVGF"></a>4 SVGF</h3><p>Spatiotemporal Variance-Guided Filtering 是一个实时光线追踪的具体解决方案，流程和我们上面说到的一致，只是在滤波核的设计上加入了一些更周全的考虑，因此可以得到非常好的效果。</p><p>SVGF 同样考虑了三个因素来影响滤波权值衰减：深度、法线和颜色。</p><p>对于深度，如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153703827.png" alt="image-20220609153703827"></p><p>由于箱子是侧对我们的，点 A 和点 B 的深度会有差异而使得滤波时的权值变小，但实际上他们属于同一面，不应该因为深度差异是他们的融合权值变小，因此引入了深度的梯度来修正这个影响，其中 $\epsilon$ 是为了防止两个点距离过近导致分母为 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153851851.png" alt="image-20220609153851851"></p><p>对于法线，使用了两点法线的点乘来作为衰减因素，同时加了一个指数来控制衰减的速度，这个指数和布林冯模型中高光的指数作用完全一致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154028387.png" alt="image-20220609154028387"></p><p>对于颜色，SVGF 使用的是光照度，也就是像素的灰度值，首先计算了像素周围 7 * 7 范围内的灰度方差，然后还将这个方差进行了时域上的平均，最后在当前帧又取了周围 3 * 3 区域的方差来进行滤波衰减：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154224920.png" alt="image-20220609154224920"></p><p>SVGF 速度快效果好，但是拖影问题依然存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时PBR材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/</id>
    <published>2022-06-08T10:06:47.000Z</published>
    <updated>2022-06-13T03:32:47.691Z</updated>
    
    <content type="html"><![CDATA[<p>在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈微表面"><a href="#1-再谈微表面" class="headerlink" title="1 再谈微表面"></a>1 再谈微表面</h3><p>通过之前的学习可以发现，实时渲染的各种方法实际上都是在离线渲染的基础上，做各种假设和近似来快速得到一个近似地效果，材质也不例外，基于物理的材质最常用的就是微表面模型，实时渲染中同样使用微表面模型，因此我们首先来回顾微表面模型的内容。</p><p>微表面 BRDF 由菲涅尔项 F，几何项 G 和法线分布函数 D 组成，描述了从某个入射方向来的光会向某个出射方向反射出多少能量：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160027871.png" alt="image-20220608160027871"></p><h4 id="1-1-菲涅尔项"><a href="#1-1-菲涅尔项" class="headerlink" title="1.1 菲涅尔项"></a>1.1 菲涅尔项</h4><p>菲涅尔项描述了随着入射方向和法线夹角增大，反射会变得越来越强的现象：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160157916.png" alt="image-20220608160157916"></p><p>对于非导体，入射方向与法线夹角和反射率的关系为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160244963.png" alt="image-20220608160244963"></p><p>即当我们沿着法线方向观察的时候几乎不会看到反射，而当我们垂直于法线方向观察的时候会看到物体几乎全部被反射。</p><p>对于导体（金属），菲涅尔曲线为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160343753.png" alt="image-20220608160343753"></p><p>即导体本身就会发生强烈的反射，随着视角变化，观察到的反射不会有太大的变化，因此可以说金属本身就会有比较固定的颜色（反射率），比如金、银、铜都有自己的颜色。</p><p>菲涅尔项表达式非常复杂，与介质和材质的折射率有关，一般在渲染中使用 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160608070.png" alt="image-20220608160608070"></p><p>总的来说，菲涅尔项描述了对于给定的入射方向和出射方向（半程向量），会有多少光从入射方向反射到出射方向上，一般来说渲染的时候出射方向固定，就是观察方向，那么不同入射方向的光反射到观察方向上的比例就不同，这是菲涅尔项的意义。</p><h4 id="1-2-法线分布函数"><a href="#1-2-法线分布函数" class="headerlink" title="1.2 法线分布函数"></a>1.2 法线分布函数</h4><p>法线分布函数描述了物体表面有多少微表面的法线和给定的半程向量方向一致，那么这些微表面才会被看到（只考虑镜面反射）。这是一个宏观的理解，实际上 NDF 描述的就是微表面的法线的概率分布：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161221287.png" alt="image-20220608161221287"></p><p>有不同的模型来描述法线分布，比如之前提到过的 Beckmann 法线分布函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161340128.png" alt="image-20220608161340128"></p><p>该函数由表面粗糙程度 $\alpha$ 和微表面法线与宏观法线（一般是 [0, 0, 1]）的夹角 $\theta_h$ 来定义，从公式可以看出，Beckmann 法线分布实际上和高斯分布非常像，其中表面粗糙程度 $\alpha$ 就类似于正态分布的标准差，粗糙程度越大，法线分布就越分散，而这个正态分布是对于 $tan\theta_h$ 的正态分布， $tan\theta_h$ 的几何意义如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161702625.png" alt="image-20220608161702625"></p><p>如果直接定义为夹角 $\theta_h$ 的正态分布，那么法线可能取到下半球，夹角就大于 90 度，而对于法线来说只有上半球有意义，因此定义为 $tan\theta_h$ 的正态分布的好处在于可以把上半球的所有法线方向对应到一个平面上的区间，这个区间是无穷大的，刚好是正态分布的积分区间，这样定义自然当法线在下半球的时候没有意义，是一个很巧妙的处理。</p><p>另一个更好的法线分布函数是 GGX 模型，也叫做 Trowbridge-Reitz（TR）模型，相较于 Beckmann 模型，GGX 是长尾（long tail）分布的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162529565.png" alt="image-20220608162529565"></p><p>也就是过度更加平滑，在值较小的部分衰减速度也更小，这样的好处是高光区域和非高光区域的过渡会更加平滑，呈现出一种 Glossy 的效果，更加真实：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162719493.png" alt="image-20220608162719493"></p><p>在 TR 模型的基础上还有一个更加通用的 GTR 法线分布，引入了一个可调的参数来控制长尾分布的程度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162902522.png" alt="image-20220608162902522"></p><p>总之，法线分布函数描述的是微表面的法线方向分布，对于给定的入射和出射方向，可以得到半程向量，法线分布函数可以给出这个材质的表面上有多少微表面的法线是在这个半程向量方向上的，那么这些微表面才可以被看到。更准确的说，NDF 描述的是法线方向的概率分布，渲染时，对于每一个着色点都有不同的半程向量，这个半程向量对应的可以被看到的概率可以通过 NDF 得出，可以被看到也就是表面法线和半程向量方向一致，因此 NDF 给出的概率实际上是当前着色点的法线刚好和当前半程向量重合的概率，而一个点的着色结果是许多不同的半程向量的结果的加权平均，权值就是这个概率，这样就能得到这个着色点正确期望的着色结果。</p><h4 id="1-3-几何项"><a href="#1-3-几何项" class="headerlink" title="1.3 几何项"></a>1.3 几何项</h4><p>几何项描述的是微表面之间的自遮挡现象，自遮挡现象有两种情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163456607.png" alt="image-20220608163456607"></p><p>一种是入射光被其他微表面遮挡入射不进来，一种是反射光被其他微表面遮挡反射不出去，前者称为 shadowing，后者称为 masking，因此几何项也被称为 Shadowing-Masking Term。</p><p>从上面的定义可以看出，当我们垂直于表面观察时，几乎不会发生自遮挡，当我们观察方向越接近法线的垂直方向，自遮挡就会越严重，因此对应于上面的法线分布得出的几何项分布大概长这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163757728.png" alt="image-20220608163757728"></p><p>几何项的意义在于，当我们垂直于表面观察的时候，几何项就是 1，对最终结果不会有任何影响，但是当我们接近垂直于法线的方向观察时，比如一个球体的边缘：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163914474.png" alt="image-20220608163914474"></p><p>如果不考虑几何项，那么按照微表面 BRDF 的定义：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163942337.png" alt="image-20220608163942337"></p><p>其他两项可以计算出正常结果，但是分母中有观察方向和法线的点乘，由于我们是接近垂直于法线的方向观察的，那么这个点乘结果就会接近于 0，于是整个BRDF 结果就会非常大，如果没有几何项来修正这个结果，那么最终的渲染图像上球体边缘就会是一圈白色。根据上面的几何项曲线可以看出，几何项在夹角接近 90 度的时候迅速变为 0，从而修正了这个非常大的结果。</p><h3 id="2-Kulla-Conty-Approximation"><a href="#2-Kulla-Conty-Approximation" class="headerlink" title="2 Kulla-Conty Approximation"></a>2 Kulla-Conty Approximation</h3><p>上面回顾了微表面模型，并进一步深入理解了各个项的作用，通过上面的分析我们可以很容易得出一个结论：微表面模型只考虑了光线在微表面之间的一次反射。被挡住的光线就认为看不到，这样做的结果就是微表面模型是能量不守恒的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608164659865.png" alt="image-20220608164659865"></p><p>随着粗糙程度增大，最终的渲染结果会越来越暗，因为粗糙程度越大意味着法线分布越分散，从而微表面之间的遮挡也会越严重，在微表面模型中被遮挡掉的能量就被丢掉不考虑了，所以自然会越来越暗。</p><p>实际上被遮挡的光线还会在微表面之间弹射从而被看到，因此为了解决这个问题，提出了 Kulla-Conty 估计，用来近似估计光线在微表面之间的多次弹射。</p><p>Kulla-Conty 估计基于一个关键思想：微表面 BRDF 只考虑了没有被遮挡的能量，那么如果能再设计一个 BRDF 来专门描述被遮挡的能量就可以修正微表面的结果了。</p><p>于是首先要知道没有被遮挡的能量是多少，我们假设入射光强度恒为 1，然后对微表面 BRDF 的渲染方程在整个半球面上积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165256048.png" alt="image-20220608165256048"></p><p>注意上面的式子中用了一个简单的积分换元，把 $d\theta$ 换成了 $dsin\theta$，这样一来原本渲染方程中的 cos 项也就没有了，光照项为常数 1，因此上面的积分结果就代表了微表面模型中在出射方向 $\mu_o$ 上全部被看到的能量总和，因为光照项为 1，所以该结果是一个系数，表示出射方向 $\mu_o$ 上被看到的能量占全部能量的比例。</p><p>于是因为遮挡而没被看到的能量总和自然就是 $1-E(\mu_o)$，因此，我们要设计一个 BRDF 来专门描述被遮挡的能量，那么这个 BRDF 在半球面上的积分结果就必须是 $1-E(\mu_o)$。</p><p>考虑到 BRDF 具有双向可逆性，因此 Kulla-Conty 估计设计了这样一个 BRDF：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165644101.png" alt="image-20220608165644101"></p><p>这个 BRDF 的形式并不是唯一的，只要能保证函数在半球的积分结果是 $1-E(\mu_o)$ 就可以，只是 Kulla-Conty 这样设计既把积分结果本身放到了函数中，还考虑了双向可逆的性质，非常巧妙。</p><p>于是通过积分结果为 $1-E(\mu_o)$ 可以求出常数 c：<br>$$<br>c &#x3D; \frac{1}{\pi(1-E_{avg})}<br>$$<br>其中：<br>$$<br>E_{avg} &#x3D; \frac{\int_0^1E(\mu)\mu d\mu}{\int_0^1\mu d\mu} &#x3D; 2\int_0^1E(\mu)\mu d\mu<br>$$<br>相当于对上面的 $E(\mu_o)$ 做了一个加权平均，权值就是各个方向的夹角正弦 $\mu$，于是整个 Kulla-Conty 估计就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170245422.png" alt="image-20220608170245422"></p><p>容易验证该函数在半球面上积分结果为 $1-E(\mu_o)$：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170313862.png" alt="image-20220608170313862"></p><p>因此这个函数可以作为描述被遮挡的能量的 BRDF，现在的问题是 $E_{avg}$ 是对一个积分 $E(\mu)$ 再进行积分，实时计算起来比较复杂，所以需要进行预计算。</p><p>对于 $E(\mu)$ 这个积分，是对全部入射方向 $\mu_i$ 的积分，因此积分结果只与观察方向和法线的夹角正弦 $\mu_o$ 和粗糙程度 $\alpha$ 有关，于是预计算的积分结果可以用一张二维纹理来存储：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608171651408.png" alt="image-20220608171651408"></p><p>而对于 $E_{avg}$ 这个积分，是对 $\mu_o$ 的积分，所以积分结果只与粗糙程度 $\alpha$ 有关，只需要一个一维纹理就可以存储。</p><p>将 Kulla-Conty 的结果加到微表面 BRDF 的结果上就可以近似模拟光线在微表面之间多次弹射的结果，达到能量守恒：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172124188.png" alt="image-20220608172124188"></p><p>接下来还有最后一个问题，上面的所有推导都是假设物体表面没有颜色，也就是反射率恒为 1，如果物体表面有颜色，那么能量在每次弹射后都会损失，如何计算这种损失来得到正确的结果呢？</p><p>Kulla-Conty 又计算了菲涅尔项的加权平均：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172427624.png" alt="image-20220608172427624"></p><p>这表示每次弹射，表面上有多少能量被反射。这类似于上面的 $E_{avg}$， $E_{avg}$ 表示表面上有多少能量没被遮挡能够被看到，于是我们可以直接看到的能量就可以表示为：<br>$$<br>F_{avg}E_{avg}<br>$$<br>没被看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})<br>$$<br>这部分能量会在微表面之间继续弹射，于是经过一次弹射后被我们看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})·F_{avg}E_{avg}<br>$$<br>以此类推，可以写出经过无数次弹射后的能量，将这些能量加起来，就可以得到当物体有颜色的时候，光线在微表面之间多次弹射后反射出的能量，这是一个级数求和问题，最终的结果是：<br>$$<br>\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}<br>$$<br>将这个系数乘到 Kulla-Conty 的 BRDF 上就可以得到有颜色的情况下被遮挡的能量的 BRDF 了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173223545.png" alt="image-20220608173223545"></p><h3 id="3-Linearly-Transformed-Cosines（LTC）"><a href="#3-Linearly-Transformed-Cosines（LTC）" class="headerlink" title="3 Linearly Transformed Cosines（LTC）"></a>3 Linearly Transformed Cosines（LTC）</h3><p>有了微表面 BRDF，另一个需要解决的问题是如何使用微表面模型进行渲染。线性变换余弦（LTC）方法是用来解决多边形面光源下，使用微表面 BRDF，主要是 GGX 法线模型的渲染而提出的方法（不考虑阴影）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173712743.png" alt="image-20220608173712743"></p><p>当然 LTC 不仅适用于上述情况，对于类似 GGX 法线分布的其他微表面模型也都有很好的效果。</p><p>在离线渲染中处理这样的渲染自然是对面光源进行采样计算，但实时渲染需要快速得到渲染结果，而不同的 BRDF 我们不知道它的分布是什么样的，所以也不容易快速求出这个 BRDF 积分的渲染方程的解析解，因此 LTC 将 BRDF 变换成一个 cos 函数，然后对所有的方向、以及面光源（积分区域）都做同样的变换：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174038845.png" alt="image-20220608174038845"></p><p>这样就将原积分转化为了一个对余弦函数的积分，保证可以快速求出解析解。具体来说，就是将原本的函数 $F(w_i)$ 变换为 $cos(w_i)$，为了便于理解，我们假设 BRDF 是各向同性的，于是 $F(w_i)$ 实际上和方位角无关，在出射方向固定的情况下就是一个只与俯仰角有关的一维函数，所以可以变换到一维的 cos 函数上，事实上 LTC 也可以处理各向异性的情况，这里就不展开讨论了。</p><p>然后将积分变量 $dw_i$ 同样变换为 $dw’_{i}$，实际上就是对原积分进行了换元：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174727016.png" alt="image-20220608174727016"></p><p>这样就可以快速求出解析解了。LTC 方法虽然思路很简单，但是效果却非常优秀，因此目前被广泛使用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174837806.png" alt="image-20220608174837806"></p><h3 id="4-Disney’s-Principled-BRDF"><a href="#4-Disney’s-Principled-BRDF" class="headerlink" title="4 Disney’s Principled BRDF"></a>4 Disney’s Principled BRDF</h3><p>Disney’s Principled BRDF 是目前工业界非常知名的，非常强大的开源 BRDF。微表面 BRDF 的问题之一在于不能够表达复合材质，现实世界中许多材质不是单一的，是多种材质的组合，比如蒙上一层塑料布的木头桌子，那么它的表面就有多层材质，光照表现自然和普通桌子不同，而 Disney’s Principled BRDF 具有强大的表达能力，可以表达各种复合材质。</p><p>并且 Disney’s Principled BRDF 摒弃了传统基于物理的材质的各种物理参数，只使用一些非常符合人直觉的参数就可以进行调节，对于艺术家非常友好，这也是迪士尼设计这个 BRDF 的原则之一，这些原则有：</p><ul><li>使用符合人直觉的参数而不是各种难懂的物理量</li><li>越少的参数越好</li><li>所有参数都是从 0 到 1 调节的</li><li>在一些合理的情况下允许参数不在 0 到 1 范围内</li><li>所有参数的任意组合都必须得出合理的结果，而不是某些非常奇怪的结果</li></ul><p>能够满足上述原则的 BRDF 可以说是完美的，虽然严格来说迪士尼的 BRDF 不是基于物理的，而是进行了各种非常复杂的拟合，但是也常被归为基于物理的 BRDF。</p><p>下图是一些可以调节的参数和得出的材质效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608175902209.png" alt="image-20220608175902209"></p><p>从上到下依次是：</p><ul><li>次表面散射 subsurface：值越大次表面散射越严重，物体看起来更像一个平面</li><li>金属度 metallic：值越大物体越像金属</li><li>高光度 specular：值越大物体高光反射越强</li><li>高光颜色 specularTint：可以调节高光反射的颜色</li><li>粗糙程度 roughness：值越大物体表面越粗糙</li><li>各向异性程度 anisotropic：值越大物体表面越呈现各向异性</li><li>绒毛 sheen：绒毛相当于物体表面每个点都有一根朝向法线方向的绒毛，表现出来就是物体边缘会有模糊感，值越大绒毛越明显</li><li>绒毛颜色 sheenTint：控制绒毛颜色</li><li>表面通透 clearcoat：类似于给物体表面蒙上一层透明的漆，值越大这个效果越明显</li><li>表面通透颜色 clearcoatGloss：表面通透高光的锐利度，值越大高光越锐利</li></ul><p>上面的所有参数可以随意组合，表达各种复合材质，所以迪士尼 BRDF 的表达能力非常强。</p><h3 id="5-Specular-Glossiness-模型"><a href="#5-Specular-Glossiness-模型" class="headerlink" title="5 Specular Glossiness 模型"></a>5 Specular Glossiness 模型</h3><p>Specular Glossiness（SG）模型是在 Disney’s Principled BRDF 的启发下提出的便于实时渲染的 PBR 材质模型，SG 将所有描述材质需要用到的值都存在各种纹理中，渲染时只需要通过简单的纹理采样就可以计算出基于物理的光照结果，不需要调整任何参数，非常方便。</p><p>SG 模型使用三张纹理来存储信息，分别是：Diffuse、Specular 和 Glossiness。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613104930087.png" alt="image-20220613104930087"></p><p>Diffuse 存储物体的基础颜色，使用 RGB 三个通道；Specular 存储菲涅尔项的基础反射率，也就是菲涅尔近似公式中的 F0，同样对应 RGB 三个通道；Glossiness 是一个标量，用于控制表面光滑程度。</p><p>通过这三张纹理，就可以得到物体表面任何一个点对应的 F、D 和 G 项，从而根据微表面模型计算光照结果，下面是使用 SG 模型计算着色的代码，可以非常直观的感受到 SG 模型有多方便：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613105637113.png" alt="image-20220613105637113"></p><p>首先根据漫反射颜色计算出了漫反射项，然后根据微表面模型计算高光反射项，其中粗糙程度根据 Glossiness 采样结果得到，基础反射率 F0 根据 Specular 采样结果得到，再结合各种简单的点乘就可以得到 D、F 和 G 项，最后根据公式计算微表面 specular 结果，加上漫反射结果就是整个 BRDF 结果。有了 BRDF 就可以根据渲染方程得到着色结果了。</p><h3 id="6-Metallic-Roughness-模型"><a href="#6-Metallic-Roughness-模型" class="headerlink" title="6 Metallic Roughness 模型"></a>6 Metallic Roughness 模型</h3><p>Metallic Roughness（MR）是对 SG 模型的又一层封装，SG 模型可以自由地调节漫反射颜色和基础反射率，但有时这对于艺术家来说还是不够直观，因此 MR 使用了另外三个贴图来描述材质：Base Color、Roughness 和 Metallic。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110249250.png" alt="image-20220613110249250"></p><p>其中 Base Color 是物体的基础颜色，RGB 三通道；Roughness 和 Metallic 都是标量，分别代表表面粗糙程度和金属度。使用的时候游戏引擎内部会将这些值转化为 SG 模型中的值，下面是转化代码：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110606512.png" alt="image-20220613110606512"></p><p>可以看到金属度 Metallic 是一个插值系数，用来从 base color 中取出一定的颜色到介质基本的颜色上，从而构成 SG 模型中的 F0，回顾前文中菲涅尔项的曲线图，金属的基础反射率是非常高的，所以金属度高的时候 base color 中很大一部分颜色就被取出到 F0 中，使得基础反射率变高，而 base color  剩下的颜色就作为 SG 中的 diffuse，于是金属度高就会使 diffuse 很小，也就是金属几乎不会发生漫反射，这和菲涅尔项描述的是完全一致的，所以 MR 模型中的基础颜色就是 diffuse 和 specular 的结合，金属度 Metallic 可以将他们拆分开来，但 base color 的概念对于艺术家来说要比 diffuse 和 specular 更好理解。粗糙程度 Roughness 和 SG 中的光滑程度 Glossiness 相反，二者之间可以互相转化，本质上是一样的。</p><p>MR 和 SG 相比，更便于人们理解，但没有 SG 灵活，因为 MR 不能够自己调节 F0，而是全部包含在了 base color 中，但也因此避免了艺术家如果使用 SG，但给出了错误的 F0 而导致的菲涅尔项错误的情况，各有利弊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时全局光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</id>
    <published>2022-06-05T05:44:59.000Z</published>
    <updated>2022-06-13T03:32:30.197Z</updated>
    
    <content type="html"><![CDATA[<p>全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。</p><p><em><span id="more"></span></em></p><h2 id="1-三维空间全局光照"><a href="#1-三维空间全局光照" class="headerlink" title="1 三维空间全局光照"></a>1 三维空间全局光照</h2><h3 id="1-1-Reﬂective-Shadow-Maps（RSM）"><a href="#1-1-Reﬂective-Shadow-Maps（RSM）" class="headerlink" title="1.1 Reﬂective Shadow Maps（RSM）"></a>1.1 Reﬂective Shadow Maps（RSM）</h3><p>RSM 算法基于一个很简单的但却是实时全局光照中的核心观察：<strong>所有被光源直接照亮的物体表面都可以作为次级光源照亮其他物体。</strong>于是当我们在渲染时得到这个想法的时候，就可以用各种方法实现全局光照了，问题只是在于如何处理这些次级光源。</p><p>那么怎么得到场景中被光源直接照亮的表面信息呢？Shadow Map 所做的正是这个工作，Shadow Map 的每一个 texel 都可以代表场景中的一块区域，这一块区域就一定是被光源直接照亮的区域，就可以作为次级光源照亮其他物体，因此 Shadow Map 实际上可以看作存储了场景中所有的次级光源，因此我们在渲染每个着色点的时候，考虑这些次级光源的贡献即可。</p><p>现在的问题是，每一个次级光源对着色点的贡献相当于从着色点 p 看向这个光源表面所得到的光照结果（其实和光线追踪原理一样），那么如果这个表面是 Glossy 的，情况会非常复杂，因此 RSM 假设所有次级光源表面都是 diffuse 的，这样次级光源对着色点 p 的光照就与他们的相对方向无关了，这样一来次级光源就被抽象为一个向各个方向均匀发光的面光源了。</p><p>那么对于面光源，我们在路径追踪中有推导过如何将渲染方程中对方向立体角的积分转化为对面光源的积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103514616.png" alt="image-20220603103514616"></p><p>于是渲染方程可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p><p>其中 $patch$ 就是代表每一个小的次级光源。现在来看渲染方程中的每一项：</p><p>首先是 BRDF 项，没有什么问题。</p><p>然后是 visibility 项，visibility 要考虑次级光源和着色点的遮挡关系，这是很难得到的，想要得到就要对每一个次级光源生成一个 Shadow Map，而假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，每个次级光源都生成一次 Shadow Map，这是不可能的，因此 RSM 选择不计算 visibility 项，毕竟间接光照是低频的，而且这么多次级光源分别的贡献实际上都很小，所以不计算 visibility 影响也不大。</p><p>最麻烦的是次级光源到着色点的光照 $L_i(q\rightarrow p)$，这要根据该表面的直接光照得到，因为假设了表面是 diffuse 的，所以 BRDF 是一个常数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104607816.png" alt="image-20220603104607816"></p><p>需要注意这里的 BRDF 是指计算次级光源表面被实际光源直接照射时的渲染方程中的 BRDF，而上面的渲染方程是计算着色点被次级光源照射时的方程。于是 $L_i(q\rightarrow p)$ 就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104650506.png" alt="image-20220603104650506"></p><p>因为 BRDF 是出射的 Radiance 和入射的 Irradiance 的比值，因此乘上该表面入射的 Irradiance，得到的就是出射的 Radiance，也就是我们想要的次级光源发出的光线。而该表面入射的 Irradiance 可以根据定义表示为直接光源的光通量，也就是功率除以单位面积（因为 Irradiance 表示单位面积上的光的能量），所以就有上面的公式了。上面公式的好处在于带入渲染方程中，我们会发现单位面积 dA 被约掉了，说明之后的计算与次级光源的面积无关。</p><p>接下来考虑的问题是，假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，如果每个次级光源都进行上面的计算，开销也是很大的，而实际上很多次级光源可能对着色点是没有贡献的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105635240.png" alt="image-20220603105635240"></p><p>着色点为 x，而 Shadow Map 中存储的桌子上的点就显然是对 x 没有贡献的，不需要进行计算，因此我们可以根据法线方向去掉一些不需要计算的次级光源；此外，距离着色点太远的次级光源也不需要计算，因此我们只需要计算着色点一定距离范围内的有贡献的次级光源就可以了，经过这些筛选最后剩下的次级光源数量是可以接受的，也是完全可以做到实时计算的。</p><p>综上，要计算渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p><p>我们需要知道的信息有：次级光源到着色点的距离，直接光源对次级光源的光通量以及次级光源表面的法线，因此 Reﬂective Shadow Maps 中存储的就是这些信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105452496.png" alt="image-20220603105452496"></p><p>RSM 只需要在 SM 的基础上额外存储一些信息就可以实现全局光照，是很容易实现的。但也存在很多缺点，比如因为是基于 Shadow Map，那么对于场景中的所有直接光源都要生成一张 RSM，复杂度会随着光源数量增加；而且整个算法做了很多舍弃和假设，比如舍弃了 visibility 项的计算，假设所有次级光源都是 diffuse 的，这会对最终效果产生一定影响。</p><h3 id="1-2-Light-Propagation-Volumes（LPV）"><a href="#1-2-Light-Propagation-Volumes（LPV）" class="headerlink" title="1.2 Light Propagation Volumes（LPV）"></a>1.2 Light Propagation Volumes（LPV）</h3><p>LPV 的核心思想是，我们要计算着色点的间接光照就需要知道着色点上从各个方向来的 Radiance 是多少，也就是 RSM 中计算的所有次级光源的 Radiance，那如果我们在渲染着色点的时候能直接查询到各个方向来的 Radiance，就不需要额外的计算了。</p><p>于是 LPV 将空间分为一个个网格，然后将所有次级光源表面发出的 Radiance 注入到表面所在的网格中，然后这些 Radiance 根据各自的方向向周围的网格传播，这样一来在渲染的时候只需要查询着色点所在的网格中的 Radiance 就可以快速计算渲染方程了。具体步骤如下：</p><ul><li>第一步：找到能被光源直接照亮的表面，这直接使用 RSM 即可</li><li>第二步：计算这些表面的 Radiance，并注入到所在的网格中，网格中将这些 Radiance 加起来，会得到一个二维函数，表示不同方向上的 Radiance，因为是只与方向有关的二维函数，那么自然可以近似表示为 SH，一般只需要使用前两阶 SH 表示即可，因为 LPV 同样假设次级光源是 diffuse 的，那么次级光源的光照就是低频的，所以不需要太高阶的 SH：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111036435.png" alt="image-20220603111036435"></p><ul><li>第三步：每个格子中的 Radiance 沿着格子进行传传播，每个格子的 Radiance 会传播到它相邻的六个格子中，传播过去的 Radiance 被加入到那个格子的 Radiance 中，如此迭代，一般 4 到 5 次迭代就可以让整个网格基本达到稳定，这时所有格子里的 Radiance 就可以代表这里的各个方向传播来的 Radiance 了，渲染时可以直接使用：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111410505.png" alt="image-20220603111410505"></p><ul><li>第四步：渲染时直接将着色点所在的网格中的 Radiance 作为着色点的 Radiance 进行渲染即可。</li></ul><p>通过上面的步骤可以看出 LPV 有一个很严重的问题，就是如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111539524.png" alt="image-20220603111539524"></p><p>点 p 是一个次级光源，正常来说它发出的 Radiance 不应该照亮墙的背面，但是由于它发出的 Radiance 会被认为是整个网格的 Radiance  ，于是这些 Radiance 就可以照亮墙的背面，也就会发生漏光现象：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111714792.png" alt="image-20220603111714792"></p><p>不过这不影响 LPV 是一个优秀的实时全局光照解决方案。</p><h3 id="1-3-Voxel-Global-Illumination（VXGI）"><a href="#1-3-Voxel-Global-Illumination（VXGI）" class="headerlink" title="1.3 Voxel Global Illumination（VXGI）"></a>1.3 Voxel Global Illumination（VXGI）</h3><p>VXGI 同样是基于体素（Voxel）的，不同于 LPV，VXGI 将场景体素化，并创建层次结构（LPV 没有层次结构）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111846023.png" alt="image-20220603111846023"></p><p>这样一来 RSM 中每个 texel 对应的一片区域就变成对应一些体素，这样就可以计算体素中物体表面的光照作为间接光照，因此 VXGI 可以计算次级光源的 Glossy 光照，不需要假设所有次级光源都是 Glossy 的，所以效果更好，但效率自然更低。VXGI 的实现非常复杂，这里不再赘述。</p><h2 id="2-屏幕空间全局光照"><a href="#2-屏幕空间全局光照" class="headerlink" title="2 屏幕空间全局光照"></a>2 屏幕空间全局光照</h2><h3 id="2-1-Screen-Space-Ambient-Occlusion（SSAO）"><a href="#2-1-Screen-Space-Ambient-Occlusion（SSAO）" class="headerlink" title="2.1 Screen Space Ambient Occlusion（SSAO）"></a>2.1 Screen Space Ambient Occlusion（SSAO）</h3><p>我们之前学习过，环境光遮蔽（AO）是一种对全局光照的近似方法，实现简单，但是可以大幅增强画面的层次感，所以被广泛使用。环境光遮蔽的想法非常简单，Blinn Phong 模型把所有间接光照抽象成了一个常数，叠加到所有着色点上进行一个统一的亮度增强来模拟全局光照，这样的问题在于所有着色点的亮度增强程度是一样的，所以无法增强明暗遮蔽关系，如果我们能对每一个着色点，根据它所处位置的遮蔽关系给这个统一的环境光常数乘上一个系数再累加到着色结果上，就可以体现出物体之间的遮蔽关系了。而这个系数正是渲染方程中的 visibility 项。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105404933.png" alt="image-20220605105404933"></p><p>上面的过程可以通过渲染方程来更深入的理解。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105617924.png" alt="image-20220605105617924"></p><p>我们使用之前常用的近似积分拆解公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105818137.png" alt="image-20220605105818137"></p><p>把 visibility 项拿出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p><p>这里我们把 $cos\theta_idw_i$ 看成了一个整体，当作公式中的 $dx$，这实际上是有意义的，我们知道 $dw_i$ 是微分立体角，是单位球面上的一小块面积，乘上了一个和法线的夹角余弦相当于把这一小块面积投影到了单位圆上，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110006953.png" alt="image-20220605110006953"></p><p>所以 $cos\theta_idw_i$ 这个整体也叫做微分投影立体角，是单位圆中的一小块面积，因此对 $cos\theta_idw_i$ 的积分实际上就是单位圆的面积 $\pi$，这也从另一个角度解释了半球面上对 $cos\theta$ 的积分为什么是  $\pi$。</p><p>现在回到渲染方程，把 visibility 项拿出来之后，渲染方程分为了两部分：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p><p>其中，蓝色框中实际上就是对着色点 p 周围<strong>遮挡关系结果的加权平均</strong>（加权和除以权值和就是加权平均），权值是 $cos\theta$，即离法线近的权值大，离法线远的权值小。而分母就是对投影立体角的积分，结果是 $\pi$，于是蓝框中的部分就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110447249.png" alt="image-20220605110447249"></p><p>一般就写成一个系数 $k_A$  来表示环境光遮蔽系数。</p><p>而黄色框中的部分是一个渲染方程，通过之前的算法我们知道，实时渲染中一般在计算全局光照的时候都会假设所有物体表面都是 diffuse 的，这样每一个次级光源就被抽象成了一个均匀发光的面光源，而在这里， SSAO 还假设所有物体的间接光照都一样，这和 Blinn Phong 模型的假设一致，于是间接光照 $L_i^{indir}$ 就是一个常数，diffuse 的 BRDF 也是常数，因此黄色框部分可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110615757.png" alt="image-20220605110615757"></p><p>自然就是一个常数，这就相当于 Blinn Phong 中的环境光常数，我们可以直接给定。于是整个渲染方程就是环境光常数乘上了每个片段的遮蔽系数，也就是我们一开始说的那个过程。因为上面的推导中使用了积分拆解近似式，而该公式近似的准确的条件是 $g(x)$ 要么连续，要么在积分区间上波动很小，而在这里 $g(x)$ 就是一个常数，自然满足这两个条件，因此使用这样的方法来近似是完全准确的。</p><p>屏幕空间环境光遮蔽自然是在屏幕空间完成上述过程，那么关键就在于如何只通过屏幕上的信息得到每一个像素对应的场景中的位置的遮蔽关系，从而得到 visibility 系数。</p><p>SSAO 的做法是在屏幕上每一个像素对应的场景中的点周围一个球体范围内随机采样一些点，根据这些点到相机的深度来判断这些点是不是能被看到，用这些结果来近似点 p 会被周围多少物体遮挡，从而得到一个 visibility 系数，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111352019.png" alt="image-20220605111352019"></p><p>这样做的问题在于我们实际去判断一个点的遮挡关系的时候只应该考虑该点法线方向半球上的遮挡关系，而这里用了整个球体内采样，是不准确的，于是一种解决方法是当采样点中被遮挡的点的数量大于一半时才开始考虑这一点的 AO，这样相当于粗略的截取了一个半球：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111534174.png" alt="image-20220605111534174"></p><p>当然现代渲染中，我们在屏幕空间也可以得到每一个像素对应的法线，因此可以直接准确的在法线方向半球内采样，并且知道了法线还可以考虑上面公式中的 $cos\theta$ 的加权平均，结果会更加准确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111716185.png" alt="image-20220605111716185"></p><p>这种方法叫做 HBAO，得到的结果也会比 SSAO 更加真实。</p><h3 id="2-2-Screen-Space-Directional-Occlusion（SSDO）"><a href="#2-2-Screen-Space-Directional-Occlusion（SSDO）" class="headerlink" title="2.2 Screen Space Directional Occlusion（SSDO）"></a>2.2 Screen Space Directional Occlusion（SSDO）</h3><p>SSDO 是 SSAO 的改进，SSAO 中假设一个点接收到的所有来自于其他物体反射光源的间接光照都是一样的（常数），但实际上我们利用 RSM 的思想，我们是知道哪些物体表面是被直接照亮的，因此我们不需要这样简单粗暴的假设，我们可以去准确的计算这些次级光源发出的间接光照是什么。</p><p>SSDO 像是在屏幕空间进行光线追踪一样，在每一个着色点向四面八方打出光光线，如果没有碰到周围的表面说明是直接光照，如果碰到了其他表面就计算该表面的间接光照作为该着色点间接光照的一部分贡献，这里计算其他表面的间接光照还是假设该表面是 diffuse 的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112300423.png" alt="image-20220605112300423"></p><p>于是就只有两种情况，可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112324715.png" alt="image-20220605112324715"></p><p>当然，SSDO 既然是屏幕空间的算法，自然不是从 RSM 中获哪那些表面是被直接照亮的，只需要通过深度图就可以近似得到，更准确地说我们认为相机看到的就是被直接照亮的，相机看到的每个点的直接光照结果就作为该点的间接光照去照亮其他点，在实际实现中也不是真的从着色点向周围发出许多光线，而是类似于 HBAO，在着色点法线所在半球随机取点，然后判断这些点的深度是否被遮挡，如果深度大于深度缓冲中的深度，就认为被遮挡，进而认为点 p 到这一点的光线打到了遮挡该点的那个表面，就将那个表面的间接光照作为点 p 的间接光照的贡献之一，整个过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112905103.png" alt="image-20220605112905103"></p><p>当然这样的做法毕竟不是真正的追踪光线，因此必然会出现一些问题，比如上图中最右边的情况，当点 A 和相机之间有一个遮挡物，点 A 会认为被遮挡，进而认为光线 PA 会打到 z1 所对应的那个点，这显然是不对的，同理点 B 被认为没有被遮挡，但实际上光线 PB 被旁边的表面遮挡到了，不过这些瑕疵在实时渲染中不会对结果有太大影响，因此可以忽略，只要整体结果是好的，那么这个是算法就是好的。</p><p>SSDO 存在的问题不止上面说到的，由于是屏幕空间的算法，所以我们所拥有的全部信息就是屏幕中的信息，相当于是整个场景能被看到的一层外壳，看不到的部分对我们来说是完全不知道的，因此就会丢失掉一些遮蔽信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113407580.png" alt="image-20220605113407580"></p><p>此外，由于是在法线所在半球内随机取点，这个半球一定对应一个范围，这个范围不能太大，如果无限大那就是光线追踪了，因此对于比较远的间接反射 SSDO 是做不出来的，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113455806.png" alt="image-20220605113455806"></p><p>上图中立方体反射出了右边的绿色墙面，这是光线追踪的结果，SSDO 是不能做到的，因为它追踪不了那么远，但是近处的颜色是可以得到的，比如左边的红色墙面，这也是 SSDO 最大的优势，就是可以实现 color blending 的效果，能够将物体之间的反射颜色融合起来，这也是因为它把我们看到的颜色作为次级光源来计算着色点的间接光照，而不是像 SSAO 一样全局的设定一个间接光照，下图中最右边可以看出蓝色物体表面映射出了一点黄色：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113729167.png" alt="image-20220605113729167"></p><h3 id="2-3-Screen-Space-Reﬂection（SSR）"><a href="#2-3-Screen-Space-Reﬂection（SSR）" class="headerlink" title="2.3 Screen Space Reﬂection（SSR）"></a>2.3 Screen Space Reﬂection（SSR）</h3><p>屏幕空间反射 SSR 真正做到了屏幕空间的光线追踪，所以 SSR 更准确地应该被叫做屏幕空间光线追踪（Screen Space Ray-tracing），因此效果很好，也是目前在实时渲染中最广泛使用的方法。</p><p>既然是光线追踪，那么一定分为两步，一是光线和场景求交点，在屏幕空间没有三维场景的信息，实际上计算的是光线和我们看到的场景的一个外壳求交点；二是计算着色，根据采样光线求解渲染方程，这一步和正常的光线追踪完全一样。</p><p>SSR 有效的一个重要原因在于，屏幕中我们能看到的场景中的反射的部分，一定有绝大部分是已经存在于当前的屏幕中的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605114441736.png" alt="image-20220605114441736"></p><p>街道上反射的就是屏幕的上半部分，因此屏幕空间光线追踪是完全可行的，仅利用屏幕中的信息是足够的。</p><p>对于每一个像素，如果只考虑最简单的镜面反射情况，那么我们直接从该点追踪镜面反射方向，就可以找到镜面反射光线和场景外壳上的一个交点，这个交点的颜色我们是直接可以知道的，就把这个颜色作为间接光照颜色（间接光照渲染方程的结果）加到该像素上就可以了，对于更复杂的 Glossy 和漫反射就像光线追踪一样采样更多光线即可，但是也不需要像光线追踪那样采样那么多，因为间接光照最后是要叠加到直接光照结果上的，所以我们只要采样少一些光线，得到一个有噪声的间接光照结果，简单去一下噪（加个模糊之类的）再叠加到直接光照上就能得到不错的结果了。</p><p>下图是镜面反射的结果：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115220889.png" alt="image-20220605115220889"></p><p>以及 Glossy 的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115237982.png" alt="image-20220605115237982"></p><p>SSR 还可以实现表面不平整的反射，无非就是不平整的表面法线影响了光线的反射方向而已：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115334563.png" alt="image-20220605115334563"></p><p>于是现在最主要的问题就是如何在屏幕空间追踪光线，也就是如何求得光线和我们看到的这一层外壳的交点。</p><p>最原始的做法是从着色点出发，沿着要追踪的光线方向，一次移动一定的距离，每次移动后判断对应的深度，如果深度小于深度缓冲中的深度则继续移动，直到深度大于深度缓冲中的深度，则认为找到了交点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605125808577.png" alt="image-20220605125808577"></p><p>这种方法找到的交点是不准确的，交点的精度取决于每次移动的步长，步长过大会找到不准确的交点，步长过小又会影响速度，因此要进行加速优化，这里又要用到图形学中常用的加速手段，类似于三维空间中的 BVH，我们为深度图生成 Mipmap，但这里的 Mipmap 不能取多个深度的均值，要取多个深度的最小值，也就是离我们最近的深度作为下一 level 的深度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130111638.png" alt="image-20220605130111638"></p><p>这样一来，我们就构建了层次深度结构，每次沿着光线移动时可以试探性地增大步长，也就是在更高一层移动，如果找到交点就降低 level 去找具体和哪个像素相交了，举例来说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130239538.png" alt="image-20220605130239538"></p><p>对于上图的情况，我们第一次从着色点出发，先在 level 0 移动，这时每一步会移动一个像素：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130325578.png" alt="image-20220605130325578"></p><p>此时深度小于深度缓冲中的深度，说明没有遮挡，继续移动，这次我们增加一个 level，在 level 1上移动，level 1 中每一个像素代表了 level 0 中的 4 个（我们这里是二维，所以是 2 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130448099.png" alt="image-20220605130448099"></p><p>移动之后还是没有交点，于是再增加一个 level，在 level 2上移动，level 2 中每一个像素代表了 level 0 中的 16 个（我们这里是二维，所以是 4 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130610015.png" alt="image-20220605130610015"></p><p>这时发现有交点了，于是减小一个 level，继续判断：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130649452.png" alt="image-20220605130649452"></p><p>继续减小 level 到 level 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130728981.png" alt="image-20220605130728981"></p><p>这时发现在 level 1有交点的像素细化到 level 0 之后没有交点，于是继续传播，因为没有交点，所以 level 加一，在 level 1 上移动：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130912940.png" alt="image-20220605130912940"></p><p>找到了交点，再次减小一个 level：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130937759.png" alt="image-20220605130937759"></p><p>最终找到了交点所在的像素，将这个像素对应的颜色作为间接光照累加到当前着色点上即可。上述过程的伪代码如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131027338.png" alt="image-20220605131027338"></p><p>屏幕空间光线追踪可以很好的实现全局光照，但也一定存在问题，因为我们只有屏幕中的场景信息，这些信息只是整个场景的一个外壳，内部的信息我们是完全不知道的，因此也就会导致我们看不到的部分就不会产生反射，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131201515.png" alt="image-20220605131201515"></p><p>此外，SSR 也只能反射屏幕中存在的物体，因此一部分在屏幕外的物体的反射就会被“切断”，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131343414.png" alt="image-20220605131343414"></p><p>不过这可以通过增加一个随距离增大的模糊衰减来解决，使结果看起来更真实：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131427066.png" alt="image-20220605131427066"></p><p>当然这只是 SSR 最基本的思想，实际实现中有非常多的细节和优化问题，比如重要性采样、样本在时间和空间上的复用等等，这里就不再展开了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时环境光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/</id>
    <published>2022-06-02T07:34:32.000Z</published>
    <updated>2022-06-13T03:32:11.647Z</updated>
    
    <content type="html"><![CDATA[<p>环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。</p><p><em><span id="more"></span></em></p><h3 id="1-回顾环境贴图"><a href="#1-回顾环境贴图" class="headerlink" title="1 回顾环境贴图"></a>1 回顾环境贴图</h3><p>环境贴图我们在之前的 Shader 部分中学习过也使用过，就是将整个场景存在一个立方体或者球体贴图中，渲染时根据光线反射方向去采样环境贴图得到环境光照。这样的环境光照渲染被称为基于图像的光照，Image-Based Lighting（IBL）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602111629808-16541623890081.png" alt="image-20220602111629808"></p><p>环境光照既然是光照，那自然也是解渲染方程的过程，解渲染方程最简单的方法就是使用数值方法，比如蒙特卡洛方法，但这需要根据光线反射方向采样大量的样本去计算，比如对于漫反射材质，需要在着色点为中心的半球面上均匀采样，而对于金属物体，需要向镜面反射方向一定范围内（Glossy 扰动）随机采样许多光线，这么多采样的计算是非常慢的，因此在实时渲染中需要使用一些方法来代替采样得到正确的环境光照结果。</p><h3 id="2-Split-Sum"><a href="#2-Split-Sum" class="headerlink" title="2 Split Sum"></a>2 Split Sum</h3><p>Split Sum 是解决实时环境光照的一个著名算法，也被使用在虚幻引擎中。上面说过，计算环境光照也是解渲染方程的过程，首先再次回顾渲染方程，并且我们现在计算环境光照的时候先不考虑环境光的阴影项：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112507731-16541623890092.png" alt="image-20220602112507731"></p><p>于是渲方程就只由两项组成，环境光照项 $L_i$ 和 BRDF 项（一般来说实时渲染中把 BRDF 和 cos 项合称为 BRDF 项），而 Split Sum 基于一个重要的观察：</p><ul><li>如果是 Glossy 的 BRDF，那么我们的积分区间是很小的，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112750875-16541623890103.png" alt="image-20220602112750875"></p><ul><li>如果是漫反射的 BRDF，虽然积分区间很大，是整个半球面，但是函数值在整个积分区间上的变化是平滑的：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112855298-16541623890104.png" alt="image-20220602112855298"></p><p>回顾之前我们说到的，实时渲染中非常重要的约等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602113010978-16541623890105.png" alt="image-20220602113010978"></p><p>这个估计要准确，函数 $g(x)$ 必须满足两个条件之一：</p><ul><li>$g(x)$ 在积分区间上波动尽可能小，也就是积分区间尽可能小</li><li>$g(x)$ 在积分区间上平滑</li></ul><p>渲染方程中的 BRDF 刚好符合这两个条件！于是我们可以把渲染方程写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><p>需要注意，在上一节中我们用同样的方法把阴影项拆分了出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123014213-16541623890107.png" alt="image-20220602123014213"></p><p>这是对于正常的光源渲染的，和我们这里讨论的是两个问题，我们这里的渲染方程是计算环境光照的，不过这两个对渲染方程的改写，用到的思路和方法都是一样的，都是基于上面的重要约等式。</p><p>渲染方程改写成这个形式意味着我们把环境光照项和 BRDF 项分开了，而光照项是环境光的积分除以积分区间的面积，这不就相当于把积分区间范围内，也就是 Glossy 的扰动范围或者漫反射的半球范围内的所有环境光取了一个平均值吗，那么我们如果能够提前计算好这个平均值，在渲染时就不需要大量采样了，只需要直接取到这个平均值就当作对应的环境光项的积分结果的近似值就可以了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124125503-16541623890108.png" alt="image-20220602124125503"></p><p>于是计算环境光照项的时候，我们可以把环境贴图按照一定的滤波核大小平均一下，生成多张平均后的环境贴图，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123621399-16541623890109.png" alt="image-20220602123621399"></p><p>当我们计算环境光的时候，根据 Glossy 的扰动大小，决定到多大滤波核平均后的环境贴图中去获取环境光，也可以在不同 level 之间进行插值，和 Mipmap 非常相似。这一步就是 split sum 的第一阶段，解决了环境光项的计算，接下来该解决后面的 BRDF 的积分了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124242578-165416238901010.png" alt="image-20220602124242578"></p><p>BRDF 的积分如何避免采样呢？BRDF 是一个比较复杂的函数，涉及到很多变量，如果我们要避免采样，就只能进行预计算。首先来回顾一下最常用的微表面 BRDF 模型：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124444075-165416238901011.png" alt="image-20220602124444075"></p><p>我们来逐个分析一下每项都是关于什么变量的函数。</p><p>首先是菲涅尔项，菲涅尔项非常复杂，但是渲染中常用的是 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124925813-165416238901113.png" alt="image-20220602124925813"></p><p>这个近似只需要一个基础反射率 $R_0$ 和一个角度 $\theta$，这个角度实际上应该是观察方向和法线的夹角，但是也可以是光线和法线的夹角，也可以是观察方向和切线的夹角，还可以是半程向量和法线的夹角，这是无所谓的，因为这些角度可以很方便的进行转换，总之就是一个角度，于是菲涅尔项需要两个参数 $R_0$ 和 $\theta$。</p><p>然后是法线分布函数 NDF，NDF 描述了微表面的法线分布，一个常用的 Beckmann 分布的公式如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602125413871-165416238901012.png" alt="image-20220602125413871"></p><p>可以看到 NDF 同样是关于两个变量的函数，一个是粗糙程度 $\alpha$，另一个同样是角度 $\theta$。</p><p>最后是遮挡项 G，与入射方向和出射方向有关，而我们的观察方向是固定的，于是遮挡项 G 也只与入射角 $\theta$ 有关。</p><p>综上， BRDF 与基础反射率 $R_0$ ，表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们如果要预计算，那么至少要计算这三个维度，虽然表面上是三个维度，实际上基础反射率 $R_0$ 还有 RGB 三个通道，如果预先计算出这三个变量所有可能的组合情况的 BRDF 积分结果，这无论是计算量还是存储量都是极大的，因此我们要让预计算的变量尽可能少，每少一个变量，就可以少一个维度的存储和计算，那对于预计算效率来说将会是质的提升。</p><p>我们将菲涅尔项的 Schlick’s 近似带入到上面渲染方程中的 BRDF 积分中并做简单的变形可以得到：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><p>这看起来让式子变得更复杂了，但实际上我们把最麻烦的基础反射率 $R_0$ 提取出来了，而剩下的两个积分只与表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们只需要预计算表面粗糙程度 $\alpha$，和入射角 $\theta$ 的所有组合情况就可以了，而这两个值 $\alpha$ 和 $cos\theta$ 都是 0 到 1 的标量，因此预计算的结果就可以存在一张二维纹理中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130931415-165416238901115.png" alt="image-20220602130931415"></p><p>在渲染时直接查找纹理中的积分结果就可以了。这就是对渲染方程 BRDF 项的计算优化。</p><p>至此我们可以总结一下 split sum 算法是如何计算环境光的：</p><ul><li>首先使用约等式将渲染方程中对光照项和 BRDF 项的乘积的积分转化为了积分的乘积：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><ul><li>然后对于第一项环境光，使用 pre-filtering 生成不同平均程度的环境贴图，使用类似 Mipmap 的方法直接取环境光的平均值近似作为积分结果</li><li>对于第二项 BRDF，预先计算与粗糙程度 $\alpha$ 和入射角 $cos\theta$ 有关的积分的结果，存在一张二维纹理中，计算时只需要查找纹理再乘以基础颜色 $R_0$ 按照以下公式就可以得到 BRDF 积分的近似结果了</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><ul><li>最后将两个积分结果相乘再除以归一化系数（积分区间的面积）就是最终的渲染方程结果</li></ul><p>这样一来整个渲染方程的计算过程就避免了采样，虽然使用了各种近似，但最终的效果却非常好：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131814205-165416238901116.png" alt="image-20220602131814205"></p><p>在工程中，公式一般不会写成积分形式，而是写成离散的求和形式，但本质是一样的：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131855491-165416238901117.png" alt="image-20220602131855491"></p><p>而 split sum 方法就是将求和拆分开来进行预计算，这也是 split sum 名称的由来。</p><h3 id="3-环境光照的阴影"><a href="#3-环境光照的阴影" class="headerlink" title="3 环境光照的阴影"></a>3 环境光照的阴影</h3><p>上面的讨论中，我们完全忽略掉了阴影，也就是 Visibility 项，实际上在实时渲染中做环境光照的阴影是几乎不可能的，因为环境贴图相当于把复杂的环境光照存在了一张贴图上，整个环境中实际上有非常多的光源，如果要做阴影，就要对每个光源生成一张 Shadow Map，这是不可能的，因此现在工业上的解决方案就是只生成最主要光源的阴影，这种方法虽然简单粗暴，但在大多数情况下也就足够了。</p><p>当然，有方法能够完全准确的计算出环境光的阴影，比如实时光线追踪，我们将在以后讨论，这里我们将讨论另一种非常强大的方法—— Precomputed radiance transfer（PRT），PRT 不仅可以计算环境光阴影，还可以用于实时全局光照。</p><h3 id="4-球面谐波函数"><a href="#4-球面谐波函数" class="headerlink" title="4 球面谐波函数"></a>4 球面谐波函数</h3><h4 id="4-1-球谐函数的定义和性质"><a href="#4-1-球谐函数的定义和性质" class="headerlink" title="4.1 球谐函数的定义和性质"></a>4.1 球谐函数的定义和性质</h4><p>球面谐波函数（Spherical Harmonics，SH）是一组二维基函数，类似于一维中的傅里叶基函数。空间中的任何球面函数（比如我们的环境贴图、BRDF 等都是球面函数）都可以表示为 SH 的线性组合。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135006568-165416238901118.png" alt="image-20220602135006568"></p><p>上图表示了前四阶 SH 的可视化结果，不难看出，n 阶 SH 有 2n + 1 个基函数，前 n 阶 SH 有 n * n 个基函数。图中蓝色代表正值，黄色代表负值，颜色深浅代表了值的大小，可以看到同一阶的基函数实际上就是函数值在不同维度的变化，阶数越高函数值变化的频率越高，因此他们的线性组合就可以表示函数中越高频的信息，使用不同阶的球谐函数的组合就可以将一个函数中的不同频率的信息表示出来，再将它们组合在一起就可以基本还原出原本函数的样子，使用的球谐函数越多，自然对原函数的还原也就越好：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602141239497-165416238901119.png" alt="image-20220602141239497"></p><p>这和一维中的傅里叶变换是完全一样的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135645988-165416238901120.png" alt="image-20220602135645988"></p><p>此外，一个函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分叫做<strong>投影</strong>，投影结果就是这个函数被表示为基函数的线性组合时，对应的基函数的线性组合系数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135934958-165416238901121.png" alt="image-20220602135934958"></p><p>这可以类比于基向量，任意一个向量 $v$ 可以表示为一组基向量的线性组合，而每个基向量的系数就是向量 $v$ 和该基向量的点乘，而我们知道，向量点乘实际上就是投影，所以函数投影的概念和向量投影是完全一样的，上面的函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分实际上就是对应的函数值相乘再累加起来，这和点乘的计算方式完全一样。</p><p>因此基函数自然也有和基向量完全一样的性质：</p><ul><li>基函数投影到自身结果为 1，相当于基向量是单位向量：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140619749-165416238901122.png" alt="image-20220602140619749"></p><ul><li>基函数互相正交，即投影结果为 0，相当于基向量互相正交：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140700382-165416238901123.png" alt="image-20220602140700382"></p><h4 id="4-2-用球谐函数表示环境光"><a href="#4-2-用球谐函数表示环境光" class="headerlink" title="4.2 用球谐函数表示环境光"></a>4.2 用球谐函数表示环境光</h4><p>首先我们回顾上面 split sum 中用到的 pre-filtering 方法，也就是对环境贴图提前进行了一个均值滤波，然后在渲染时只进行一次查询得到平均值作为多次采样的积分近似值，因此可以说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602142643059-165416238901124.png" alt="image-20220602142643059"></p><p>而我们知道均值滤波是低通滤波，只保留了低频信号，如上图，虽然滤波后不能完全还原出原本的环境光照，但是光源之间的明暗关系是完全保留了下来的，对于漫反射或者 Glossy 来说，这是完全够用的，这也是 split sum 可以 work 的原因。</p><p>在这个理解的基础上，又可以得出一个新的理解，那就是<strong>漫反射的 BRDF 对光照的作用，其实就相当于一个低通滤波器的作用</strong>。这其实很好理解，不管环境光照如何复杂，变化如何剧烈，漫反射物体显示出来的都是模糊的变化，不会显示出原本的环境光照那样高频的变化。而这样的特性是由 BRDF 决定的，因此漫反射的 BRDF 相当于对光照做了一个低通滤波。</p><p>于是有人就把 BRDF 投影到了球谐基函数上，并且发现投影只在前三阶有值，之后的投影结果几乎都为 0，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143333455-165416238901125.png" alt="image-20220602143333455"></p><p>这说明漫反射的 BRDF 中就只包含前三阶 SH 对应的频率的信息，根本就不包含更高频的信息。于是我们也完全可以把环境光照表示为球谐函数，而且只用前三阶就可以近似得到漫反射物体的环境光照结果，事实也确实如此：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143819188-165416238901126.png" alt="image-20220602143819188"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143830579-165416238901227.png" alt="image-20220602143830579"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143841772-165416238901228.png" alt="image-20220602143841772"></p><h3 id="5-Precomputed-radiance-transfer（PRT）"><a href="#5-Precomputed-radiance-transfer（PRT）" class="headerlink" title="5 Precomputed radiance transfer（PRT）"></a>5 Precomputed radiance transfer（PRT）</h3><h4 id="5-1-PRT-原理"><a href="#5-1-PRT-原理" class="headerlink" title="5.1 PRT 原理"></a>5.1 PRT 原理</h4><p>对于一个场景中的一个着色点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144122954-165416238901229.png" alt="image-20220602144122954"></p><p>它的渲染方程可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144003377-165416238901230.png" alt="image-20220602144003377"></p><p>环境贴图自然表示整个空间的环境光，visibility 是从这一点看向整个场景得到的遮挡关系，下半部分全黑是因为只在着色点上半球有值，最后是 BRDF 可视化，同样只在上半球有值。渲染方程相当于这些值的乘积的和，如果环境贴图每一面分辨率是 64 * 64，那么计算这一个着色点就要进行 6 * 64 * 64 次三个数的乘法运算再求和，当分辨率变大的时候这个数字是指数增长的，因此 PRT 将渲染方程分为两部分处理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602145517079-165416238901231.png" alt="image-20220602145517079"></p><p>一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150253420-165416238901232.png" alt="image-20220602150253420"></p><h4 id="5-2-漫反射情况"><a href="#5-2-漫反射情况" class="headerlink" title="5.2 漫反射情况"></a>5.2 漫反射情况</h4><p>我们接下来先从简单的漫反射情况来详细理解上述过程。对于漫反射， BRDF 是一个常数，我们之前推导过，这里不再赘述，于是渲染方程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150537-165416238901233.png" alt="2022-06-02 150537"></p><p>其中光照项表示为球谐函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150658443-165416238901234.png" alt="image-20220602150658443"></p><p>这样一来对于一个环境光（二维函数），我们只需要记录一个 SH 系数的向量（一维向量）就可以表示了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152232311.png" alt="image-20220602152232311"></p><p>将 SH 表示的环境光带入渲染方程中可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150745-165416238901235.png" alt="2022-06-02 150745"></p><p>其中的积分相当于把 light transport 项投影到基函数上，实际上这个投影方程也可以看作是一个渲染方程，因此投影结果可以认为是在某一个基函数的光照条件下的渲染结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602151932922-165416238901236.png" alt="image-20220602151932922"></p><p>这也是为什么 PRT 能够得到环境光阴影，因为在计算投影结果的时候，计算的是 light transport 的投影结果，而 light transport 就包含了 visibility 项，因此 PRT 能够得到准确的环境光阴影。这个投影结果是可以通过预计算得到的，因此渲染方程最终就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>这样在渲染时只需要计算一次点乘就可以得到环境光照了，为什么是点乘呢？我们接下来从另一个角度来理解上面的过程。</p><p>上面的推导中我们只把光照项表示为了 SH，然后将光照传播项投影到了这些 SH 上去预计算投影结果。我们当然也可以把光照项和光照传播项完全分开计算，分别把他们表示成 SH：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162810390.png" alt="image-20220602162810390"></p><p>于是渲染方程就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162847615.png" alt="image-20220602162847615"></p><p>渲染方程变成了一个二次的求和公式，这看起来和之前推导的结果不一样，因为这里二次求和显然是一个 $O(n^2)$ 的复杂度，要遍历 p 和 q 的结果全部累加起来，但是我们知道 SH 是基函数，基函数有正交性，也就是说只有两个基函数相同的时候，上面的积分值才为 1，其他情况下都是 0，因此上面的求和式实际上只是把光照项和光照传播项表示为 SH 后，相同的基函数对应的系数乘积累加了起来，之前说过，用 SH 表示一个二维函数相当于把二维函数压缩成了一个一维的系数向量，所以上面的求和式表示的就是光照项和光照传播项的系数向量的点乘。这和之前推导的公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>表示的意义是完全一样的，这里面 $l_i$ 是光照项的每一个 SH 基函数的系数，$T_i$ 是光照传播项投影到每一个基函数的结果，也就是光照传播项的 SH 系数，二者相乘再求和不正是向量点乘吗。 </p><h4 id="5-3-Glossy-情况"><a href="#5-3-Glossy-情况" class="headerlink" title="5.3 Glossy 情况"></a>5.3 Glossy 情况</h4><p>在此基础上，我们就可以理解 Glossy 情况下 PRT 的计算了。漫反射时， BRDF 是一个常数，无论观察方向如何变化，观察到的光照结果都是一样的，因此光照传播项就是一个二维函数（因为 visibility 是二维的，只与 $w_i$ 有关），表示为 SH 可以得到一个系数向量，再点乘光照项的系数向量就得到了渲染方程的结果。</p><p>但是 Glossy 的 BRDF 不再是一个常数了，而是一个真正的四维函数，当我们在任意一个观察方向 $w_o$ 的时候，BRDF 都是一个与 $w_i$ 有关的二维函数，可以表示为 SH 得到一个系数向量，对于不同的观察方向 $w_o$，自然会得到不同的 SH 表示，也就会得到不同的系数向量。也就是说将 Glossy 的 BRDF 投影到 SH 之后，我们得到的不再是一个系数向量了，而是一个系数矩阵，每一行是一个观察方向 $w_o$ 对应的系数向量，每一列是每一个入射方向 $w_i$ 对应的系数向量，因此上面的公式就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-0265720.png" alt="2022-06-0265720"></p><p>于是我们在计算时就不再是向量点乘了，而是向量和矩阵相乘了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602165910171.png" alt="image-20220602165910171"></p><p>也就是用光照项的系数向量乘以光照传播项的系数矩阵，最终得到的还是一个系数向量，表示的是不同观察方向所看到的光照结果，是一个关于观察方向 $w_o$ 的二维函数，因为对于 Glossy 材质，不同观察方向看到的光照结果是不同的，而漫反射与观察方向无关，所以向量点乘得到的是一个值。</p><h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>总结一下，PRT 将渲染方程分为两部分，一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，漫反射需要预计算一个向量，Glossy 反射需要预计算一个矩阵，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算。</p><p>PRT 效果好速度快，而且可以准确计算环境光阴影，并且如果预计算的时候考虑了光线的多次弹射还可以实现全局光照，而且得益于 SH 的快速旋转性质，PRT 可以在环境光旋转的时候迅速得到渲染结果，无需重新计算，因为当环境光旋转的时候相当于表示它的所有基函数进行了旋转，而旋转后的基函数可以表示为其他同阶基函数的线性组合，因此可以快速得到旋转后的环境光的 SH 表示。</p><p>但 PRT 也存在很多问题，比如只适用于静态场景，因为预计算了光照传播项，而光照传播项又包含了 visibility 和 BRDF，因此预计算完成后，场景的遮挡关系和物体的材质就不能改变了，否则就要重新计算；并且使用 SH 作为基函数只适用于低频环境光照，因为 SH 在表示高频信号的时候会非常吃力，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152155042-165416238901838.png" alt="image-20220602152155042"></p><p>这是因为 SH 是从低到高的频段表示，我们使用前 n 阶的 SH，就只能表示信号中对应的这么多频段的信息，更高频的信息就会丢失掉，对于一些高频环境光照的场景，可以使用其他基函数，比如二维小波函数（Wavelet），任意一个二维函数都可以表示为所有小波基函数的线性组合，而我们可以只保留线性组合系数最高的那些项来表示原函数，因此小波表示是全频率的，比 SH 更适合表示高频环境光，但小波函数不具有快速旋转性质，当环境光变化时处理非常不灵活，下图是 SH 和 小波函数的渲染结果对比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602172803653.png" alt="image-20220602172803653"></p><p>显然小波保留了更多的高频信息，得到了更好的阴影和反射效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时阴影</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/</id>
    <published>2022-05-30T12:49:23.000Z</published>
    <updated>2022-06-13T03:31:52.570Z</updated>
    
    <content type="html"><![CDATA[<p>阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈-Shadow-Map"><a href="#1-再谈-Shadow-Map" class="headerlink" title="1 再谈 Shadow Map"></a>1 再谈 Shadow Map</h3><h4 id="1-1-Shadow-Map-背后的数学原理"><a href="#1-1-Shadow-Map-背后的数学原理" class="headerlink" title="1.1 Shadow Map 背后的数学原理"></a>1.1 Shadow Map 背后的数学原理</h4><p>关于 Shadow Map，我们在之前已经了解过，原理非常简单，首先从光源的视角看向整个场景生成一张深度图，然后再从真正的相机视角渲染场景，并对每一个着色点计算其到光源的距离，和深度图中的距离作比较，就可以判断该着色点和光源中间是否有遮挡物，从而产生阴影。整个过程可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/">【计算机图形学】（十）阴影</a>。</p><p>那么 Shadow Map 为什么可以这么做，可以利用数学知识简单的进行解释，同时了解实时渲染中的优化方向。</p><p>首先是在实时渲染领域非常重要的一个思想，那就是只要看起来是对的，那么它就是对的。也就是说我们不需要精确地计算出结果，只要能够得到结果的正确近似，使最终的渲染效果看起来正确就足够了。因此在实时渲染中会用到各种近似的方法，后面就可以看到，这里先熟悉一个实时渲染中经常用到的近似等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152415189.png" alt="image-20220530152415189"></p><p>也就是把两个函数乘积的积分近似转化为两个函数积分的乘积，其中分母是一个缩放因子，为了将积分的乘积缩小到和原积分同样的大小，可以通过一个例子来理解：比如 $f(x)$ 是一个常量函数，函数值恒为 2，积分区间是一个长度为 3 的一维区间，那么原积分相当于两倍的 $g(x)$ 在该区间上的积分，转化后的分子，也就是对 $f(x)$ 的积分结果为 3 * 2 &#x3D;  6，如果不除以缩放因子那么结果就是 6 倍的 $g(x)$ 在该区间上的积分，而除以分母的缩放因子，也就是积分区间长度 3，结果刚好就是 2 倍的 $g(x)$ 在该区间上的积分。</p><p>这个式子在实时渲染中非常有用，比如我们的渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152854014.png" alt="image-20220530152854014"></p><p>在实时渲染中经常会改写为下面的形式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153029862.png" alt="image-20220530153029862"></p><p>其中 V 代表可见项，表示了该点的可见程度，可以理解为阴影项，于是上面的渲染方程根据之前的近似等式就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153303843.png" alt="image-20220530153303843"></p><p>我们在之前的 Shader 中就是在光照计算结果上乘了一个阴影项，这就是可以这么做的道理所在。当然使用这样的近似结果要想估计的准确需要一定的条件：</p><ul><li>$g(x)$ 在积分区间上的波动要尽可能小，或者说积分区间要足够小，体现到渲染中就是光源最好是点光源或者平行光</li><li>$g(x)$ 要是光滑函数，体现到渲染中就是如果不是点光源那么最好是均匀发光的面光源</li></ul><h4 id="1-2-Shadow-Map-的问题"><a href="#1-2-Shadow-Map-的问题" class="headerlink" title="1.2 Shadow Map 的问题"></a>1.2 Shadow Map 的问题</h4><p>Shadow Map 是最基础的阴影算法，优点在于它是一个屏幕空间的算法，不需要知道场景的几何信息，只要知道光源位置和每一个片段的位置就可以完成（世界空间或者裁剪空间都可以），但是正因为其简单，所以有不少缺点，这也是后面的阴影算法的改进方向，总的来说 Shadow Map 有三个最大的问题：</p><p>首先是<strong>自遮挡问题。</strong> Shadow Map 是一个需要两个 Pass 完成的算法，在第一个 Pass 中先从光源位置渲染一遍场景，并将每个像素的深度信息存下来，第二个 Pass 中利用这些深度信息产生阴影。问题在于 Shadow Map 分辨率有限，Shadow Map 中每个像素对应到场景中的一块区域，当第二次进行深度对比的时候，就可能会产生错误，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145535937.png" alt="image-20220530145535937"></p><p>由于 Shadow Map 分辨率有限，因此每个 texel 对应于场景中一个区域，如图中的区域 1。点 p1 和 p2 对应于屏幕上的不同像素点，由于我们判断一个像素是否位于阴影中，是通过比较该点在以光源为视点的空间中的深度和对应 texel 中储存的深度值。在这种情况下 d(p1) &gt; s，而 d(p2) &lt; s，因此 p1 将会被认为是在阴影中，但其实 p1 和 p2 应该都不在阴影中。于是渲染出来的图就会产生下面的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145805637.png" alt="image-20220530145805637"></p><p>存在很多阴影纹路，解决这个问题最简单的方法就是在深度比较的时候加上一个容忍度，也就是当着色点的深度比 Shadow Map 中的深度大且它们的差在一定范围内我们就不认为该点被遮挡了。但是如果我们手动设定一个固定的容忍度，也就相当于为 Shadow Map 中的深度进行了一个统一的偏移，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150153504.png" alt="image-20220530150153504"></p><p>这样虽然解决了自遮挡的问题，但会产生新的问题，也就是一部分本该在阴影中的点就不在阴影中了，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150232576.png" alt="image-20220530150232576"></p><p>脚的部分阴影就会断掉，原因如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150705056.png" alt="image-20220530150705056"></p><p>当三角形平面相对于光源的斜率比较大的时候，Shadow Map 中的深度偏移了一段距离，原本被遮挡的点就会变成没有被遮挡从而不产生阴影，如果使用相同的偏移量就会在斜率大的地方有更多的点不被遮挡，从而造成阴影断裂，也就是上图中鞋的部分显然相对于光源的斜率更大，因此会产生阴影断裂现象。因此我们希望可以根据三角形相对于光源的斜率来自适应的调整容忍度，现代显卡已经支持了这种操作。</p><p>Shadow Map 的第二个问题是会<strong>产生走样</strong>，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530151628306.png" alt="image-20220530151628306"></p><p>这同样是由于 Shadow Map 的分辨率有限造成的，可以通过 PCF 来解决，下面会详细介绍。</p><p>Shadow Map 的第三个问题是<strong>只能产生硬阴影</strong>。于是产生了各种软阴影算法，同样在之后详细介绍。</p><h3 id="2-Percentage-Closer-Filtering（PCF）"><a href="#2-Percentage-Closer-Filtering（PCF）" class="headerlink" title="2 Percentage Closer Filtering（PCF）"></a>2 Percentage Closer Filtering（PCF）</h3><p>PCF 是解决 Shadow Map 的走样问题而被提出的。其思想是获取着色点周围的一系列点的深度值，与 P 点深度比较再对比较结果计算一个平均值，也就是说，在比较着色点和 Shadow Map 中的深度的时候，不仅和一个 texel 作比较，而是和多个 texel 作比较，然后将比较的结果进行一个平均作为该点的最终比较结果，这样就得到了一个平滑的，不是非 0 即 1 的阴影项。下面通过一个例子来说明：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154335327.png" alt="image-20220530154335327"></p><p>对于点 P，我们将其周围 3 * 3 的深度值和当前像素作比较，得到一个比较结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154413210.png" alt="image-20220530154413210"></p><p>然后将这些结果（加权）平均起来，作为最终该像素的阴影项，这个例子中阴影项最终结果是 0.667，当然一般来说不会取 3 * 3 这么小的邻域。现在的硬件也支持 PCF，但只会取离纹理坐标最近的四个 texel 做平均，效果有限，因此大多数情况下还是在软件 Shader 中做 PCF。</p><p>需要注意的是，PCF 既不是对 Shadow Map 中的深度进行平均，也不是对生成的阴影图像进行滤波，而是对深度比较的结果进行平均。</p><p>下图是 PCF 的效果，可以一定程度上改善阴影的走样问题：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155053026.png" alt="image-20220530155053026"></p><h3 id="3-Percentage-Closer-Soft-Shadows（PCSS）"><a href="#3-Percentage-Closer-Soft-Shadows（PCSS）" class="headerlink" title="3 Percentage Closer Soft Shadows（PCSS）"></a>3 Percentage Closer Soft Shadows（PCSS）</h3><p>PCSS 是利用 PCF 产生软阴影的算法，为了解决 Shadow Map 无法产生软阴影的问题，实际上所有阴影反走样算法都可以用来产生软阴影。</p><p>从 PCF 的原理可以看出，当我们使用的邻域面积越大，也就是卷积核越大，得到的阴影就会越软，因此我们完全可以使用大卷积核的 PCF 来产生软阴影，但是卷积核选择多大合适呢？如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155441750.png" alt="image-20220530155441750"></p><p>笔尖附近的阴影非常锐利，而笔杆部分的阴影就变得比较软，这是因为在笔尖处，阴影投射物（Shadow Caster）和阴影接收物（Shadow Reciever）之间的距离很近，而在笔杆部分 Shadow Caster 和 Shadow Reciever 之间的距离较远。因此我们希望 Shadow Caster 和 Shadow Reciever 之间的距离越远，使用的卷积核越大，也就使得阴影越软。</p><p>这可以通过几何关系来描述：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160458278.png" alt="image-20220530160458278"></p><p>绿色虚线是遮挡物（Blocker）到光源平面的距离，蓝色虚线是阴影接收平面到光源平面的距离，当 Blocker 离光源平面越远，也就是离阴影接收平面越近，光源平面经过 Blocker 上一点映射到阴影接收平面上的面积就越小，我们根据这个映射后的面积决定使用多大的卷积核，这样一来，Blocker 离阴影接收平面越近，使用的卷积核就越小，当 Blocker 离光源平面越近，也就是离阴影接收平面越远，使用的卷积核就越大，这样就可以产生比较真实的软阴影效果。从图中也很容易根据相似三角形原理得出映射后的光源面积：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160930593.png" alt="image-20220530160930593"></p><p>现在的问题是，Blocker 的深度 $d_{Blocker}$ 如何得到？我们在渲染时只知道阴影接收平面上的一点，并不知道遮挡物距离光源的深度是多少，这时可以再次利用 PCF 的思想，将这一点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 Blocker 的深度。</p><p>于是 PCSS 算法的整个流程就是：</p><ul><li>对于每个像素，首先利用上述方法计算其 $d_{Blocker}$ </li><li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li><li>使用对应大小的卷积核进行 PCF</li></ul><p>那么又产生了一个问题，计算 $d_{Blocker}$ 时，又该选用多大的邻域范围呢？当然可以是一个固定的大小，比如 5 * 5，但是更好的方法是根据光源面积大小和着色点到光源的距离远近来选择不同的卷积核大小，一种方法是从着色点到光源平面构建一个锥体，然后看该点在  Shadow Map 上对应了多大的区域，将该区域内的深度和该点的深度进行比较，把所有小于该点深度的值平均起来作为 $d_{Blocker}$，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530162415880.png" alt="image-20220530162415880"></p><p>另外需要说明的是对于面光源，生成 Shadow Map 时也要像点光源一样，取光源平面中心一点，作为渲染深度图的视点，从该视点出发构建视锥体进行渲染，而 Shadow Map 也就是视锥体的近平面，所以使用上面的方法就可以从空间中一点覆盖到 Shadow Map 上的一块区域。</p><h3 id="4-Variance-Soft-Shadow-Mapping（VSM）"><a href="#4-Variance-Soft-Shadow-Mapping（VSM）" class="headerlink" title="4 Variance Soft Shadow Mapping（VSM）"></a>4 Variance Soft Shadow Mapping（VSM）</h3><h4 id="4-1-PCSS-的问题"><a href="#4-1-PCSS-的问题" class="headerlink" title="4.1 PCSS 的问题"></a>4.1 PCSS 的问题</h4><p>PCSS 利用 PCF 产生软阴影，但是速度并不快，因为 PCSS 在第一步计算 $d_{Blocker}$ 和最后一步进行 PCF 都需要对 Shadow Map 进行采样，而且当卷积核比较大的时候，需要采样很多纹理值，造成性能下降。一种解决方法是不对卷积核内的所有纹理进行采样，而是选取其中一些样本进行计算，但是这样得到的结果中一定存在噪声，不过可以利用后期的去噪方法来优化结果。</p><p>进一步思考这个问题，PCF 的精髓在于 “Percentage Closer”，也就是有多少百分比的 texel 是能够遮挡到当前位置的，换一种说法就是在当前点的一定邻域范围内有多少深度是小于当前点深度的。这就将原问题转化为了一个统计问题，因此使用少量样本也一定程度上能够得到近似正确的结果，但有没有更好的方法来得到相对准确的近似呢？</p><p>从概率与统计的角度来解决上述问题，我们只要能够知道这个邻域范围内的深度是如何分布的，就可以快速地得到一个近似的百分比。最容易想到的就是将深度的分布近似的看作是正态分布，而得到一个正态分布只需要两个量：均值和方差。</p><p><strong>因此 VSM 的核心思想就是</strong>，利用区域查询方法快速地得到 Shadow Map 中一个区域内深度的均值和方差，从而得到深度的近似分布，根据深度分布得到这个区域内有多少深度是小于当前点深度的，然后就可以改进 PCSS 的第一步和第三步中 PCF 的多次纹理采样，从而获得效率提升。</p><h4 id="4-2-区域查询方法"><a href="#4-2-区域查询方法" class="headerlink" title="4.2 区域查询方法"></a>4.2 区域查询方法</h4><p>对于一个区域内的均值，可以利用 MipMap 来快速查询，但是 MipMap 得到的均值是近似值，因为需要三线性插值，即在同一层级的不同平均值之间插值，然后还得在不同层级之间再插值一次得到结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530174618341.png" alt="image-20220530174618341"></p><p>更准确的查询区域均值的方法是利用 Summed Area Tables (SAT)。SAT 实际上就是二维前缀和，具体细节就不赘述了，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170245397.png" alt="image-20220530170245397"></p><p>因此使用 SAT 获取区域均值是绝对准确的，非近似的，而且还支持矩形区域查询，MipMap 只支持正方形区域。</p><p>至于 SAT 的构建，需要随着 Shadow Map 的更新而重新计算，而 Shadow Map 也要在场景中的物体运动或者光源运动的情况下不断更新，所以还是存在一定的开销的，但 SAT 一旦构建完成就可以使用 VSM 算法快速得到的 PCF 的结果，而不需要再对 Shadow Map 进行多次采样再平均，所以降低了 PCSS 的开销。</p><h4 id="4-3-VSM-的实现"><a href="#4-3-VSM-的实现" class="headerlink" title="4.3 VSM 的实现"></a>4.3 VSM 的实现</h4><p>利用区域查询方法可以快速得到深度的均值，那么如何得到区域内深度的方差呢？利用一个经典概率论公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170818733.png" alt="image-20220530170818733"></p><p>我们只需要在构建 Shadow Map 的时候，将深度的平方也存在一张纹理中，就可以计算出区域内深度的方差了。在实际实现中，深度和深度的平方可以存在一张纹理的两个不同通道，甚至不需要两张纹理，也不需要 MRT 支持，非常方便。</p><p>于是根据均值和方差就可以构建出该区域内深度的近似分布了，下一步就是得到有多少深度比当前点深度小，也就是算出 $P(x &lt; x_{cur})$，已知概率密度函数（PDF）求概率就是对 PDF 进行积分，而如果能够提前算出所有的概率，对于给定的 $x_{cur}$，只需要查询就可以了，这正是分段概率函数（CDF），如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171327752.png" alt="image-20220530171327752"></p><p>但是对于一个连续的概率分布，求其 CDF 是非常困难的，于是 VSM 又利用了一个巧妙的方法来近似 CDF —— 利用切比雪夫不等式。</p><p>切比雪夫不等式（Chebychev’s inequality）在单峰概率分布时如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171632090.png" alt="image-20220530171632090"></p><p>这个不等式甚至不需要知道具体的概率分布，只要给定均值和方差，就可以得到上面的关系，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171726482.png" alt="image-20220530171726482"></p><p>切比雪夫不等式描述的是 $x&gt;t$ 的概率不大于右边通过均值和方差计算出来的值。而在图形学中一个常规操作就是把不等式看作约等式，因此可以直接把切比雪夫不等式的右边的值作为 $P(x&gt;t)$ 的估计值，这样自然也就得到了我们需要的 $P(x &lt; t)$ 的估计值。</p><p>但是切比雪夫不等式要求 t 必须大于均值才有效，不过对于图形学来说，这样的近似估计已经足够好了，因为它足够简单快速。</p><p>现在我们可以总结一下 VSM 算法对 PCF 的改进流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>然后在渲染时，只需要查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，这一系列操作只需要 O(1) 时间，不需要任何循环和多次纹理采样</li></ul><p>于是就解决了 PCSS 中的第三步 PCF，那么第一步获取 $d_{Blocker}$ 又该如何优化呢？</p><p>回顾获取 $d_{Blocker}$ 的方法：将当前点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 $d_{Blocker}$。</p><p>对于一个区域，区域内所有深度可以分为两类：</p><ul><li>一类是小于当前点深度的，也就是会遮挡到当前点的深度，这些点的深度均值为 $z_{occ}$</li><li>另一类是小于当前点深度的，也就是不会遮挡到当前点的深度，这些点的深度均值为 $z_{unocc}$</li></ul><p>于是区域内所有深度的均值 $z_{avg}$ 可以表示成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530173458126.png" alt="image-20220530173458126"></p><p>其中 N 是区域内 texel 总数量， N1 和 N2 分别是不会遮挡和会遮挡当前点的 texel 数量。</p><p>我们希望得到的是会遮挡到当前点的深度的均值 $z_{occ}$。而 N1&#x2F;N 就是我们上面切比雪夫不等式计算的 $P(x &gt; x_{cur})$，那么自然 N2&#x2F;N 就是 $1-P(x &gt; x_{cur})$，于是现在我们只要知道 $z_{unocc}$ 就可以得到 $z_{occ}$ 了，VSM 直接假设 $z_{unocc}&#x3D;x_{cur}$ ，也就是假设不会遮挡到当前点的深度的均值就是当前点的深度，根据这些值，就可以得到一个 $z_{occ}$ 的近似值了，这个值就作为 $d_{Blocker}$ 去计算 PCF 卷积核大小。</p><p>于是 PCSS 中第一步的多次采样问题也解决了，最后总结一下 VSM 的算法流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>渲染时，对于每个像素，根据之前说的方法得到计算 $d_{Blocker}$ 时的卷积核大小，查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计，利用上述方法计算 $z_{occ}$ 作为 $d_{Blocker}$ </li><li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li><li>使用对应大小的卷积核查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，将切比雪夫估计值作为该像素的阴影项</li></ul><h4 id="4-4-VSM-的优缺点"><a href="#4-4-VSM-的优缺点" class="headerlink" title="4.4 VSM 的优缺点"></a>4.4 VSM 的优缺点</h4><p>VSM 实际上就是 PCSS 的改进方法，加速了 PCF 的计算过程，效率更高，且阴影不会产生噪声，但也存在一些问题。最严重的问题就是会产生漏光（Light Leaking）现象。</p><p>所谓漏光是指当两个 shadow caster 的阴影出现重叠时，在阴影的交界处会出现漏光，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175426796.png" alt="image-20220530175426796"></p><p>汽车底盘下方有些亮的地方，但是汽车底盘不应该是透光的，这是因为这些地方处于多个 shadow caster 的交界处，车顶有镂空的架子。</p><p>漏光的原因在于 VSM 中使用了单峰概率分布的切比雪夫不等式作为 PCF 的估计值，也就是默认当前点周围的深度分布是一个单峰的概率分布。对于一些复杂的情况，比如树枝，确实一个点周围的深度分布很复杂，可以近似为正态分布，所以阴影也不会有问题，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175756313.png" alt="image-20220530175756313"></p><p>但是有些情况下，深度分布很简单，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175829567.png" alt="image-20220530175829567"></p><p>这时如果一个着色点刚好在多个镂空区域的下方，那么该点周围的深度分布可能就是多个峰值或者像上图那样的极端情况，只有几个离散的深度，这时还是用单峰切比雪夫不等式就会使得估计出来的 $P(x &gt; x_{cur})$ 偏大或者偏小，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180032457.png" alt="image-20220530180032457"></p><p>也就会导致阴影项偏小或者偏大，体现在图像上就是该像素更暗或者更亮，对于阴影来说，更暗我们一般看不出来，但是更亮就会很敏感地被捕捉到，也就是漏光现象。</p><h3 id="5-Moment-Shadow-Mapping（MSM）"><a href="#5-Moment-Shadow-Mapping（MSM）" class="headerlink" title="5 Moment Shadow Mapping（MSM）"></a>5 Moment Shadow Mapping（MSM）</h3><p>MSM 就是为了解决 VSM 的漏光现象而提出的。VSM 漏光的本质原因在于对深度分布的估计不准确，因为 VSM 只使用了均值和方差来估计分布，也就是只使用了深度的一阶矩和二阶矩，MEM 使用更高阶的矩来估计深度分布，得到的分布估计自然更加准确，MEM 经过实验指出，一般情况下使用前四阶矩就可以很好的拟合 PCF 的深度分布了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180617122.png" alt="image-20220530180617122"></p><p>最后值得一提的是，现在更多的实时阴影还是使用在区域内采样深度的 PCSS，得益于时间和空间上的去噪和模糊算法可以在很短时间内达到很好的效果，因此我们可以在很小的开销下得到一张有噪声的结果，然后使用去噪或者模糊算法来优化这个结果得到好的渲染图片。</p><h3 id="6-Distance-Field-Soft-Shadows"><a href="#6-Distance-Field-Soft-Shadows" class="headerlink" title="6 Distance Field Soft Shadows"></a>6 Distance Field Soft Shadows</h3><p>基于距离场的软阴影是另一种软阴影的近似算法，与以上基于 Shadow Map 的软阴影算法完全不同。相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，因此目前基于距离场的软阴影算法也逐渐被广泛使用。</p><p>首先回顾一下距离场，距离场是由空间中所有点的距离函数组成的场，而距离函数是指一个点到离它最近的物体表面的距离。下图是一个字母 A 的距离场可视化的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142044408.png" alt="image-20220601142044408"></p><p>距离场的优势在于可以使用插值得到物体表面的中间状态，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142307684.png" alt="image-20220601142307684"></p><p>上面一行是直接对图像进行插值的结果，黑色部分代表物体，从状态 A 到状态 B 表示一个物体从左向右运动，黑白的边界就表示物体的表面。如果直接对两幅图像的每个像素进行插值是无法得到这两个状态的中间状态的，而如果转化为距离场，对距离场插值之后再逆变换回图像，就可以得到两个状态的中间状态。</p><h4 id="6-1-距离场的用途"><a href="#6-1-距离场的用途" class="headerlink" title="6.1 距离场的用途"></a>6.1 距离场的用途</h4><p>距离场的一个用途就是用来做 Ray marching，也叫做 sphere tracing，也就是可以通过距离场来求光线和表面的交点，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142714292.png" alt="image-20220601142714292"></p><p>因为距离场表示的是空间中一点到离它最近的物体表面的距离，因此在任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，也就是不会碰到物体的距离，所以在该点处 SDF(p) 范围内，光线不会与任何物体有交点，于是光线就可以前进 SDF(p) 距离到达边界，到达边界后又会得到一点，然后再去查找该点的 SDF(p) 并继续前进，直到光线足够接近物体或者追踪了足够多次，因此这种方法也叫做 sphere tracing。</p><h4 id="6-2-基于距离场的软阴影"><a href="#6-2-基于距离场的软阴影" class="headerlink" title="6.2 基于距离场的软阴影"></a>6.2 基于距离场的软阴影</h4><p>在 Ray marching 中就可以顺便完成阴影项的计算，得到一个软阴影，上面说到，任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，那么也就表示了这一点的安全角度，所谓安全角度是指该点不会被遮挡到的角度，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601143236308.png" alt="image-20220601143236308"></p><p>而这个安全角度是很容易算出的，我们知道着色点到该点的距离，也知道该点到离他最近的物体表面的距离，那么安全角度就是：<br>$$<br>arcsin(\frac{SDF(p)}{|p - o|})<br>$$<br>该值就可以直接作为阴影项，安全角度越小，被遮挡的概率就越大，因此该着色点的阴影也就越暗。</p><p>但是在着色过程中，反三角函数的计算还是太过复杂，为了简化计算，我们直接使用该点的距离函数值和着色点到该点的距离的比值乘上一个系数来近似 arcsin 值，并且将其限制在 [0, 1] 范围内：<br>$$<br>min(k·\frac{SDF(p)}{|p - o|},1.0)<br>$$<br>这样近似不仅降低了计算开销，还能使软阴影更加灵活，因为 k 值越大，相当于在一个很小的安全角度阴影项就达到了 1.0，因此从0 到 1 的过渡就越陡峭，阴影和非阴影的边界就越明显，阴影也就越硬，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/2022-06-01144018.png" alt="2022-06-01 144018"></p><h4 id="6-3-距离场的优缺点"><a href="#6-3-距离场的优缺点" class="headerlink" title="6.3 距离场的优缺点"></a>6.3 距离场的优缺点</h4><p>相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，但是距离场是定义在三维空间中的，三维空间中的每个点的 SDF 都要存下来，需要非常大的存储开销，虽然有一些距离场的压缩算法，但相比于一张 Shadow Map 二维纹理，依然是极大的开销。</p><p>此外，使用距离场自然需要预先对一个场景计算其距离场，对于一些有形变的物体每次还要重新计算，也是一个很大开销，一个场景中有多个物体还要先计算点到不同物体表面的距离，再取所有距离的最小值作为该点的 SDF，当然也可以使用场景管理的 BVH 等数据结构来优化距离场的计算过程，下图是一个复杂场景的距离场可视化结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601144718966.png" alt="image-20220601144718966"></p><p>除了上面的缺点外，距离场实际上也存在一些 artifact，这里不赘述，有必要可以之后再做深入了解。</p><h3 id="7-Cascaded-Shadow-Maps（CSM）"><a href="#7-Cascaded-Shadow-Maps（CSM）" class="headerlink" title="7 Cascaded Shadow Maps（CSM）"></a>7 Cascaded Shadow Maps（CSM）</h3><p>CSM 也称为级联阴影，通常用于大型场景的实时阴影中，当场景很大的时候，在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率，否则就会造成阴影的严重锯齿。CSM 的思想是使用多张不同分辨率的阴影贴图，对于<strong>近处</strong>的场景使用<strong>较高分辨率</strong>的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。因为远处的对象只占画面的很少一部分像素，而近处的对象占据了画面的很大一部分，进行这样的处理显然非常合理。</p><p>CSM 根据场景的远近来划分 camera frustum，靠近 camera 的区域划分的较密，远离 camera 的区域划分的比较稀疏，这就使得靠近 camera 的区域能够使用一个相对较大分辨率的 shandow map，减少失真现象。CSM的具体流程如下：</p><ul><li>划分 camera frustum 成多个 subfrustum ;</li><li>计算每个小的 subfrustum 的包围盒；</li><li>对每个 subfrustum 生成投影矩阵；</li><li>对每个 subfrustum 生成一张 shadow map；</li><li>对每一个像素根据深度选择合适的 shadow map 生成阴影。</li></ul><p>CSM 几乎是现代游戏引擎中的标配算法，可以配合上面的软阴影生成算法在大型场景中达到很好的效果，并且保证时效性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（二）游戏引擎中的渲染系统</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-26T08:23:09.000Z</published>
    <updated>2022-05-26T08:27:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。</p><p><em><span id="more"></span></em></p><h3 id="1-GPU-架构"><a href="#1-GPU-架构" class="headerlink" title="1 GPU 架构"></a>1 GPU 架构</h3><p>GPU 是渲染系统使用的核心工具，要想使游戏引擎充分利用资源，就要对 GPU 的架构有所了解。关于现代 GPU 架构，这篇文章写的比较细致：<a href="https://zhuanlan.zhihu.com/p/406096300">现代渲染引擎开发-GPU架构</a>，这里只总结重点：</p><ul><li>SIMD是单指令多数据，一条指令处理多个数据，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155458175.png" alt="image-20220526155458175"></p><ul><li>SIMT是单指令多线程，N 卡使用这种方式，即单条指令在多个核上分多个线程执行</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155551595.png" alt="image-20220526155551595"></p><ul><li>GPU 中最重要的计算单元是 CU，N 卡中为 CUDA Core，还有专门支持光追的 RT Core 和支持 AI 运算的 Tensor Core 等，多个 CU 组成一个 GPC，也叫做 Shader Engine</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526160001900.png" alt="image-20220526160001900"></p><ul><li>GPU 对性能的瓶颈包括：内存瓶颈、ALU（整形运算单元）瓶颈、TMU（纹理映射单元）瓶颈、BW（带宽）瓶颈等</li></ul><h3 id="2-渲染资源管理"><a href="#2-渲染资源管理" class="headerlink" title="2 渲染资源管理"></a>2 渲染资源管理</h3><p>游戏中的所有对象被称为 GameObject（GO），每一个 GO 包含很多组件，比如模型、语音、动画等等，GO 之间还可以通过事件系统进行交流，并根据其他 GO 发来的消息做出响应。其中，与渲染相关的组件就称为 Renderable，Renderable 包含渲染这个 GO 所需的所有数据，包括顶点、法线、纹理坐标、材质、贴图等等。游戏引擎需要将这些数据高效地组织起来。</p><p>顶点数据的组织我们在 OpenGL 中已经了解，分为顶点数据和顶点索引，顶点索引就描述了所有图元由哪些顶点组成，因为很多图元之间会共享顶点，这样就不需要为每个图元单独存储顶点，从而避免资源浪费。</p><p>一个 GO 最重要的就是要有一个模型，模型由网格 Mesh 组成，因为模型的不同部位可能需要不同的材质，所以一个模型又分为了多个子 Mesh，称为 SubMesh，每个 SubMesh 有它对应的材质（Material），材质包含纹理（Texture）和 Shader 等，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161157448.png" alt="image-20220526161157448"></p><p>在实际的游戏中，许多游戏对象的 Renderable 可能是重复的，比如许多步兵 NPC，渲染它们需要的数据是完全一样的，如果为每个 GO 都存储一遍这些数据那将会是极大的浪费，因此游戏引擎将所有这些资源放入了资源池中，不同的 GO 只需要存储资源池中资源的索引即可，比如一个模型的 Mesh 对应 Mesh 池中的哪些图元，使用 Shader 池中的哪些 Shader 去渲染，这样就将资源紧凑的管理起来了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161435933.png" alt="image-20220526161435933"></p><p>这种管理方式也是游戏引擎中很常见的一种管理方式，用来应对资源复用的问题，不只是在渲染系统中，其他系统中也广泛使用了这种管理方式。因此每一个 GO 只是这些资源的组合，是实例化的资源。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161628614.png" alt="image-20220526161628614"></p><p>此外，因为不同的 GO 会有不同的材质，即使是一个 GO 也会在不同部位使用不同的材质，如果不做任何优化的进行渲染，会有大量的材质更新操作，即卸载掉这个材质的纹理和 Shader，并加载 另一个材质的纹理和 Shader，这样也会造成性能的下降，因此一般的做法是将 SubMesh 按照材质排序，将所有材质相同的 SubMesh 放在一起，这样只需要加载一次材质就可以渲染所有使用该材质的 SubMesh：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526162146227.png" alt="image-20220526162146227"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>关于透视插值校正</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/</id>
    <published>2022-05-25T08:51:00.000Z</published>
    <updated>2022-05-25T09:16:54.596Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。</p><p><em><span id="more"></span></em></p><h3 id="1-为什么需要透视插值校正"><a href="#1-为什么需要透视插值校正" class="headerlink" title="1 为什么需要透视插值校正"></a>1 为什么需要透视插值校正</h3><p>透视投影我们已经非常熟悉了，透视投影是为了模拟人眼所看到的近大远小的效果，比如一个正方形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/image-20220525160340619.png" alt="image-20220525160340619"></p><p>如果是正交投影，那么点 Q 就在 BC 连线中点处，而如果是透视投影，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/2022-05-25160428.png" alt="屏幕截图 2022-05-25 160428"></p><p>点 Q 就不再处于 BC 连线的中间处了，在我们的渲染器中纹理出现变形的原因就是我们在对顶点的纹理坐标进行插值的时候没有考虑透视的影响。如下图，红色坐标为纹理坐标，黑色为顶点位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-d6f128e3e3150d0ab3941dfdc452e111_r.jpg" alt="v2-d6f128e3e3150d0ab3941dfdc452e111_r"></p><p>当摄像机视线垂直于平面时，将贴图按照 uv 坐标插值，贴到正方形上会如右图所示，不会出现任何问题，但如果相机不垂直于平面：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-67871f21f22f9573e64d3bd30788c033_b.jpg" alt="v2-67871f21f22f9573e64d3bd30788c033_b"></p><p>本来按照正确的透视，正方形的中心点应该在 AC 和 BD 的交点 Q，我们应该把纹理坐标为 (0.5, 0.5) 的颜色值赋给 Q，但是图中却赋给了 P 点，这是因为我们在光栅化插值的时候，使用的是屏幕坐标进行的线性插值，屏幕坐标是投影后的坐标，是没有考虑近大远小的。</p><p>也就是说通，过屏幕坐标插值，可以得到 AC 的中点为点 P，AB 的中点为点 N，AD 的中点为点 M，这些都是投影后屏幕上线段的中点，而不是实际这个正方形在空间中线段的中点，因此就会出现纹理映射错误的情况。所以这时候我们就需要进行透视插值校正。</p><h3 id="2-如何进行透视插值校正"><a href="#2-如何进行透视插值校正" class="headerlink" title="2 如何进行透视插值校正"></a>2 如何进行透视插值校正</h3><p>我们在二维空间中进行推导会简单许多。下图为二维空间中的投影，因为是二维，所以我们把 x 坐标全部置 0，各种几何关系如图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-9ef76bf017541df6b268f0fc5d50f400_b.jpg" alt="v2-9ef76bf017541df6b268f0fc5d50f400_b"></p><p>二维空间中的线段 AB 被投影到 Z &#x3D; C 平面上，显示为线段 A’B’，利用投影平面的坐标进行插值可以得到：<br>$$<br>P’ &#x3D; (1-m)A’ + mB’<br>$$<br>于是现在的问题是，如何通过屏幕上的点 P‘ 得到空间中原本的点 P，并求出一个插值关系：<br>$$<br>P &#x3D; (1-n)A + nB<br>$$<br>最简单的方法自然是对点 P’ 应用透视投影变换的逆变换，但矩阵变换太麻烦，我们完全可以通过几何关系解决这个问题。</p><p>在图中添加两条辅助线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-1766a667c7a314f19092ecc00ea03b6b_b.jpg" alt="v2-1766a667c7a314f19092ecc00ea03b6b_b"></p><p>根据三角形相似可以得到：<br>$$<br>\frac{n}{1-n} &#x3D; \frac{|AG|}{|BK|} &#x3D; \frac{|A’P’|\frac{Z_1}{c}}{|B’P’|\frac{Z_2}{c}} &#x3D; \frac{mZ_1}{(1-m)Z_2}<br>$$<br>等式两边取倒数可得：<br>$$<br>\frac{1}{n} - 1 &#x3D; \frac{(1-m)Z_2}{mZ_1}<br>$$<br>由此可以解得：<br>$$<br>n &#x3D; \frac{mZ_1}{mZ_1 + (1-m)Z_2}<br>$$<br>这样我们就得到了已知屏幕空间的插值系数 m，求观察空间的插值系数 n 的方法。使用插值系数 n 就可以对顶点的任意属性进行插值了。比如点 P 的 Z 坐标：<br>$$<br>Z_n &#x3D; (1-n)Z_1 + nZ_2 &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}Z_1 + \frac{mZ_1}{mZ_1 + (1-m)Z_2}Z_2<br>$$<br>化简后得到：<br>$$<br>Z_n &#x3D; \frac{Z_1Z_2}{mZ_1 + (1-m)Z_2} &#x3D; \frac{1}{\frac{1-m}{Z_1} + \frac{m}{Z_2}}<br>$$<br>这样计算其他属性的插值就可以直接将 $Z_n$ 带入，为什么要将 $Z_n$ 带入呢？因为我们的观察方向都是沿着 -Z 轴方向，所以透视的缩放关系只和深度 Z 有关。比如求点 P 的纹理坐标：<br>$$<br>UV_P &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}UV_A + \frac{mZ_1}{mZ_1 + (1-m)Z_2}UV_B<br>$$<br>将 $Z_n$ 带入得：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-m}{Z_1}UV_A + \frac{m}{Z_2}UV_B)<br>$$<br>上式就是我们在代码中实现的，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的线性插值之后再乘以插值点的深度值，就完成了线性插值的透视校正。</p><p>现在推广到三维空间，可以得到：<br>$$<br>Z_n &#x3D; \frac{1}{\frac{1-u-v}{Z_1} + \frac{u}{Z_2} + \frac{v}{Z_3}}<br>$$<br>其中 u 和 v 是重心插值系数：<br>$$<br>P &#x3D; (1-u-v)A + uB + vC<br>$$<br>于是在三维空间中，点 P 的纹理坐标为：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-u-v}{Z_1}UV_A + \frac{u}{Z_2}UV_B + \frac{v}{Z_3}UV_C)<br>$$<br>于是同样的，在透视除法中，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的重心插值之后再乘以插值点的深度值，就完成了重心插值的透视校正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="3D数学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（九）改进光栅化</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2022-05-25T07:34:39.000Z</published>
    <updated>2022-05-25T09:05:15.976Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。</p><p><em><span id="more"></span></em></p><h3 id="1-边界函数算法"><a href="#1-边界函数算法" class="headerlink" title="1 边界函数算法"></a>1 边界函数算法</h3><p>关于边界函数算法，原理同样非常简单，就是用点和三角形三个顶点连线的向量叉乘来判断点是否在三角形内部，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/">【计算机图形学】（三）光栅化</a>，其中还包含了 C++ 代码实现。我们先照搬过来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓边界函数实际上就是上述代码中的 <code>(signOfAB * signofTrig &gt; 0)</code> 等这三个判断条件，因为这个条件判断了点和三角形的一条边界的位置关系，因此被称为边界函数。根据边界函数经过推导可以看出每次移动一个像素得到的边界函数和之前的边界函数的差值是固定的，具体推导过程可以查看<a href="https://zhuanlan.zhihu.com/p/140926917">图形学底层探秘 - 更现代的三角形光栅化与插值算法的实现与优化</a>，因此我们不需要每次都计算叉乘，只需要在前一次的结果上加上差值即可。</p><p>另一个问题是，我们对每个三角形的 Bounding Box 内的像素进行遍历来判断其是否在三角形内部，那么至少会有一半的像素不在三角形内而造成计算浪费，因此出现了分块优化算法，即将 Bounding Box 进行分块，然后只判断每块四个角上的像素是否在三角形内，如果每块的四个像素都在三角形内部或者外部，其他像素就不需要再进行判断了，如果四个像素部分在内部部分在外部就执行正常的算法在块内逐像素判断。这个方法对于占屏幕面积较大的三角形优化效果明显，但如果是小三角形或是斜长的细三角形，反而不如不分块来得快。而且，太大的分块会进一步降低小三角形的绘制效率，而太小的分块又变回了逐像素算法，因此分块的大小需要仔细的权衡。</p><h3 id="2-重心插值"><a href="#2-重心插值" class="headerlink" title="2 重心插值"></a>2 重心插值</h3><p>扫描线算法中使用线性插值就可以确定片元的各种属性值，而在边界函数算法中需要使用重心插值，关于重心坐标我们之前的笔记中也有具体的推导：<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a>中的第4部分。</p><p>在实现中我们如何计算重心坐标呢？首先整个三角形的面积可以通过：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}a·b·sin\theta<br>$$<br>来计算，也就是三角形两条边叉乘得到的向量模的一半，以 AB 和 BC 边为例，三角形的面积为：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}(A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx)<br>$$<br>而我们的三个边界函数相加：<br>$$<br>F_{AB}(P) + F_{BC}(P) + F_{CA}(P) &#x3D; A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx<br>$$<br>刚好是三角形面积的二倍，即：<br>$$<br>\frac{F_{AB}(P) + F_{BC}(P) + F_{CA}(P)} {2S_{\Delta} } &#x3D; 1<br>$$<br>而重心坐标就是小三角形面积和整个三角形面积的比值，因此我们可以直接通过边界函数得到点 P 的重心坐标：<br>$$<br>\alpha &#x3D; \frac{F_{AB}(P)} { {2S_{\Delta} } },\beta &#x3D; \frac{F_{BC}(P)} { {2S_{\Delta} } },\gamma &#x3D; \frac{F_{CA}(P)} { {2S_{\Delta} } }<br>$$<br>这样整个光栅化算法就完成了。需要注意的是重心插值和之前的线性插值一样，都需要进行透视插值校正，即在透视除法中将所有属性都除以 w 值，最后在片元着色器之前再乘以 w 值恢复。关于透视插值校正我们将在下一节详细讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（八）光源</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/</id>
    <published>2022-05-25T03:24:21.000Z</published>
    <updated>2022-05-25T03:25:42.269Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。</p><p><em><span id="more"></span></em></p><h3 id="1-光源概述"><a href="#1-光源概述" class="headerlink" title="1 光源概述"></a>1 光源概述</h3><p>在 RTR 一书中，作者将光源分为三种，分别是：平行光（direction）、点光源（point）和聚光灯（spot）。我们分别来实现这三种光源。</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h3><p>在实现光源之前我们需要一些函数和变量，首先是在 <code>Global.h</code> 中定义的环境光项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>还有计算反射方向的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射的计算 2n * cos(n,l) - l = r</span></span><br><span class="line"><span class="comment">// lightDir是光指向片元的方向</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> glm::vec3&amp; lightDir, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightDir - <span class="number">2</span> * glm::<span class="built_in">dot</span>(normal, lightDir) * normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-平行光"><a href="#3-平行光" class="headerlink" title="3 平行光"></a>3 平行光</h3><p>在实现各类光源之前我们先实现一个光源基类，这样其他光源都派生自该基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光源基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Color;</span><br><span class="line">    glm::vec3 Specular;</span><br><span class="line">    glm::vec3 Direction;</span><br><span class="line">    <span class="type">float</span> Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Light</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Light</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) :</span><br><span class="line">        <span class="built_in">Position</span>(pos),</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Direction</span>(dir),</span><br><span class="line">        <span class="built_in">Intensity</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是平行光，平行光不需要位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光，不需要位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DirectionLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) : </span><br><span class="line">        <span class="built_in">Light</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), color, specular, dir, i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们新建一个 <code>BlinnPhongShader</code> 类继承于基本的 Shader 类，在其中实现平行光的计算，并修改片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Light.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlinnPhongShader</span> : <span class="keyword">public</span> Shader &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量都要是单位向量</span></span><br><span class="line">    <span class="comment">// ViewDir是片元指向摄像机的方向</span></span><br><span class="line">    <span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcDirLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> DirectionLight&amp; dirLight,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -dirLight.Direction), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - dirLight.Direction);</span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">        glm::vec3 diffuse = dirLight.Color * diff * albedo;</span><br><span class="line">        glm::vec3 specular = dirLight.Specular * spec;</span><br><span class="line">        <span class="keyword">return</span> (diffuse + specular) * dirLight.Intensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">        glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">        glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">        glm::vec3 result = Ambient * albedo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">            result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个平行光：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光源</span></span><br><span class="line"><span class="function">DirectionLight <span class="title">dir</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">1.0</span>)</span></span>;</span><br><span class="line">dirLights = &amp;dir;</span><br><span class="line">dirLtNums = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用光照Shader</span></span><br><span class="line">BlinnPhongShader shader;</span><br><span class="line"><span class="comment">// 加载模型</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112039177.png" alt="image-20220525112039177"></p><h3 id="4-点光源"><a href="#4-点光源" class="headerlink" title="4 点光源"></a>4 点光源</h3><p>点光源无所谓方向，它向四周均匀发光，光照强度和距离成反比，我们使用常数项、一次项和二次项来控制光照衰减，首先是点光源类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点光源，不需要方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> Constant;        <span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> Linear;        <span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> Quadratic;    <span class="comment">// 二次项</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PointLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span></span><br><span class="line">    ) : <span class="built_in">Light</span>(pos, color, specular, glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), i), <span class="built_in">Constant</span>(c), <span class="built_in">Linear</span>(l), <span class="built_in">Quadratic</span>(q)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是计算点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算点光源</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcPtLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PointLight&amp; ptLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到光源的距离</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, ptLight.Position);</span><br><span class="line">    <span class="comment">// 强度衰减因子</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (ptLight.Constant + ptLight.Linear * distance +</span><br><span class="line">                               ptLight.Quadratic * (distance * distance));</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - ptLight.Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = ptLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = ptLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * ptLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入点光源贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PointLight <span class="title">pt</span><span class="params">(glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">ptLights = &amp;pt;</span><br><span class="line">ptLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112022188.png" alt="image-20220525112022188"></p><h3 id="5-聚光灯"><a href="#5-聚光灯" class="headerlink" title="5 聚光灯"></a>5 聚光灯</h3><p>聚光灯可以理解为手电筒，只有在与手电筒正方向夹角在一定范围内的像素才会被照亮。像素到光源位置的方向与光源正向夹角被称为切光角，切光角在设定范围内的像素，按照点光源的方式计算光照。切光角之外的像素不会被照亮。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525110724976.png" alt="image-20220525110724976"></p><p>为了避免边缘突变，可以设立一个外切光角，在内外切光角之间使用插值乘以计算结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span> : <span class="keyword">public</span> PointLight &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> innerCutOff;        <span class="comment">// 内切光角范围</span></span><br><span class="line">    <span class="type">float</span> outterCutOff;        <span class="comment">// 外切光角范围</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpotLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; icut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; ocut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5</span>))</span><br><span class="line">    ) : <span class="built_in">PointLight</span>(pos, color, specular, i, c, l, q), <span class="built_in">innerCutOff</span>(icut), <span class="built_in">outterCutOff</span>(ocut)</span><br><span class="line">    &#123;</span><br><span class="line">        Direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计算聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算聚光灯，切光角以内按点光源计算</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcSpLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SpotLight&amp; spLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - spLight.Position);</span><br><span class="line">    <span class="comment">// 切光角</span></span><br><span class="line">    <span class="type">float</span> theta = glm::<span class="built_in">dot</span>(lightDir, glm::<span class="built_in">normalize</span>(spLight.Direction));</span><br><span class="line">    <span class="comment">// 内外切光角插值系数</span></span><br><span class="line">    <span class="type">float</span> weight = <span class="built_in">saturate</span>((theta - spLight.outterCutOff) / (spLight.innerCutOff - spLight.outterCutOff));</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">Lerp</span>(<span class="number">0</span>, <span class="number">1</span>, weight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按点光源计算</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, spLight.Position);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (spLight.Constant + spLight.Linear * distance +</span><br><span class="line">                               spLight.Quadratic * (distance * distance));</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = spLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = spLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= (attenuation * intensity);</span><br><span class="line">    specular *= (attenuation * intensity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * spLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入聚光灯贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; spLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcSpLight</span>(*(spLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中加入聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="function">SpotLight <span class="title">sp</span><span class="params">(camera-&gt;Position, camera-&gt;Front)</span></span>;</span><br><span class="line">spLights = &amp;sp;</span><br><span class="line">spLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525111959282.png" alt="image-20220525111959282"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（七）加载模型</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-05-24T11:51:24.000Z</published>
    <updated>2022-05-24T11:52:25.830Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。</p><p><em><span id="more"></span></em></p><h3 id="1-模型、对象、网格的关系"><a href="#1-模型、对象、网格的关系" class="headerlink" title="1 模型、对象、网格的关系"></a>1 模型、对象、网格的关系</h3><p>在实现加载模型的功能之前，我们首先要了解模型由什么组成。一个模型（Model）包含多个对象（Object），每个对象拥有网格（Mesh）和材质（Material），网格存储了多边形的绘制信息，包括顶点位置、顶点法向、顶点纹理坐标，顶点索引；材质存储了光照和贴图信息，比如漫反射光颜色、镜面反射光颜色、镜面反射光泽度、纹理贴图信息等。所有这些数据都提供给 Shader 来使用，因此一个 Shader 需要绑定一个材质才能发挥作用。</p><h3 id="2-材质与对象类"><a href="#2-材质与对象类" class="headerlink" title="2 材质与对象类"></a>2 材质与对象类</h3><p>了解了这些关系后，我们开始实现相应的类。首先是材质类，最简单的材质包括漫反射颜色、镜面反射颜色、Glossy 扰动和一张主纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 材质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准光照材质包括</span></span><br><span class="line"><span class="comment">//漫反射颜色 镜面反射颜色 镜面反射强度</span></span><br><span class="line"><span class="comment">//纹理一张</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec4 Specular;</span><br><span class="line">    <span class="type">int</span> Gloss;</span><br><span class="line">    Texture* MainTex;</span><br><span class="line">    Shader* shader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Material</span>() :</span><br><span class="line">        <span class="built_in">Color</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Specular</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Gloss</span>(<span class="number">32</span>),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Material</span>(<span class="type">const</span> glm::vec4&amp; color, <span class="type">const</span> glm::vec4&amp; specular, <span class="type">const</span> <span class="type">int</span>&amp; gloss) :</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Gloss</span>(gloss),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Material</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetShader</span><span class="params">(Shader* s)</span> </span>&#123;</span><br><span class="line">        shader = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTexture</span><span class="params">(Texture* t)</span> </span>&#123;</span><br><span class="line">        MainTex = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后是 Object 类，一个 Object 包含一个 Mesh 和一个 Material：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Object类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    Material material;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Mesh&amp; m, <span class="type">const</span> Material&amp; mat) &#123;</span><br><span class="line">        mesh = m;</span><br><span class="line">        material = mat;</span><br><span class="line">    &#125;</span><br><span class="line">    Object&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3 模型类"></a>3 模型类</h3><p>最后是模型类，模型类需要能够加载 obj 模型并解析，之前在图形学中我们了解过 obj 文件的格式，这里再复习一遍。</p><p>一个典型的 obj 文件使用记事本打开可以看到如下格式，这里使用我们项目中用到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 3ds Max Wavefront OBJ Exporter v0.97b - (c)2007 guruware</span><br><span class="line"># File Created: 04.08.2011 15:18:00</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object01</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">v  -7.0063 72.8042 6.8872</span><br><span class="line">v  -6.9854 72.8711 8.2541</span><br><span class="line">v  -7.8984 74.1601 6.7762</span><br><span class="line">......</span><br><span class="line"># 65 vertices</span><br><span class="line"></span><br><span class="line">vn -0.8222 -0.5678 0.0404</span><br><span class="line">vn -0.7979 -0.5926 0.1101</span><br><span class="line">vn -0.8362 -0.5469 0.0396</span><br><span class="line">......</span><br><span class="line"># 70 vertex normals</span><br><span class="line"></span><br><span class="line">vt 0.4465 -0.7212 0.0000</span><br><span class="line">vt 0.4014 -0.7905 0.0000</span><br><span class="line">vt 0.4932 -0.8096 0.0000</span><br><span class="line">......</span><br><span class="line"># 36 texture coords</span><br><span class="line"></span><br><span class="line">g Object01</span><br><span class="line">s 1</span><br><span class="line">f 1/1/1 2/2/2 3/3/3 </span><br><span class="line">s 2</span><br><span class="line">f 3/3/4 2/2/2 4/4/5 </span><br><span class="line">s 3</span><br><span class="line">f 5/5/6 2/2/2 1/1/1 </span><br><span class="line">......</span><br><span class="line"># 0 polygons - 104 triangles</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object02</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>每一个 Object 下面都有 v、vn、vt 和 g、s、f 开头的数据，它们分别代表：</p><ul><li>v（vertex） ：后面记录了一个顶点坐标</li><li>vn（vertex normal）：后面记录了一个法线</li><li>vt（vertex texcood）：后面记录了一个纹理坐标</li><li>g（geometry）：代表下面将开始几何信息</li><li>s：后面跟图元编号</li><li>f（face）：后面后面记录了一个面的三个顶点所使用的顶点坐标、法线和纹理坐标（也可以是四个或者多个组成多边形）</li><li>5&#x2F;5&#x2F;6：表示该顶点使用第 5 个 v，第 5 个 vn，第 6 个 vt，这个索引是全局的</li></ul><p>于是我们可以实现模型 Model 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Model类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Object&gt; objects;</span><br><span class="line">    <span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> std::string&amp; path) &#123;</span><br><span class="line">        <span class="built_in">LoadObj</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Model&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;model == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMaterial</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; id, <span class="type">const</span> Material&amp; m)</span> </span>&#123;</span><br><span class="line">        objects[id].material = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadObj</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Open Obj File Error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;glm::vec3&gt; vertexs;</span><br><span class="line">        std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line">        std::vector&lt;glm::vec2&gt; texcoords;</span><br><span class="line"></span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> currentObjectNums = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">            <span class="comment">// 顶点数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    currentObjectNums++;</span><br><span class="line">                    Object o;</span><br><span class="line">                    objects.<span class="built_in">push_back</span>(o);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 v;</span><br><span class="line">                iss &gt;&gt; v.x;</span><br><span class="line">                iss &gt;&gt; v.y;</span><br><span class="line">                iss &gt;&gt; v.z;</span><br><span class="line">                vertexs.<span class="built_in">push_back</span>(v);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 法线数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vn &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vn;</span><br><span class="line">                iss &gt;&gt; vn.x;</span><br><span class="line">                iss &gt;&gt; vn.y;</span><br><span class="line">                iss &gt;&gt; vn.z;</span><br><span class="line">                normals.<span class="built_in">push_back</span>(vn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纹理坐标</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vt;</span><br><span class="line">                iss &gt;&gt; vt.x;</span><br><span class="line">                iss &gt;&gt; vt.y;</span><br><span class="line">                vt.y = <span class="number">1</span> - vt.y;</span><br><span class="line">                <span class="comment">// 纹理坐标z为0</span></span><br><span class="line">                iss &gt;&gt; vt.z;</span><br><span class="line">                texcoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>(vt.x, vt.y));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 图元数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                <span class="type">char</span> bar;</span><br><span class="line">                <span class="type">int</span> vIndex, vtIndex, vnIndex;</span><br><span class="line">                <span class="comment">//解析每个顶点数据 eg：1/1/1</span></span><br><span class="line">                <span class="type">int</span> offset = objects[currentObjectNums].mesh.VBO.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    iss &gt;&gt; vIndex &gt;&gt; bar &gt;&gt; vtIndex &gt;&gt; bar &gt;&gt; vnIndex;</span><br><span class="line">                    <span class="function">Vertex <span class="title">vertex</span><span class="params">(vertexs[vIndex - <span class="number">1</span>], glm::vec4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), texcoords[vtIndex - <span class="number">1</span>], normals[vnIndex - <span class="number">1</span>])</span></span>;</span><br><span class="line">                    objects[currentObjectNums].mesh.VBO.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">                    objects[currentObjectNums].mesh.EBO.<span class="built_in">push_back</span>(offset + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-绘制模型"><a href="#4-绘制模型" class="headerlink" title="4 绘制模型"></a>4 绘制模型</h3><p>接下来在我们原来的 <code>DarwMesh</code> 函数基础上，稍作修改实现绘制对象和绘制模型的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制一个模型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawModel</span><span class="params">(Model&amp; model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.objects.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">DrawObject</span>(model.objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawObject</span><span class="params">(Object&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentMat = &amp;obj.material;</span><br><span class="line">    currentMat-&gt;shader-&gt;texture = currentMat-&gt;MainTex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj.mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = obj.mesh.VBO[obj.mesh.EBO[i]];</span><br><span class="line">        p2 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>修改主函数，加载模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;Model.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用标准Shader</span></span><br><span class="line">    Shader shader;</span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    Material bodyMat;</span><br><span class="line">    bodyMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">bodyTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_body02.jpg&quot;</span>)</span></span>;</span><br><span class="line">    bodyMat.<span class="built_in">SetTexture</span>(&amp;bodyTexture);</span><br><span class="line"></span><br><span class="line">    Material faceMat;</span><br><span class="line">    faceMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">faceTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex002f_body01.jpg&quot;</span>)</span></span>;</span><br><span class="line">    faceMat.<span class="built_in">SetTexture</span>(&amp;faceTexture);</span><br><span class="line"></span><br><span class="line">    Material mouseMat;</span><br><span class="line">    mouseMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">mouseTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_mouse.jpg&quot;</span>)</span></span>;</span><br><span class="line">    mouseMat.<span class="built_in">SetTexture</span>(&amp;mouseTexture);</span><br><span class="line"></span><br><span class="line">    Material eyeMat;</span><br><span class="line">    eyeMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">eyeTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex001f_eye.jpg&quot;</span>)</span></span>;</span><br><span class="line">    eyeMat.<span class="built_in">SetTexture</span>(&amp;eyeTexture);</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">model</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\neptune.obj&quot;</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">0</span>, mouseMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">1</span>, faceMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">2</span>, bodyMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">3</span>, eyeMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建箱子</span></span><br><span class="line">    Mesh box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    Material mat;</span><br><span class="line">    mat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">boxt</span><span class="params">(TEXTURE_PATH)</span></span>;</span><br><span class="line">    mat.<span class="built_in">SetTexture</span>(&amp;boxt);</span><br><span class="line">    <span class="function">Object <span class="title">obj</span><span class="params">(box, mat)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line">    <span class="comment">// 改变渲染模式，默认为纹理填充，改变后为只绘制边框</span></span><br><span class="line">    <span class="comment">//dw-&gt;ChangeRenderMode();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    ViewMatrix = camera-&gt;<span class="built_in">ViewMatrix</span>();</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    ProjectMatrix = camera-&gt;<span class="built_in">PerspectiveMatrix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将箱子左移两单位</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 让箱子在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">0.0</span>;</span><br><span class="line">    ModelMatrix *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="comment">// 旋转后要更新法线</span></span><br><span class="line">    <span class="built_in">UpdateNormalMatrix</span>();</span><br><span class="line">    <span class="comment">// 绘制箱子</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawObject</span>(obj);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 因为模型太大，需要缩小100倍</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/Model1.png" alt="Model1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（六）剔除与裁剪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2022-05-24T03:16:46.000Z</published>
    <updated>2022-05-24T03:30:36.765Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。</p><p><em><span id="more"></span></em></p><h3 id="1-剔除和裁剪概览"><a href="#1-剔除和裁剪概览" class="headerlink" title="1 剔除和裁剪概览"></a>1 剔除和裁剪概览</h3><p>在整个渲染管线中，需要进行多次剔除与裁剪，分别是：视锥剔除、正面&#x2F;背面剔除、齐次裁剪。</p><ul><li>视锥剔除一般发生在 CPU 阶段，通过 AABB、OBB 等将物体包围起来，然后与视锥体做碰撞检测，可以直接剔除掉完全不可见的物体，运算量较低但精度也较低。</li><li>正面&#x2F;背面剔除在顶点着色器之后，齐次裁剪之前进行，将不需要渲染的图元直接剔除掉；一般来说这一步也可以在齐次裁剪之后进行，因为操作比较简单，所以可以在世界空间运算也可以在 NDC 中运算，取决于管线的设计。</li><li>齐次裁剪自然是在裁剪空间中进行，即顶点着色器之后，透视除法之前。在透视除法之前是因为如果有物体在摄像机的位置，会出现 w &#x3D; 0 ，做透视除法的时候会出现除零错误。这一阶段是将在视口外的图元丢弃，一部分在视口内的图元，会进行裁剪，生成新的多边形。当然做裁剪的性能消耗也不小，很多情况下裁剪之后并不比直接把原来的多边形画出来丢弃一部分更快，尤其是 GPU 并不适合做这种判断条件比较多的工作。现代 GPU 通常是用一个比视口大很多（10倍以上？）的虚拟视口来裁剪，那种超出一点点的，就直接画了吧，GPU 性能没那么捉襟见肘。</li></ul><h3 id="2-视锥剔除"><a href="#2-视锥剔除" class="headerlink" title="2 视锥剔除"></a>2 视锥剔除</h3><p>视锥剔除首先要计算物体的包围盒，一般来说如果场景管理使用 BVH 的话，层次包围盒已经计算好了，直接遍历整个 BVH 树即可。然后获得视锥体的六个面的方程，用包围盒和六个面进行碰撞检测，具体实现可以有很多种方法，这里我们实现世界空间下的视锥剔除，流程如下：</p><ul><li>计算包围要绘制物体的 AABB（世界空间），实际我们逐图元计算，剔除掉完全在视锥体外的图元，这样一来就和后面的齐次裁剪中的剔除所做的工作几乎一样了，但这里只是为了学习原理，实际的渲染管线中是利用 BVH 等来剔除掉完全不在视锥体内的物体，而图元是在齐次裁剪的时候剔除的</li><li>获得视锥体六个面的平面方程（世界空间）</li><li>判断 AABB 的顶点在六个面的内侧还是外侧，也可以判断最小点和最大点，实现方法不唯一</li><li>剔除掉所有顶点完全在某一面外侧的物体，我们这里是图元</li></ul><h4 id="2-1-获取视锥平面方程"><a href="#2-1-获取视锥平面方程" class="headerlink" title="2.1 获取视锥平面方程"></a>2.1 获取视锥平面方程</h4><p>那么如何获取视锥体六个平面的方程呢？通过 MVP 变换矩阵就可以直接得出，并且使用 MVP 三个矩阵的不同组合可以得出不同空间下的视锥体平面方程。具体推导的原文可以查看：<a href="http://www8.cs.umu.se/kurser/5DV180/VT18/lab/plane_extraction.pdf">Fast Extraction of Viewing Frustum Planes from the WorldView-Projection Matrix</a></p><p>我们首先定义一个顶点 $v &#x3D; (x, y, z, w&#x3D;1)$，以及一个 4 * 4 的矩阵 $$M &#x3D; m_{ij}$$，这个矩阵可以是投影矩阵 P，也可以是 VP，还可以是 MVP，总之经过矩阵 $M$ 后，顶点 $v$ 就被转换到了一个规范立方体中变为 $v’ &#x3D; (x’, y’, z’, w’)$，这个过程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523110857514.png" alt="image-20220523110857514"></p><p>规范立方体的范围是 [-w’, w’]，因此如果这个顶点在立方体内，那么必须满足：</p><ul><li>-w’ &lt; x’ &lt; w’</li><li>-w’ &lt; y’ &lt; w’</li><li>-w’ &lt; z’ &lt; w’</li></ul><p>这实际上描述了顶点和视锥体六个平面的关系，原文中以下表列出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111017102.png" alt="image-20220523111017102"></p><p>现在以顶点和左侧平面的关系为例，只需要判断 -w’ &lt; x’ 就可以了，根据矩阵乘法，可以得出：<br>$$<br>-w’ &lt; x’ \Rightarrow -(row4 · v) &lt; (row1 · v)<br>$$<br>于是可以进一步得到：<br>$$<br>(row1 + row4) · v &gt; 0<br>$$<br>将矩阵元素带入展开可以写成：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44})*w &gt; 0<br>$$<br>由于 $w &#x3D; 1$，因此可以写为：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44}) &gt; 0<br>$$<br>这实际上已经得到了视锥体左平面的方程，因为空间中一个平面可以表示为 $$Ax + By + Cz + D &#x3D; 0$$，所以视锥体左平面的方程中：<br>$$<br>A &#x3D; m_{11}+m_{41},\ B &#x3D; m_{12}+m_{42},\ C &#x3D; m_{13}+m_{43},\ D &#x3D; m_{14}+m_{44}<br>$$<br>类似的可以得出其他几个面的方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111837599.png" alt="image-20220523111837599"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111857255.png" alt="image-20220523111857255"></p><p>上面说过， 4 * 4 的矩阵 $$M$$ 可以是投影矩阵 P，也可以是 VP，还可以是 MVP，不同的组合得到的视锥体平面方程是不同空间下的：</p><ul><li>当矩阵是 P 时，得到的是观察空间下的平面</li><li>当矩阵是 VP 时，得到的是世界空间下的平面</li><li>当矩阵是 MVP 时，得到的是模型空间下的平面</li></ul><h4 id="2-2-判断顶点与平面的关系"><a href="#2-2-判断顶点与平面的关系" class="headerlink" title="2.2 判断顶点与平面的关系"></a>2.2 判断顶点与平面的关系</h4><p>顶点与平面的关系判断非常简单，类似于二维中点和直线的关系，将顶点坐标 $(x, y, z)$ 带入平面方程计算得到点到平面的距离 $$d &#x3D; Ax + By + Cz + D$$：</p><ul><li>d &gt; 0 时，点在平面法向所指的区域</li><li>d &lt; 0 时，点在平面法向反方向所指的区域</li><li>d &#x3D; 0 时，点在平面上</li></ul><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>我们使用世界空间下的视锥体剔除，首先在 <code>math.h</code> 中加入视锥体六个平面的方程以及点和平面的关系判断函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视锥体的六个平面方程（世界空间下，传入的是 VP 矩阵），用于视锥剔除</span></span><br><span class="line"><span class="comment">// 所得的平面法向都是指向视锥体内部的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewingFrustumPlanes</span><span class="params">(std::vector&lt;glm::vec4&gt;&amp; result, <span class="type">const</span> glm::mat4&amp; vp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左侧  </span></span><br><span class="line">    result[<span class="number">0</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//右侧</span></span><br><span class="line">    result[<span class="number">1</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//上侧</span></span><br><span class="line">    result[<span class="number">2</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//下侧</span></span><br><span class="line">    result[<span class="number">3</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Near</span></span><br><span class="line">    result[<span class="number">4</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//Far</span></span><br><span class="line">    result[<span class="number">5</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点到平面距离 d =  Ax + By + Cz + D;</span></span><br><span class="line"><span class="comment">// d &lt; 0 点在平面法向反方向所指的区域</span></span><br><span class="line"><span class="comment">// d &gt; 0 点在平面法向所指的区域</span></span><br><span class="line"><span class="comment">// d = 0 在平面上</span></span><br><span class="line"><span class="comment">// d &lt; 0 返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point2Plane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    <span class="keyword">return</span> sb &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于管理，我们新建一个 <code>Cull.h</code> 来管理各类剔除函数，目前只有视锥体剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界空间的视锥剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFrustumCull</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::vec4&gt; ViewPlanes, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果三个顶点都在某一个平面外侧，则剔除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">3</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">4</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 远平面只保留完全在内的图元，部分在内的直接丢掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">5</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入视锥体剔除，一般来说应该在 CPU 阶段进行，但是我们为了方便将视锥体剔除放在顶点着色器之后，因为顶点着色器之后才知道世界空间下的坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line">    <span class="comment">// 视锥体剔除用到的视锥体平面</span></span><br><span class="line">    std::vector&lt;glm::vec4&gt; ViewPlanes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除开关</span></span><br><span class="line">    <span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Draw</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        shader = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取视锥体六个平面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateViewPlanes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ViewingFrustumPlanes</span>(ViewPlanes, ProjectMatrix * ViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            Vertex p1, p2, p3;</span><br><span class="line">            p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">            p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">            p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">            <span class="comment">//顶点着色器变换到裁剪空间</span></span><br><span class="line">            V2F v1, v2, v3;</span><br><span class="line">            v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">            v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">            v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视锥体剔除</span></span><br><span class="line">            <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">            <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">            v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">            v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-正面-x2F-背面剔除"><a href="#3-正面-x2F-背面剔除" class="headerlink" title="3 正面&#x2F;背面剔除"></a>3 正面&#x2F;背面剔除</h3><p>经过视锥体剔除将所有完全不在视锥体内的图元剔除掉之后，剩下的图元要么完全在视锥体内，要么部分在视锥体内，对于部分在视锥体内的图元需要进行裁剪，但因为裁剪是计算量较大的操作，为了进一步减少无用的运算，在此之前还要根据需要将背面（有时也需要将正面的剔除）的图元剔除掉，这一步操作比较简单，我们在世界空间计算。根据观察方向和图元的法线方向的夹角来判断图元是正对我们还是背对我们，原理在之前的 RTR 总结中有介绍，这里不再赘述。</p><p>也可以先做齐次裁剪，透视除法之后在 NDC 中进行正面&#x2F;背面剔除，但要注意 NDC 是左手系，观察方向恒定为 (0, 0, 1)。无论在哪里计算，原理都是一样的。</p><p>在 <code>Cull.h</code> 中加入正面&#x2F;背面剔除函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正面/背面</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Face</span> &#123;</span><br><span class="line">    Back,</span><br><span class="line">    Front</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界空间的面剔除，剔除正向面或者逆向面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFaceCull</span><span class="params">(Face face, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叉乘得到法向量</span></span><br><span class="line">    glm::vec3 tmp1 = glm::<span class="built_in">vec3</span>(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);</span><br><span class="line">    glm::vec3 tmp2 = glm::<span class="built_in">vec3</span>(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);</span><br><span class="line">    glm::vec3 normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(tmp1, tmp2));</span><br><span class="line">    <span class="comment">// 世界空间下的观察方向</span></span><br><span class="line">    glm::vec3 view = camera-&gt;Front;</span><br><span class="line">    <span class="comment">// 也可以在NDC中剔除，这时观察方向恒定为(0, 0, 1)，但上面的叉乘顺序顺序要颠倒一下，因为NDC是左手系</span></span><br><span class="line">    <span class="comment">//glm::vec3 view = glm::vec3(0, 0, 1);</span></span><br><span class="line">    <span class="keyword">if</span> (face == Back)</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入正面&#x2F;背面剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 剔除开关</span></span><br><span class="line"><span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="type">bool</span> FaceCull;</span><br><span class="line">Face CullMode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisableFaceCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableFaceCull</span><span class="params">(Face f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">true</span>;</span><br><span class="line">    CullMode = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldSpaceCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 光栅化</span></span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-齐次裁剪"><a href="#4-齐次裁剪" class="headerlink" title="4 齐次裁剪"></a>4 齐次裁剪</h3><p>最后是比较麻烦的齐次裁剪，之前说过，渲染管线中进行齐次裁剪的位置是<strong>投影之后，透视除法之前</strong>，我们知道，在世界空间和观察空间中，一个点的坐标是 (X, Y, Z, 1)，经过透视投影之后变为 (X’, Y’, Z’, -Z)，再除以 W 坐标变化到 NDC 中 (X’&#x2F;-Z, Y’&#x2F;-Z, Z’&#x2F;-Z, 1)。这其中，如果一个点在观察者的身后，其观察坐标 Z 会大于 0（观察空间是右手系），那么透视投影之后 W 会小于 0，进行透视除法会导致顶点的 X, Y 坐标上下左右翻转。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523175755959.png" alt="image-20220523175755959"></p><p>并且如果一个物体在相机平面上，会在透视除法时导致除零错误。</p><p>透视投影之后，透视除法之前的坐标空间被称为裁剪空间，也叫齐次（裁剪）空间，它实质上是一个四维空间，变换到齐次空间的顶点之间仍然是线性相关的（可以直接使用线性插值而不是透视插值）。这是因为透视除法将所有坐标除以 w 才会真正破坏顶点之间的线性关系，所以也有这种说法：<strong>真正的投影是通过透视除法完成的</strong>。</p><p>这时，在视锥体中的点一定满足如下条件：</p><ul><li>$-w &lt; x,y,z &lt; w$</li><li>$near&lt;w&lt;far$</li></ul><p>如果不满足这个条件的点，就需要被剔除，因此我们可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 裁剪空间剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClipSpaceCull</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三个点的w都在near或far之外则需要剔除</span></span><br><span class="line">    <span class="keyword">if</span> (v1.w &lt;= camera-&gt;Near &amp;&amp; v2.w &lt;= camera-&gt;Near &amp;&amp; v3.w &lt;= camera-&gt;Near)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.w &gt;= camera-&gt;Far &amp;&amp; v2.w &lt;= camera-&gt;Far &amp;&amp; v3.w &lt;= camera-&gt;Far)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 任意一个点在规范立方体内则不需要剔除，等待进行下一步裁剪</span></span><br><span class="line">    <span class="keyword">if</span> (v1.x &lt;= v1.w || v1.y &lt;= v1.w || v1.z &lt;= v1.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2.x &lt;= v2.w || v2.y &lt;= v2.w || v2.z &lt;= v2.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v3.x &lt;= v3.w || v3.y &lt;= v3.w || v3.z &lt;= v3.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对没有被剔除的片元进行裁剪，使用 <strong>Sutherland-Hodgeman 裁剪算法</strong>，也叫做逐边裁剪算法，它的原理很简单，在二维中就是每次使用裁剪框的一条边去裁剪多边形的每一条边，生成新的顶点并作为下一条裁剪边的输入，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220524094004535.png" alt="image-20220524094004535"></p><p>这个算法在齐次空间也同样适用（而且可以推广到任意维），与二维的区别是，裁剪平面变为了 6 个，而不是四条线了。</p><p>使用点到平面的距离来判断点在平面的内外，和之前的计算方法类似，之前的计算方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool Point2Plane(const glm::vec3&amp; v, const glm::vec4&amp; p) &#123;</span><br><span class="line"></span><br><span class="line">    float sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    return sb &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只适用于世界空间或者观察空间等 w 为 1 的空间中，而我们现在是在裁剪空间，顶点的 w 值不为 1， 因此不能省略顶点的 w，所以需要重新写一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在裁剪平面法线所指方向，即内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inside</span><span class="params">(<span class="type">const</span> glm::vec4&amp; line, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line.x * p.x + line.y * p.y + line.z * p.z + line.w * p.w &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还需要一个函数直接判断三个顶点是否都在视口内，这样就无需裁剪了，也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有顶点都在内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AllVertexsInside</span><span class="params">(<span class="type">const</span> std::vector&lt;V2F&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.x) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.y) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.z) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是计算两个点连线与平面的交点，这可以通过插值实现，分别在一个平面两侧的两个点 A 和 B，它们连线与平面的交点 C 可以通过权重 da &#x2F; (da - db) 从 A 到 B 插值得到。其中 da 和 db 分别是点 A 和 B 到裁剪平面的距离，可以通过上面函数的方法计算得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交点，通过端点插值得到</span></span><br><span class="line"><span class="function">V2F <span class="title">Intersect</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> glm::vec4&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> da = v1.windowPos.x * line.x + v1.windowPos.y * line.y + v1.windowPos.z * line.z + v1.windowPos.w * line.w;</span><br><span class="line">    <span class="type">float</span> db = v2.windowPos.x * line.x + v2.windowPos.y * line.y + v2.windowPos.z * line.z + v2.windowPos.w * line.w;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> weight = da / (da - db);</span><br><span class="line">    <span class="keyword">return</span> V2F::<span class="built_in">lerp</span>(v1, v2, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 Sutherland-Hodgeman 裁剪算法，代码很好理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SutherlandHodgeman裁剪算法</span></span><br><span class="line"><span class="comment">// 输入三个顶点，输出裁剪后的顶点组</span></span><br><span class="line"><span class="function">std::vector&lt;V2F&gt; <span class="title">SutherlandHodgeman</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;V2F&gt; output = &#123; v1,v2,v3 &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AllVertexsInside</span>(output)) &#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ViewLines.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;V2F&gt; <span class="title">input</span><span class="params">(output)</span></span>;</span><br><span class="line">        output.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            V2F current = input[j];</span><br><span class="line">            V2F last = input[(j + input.<span class="built_in">size</span>() - <span class="number">1</span>) % input.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], current.windowPos)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                    V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                    output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">                &#125;</span><br><span class="line">                output.<span class="built_in">push_back</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在渲染流程中加入裁剪，因为裁剪后生成了新的顶点，所以要做比较多的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了能更方便看出裁剪效果，我们加入了渲染模式选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RenderMode</span> &#123;</span><br><span class="line">    Line,    <span class="comment">// 仅绘制边框</span></span><br><span class="line">    Fill    <span class="comment">// 绘制图形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变渲染模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChangeRenderMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (renderMode == Fill)</span><br><span class="line">        renderMode = Line;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        renderMode = Fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新增一个画线算法，使用 BresenhamLine 画线算法，原理比较简单，具体可以查看<a href="https://blog.csdn.net/yzh1994414/article/details/82860187">Bresenham 算法原理</a>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ****************** BresenhamLine画线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">const</span> V2F&amp; from, <span class="type">const</span> V2F&amp; to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = to.windowPos.x - from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> dy = to.windowPos.y - from.windowPos.y;</span><br><span class="line">    <span class="type">int</span> Xstep = <span class="number">1</span>, Ystep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Xstep = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Ystep = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> currentX = from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> currentY = from.windowPos.y;</span><br><span class="line">    V2F tmp;</span><br><span class="line">    <span class="comment">//斜率小于1</span></span><br><span class="line">    <span class="keyword">if</span> (dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dy - dx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dx));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentX += Xstep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentY += Ystep;</span><br><span class="line">                P += <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//斜率大于1，利用对称性画</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dx - dy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dy; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dy));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentY += Ystep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dx;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentX += Xstep;</span><br><span class="line">                P -= <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>现在来测试一下上面实现的裁剪吧，因为可以只渲染边框，可以清楚的看到每个面的渲染情况。</p><p>我们首先关闭背面剔除，得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/NonCull.png" alt="NonCull"></p><p>然后开启背面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/BackCull.png" alt="BackCull"></p><p>试试开启正面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/FrontCull.png" alt="FrontCull"></p><p>接下来将正方体移动到屏幕边缘，测试裁剪效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/Clip.png" alt="Clip"></p><p>可以看到裁剪产生的新的图元。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（五）相机</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-05-23T08:19:01.000Z</published>
    <updated>2022-05-23T08:20:35.725Z</updated>
    
    <content type="html"><![CDATA[<p>上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。</p><p><em><span id="more"></span></em></p><p>MVP 矩阵中， M 矩阵负责改变模型在世界空间的位置和姿态，V 矩阵需要相机位置和相机的三个向量（up、right、front）来确定，P 矩阵跟视场大小、宽高比和远近平面位置有关。因此相机类主要负责管理确定 V 和 P 矩阵的参数。</p><p>这里相机类的实现可以参考之前光线追踪器中的相机类，只需要给定相机的位置、lookat 位置和在世界空间的 up 方向就可以确定相机的三个向量 up、right 和 front；对于相机旋转，我们使用欧拉角，由于大部分第一人称游戏也不支持滚转角旋转，因此我们也只实现俯仰角和偏航角，具体计算方法也很简单，以（0, 0, -1）为默认观察方向：</p><ul><li>对于每一个 front 向量，将其投影到 XOZ  平面（即把 y 置 0 再单位化）</li><li>front 向量和投影向量的夹角即为俯仰角，需要注意俯仰角不能超过 90 度否则整个视野会倒过来</li><li>投影向量与（0, 0, -1）的夹角为偏航角</li></ul><p>由此我们可以写出相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line">    <span class="comment">// 视场和宽高比</span></span><br><span class="line">    <span class="type">float</span> Fov;</span><br><span class="line">    <span class="type">float</span> Aspect;</span><br><span class="line">    <span class="comment">// 远近平面距离</span></span><br><span class="line">    <span class="type">float</span> Near;</span><br><span class="line">    <span class="type">float</span> Far;</span><br><span class="line">    <span class="comment">// 俯仰和偏航角</span></span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(</span><br><span class="line">        glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">        glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3 lookat = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        <span class="type">float</span> fov = <span class="number">60.0f</span>,</span><br><span class="line">        <span class="type">int</span> w = <span class="number">800</span>,</span><br><span class="line">        <span class="type">int</span> h = <span class="number">600</span>,</span><br><span class="line">        <span class="type">float</span> n = <span class="number">0.3f</span>,</span><br><span class="line">        <span class="type">float</span> f = <span class="number">100</span></span><br><span class="line">    ) :</span><br><span class="line">        <span class="built_in">Position</span>(position), <span class="built_in">WorldUp</span>(up), <span class="built_in">Fov</span>(glm::<span class="built_in">radians</span>(fov)), <span class="built_in">Aspect</span>((<span class="type">float</span>)w / h), <span class="built_in">Pitch</span>(<span class="number">0</span>), <span class="built_in">Yaw</span>(<span class="number">0</span>), <span class="built_in">Near</span>(n), <span class="built_in">Far</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(lookat - Position);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Front 向量计算欧拉角</span></span><br><span class="line">        <span class="function">glm::vec3 <span class="title">WorldFront</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        glm::vec3 FrontXZ = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(Front.x, <span class="number">0</span>, Front.z));</span><br><span class="line">        <span class="type">float</span> yd = glm::<span class="built_in">dot</span>(WorldFront, FrontXZ);</span><br><span class="line">        <span class="type">float</span> pd = glm::<span class="built_in">dot</span>(Front, FrontXZ);</span><br><span class="line">        <span class="keyword">if</span> (yd &gt; <span class="number">1.0</span>)</span><br><span class="line">            yd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (yd &lt; <span class="number">-1</span>)</span><br><span class="line">            yd = <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &gt; <span class="number">1.0</span>)</span><br><span class="line">            pd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &lt; <span class="number">-1</span>)</span><br><span class="line">            pd = <span class="number">-1.0</span>;</span><br><span class="line">        Yaw = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(yd));</span><br><span class="line">        Pitch = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(pd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">ViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetViewMatrix</span>(Position, Front, Right, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">PerspectiveMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPerspectiveMatrix</span>(Fov, Aspect, Near, Far);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateFov</span><span class="params">(<span class="type">float</span> fov = <span class="number">60.0f</span>)</span> </span>&#123;</span><br><span class="line">        Fov = glm::<span class="built_in">radians</span>(fov);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateAspect</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        Aspect = (<span class="type">float</span>)w / h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改俯仰角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotatePitch</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Pitch += angle;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0</span>)</span><br><span class="line">            Pitch = <span class="number">89.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0</span>)</span><br><span class="line">            Pitch = <span class="number">-89.0</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更改偏航角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateYaw</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Yaw += angle;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &gt; <span class="number">360</span>)</span><br><span class="line">            Yaw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &lt; <span class="number">0</span>)</span><br><span class="line">            Yaw = <span class="number">360</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 更新相机三个向量，根据俯仰角和偏航角计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = -<span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = -<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>相机应该作为全局变量，以便于之后的裁剪等算法获取相机相关的参数，因此我们在 <code>Global.h</code> 中加入全局变量的定义，将渲染管线以及之后要实现的材质等也设置为全局对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">Camera* camera;</span><br><span class="line">Draw* dw;</span><br><span class="line">Material* currentMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;camera.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setViewMatrix</span>(camera-&gt;<span class="built_in">ViewMatrix</span>());</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setProjectMatrix</span>(camera-&gt;<span class="built_in">PerspectiveMatrix</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw-&gt;<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制，渲染管线流程</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到和之前一样的结果说明正确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/camera.png" alt="camera"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（四）纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/</id>
    <published>2022-05-22T10:21:49.000Z</published>
    <updated>2022-05-23T08:20:42.365Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。</p><p><em><span id="more"></span></em></p><h3 id="1-OpenGL-中的纹理"><a href="#1-OpenGL-中的纹理" class="headerlink" title="1 OpenGL 中的纹理"></a>1 OpenGL 中的纹理</h3><p>首先来看 OpenGL 中如何使用纹理有关的操作，可以参考官方教程：[纹理 - LearnOpenGL CN](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;06 Textures&#x2F;)</p><h3 id="2-实现纹理类"><a href="#2-实现纹理类" class="headerlink" title="2 实现纹理类"></a>2 实现纹理类</h3><p>然后我们自己手动实现一个简单的纹理类，纹理环绕方式使用 GL_REPEAT 的方式，即超过 1.0 的纹理坐标就直接重复，纹理过滤的方式采用最近邻方式，加载图片还是使用简单强大的 stbi 库，纹理类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 图片纹理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> channels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>() : <span class="built_in">width</span>(<span class="number">-1</span>), <span class="built_in">height</span>(<span class="number">-1</span>), <span class="built_in">channels</span>(<span class="number">-1</span>), <span class="built_in">data</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; Path) &#123;</span><br><span class="line">        <span class="built_in">LoadTexture</span>(Path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; Path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">        data = <span class="built_in">stbi_load</span>(Path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理采样，使用重复寻址方式,等同于OpenGL的GL_REPEAT</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">Sample2D</span><span class="params">(<span class="type">const</span> glm::vec2&amp; texcoord)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> x = texcoord.x - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.x);</span><br><span class="line"><span class="type">float</span> y = texcoord.y - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.y);</span><br><span class="line">x = x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetColor</span>(x * (width - <span class="number">1</span>), y * (height - <span class="number">1</span>)) / <span class="number">255.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取颜色，对不同通道纹理图片分别处理，以便于加载法线、高度纹理等</span></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width || y &lt; <span class="number">0</span> || y &gt;= height)</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">switch</span> (channels) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor1</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor2</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor3</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor4</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = y * width + x;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">2</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">3</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">4</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), *(data + xy + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改 Shader 类，加入纹理成员，并修改片元着色器，将颜色改为纹理采样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        texture = <span class="keyword">new</span> <span class="built_in">Texture</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 ModelMatrix;</span><br><span class="line">    glm::mat4 ViewMatrix;</span><br><span class="line">    glm::mat4 ProjectMatrix;</span><br><span class="line">    Texture* texture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">        V2F o;</span><br><span class="line">        <span class="comment">// 变换到世界空间</span></span><br><span class="line">        o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line">        <span class="comment">// 变换到裁剪空间</span></span><br><span class="line">        o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line">        <span class="comment">// 法线变换</span></span><br><span class="line">        o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">        o.texcoord = a2v.texcoord;</span><br><span class="line">        o.color = a2v.color;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (texture-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec4 color = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord);</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">        ModelMatrix = model;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">        ViewMatrix = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">        ProjectMatrix = project;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTexture</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        texture-&gt;<span class="built_in">LoadTexture</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在 Draw 类中加入纹理图片路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">        FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">        shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">        shader-&gt;<span class="built_in">setTexture</span>(TexturePath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;texture_box2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(0,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box.png" alt="texture_box"></p><h3 id="3-透视纹理映射"><a href="#3-透视纹理映射" class="headerlink" title="3 透视纹理映射"></a>3 透视纹理映射</h3><p>可以看出当立方体的面不正对我们的时候，纹理出现了变形。这是因为我们对顶点插值时使用的插值参数是通过顶点间的 x, y 坐标求出的，但是透视投影之后纹理坐标并不跟投影点 x , y 坐标线性相关。这种直接插值纹理坐标的方式被称为<strong>仿射映射</strong>，解决办法是做<strong>透视映射</strong>，具体可以查看<a href="https://blog.csdn.net/popy007/article/details/5570803">深入探索透视纹理映射</a>这篇文章。</p><p>总之实际的做法就是在透视除法时，将除了屏幕坐标之外的所有值都除以 w 值，然后再进行插值，这样就可以得到正确的纹理映射关系，最后在扫描线函数中，调用片元着色器之前再乘以 w 恢复即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录下原本的 w</span></span><br><span class="line">    v.w = v.windowPos.w;</span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他属性也要除以 w，以便于正确插值，之后在片元着色器之前再乘以原本的 w 恢复</span></span><br><span class="line">    v.worldPos /= v.w;</span><br><span class="line">    v.normal /= v.w;</span><br><span class="line">    v.texcoord /= v.w;</span><br><span class="line">    v.color /= v.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            v.worldPos *= v.w;</span><br><span class="line">            v.normal *= v.w;</span><br><span class="line">            v.texcoord *= v.w;</span><br><span class="line">            v.color *= v.w;</span><br><span class="line"></span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box2.png" alt="texture_box2"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box3.png" alt="texture_box3"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（三）变换与深度测试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-21T10:28:14.000Z</published>
    <updated>2022-05-23T08:21:00.151Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。</p><p><em><span id="more"></span></em></p><h3 id="1-Mesh-类"><a href="#1-Mesh-类" class="headerlink" title="1 Mesh 类"></a>1 Mesh 类</h3><p>网格（Mesh）是用于保存三维模型的数据结构，通常来说一个网格包含一系列顶点数据和索引，用它们就能绘制出一系列多边形。同时网格还包含该模型所使用的材质信息（贴图、光照等）。上一章中我们是直接用顶点来画图形的，相当于手动创建了一个 Mesh，但是当模型比较复杂的时候，就需要一个类来管理模型的 Mesh，于是我们创建一个 Mesh 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 网格类，基础单位是三角形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; VBO;        <span class="comment">// 存放顶点数据</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; EBO;    <span class="comment">// 存放顶点索引顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> <span class="type">int</span>&amp; vNum, <span class="type">const</span> <span class="type">int</span>&amp; iNum) &#123;</span><br><span class="line">        VBO.<span class="built_in">resize</span>(vNum);</span><br><span class="line">        EBO.<span class="built_in">resize</span>(iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">        :<span class="built_in">VBO</span>(mesh.VBO), <span class="built_in">EBO</span>(mesh.EBO) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        VBO = mesh.VBO;</span><br><span class="line">        EBO = mesh.EBO;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddMesh</span>(mesh);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向网格中加入其它网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> offset = VBO.<span class="built_in">size</span>();</span><br><span class="line">        VBO.<span class="built_in">insert</span>(VBO.<span class="built_in">end</span>(), mesh.VBO.<span class="built_in">begin</span>(), mesh.VBO.<span class="built_in">end</span>());</span><br><span class="line">        EBO.<span class="built_in">reserve</span>(EBO.<span class="built_in">size</span>() + mesh.EBO.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            EBO.<span class="built_in">push_back</span>(mesh.EBO[i] + offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向网格中添加一一个三角形片面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v1);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v2);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v3);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后我们就可以在 Draw 类中将之前画三角形的函数 <code>DrawTriangle</code> 改为更一般的画网格的函数 <code>DrawMesh</code> 了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">// 顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><p>接下来是重头戏，三维变换。虽然对三维坐标变换已经有过深入的理论学习，但是在实践之前还是有必要再复习一次，把理论和实际结合起来。之前的笔记参考<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>。</p><p>首先梳理一下整个从三维模型到屏幕上的图像变换过程：</p><ul><li>模型定点定义在模型空间，需要将所有模型的顶点转换到世界空间</li><li>世界空间中有各种模型和观察整个场景的相机，因此要将世界空间变换到相机空间，也称观察空间</li><li>观察空间中的顶点位置还是三维坐标，因此要进行投影变换将所有物体顶点变换到裁剪空间，得到二维位置以及深度</li><li>裁剪空间经过透视除法变换到标准设备坐标系</li><li>标准设备坐标系最后经过视口变换到屏幕空间中</li></ul><p>于是首先是世界空间到观察空间的变换，也就是将世界空间原点移动到相机位置，然后将世界空间的三个坐标轴和相机的 right、up、front 三个方向对齐。平移矩阵很好写出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165556253.png" alt="image-20220521165556253"></p><p>坐标轴对齐也很简单，要将 A 空间的坐标轴和 B 空间的坐标轴对齐，只需要将 A 空间下 B 空间的坐标轴按行排列即可，因此只要将世界坐标系下的相机的三个方向按行排列，就是从世界空间到相机空间的变换矩阵：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165545686.png" alt="image-20220521165545686"></p><p>于是整个视角变换矩阵即为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165714434.png" alt="image-20220521165714434"></p><p>我们在 <code>math.h</code> 中加入视角变换矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视角变换矩阵，也称观察矩阵</span></span><br><span class="line"><span class="comment">// V = R*T</span></span><br><span class="line"><span class="comment">// T = [  1 , 0 , 0 , -eyex          R = [  Right , 0 </span></span><br><span class="line"><span class="comment">//        0 , 1 , 0 , -eyey                   UP  , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 1 , -eyez               - Front , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 0 ,   1   ]                 0   , 1 ]</span></span><br><span class="line"><span class="comment">//V =  [  Right  ,  - Right·eye</span></span><br><span class="line"><span class="comment">//          UP   ,  - UP·eye</span></span><br><span class="line"><span class="comment">//       -Front  ,   Front·eye</span></span><br><span class="line"><span class="comment">//         0     ,       1        ]</span></span><br><span class="line"><span class="comment">// OpenGL中观察空间是右手系，+z 轴指向屏幕外，为了让朝向保持不变，对Front向量取反</span></span><br><span class="line"></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">(glm::vec3 pos, glm::vec3 front, glm::vec3 right, glm::vec3 up)</span> </span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = right.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">0</span>] = right.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">0</span>] = right.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">0</span>] = -glm::<span class="built_in">dot</span>(right, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">1</span>] = up.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = up.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">1</span>] = up.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">1</span>] = -glm::<span class="built_in">dot</span>(up, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">2</span>] = -front.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">2</span>] = -front.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -front.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = glm::<span class="built_in">dot</span>(front, pos);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是透视投影矩阵，之前的笔记有详细推导，这里就不再赘述了，顺便再附上两篇透视投影的详细推导和理解的文章：</p><ul><li><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">OpenGL投影矩阵(Projection Matrix)构造方法</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影</a></li></ul><p>这里我们使用的透视投影矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172401734.png" alt="image-20220521172401734"></p><p>其中 r &#x3D; -l, t &#x3D; -b，因此投影矩阵最终为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172445502.png" alt="image-20220521172445502"></p><p>其中，r 是屏幕半宽，t 是屏幕半高，f 是远平面距离，n 是近平面距离。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视投影 参数 fov(弧度) aspect near far</span></span><br><span class="line"><span class="comment">//M = [   1/aspect*tan(fov/2),       0      ,         0      ,       0</span></span><br><span class="line"><span class="comment">//               0  ,         1/tan(fov/2)  ,         0      ,       0 </span></span><br><span class="line"><span class="comment">//               0  ,                0      ,  - (f+n)/(f-n) ,  -2fn/(f-n)</span></span><br><span class="line"><span class="comment">//               0  ,                0      ,         -1     ,       0     ]</span></span><br><span class="line"><span class="comment">// 投影之后从右手系变成了左手系，+Z指向屏幕内</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; fovy, <span class="type">const</span> <span class="type">float</span>&amp; aspect, <span class="type">const</span> <span class="type">float</span>&amp; n, <span class="type">const</span> <span class="type">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> tanHalfFov = <span class="built_in">tan</span>(fovy * <span class="number">0.5f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span> / (aspect * tanHalfFov);</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span> / (tanHalfFov);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -(f + n) / (f - n);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-1.0f</span>;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = (<span class="number">-2.0f</span> * n * f) / (f - n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过透视投影后，所有坐标都在 [-w, w] 之间，还需要经过透视除法将其变换到 NDC：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 透视除法在顶点着色器变换到裁剪空间之后，视口变换之前进行，因此修改画网格的函数，加入透视除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">//顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3 构建模型"></a>3 构建模型</h3><p>到此为止我们已经可以渲染一个三维物体了，我们使用 Mesh 构建一个立方体。一个立方体由 6 个面组成，每个面又可以分为两个三角形，于是我们写出三个函数：分别是构建三角形，构建平面和构建立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个三角形</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateTriangle</span><span class="params">(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//逆时针的三角形</span></span><br><span class="line">    <span class="comment">//顶点顺序 0 1 2</span></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(p1, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(p2, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(p3, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建一个平面，顶点顺序为左上 左下 右下 右上</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreatePlane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; leftTop, <span class="type">const</span> glm::vec3&amp; leftBottom, <span class="type">const</span> glm::vec3&amp; rightBottom, <span class="type">const</span> glm::vec3&amp; rightTop, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(leftTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(rightTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(rightBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">3</span>].position = glm::<span class="built_in">vec4</span>(leftBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">3</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个逆时针三角形</span></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    result.EBO[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建立方体</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateBox</span><span class="params">(<span class="type">const</span> glm::vec3&amp; center, <span class="type">float</span> radius)</span> </span>&#123;</span><br><span class="line">    Mesh result;</span><br><span class="line"></span><br><span class="line">    Mesh front = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(front);</span><br><span class="line"></span><br><span class="line">    Mesh left = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(left);</span><br><span class="line"></span><br><span class="line">    Mesh right = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(right);</span><br><span class="line"></span><br><span class="line">    Mesh back = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(back);</span><br><span class="line"></span><br><span class="line">    Mesh up = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(up);</span><br><span class="line"></span><br><span class="line">    Mesh down = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(down);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的颜色更加标准了，所有分量范围都在 [0 ,1]，因此需要修改对应的 <code>FrameBuffer</code> 中的写颜色函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>saturate</code> 函数在 math.h 中定义，作用是将输入值截断在 [0, 1] 范围内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">saturate</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数绘制立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;box.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">30.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box.png" alt="box"></p><p>可以看出透视关系不正确，这是因为没有做深度测试的原因，因此我们需要实现深度测试。</p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4 深度测试"></a>4 深度测试</h3><p>我们首先需要在 FrameBuffer 类中加入深度缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Width, Height;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; depthBuffer;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        <span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重设缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">            *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时重置深度缓冲</span></span><br><span class="line">        depthBuffer.<span class="built_in">assign</span>(Width * Height, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将颜色写入对应位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入深度，Z-Buffer 中深度范围是 [0,1]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">float</span>* p = depthBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + y * Width + x) = depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取深度</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> *(depthBuffer.<span class="built_in">data</span>() + y * Width + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正常深度测试应该在片元着色器之后，但是为了避免不必要的计算，可以在扫描线算法中加入深度测试，也相当于实现了 Early-Z 算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box-16531280264721.png" alt="box"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（二）框架搭建</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-05-20T03:33:30.000Z</published>
    <updated>2022-05-23T08:21:17.571Z</updated>
    
    <content type="html"><![CDATA[<p>上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。</p><p><em><span id="more"></span></em></p><h3 id="1-统一管理全局变量"><a href="#1-统一管理全局变量" class="headerlink" title="1 统一管理全局变量"></a>1 统一管理全局变量</h3><p>首先我们使用一个头文件 <code>Global.h</code> 来统一管理我们用到的所有头文件、全局变量和类声明，为了之后使用方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-FrameBuffer-类"><a href="#2-FrameBuffer-类" class="headerlink" title="2 FrameBuffer 类"></a>2 FrameBuffer 类</h3><p>和光线追踪器中一样，我们使用一个 unsigned char 数组来存放像素，但这次我们使用 RGBA 四个通道。为了保证整个代码结构清晰，我们封装一个 <code>FrameBuffer</code> 类来管理颜色缓冲，后续还可以加入深度缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> Width, Height;</span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line"><span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设缓冲区大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">*(p + i) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + i + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + i + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + i + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> xy = (y * Width + x);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">*(p + xy * <span class="number">4</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-管理顶点数据"><a href="#3-管理顶点数据" class="headerlink" title="3 管理顶点数据"></a>3 管理顶点数据</h3><p>顶点是我们光栅化渲染器的输入数据，所以理所应当用一个类来管理。一个顶点包含的数据有：模型坐标、顶点颜色、顶点法线、纹理坐标。注意位置坐标使用的是四维齐次坐标，在模型空间和世界空间的坐标都是 x, y, z 加上恒为 1 的 w，所以要用四维向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 顶点Vertex类和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VERTEX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 position;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex = glm::<span class="built_in">vec2</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos, <span class="number">1.0f</span>), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; v) :<span class="built_in">position</span>(v.position), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-渲染管线思路"><a href="#4-渲染管线思路" class="headerlink" title="4 渲染管线思路"></a>4 渲染管线思路</h3><p>输入输出都定义完了，接下来开始一步一步实现渲染管线。通常的 OpenGL 渲染管线流程如下：</p><ol><li>输入顶点数据和图元类型（点、直线、三角形等基本图元）</li><li>顶点着色器对顶点进行处理，将坐标变换到世界坐标，计算纹理坐标和顶点颜色等，输出到中间结构体（v2f）</li><li>对 v2f 进行图元装配过程，也就是为每个三角形指定顶点数据与索引</li><li>将顶点变换到摄像机的观察空间</li><li>进行投影，将顶点变换到裁剪空间</li><li>进行裁剪和面剔除工作，将看不见的图元进行裁剪，剔除背向面，减少后续计算量</li><li>执行齐次除法，将顶点变换到 NDC（标准设备坐标）</li><li>执行视口变换，最终将顶点转换到屏幕坐标（从三维变成二维）</li><li>光栅化，计算图形在屏幕上最终覆盖的像素点</li><li>用顶点数据插值，在像素点位置生成新的 v2f</li><li>逐像素运行片元着色器，进行纹理采样、光照计算等，输出该点最终颜色值（RGBA）</li><li>执行透明度测试-&gt;模板测试-&gt;深度测试，丢弃掉一些片元</li><li>执行混合操作</li></ol><h3 id="5-V2F-类"><a href="#5-V2F-类" class="headerlink" title="5 V2F 类"></a>5 V2F 类</h3><p>上述过程中，一个重要的结构体是 v2f，因此首先我们需要定义一个 v2f 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> V2F_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2F_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V2F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 worldPos;</span><br><span class="line">glm::vec4 windowPos;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">glm::mat3 TBN;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">V2F</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _wPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal,</span><br><span class="line"><span class="type">const</span> glm::mat3&amp; _tbn</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">worldPos</span>(_wPos), <span class="built_in">windowPos</span>(_pPos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal), <span class="built_in">TBN</span>(_tbn) &#123;&#125;</span><br><span class="line"><span class="built_in">V2F</span>(<span class="type">const</span> V2F&amp; v) :</span><br><span class="line"><span class="built_in">worldPos</span>(v.worldPos), <span class="built_in">windowPos</span>(v.windowPos), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal), <span class="built_in">TBN</span>(v.TBN), <span class="built_in">Z</span>(v.Z) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个顶点之间的插值</span></span><br><span class="line"><span class="function"><span class="type">static</span> V2F <span class="title">lerp</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> <span class="type">float</span>&amp; factor)</span> </span>&#123;</span><br><span class="line">V2F result;</span><br><span class="line">result.windowPos = <span class="built_in">Lerp</span>(v1.windowPos, v2.windowPos, factor);</span><br><span class="line">result.worldPos = <span class="built_in">Lerp</span>(v1.worldPos, v2.worldPos, factor);</span><br><span class="line">result.color = <span class="built_in">Lerp</span>(v1.color, v2.color, factor);</span><br><span class="line">result.normal = <span class="built_in">Lerp</span>(v1.normal, v2.normal, factor);</span><br><span class="line">result.texcoord = <span class="built_in">Lerp</span>(v1.texcoord, v2.texcoord, factor);</span><br><span class="line"></span><br><span class="line">result.TBN = v1.TBN;</span><br><span class="line"></span><br><span class="line">result.Z = <span class="built_in">Lerp</span>(v1.Z, v2.Z, factor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>V2F 中一个重要的操作就是插值，为此我们新建一个 <code>math.h</code> 文件来存放需要用到的数学操作，首先是线性插值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v1, <span class="type">const</span> glm::vec3&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec2&amp; v1, <span class="type">const</span> glm::vec2&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; f1, <span class="type">const</span> <span class="type">float</span>&amp; f2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * f1 + factor * f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-Shader-类"><a href="#6-Shader-类" class="headerlink" title="6 Shader 类"></a>6 Shader 类</h3><p>有了上面这些准备，现在我们可以用顶点着色器来对顶点进行处理了。先从简单的情况开始，我们首先渲染一个二维图形，因为画二维图形不需要三维到二维的变换，所以三个变换矩阵都置为单位矩阵，实际上等于没做变换直接输出。片元着色器也是直接将调用点的颜色进行输出即可。我们同样封装一个 <code>Shader</code> 类来管理顶点和片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">V2F o;</span><br><span class="line"><span class="comment">// 变换到世界空间</span></span><br><span class="line">o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line"><span class="comment">// 变换到裁剪空间</span></span><br><span class="line">o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line"><span class="comment">// 法线变换</span></span><br><span class="line">o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">o.texcoord = a2v.texcoord;</span><br><span class="line">o.color = a2v.color;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">ModelMatrix = model;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">ViewMatrix = view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">ProjectMatrix = project;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="7-视口变换"><a href="#7-视口变换" class="headerlink" title="7 视口变换"></a>7 视口变换</h3><p>现在我们可以在主函数中定义是三个顶点，由于 OpenGL 的 NDC 的坐标范围是[-1,1)，而我们目前并没有做任何的坐标变换，因此我们直接定义 NDC 下的顶点坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br></pre></td></tr></table></figure><p>现在我们得到了处理后的顶点，但还在 NDC 当中，需要进一步转化为屏幕空间中的坐标，即需要进行视口变换。视口变换做的操作是将 X, Y 坐标从 [-1,1) 映射到屏幕坐标 [0,w) 和 [0,h) 上，同时将原点从屏幕中间移到左下角。注意，在 OpenGL 中，左下角是原点，右上角是 (w,h) ，而 DirectX 中左上角是原点。在我们的 <code>math.h</code> 中定义视口变换矩阵，该矩阵是一个缩放+平移的矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glm 的矩阵是行矩阵，而我们一般使用的是列矩阵，所以存放的时候要转置</span></span><br><span class="line"><span class="comment">// 行矩阵做变换是右乘 v * M  ，列矩阵是左乘 M * v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视口变换矩阵  ox oy是左下角的坐标  从[-1,1]的 NDC 变换到屏幕坐标 [0,0],[w,h]</span></span><br><span class="line"><span class="comment">// Vp = [  w/2 ,   0  ,  0  , ox+w/2 ,</span></span><br><span class="line"><span class="comment">//0  ,  h/2 ,  0  , oy+h/2 ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  1  ,   0    ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  0  ,   1   ]</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewPortMatrix</span><span class="params">(<span class="type">int</span> ox, <span class="type">int</span> oy, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">result[<span class="number">0</span>][<span class="number">0</span>] = width / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">0</span>] = ox + (width / <span class="number">2.0f</span>);</span><br><span class="line">result[<span class="number">1</span>][<span class="number">1</span>] = height / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">1</span>] = oy + (height / <span class="number">2.0f</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br></pre></td></tr></table></figure><h3 id="8-光栅化"><a href="#8-光栅化" class="headerlink" title="8 光栅化"></a>8 光栅化</h3><p>接下来需要计算我们的三角形覆盖了哪些屏幕像素，这里使用经典的扫描线算法。其思想很简单，从三角形最上面的点开始往下逐步画横线，两个交点之间的区域就是覆盖的区域。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162253946.png" alt="image-20220519162253946"></p><p>朝向下侧的三角形原理也是一样的，只不过是对称过来了。有了这两种三角形，不难发现任意三角形都能最多分为一个平顶和一个平底三角形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162338364.png" alt="image-20220519162338364"></p><p>于是我们得到一般三角形的光栅化方法：</p><ol><li>根据三个顶点的 y 坐标判定是否有两个相等，有则判断是平底还是平顶三角形，直接画</li><li>找到 y 值在中间的点，划分出上下两个三角形，画两个</li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扫描线算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader.<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改上一节的主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line">FrameBuffer FrontBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">Resize</span>(SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染并写出图片</span></span><br><span class="line">FrontBuffer.<span class="built_in">ClearColorBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line"></span><br><span class="line">std::string filepath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\test.png&quot;</span>;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), SCR_WIDTH, SCR_HEIGHT, <span class="number">4</span>, FrontBuffer.colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test.png" alt="test"></p><h3 id="9-Draw-类"><a href="#9-Draw-类" class="headerlink" title="9 Draw 类"></a>9 Draw 类</h3><p>我们成功渲染出了二维图形，不过目前我们的渲染流程全都写在主函数中，需要一定的封装，于是我们定义一个 <code>Draw</code> 类来封装渲染过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRAW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> Width;</span><br><span class="line"><span class="type">int</span> Height;</span><br><span class="line">FrameBuffer* FrontBuffer;</span><br><span class="line">Shader* shader;</span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line"><span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">~<span class="built_in">Draw</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">shader = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setModelMatrix</span>(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setViewMatrix</span>(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setProjectMatrix</span>(project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">Resize</span>(w, h);</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">ClearColorBuffer</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), Width, Height, <span class="number">4</span>, FrontBuffer-&gt;colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F o1 = shader-&gt;<span class="built_in">VertexShader</span>(v1);</span><br><span class="line">V2F o2 = shader-&gt;<span class="built_in">VertexShader</span>(v2);</span><br><span class="line">V2F o3 = shader-&gt;<span class="built_in">VertexShader</span>(v3);</span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">****************** 扫描线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后主函数就变得非常简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;test.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line">dw.<span class="built_in">Init</span>();</span><br><span class="line"><span class="comment">// 三角形三个顶点</span></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="comment">// 设定背景并画三角形，这次有透明效果</span></span><br><span class="line">dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">dw.<span class="built_in">DrawTriangle</span>(V1, V2, V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出图片</span></span><br><span class="line">std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test-16530173154901.png" alt="test"></p><p>到此为止整个渲染器的框架就搭建完成，之后只需要在这个框架上添加算法和各种功能即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（一）环境配置</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-19T03:46:26.000Z</published>
    <updated>2022-05-23T08:21:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。</p><p><em><span id="more"></span></em></p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h3><p>我们使用 GLFW 和 GLAD 来显示最终渲染的图片，这些可以参照<a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/#glfw">LearnOpenGL CN</a>上的教程来进行配置。</p><p>使用 GLM 作为数学库，下载地址：<a href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm · GitHub</a></p><p>也可以使用和光线追踪器中一样的 STB 图像库来输出图片。</p><h3 id="2-OpenGL-基础"><a href="#2-OpenGL-基础" class="headerlink" title="2 OpenGL 基础"></a>2 OpenGL 基础</h3><p>下面是一个简单的 OpenGL 程序，但展示了所有 OpenGL 程序的通用流程和框架，包含详细注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些回调函数</span></span><br><span class="line"><span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line"><span class="comment">// 这里我们在改变窗口大小的时候也改变视口大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测是否按下 ESC 键，如果按下则将WindowShouldClose属性设置为true，这样既可退出渲染循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像设置</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器代码，存放在字符串中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW，并配置版本信息等</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GLFW 创建一个窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 用来来管理OpenGL的函数指针，使其在不同版本不同硬件上能够正确运行</span></span><br><span class="line">    <span class="comment">// 因此在使用 OpenGL 函数前需要先初始化 GLAD</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并编译顶点着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并编译片元着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将着色器代码链接为一个着色器程序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 检查链接错误</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ；链接完成后即可删除着色器对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个三角形</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点缓冲区VBA和顶点数组缓冲区VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 绑定顶点数组缓冲</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">// 绑定顶点缓冲，顶点缓冲是GL_ARRAY_BUFFER类型</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 将上面的顶点数据复制到顶点缓冲中</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 链接顶点属性，即告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除缓冲区绑定，非必要</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 是否按下ESC关闭窗口</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置清空屏幕缓冲所用的颜色</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 用设置的颜色清空颜色缓冲，可选的还有深度缓冲和模板缓冲</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双缓冲渲染，屏幕显示前缓冲区，渲染在后缓冲进行，因此每一帧交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果如图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20220519114457379.png" alt="image-20220519114457379"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】渲染加速技术总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T09:05:35.000Z</published>
    <updated>2022-05-18T09:07:36.914Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：</p><ul><li>空间管理（BVH、BSP 树、八叉树、场景图）</li><li>裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）</li><li>层次细节技术（LOD）</li><li>点渲染</li></ul><p><em><span id="more"></span></em></p><h2 id="1-空间管理"><a href="#1-空间管理" class="headerlink" title="1 空间管理"></a>1 空间管理</h2><p>空间数据结构（Spatial Data Structures）是将几何体组织在 N 维空间中的一系列数据结构，而且我们可以很容易地将二维和三维的一些概念扩展到高维之中。这些空间数据结构可以用于很多实时渲染相关操作的加速查询中，如场景管理，裁减算法、相交测试、光线追踪、以及碰撞检测等。</p><p>空间数据结构的组织通常是层次结构的。宽泛地说，即最顶层包含它之下的层次，后者又包含更下层的层次，以此类推。因此，这种结构具有嵌套和递归的特点。用层次结构的实现方式对访问速度的提升很有帮助，复杂度可以从 O(n) 提升到 O(log n)。但同时，使用了层次结构的大多数空间数据结构的构造开销都比较大，虽然也可以在实时过程中进行渐进更新，但是通常需要作为一个预处理的过程来完成。</p><p>一些常见的空间数据结构包括：</p><ul><li>层次包围盒（Bounding Volume Hierachy，BVH）</li><li>二元空间分割树（Binary Space Partitioning，BSP）</li><li>四叉树（QuadTree）</li><li>kd 树（k-dimensional tree）</li><li>八叉树（Octree）</li><li>场景图（Scene Graphs）</li></ul><p>其中，BSP 树和八叉树都是基于空间细分（Space Subdivision）的数据结构，这说明它们是对整个场景空间进行细分并编码到数据结构中的。例如，所有叶子节点的空间集合等同于整个场景空间，而且叶子节点不相互重叠。</p><p>层次包围盒不是空间细分结构，是对物体进行细分的结构，它仅将几何物体周围的空间包围起来，所以包围层次不需要包围所有的空间，但包围盒之间可以重叠。</p><p>而场景图是一种比较高层次的，相较渲染性能更关注模型关系的数据结构。</p><h3 id="1-1-层次包围盒-BVH"><a href="#1-1-层次包围盒-BVH" class="headerlink" title="1.1 层次包围盒 BVH"></a>1.1 层次包围盒 BVH</h3><p>对于三维场景的实时渲染来说，层次包围体（Bounding Volume Hierarchy，BVH）是最常使用的一种空间数据结构。例如，层次包围体经常用于层次视锥裁减。使用 BVH 的场景以层次树结构进行组织，包含一个根节点（root）、一些中间节点（internal nodes），以及一些叶子节点（leaves）。顶部的节点是根，其无父节点。叶子节点（leaf node）包含需渲染的实际几何体，且其没有子节点。</p><p>相比之下，中间节点包含指向它子节点的指针。因此，只要根节点不是这颗树唯一的一个节点，那么它就是一个内部节点。树中的每一个节点，包括叶子节点，都有一个包围体可以将其子树中的所有几何体包围起来，这就是包围体层次的命名来源，同时，也说明了根节点有一个包含整个场景的包围体。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154315059.png" alt="image-20220518154315059"></p><p>关于 BVH 的理论详述可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>中的“交点计算加速”部分。而 BVH 的代码实现可以在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/">【RayTracer】（十）实现 BVH</a>中查看。</p><h3 id="1-2-BSP-树"><a href="#1-2-BSP-树" class="headerlink" title="1.2 BSP 树"></a>1.2 BSP 树</h3><p>BSP 树（二叉空间分割树，全称 Binary Space Partitioning Tree）是一种常用于判别对象可见性的空间数据结构。类似于画家算法，BSP 树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。</p><p>其中，BSP 是 Binary SpacePartitioning（二叉空间划分法）的缩写。这种方法递归地将空间使用超平面划分为凸面体集合。而这种子划分引出了借助于称之为 BSP 树的树形数据结构的场景表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154653690.png" alt="image-20220518154653690"></p><p>BSP 树是一棵二叉树，每个节点表示一个有向超平面，其将当前空间划分为前向（front）和背向（back）两个子空间，分别对应当前节点的左子树和右子树。BSP 树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。而 BVH 与之不同，因为 BVH 通常不包含任何形式的排序。</p><h4 id="1-2-1-BSP-树的构建"><a href="#1-2-1-BSP-树的构建" class="headerlink" title="1.2.1 BSP 树的构建"></a>1.2.1 BSP 树的构建</h4><ul><li>从空树开始，每次选择一个面片作为节点插入树中</li><li>每次插入一个新节点，从树的根节点开始遍历<ul><li>如果新节点面片与当前结点片面相交，将新面片分割成两个面片</li><li>新节点在当前节点前向空间，插入左子树</li><li>新节点在当前节点背向空间，插入右子树</li><li>当前节点为空，直接插入新节点</li></ul></li><li>直到所有面片都被插入树中</li></ul><p>简单来说，若要创建 BSP 树，需递归将一个平面空间一分为二，并将几何体归类到这两个空间中来完成。</p><h4 id="1-2-2-BSP-树的遍历"><a href="#1-2-2-BSP-树的遍历" class="headerlink" title="1.2.2 BSP 树的遍历"></a>1.2.2 BSP 树的遍历</h4><p>从根节点开始，判断输入位置与当前分割平面的“前”、“后”关系，“前”则遍历左子树，“后”则遍历右子树，递归到叶子节点终止。</p><p>用平面方程 <code>Ax + By + Cz + D = 0</code> 判断前后位置，可用<code>D(x0, y0, z0) = Ax0 + By0 + Cz0 + D</code>  进行判别，其中：</p><ul><li>D &gt; 0：在平面前面</li><li>D &#x3D; 0：在平面上</li><li>D &lt; 0：在平面后面</li></ul><h4 id="1-2-3-BSP-树的种类"><a href="#1-2-3-BSP-树的种类" class="headerlink" title="1.2.3 BSP 树的种类"></a>1.2.3 BSP 树的种类</h4><p>在计算机图形学中，BSP 树有两大类别，分别是为轴对齐（Axis-Aligned）BSP 树和多边形对齐（Polygon-Aligned）BSP 树。下面分别进行介绍。</p><h4 id="1-2-4-轴对齐-BSP-树"><a href="#1-2-4-轴对齐-BSP-树" class="headerlink" title="1.2.4 轴对齐 BSP 树"></a>1.2.4 轴对齐 BSP 树</h4><p>轴对齐 BSP 树可以按如下方式来创建。首先，将整个场景包围在一个 AABB（轴对齐包围盒，Axis-Aligned Bounding Box）中，然后以递归的方式将这个包围盒分为若干个更小的盒子。</p><p>现在，考虑一下任何递归层次的盒子。选取盒子的一个轴，生成一个与之垂直的平面，将盒子一分为二。有一些方法可以将这个分割平面固定，从而将这个盒子分为完全相同的两部分，而也有其他的一些方法，允许这个平面在位置上有一些变化。与分割平面相交的物体，要么存储在这个层次上，成为两个子集中的一员，要么被这个平面分割为两个不同的物体。</p><p>经过这个过程，每个子集就处于一个比较小的盒子中，重复这个平面分割的过程，就可以对每个 AABB 进行递归细分，直到满足某个标准才终止这个分割过程。而这个标准，通常是用户定义的树最大深度，或者是盒子里面所包含的几何图元数量，需低于用户定义的某个值。</p><p>分割平面的轴线和位置对提高效率至关重要。一种分割包围盒的方法就是轴进行循环。即在根节点，沿着 x 轴对盒子进行分割，然后再沿着 y 轴对其子盒子进行分割，最后沿 z 轴对其孙盒子进行分割。这样，就完成了一个循环周期。<strong>使用这种分割策略的 BSP 树常被称为 k-d 树。</strong>而另一种常见策略是找到盒子的最长边，沿着这条边的方向对盒子进行分割。</p><p>下图显示了一个 BSP 树的分割过程，可以直观理解上述过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155441829.png" alt="image-20220518155441829"></p><p>值得一提的是，从前到后的粗排序（Rough Front-to-Back Sorting）是轴对齐 BSP 树的一种应用示例，这种方法对于遮挡剔除算法非常有用。而在视点的另一侧进行遍历，可以得到从后向前的粗排序（Rough Fack-to-Gront Sorting）,这对于透明排序非常有用。且还可以用来测试射线和场景几何体相交的问题，只需将视点位置换为射线原点即可，另外还可以用于视锥裁剪。</p><h4 id="1-2-5-多边形对齐-BSP-树"><a href="#1-2-5-多边形对齐-BSP-树" class="headerlink" title="1.2.5 多边形对齐 BSP 树"></a>1.2.5 多边形对齐 BSP 树</h4><p>多边形对齐 BSP 树（Polygon-aligned BSP tree）是 BSP 树的另一大类型，其中将多边形作为分隔物，对空间进行平分。也就是说，在根节点处，选取一个多边形，用这个多边形所在平面将场景中剩余多边形分为两组。对于与分割平面相交的多边形来说，沿着其中的交线将这个多边形分为两部分。然后，在分割平面的每个半空间中，选取另外一个多边形作为分隔物，只对这个分隔物所在平面的多边形进行继续分割，直到所有的多边形都在 BSP 树中为止。下图是一个多边形对齐 BSP 树的示意图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155804963.png" alt="image-20220518155804963"></p><p>需要注意，多边形对齐 BSP 树的创建是一个非常耗时的过程，这些树通常只需计算一次，可以存储起来进行重用。另外，因为完全不平衡树的效率非常低，所以多边形对齐 BSP 树分割时最好是形成平衡树，即每个叶子节点的深度相同或者相差一个层次的树。</p><p>多边形对齐 BSP 树的一个典型性质就是对于一个给定的视点来说，可以对该结构按照从后往前（或者从前往后）的顺序进行严格遍历，而轴对齐的 BSP 通常只能给出粗略的排序顺序。所以，基于多边形对齐 BSP 树的此性质，建立了严格的前后顺序，可以配合画家算法来绘制整个场景，而无需 Z 缓冲。多边形对齐 BSP 树的其他应用也包括相交测试和碰撞检测等。</p><h3 id="1-3-八叉树"><a href="#1-3-八叉树" class="headerlink" title="1.3 八叉树"></a>1.3 八叉树</h3><h4 id="1-3-1-普通八叉树"><a href="#1-3-1-普通八叉树" class="headerlink" title="1.3.1 普通八叉树"></a>1.3.1 普通八叉树</h4><p>八叉树（octree），或称八元树，是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p><p>简单来说，八叉树的空间划分方式很简单，即递归地进行规整地 1 分为 8 的操作。如下图，把一个立方体分割为八个同样大小的小立方体，然后递归地分割出更的小立方体。这个就是八叉树的命名来源。这种分割方式可以得到比较规则的结构，从而使得查询变得高效。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160027641.png" alt="image-20220518160027641"></p><p>相似地，四叉树是把一个二维的正方形空间分割成四个小正方形。而八叉树是四叉树的三维空间推广。</p><h4 id="1-3-2-松散八叉树"><a href="#1-3-2-松散八叉树" class="headerlink" title="1.3.2 松散八叉树"></a>1.3.2 松散八叉树</h4><p>松散八叉树（Loose Octrees）的基本思想和普通八叉树一样，但是每个长方体的大小选择比较宽松。如果一个普通长方体的边长为 a，那么可以用 ka 来代替，其中 k &gt; 1，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160218107.png" alt="image-20220518160218107"></p><p>上图是一个普通八叉树和松散八叉树的比较。图中黑色的原点表示长方形的中心点（第一次细分）。在左图中，星形物体刺穿了一个普通八叉树的一个分割平面。这时，一种选择就是将这个星型物体放在最大的长方形中（根节点的长方体）。而右图所示为一个 k&#x3D;1.5 的松散八叉树，也就是将细分的长方体放大了 50%，如果将这些长方体稍微移动，就可以保证区分出们。这样，这个星形多边形就完全位于左上角的长方形之中。</p><h3 id="1-4-场景图"><a href="#1-4-场景图" class="headerlink" title="1.4 场景图"></a>1.4 场景图</h3><p>BVH、BSP 树和八叉树都是使用某种形式的树来作为基本的数据结构，它们的具体区别在于各自是如何进行空间分割和几何体的存储，且他们均是以层次的形式来保存几何物体。然而三维场景的绘制不仅仅是几何体。对动画，可见性，以及其他元素的控制，往往需要通过场景图（Scene Graphs）来完成。</p><p>场景图被誉为“当今最优秀且最为可重用的数据结构之一“。Wiki 中对场景图的定义是：</p><blockquote><p>场景图（Scene Graph）是组织和管理三维虚拟场景的一种数据结构，是一个有向无环图（Directed Acyclic Graph， DAG）。</p></blockquote><p>场景图是一个面向用户的树结构，可以通过纹理、变换、细节层次、渲染状态（例如材质属性）、光源以及其他任何合适的内容进行扩充。它由一棵以深度优先遍历来渲染整个场景的树来表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160821493.png" alt="image-20220518160821493"></p><p>开源的场景图有 Open Scene Graph 和 OpenSG 等。</p><h2 id="2-裁剪技术"><a href="#2-裁剪技术" class="headerlink" title="2 裁剪技术"></a>2 裁剪技术</h2><p>裁剪（Culling）的字面意思是“从大量事物中进行删除”。在计算机图形学中，相对应的就是裁剪技术（Culling Techniques）所要做的工作——“从大量游戏事物中进行删除”。所谓的“大量事物”就是需要绘制的整个场景，删除的是对最终图像没有贡献的场景部分，然后将剩余场景发送到渲染管线。因此，在渲染方面通常使用“可见性裁剪 (Visibility Culling)”这个术语。但其实，裁剪也可以用于程序的其他部分，如碰撞检测（对不可见物体进行不十分精确的计算）、物理学计算，以及人工智能（AI）领域。</p><p>与渲染相关的裁剪技术，常见的有：</p><ul><li><strong>背面裁剪（Backface Culling）</strong>：将背向视点的物体删除，是一种非常简单直观的操作，只能一次对一个单一多边形进行操作。</li><li><strong>视锥裁剪（View Frustum Culling）</strong>：将视锥之外的多边形删除，相对而言，这种操作比背面裁剪稍微复杂。</li><li><strong>遮挡剔除（Occlusion Culling）</strong>：将被其他物体遮挡的物体进行删除，这种操作在三者中最为复杂，因为其需要聚集一个或者多个物体，同时还需使用其他物体的位置信息。</li></ul><p>理论上，裁剪操作可以发生在渲染管线的任何一个阶段，而且对于一些遮挡裁剪算法来说，甚至可以预先计算出来。对于在硬件中实现的裁剪算法来说，有时只需启动&#x2F;禁止或者设置一些裁剪函数即可。而为了进行完全控制，我们可以在应用程序阶段在（CPU 上）实现一些裁剪算法。裁剪通常可以使用几何计算来实现，但也不局限于此。</p><p>下图展示了三种裁剪技术：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161245851.png" alt="image-20220518161245851"></p><h3 id="2-1-背面裁剪"><a href="#2-1-背面裁剪" class="headerlink" title="2.1 背面裁剪"></a>2.1 背面裁剪</h3><p>假设你正在观察一个场景中不透明的球体。大约有一半的球体是不可见的。那么，可以从中这个例子里得到一个众所周知的结论，那就是，对不可见的内容不需要进行渲染，因为它们对最终的渲染图像没有贡献。不需要对球体的背面进行处理，这就是背面裁剪的基本思想。对于一组物体来说，还可以一次性地进行背面裁剪，这也称为聚集背面裁剪（Clustered Backface Culling）。</p><p>背面裁剪有屏幕空间和观察空间两种方法，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161502669.png" alt="image-20220518161502669"></p><p>左图为屏幕空间背面裁剪，使用叉乘运算。根据右手定则可以判断出三角形和四边形是正面，七边形是背面，背面的多边形无需进行光栅化。</p><p>右图为观察空间背面裁剪，使用点乘运算。根据表面法线和视线夹角判断正面还是背面。</p><h3 id="2-2-层次视锥裁剪"><a href="#2-2-层次视锥裁剪" class="headerlink" title="2.2 层次视锥裁剪"></a>2.2 层次视锥裁剪</h3><p>众所周知，只需对完全或者部分在视锥中的图元进行渲染。一种加快渲染速度的方法便是将每个物体的包围体与视锥进行比较，如果包围体位于视锥之外，那么便不需要渲染包围体中的几何体。由于这些计算在 CPU 上进行，因此包围体中的几何体不需要通过管线中的几何和光栅阶段。相反，如果包围体在视锥内或者与视锥相交，那么包围体中的内容就是可见的，所以必须发送到渲染管线中去。</p><p>利用空间数据结构，可以分层地来应用这种裁剪。例如，对于层次包围盒 BVH 来说，从根节点进行前序遍历（Preorder Transversal），就可以完成这一任务。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161828374.png" alt="image-20220518161828374"></p><p>视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围盒中，而且几乎所有包围盒都是以层次形式聚集在一起。</p><p>除了层次包围盒，其他的空间数据结构同样也可以用于视锥裁剪，包括上文提到的八叉树和 BSP 树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围盒。</p><h3 id="2-3-入口裁剪"><a href="#2-3-入口裁剪" class="headerlink" title="2.3 入口裁剪"></a>2.3 入口裁剪</h3><p>对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪（Protal Culling）。入口裁剪算法的基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪，只对穿过入口能看到的几体体进行渲染。当遍历入口的时候，就减小视锥，使得与入口尽可能紧密贴合。因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展，且需将位于视锥之外的入口丢弃。</p><p>入口裁剪方法以某种方式对场景进行预处理，可以是自动形式，也可以是手动形式，可以将场景分割为一系列单元（Cells），其通常对应于建筑物中的房间或者走廊；房间的门和窗口称为入口（Protals）。单元中的每个物体和单元的墙面可以存储在一个与单元关联的数据结构中，还可以将邻接单元和链接这些单元的入口信息保存在一个临接图中。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162241213.png" alt="image-20220518162241213"></p><h3 id="2-4-细节裁剪"><a href="#2-4-细节裁剪" class="headerlink" title="2.4 细节裁剪"></a>2.4 细节裁剪</h3><p>细节裁剪（Detail Culling）是一种通过牺牲质量换取速度的技术。其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。</p><p>考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪（Screen-Size Culling）。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。</p><p>细节裁剪还可以作为一种简化的 LOD 技术来实现，其中一个 LOD 是整个模型，另外一个 LOD 是空物体。</p><h3 id="2-5-遮挡剔除"><a href="#2-5-遮挡剔除" class="headerlink" title="2.5 遮挡剔除"></a>2.5 遮挡剔除</h3><p>可见性问题可以通过 Z 缓冲器的硬件构造来实现，即使可以使用 Z 缓冲器正确解决可见性问题，但其中 Z 缓冲并不是在所有方面都不是一个很“聪明”的机制。例如，假设视点正沿着一条直线观察，其中，在这条直线上有 10 个球体，虽然这 10 个球体进行了扫描转换，同时与 Z 缓冲器进行了比较并写入了颜色缓冲器和 Z 缓冲器，但是这个从这个视点渲染出的图像只会显示一个球体，即使所有 10 个球体都将被光栅化并与 Z 缓冲区进行比较，然后可能写入到颜色缓冲区与 Z 缓冲区。下图中间部分显示了在给定视点处场景的深度复杂度，深度复杂度指的是对每个像素重写的次数。对于有 10 个球体的情形，最中间的位置，深度复杂度为 10，因为在这个地方渲染了 10 个球体（假设背面裁剪是关闭的），而且这意味着其中有 9 次像素写入是完全没有必要的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162730519.png" alt="image-20220518162730519"></p><p>像上图这样无聊极端的场景，现实生活中很难找到，但其描述的这种密集性很高的模型的情形，在现实生活中却很常见，如热带雨林，发动机，城市，以及摩天大楼的内部。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162841447.png" alt="image-20220518162841447"></p><p>左图和中图为视锥裁剪后的图示，右图所示为遮挡剔除和视锥裁剪后的图示。</p><p>有两种主要形式的遮挡裁剪算法，分别是基于点的遮挡裁剪和基于单元的遮挡裁剪。如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162926792.png" alt="image-20220518162926792"></p><p>左图所示为基于点的可见性，右图所示为基于单元的可见性，其中单元是一个长方形，从中可以看出，从视点左边看上去，有些圆被遮挡了，但是从右边看上去，这些圆却是可见的，因为可以从单元的某个位置到这些圆画一些射线，这些射线没有和任何遮挡物相交。</p><h4 id="2-5-1-硬件遮挡查询"><a href="#2-5-1-硬件遮挡查询" class="headerlink" title="2.5.1 硬件遮挡查询"></a>2.5.1 硬件遮挡查询</h4><p>现代  GPU 可以以一种特殊的渲染模式来支持遮挡剔除。通过硬件遮挡查询（Hardware Occlusion Queries），我们能够直接获得所提交的物体是否被绘制到场景中。<br>简单来说，硬件遮挡查询的基本思想是，当和 Z 缓冲器中内容进行比较时，用户可以通过查询硬件来找到一组多边形是否可见的，且这些多边形通常是复杂物体的包围体（如长方体）。如果其中没有多边形可见，那么便可将这个物体裁剪掉。硬件实现对查询的多边形进行光栅化，并且将其深度和 Z 缓冲器进行比较。</p><h4 id="2-5-2-层次-Z-缓冲"><a href="#2-5-2-层次-Z-缓冲" class="headerlink" title="2.5.2 层次  Z 缓冲"></a>2.5.2 层次  Z 缓冲</h4><p>层次 Z-缓冲算法（Hierarchical Z-Buffering，HZB）对遮挡剔除的研究有着显著的影响。尽管其在 CPU 上很少使用，但该算法是 GPU 上做 Z-Culling（深度裁剪）的基础。</p><p>层次  Z-缓冲算法用八叉树来维护场景模型，并将画面的 Z 缓冲器作为图像金字塔（也称为 Z-金字塔，Z-pyramid），该算法因此在图像空间中进行操作。其中，八叉树能够对场景的遮挡区域进行层次剔除，而  Z-金字塔则可以对单个基元和边界体积进行层次 Z 缓冲。因此  Z-金字塔可以作为此算法的遮挡表示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163313731.png" alt="image-20220518163313731"></p><p>使用  HZB 算法的遮挡裁剪示例，显示了一个复杂的场景（右下），相应的  Z-pyramid（左图），以及八叉树细分（右上）。通过从前到后遍历八叉树并裁剪遇到的八叉树节点，此算法可以仅访问可见的八叉树节点及其子节点（右上角的节点），的容器只对可见包围体中的多边形进行渲染。在这个例子中，遮挡八叉树节点的裁剪可以将深度复杂度从 84 降低到了 2.5。</p><h2 id="3-层次细节技术"><a href="#3-层次细节技术" class="headerlink" title="3 层次细节技术"></a>3 层次细节技术</h2><p>细节层次（Level of Detail，LOD）的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。这是一个已经在各种游戏中广泛使用的基本优化技术。</p><p>例如，一个包含一百万个三角形的汽车，其中所包含的细节信息比较丰富。当视点靠近物体时，可以使用详细的细节表示，而当视点远离物体时，比如仅需覆盖 200 个像素，则完全无需渲染出一百万个三角形，相反，我可以使用诸如只有 1000 个三角形的简化模型。而由于距离的原因，简化后的模型与细节较丰富的模型看上去其实很接近。以这种方式，可以显著地提高渲染的性能开销。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163650813.png" alt="image-20220518163650813"></p><p>通常情况下，雾效会与 LOD 一起使用。这样我们可以完全跳过对一些物体的渲染，直接用不透明的雾来进行遮挡。</p><p>一般情况下，完整的 LOD 算法包含 3 个主要部分：</p><ul><li><strong>生成 Generation</strong>：生成不同细节的模型表示，可以使用算法，也可以手工制作具有不同数量的三角形模型</li><li><strong>选择 Selection</strong>：基于某种准则选取一个层次细节模型，比如屏幕上的评估面积</li><li><strong>切换 Switching</strong>：从一个细节层次转换到另一个细节层次</li></ul><h3 id="3-1-LOD-的切换方法"><a href="#3-1-LOD-的切换方法" class="headerlink" title="3.1 LOD 的切换方法"></a>3.1 LOD 的切换方法</h3><p>当从一个 LOD 切换到另一个 LOD 的时候，忽然的模型替换往往会引起观察者的注意。这种现象被称为突越（Poping）。这里有几种不同的 LOD 切换方法，有着不同的特性。</p><h4 id="3-1-1-离散几何-LOD"><a href="#3-1-1-离散几何-LOD" class="headerlink" title="3.1.1 离散几何 LOD"></a>3.1.1 离散几何 LOD</h4><p>离散几何 LOD 是最简单的 LOD 算法，不同的表示是不同图元数量的同一模型，但这种方法突越现象严重。</p><h4 id="3-1-2-混合-LOD"><a href="#3-1-2-混合-LOD" class="headerlink" title="3.1.2 混合 LOD"></a>3.1.2 混合 LOD</h4><p>在概念上，完全可能存在一种直观的方法，从一个 LOD 切换到另一个 LOD，只需要在较短的时间内在两个 LOD 之间执行一个线性混合，这种方法无疑可以得到一种比较平滑的切换，但是这种混合操作的代价较高。渲染两个 LOD 要比一个 LOD 需要更大开销，因此也就违背了 LOD 的初衷。但 LOD 切换通常发生在较短时间内容，在同一时间也不是对场景中所有物体进行切换，所以依然可以从中获益。</p><h4 id="3-1-3-透明-LOD"><a href="#3-1-3-透明-LOD" class="headerlink" title="3.1.3 透明 LOD"></a>3.1.3 透明 LOD</h4><p>完全避免突越现象的一种简单方法便是使用 alpha LOD。其中并没有使用同一物体很多不同细节的实例，而且每个物体只有一个实例。随着 LOD 选取度量值（如与物体之间的距离）的增大，物体整体透明度也随之增大（也就是 alpha 值减小），当完全透明时，物体最终就会消失。这种方法的优点是，比离散几何 LOD 方法上感觉更连续一些，可以避免突跃现象。此外，由于物体最终会完全消失而不需要进行渲染，可以得到很好的加速效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164303220.png" alt="image-20220518164303220"></p><p>使用 Alpha LOD 对图中的圆锥体进行渲染，当距离圆锥体较远时，就提高它的透明度，直到最后消失。直线左边的图像是从同一距离处进行的观察，而直线右边的图像是左边图像不同尺寸的情形。</p><h4 id="3-1-4-连续-LOD-和几何形变-LOD"><a href="#3-1-4-连续-LOD-和几何形变-LOD" class="headerlink" title="3.1.4  连续 LOD 和几何形变 LOD"></a>3.1.4  连续 LOD 和几何形变 LOD</h4><p>连续细节层次（Continuous Level of Detail , CLOD）的基本思想是基于 LOD 选取值来精确决定可见多边形的数量。在 100m 远处，模型包含 1000 个多边形，当移动的到 101m 的地方时，模型减少到 998 个多边形。</p><p>几何形变层次细节（Geomorph LODs）是基于简化生成的一组离散模型，且其中模型顶点之间的链接关系保持不变。关于GLODs 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/">【计算机图形学】（九）几何</a>中的表面简化方法。</p><h3 id="3-2-LOD-的选取方法"><a href="#3-2-LOD-的选取方法" class="headerlink" title="3.2 LOD 的选取方法"></a>3.2 LOD 的选取方法</h3><p>给定一个物体不同细节层次，必须做一个选择，决定渲染或者混合其中的哪一个层次，这就是 LOD 选择（LOD selection）的任务。有几种不同的 LOD 选择方案，这些方案也可以用于遮挡剔除算法。</p><h4 id="3-2-1-基于距离的-LOD-选取"><a href="#3-2-1-基于距离的-LOD-选取" class="headerlink" title="3.2.1 基于距离的 LOD 选取"></a>3.2.1 基于距离的 LOD 选取</h4><p>原理如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164744364.png" alt="image-20220518164744364"></p><h4 id="3-2-2-基于投影面积的-LOD-选取"><a href="#3-2-2-基于投影面积的-LOD-选取" class="headerlink" title="3.2.2 基于投影面积的 LOD 选取"></a>3.2.2 基于投影面积的 LOD 选取</h4><p>基于投影面积的 LOD 选取，顾名思义，即投影面积越大，就选取细节越丰富的 LOD。</p><h4 id="3-2-3-基于滞后的-LOD-选取"><a href="#3-2-3-基于滞后的-LOD-选取" class="headerlink" title="3.2.3 基于滞后的 LOD 选取"></a>3.2.3 基于滞后的 LOD 选取</h4><p>若用于确定 LOD 度量标准围绕某个值 ri 在画面之间是变化的，那么就会出现不必要的突跃现象，也就会在不同的 LOD 之间来回快速切换。对此，可以引入一个围绕 ri 值的滞后来解决这个问题。如下图，这是一个基于距离的 LOD，可以应用于任何类型，当 r 增大时，使用上一行的 LOD 距离；当 r 减小时，使用下面一行的 LOD 距离。  </p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164927013.png" alt="image-20220518164927013"></p><h2 id="4-点渲染"><a href="#4-点渲染" class="headerlink" title="4 点渲染"></a>4 点渲染</h2><p>点渲染的基本思想是用一个大的点集来表示物体表面并予以渲染。在随后的通道中，使用高斯滤波来填充渲染点之间的间隙。而高斯滤波器的半径取决于表面上点的密度和屏幕上的投影密度。知道有这种渲染方法即可，不必深究。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间管理（BVH、BSP 树、八叉树、场景图）&lt;/li&gt;
&lt;li&gt;裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）&lt;/li&gt;
&lt;li&gt;层次细节技术（LOD）&lt;/li&gt;
&lt;li&gt;点渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】非真实感渲染总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T07:32:47.000Z</published>
    <updated>2022-05-18T07:34:00.662Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中的非真实感渲染技术进行概括总结和扩展。主要内容包括：</p><ul><li>非真实感渲染（NPR）的基本思想</li><li>卡通渲染</li><li>轮廓描边方法总结</li><li>其他风格的 NPR 渲染技术</li></ul><p><em><span id="more"></span></em></p><h3 id="1-非真实感渲染概述"><a href="#1-非真实感渲染概述" class="headerlink" title="1 非真实感渲染概述"></a>1 非真实感渲染概述</h3><p>非真实感渲染（Non-Photorealistic Rendering，NPR），亦被称为风格化渲染（Stylistic Rendering），是致力于为数字艺术提供多种表达方式的一种渲染流派。与传统的追求照片真实感的真实感渲染（Photorealistic Rendering）计算机图形学不同，非真实感渲染旨在模拟艺术式的绘制风格，也用于尝试新的绘制风格。</p><p>NPR 的目的之一就是创建类似技术示意图、技术图纸相关的图像，而另一个应用领域便是对绘画风格和自然媒体（如铅笔、钢笔、墨水、木炭、水彩画等）进行模拟。这是一个涉及内容非常之多的应用领域，为了捕捉各种媒体的真实效果，人们已经提出了各种不同的算法。</p><h3 id="2-卡通渲染"><a href="#2-卡通渲染" class="headerlink" title="2 卡通渲染"></a>2 卡通渲染</h3><p>卡通渲染（Toon Rendering）作为一种特殊形式的非真实感渲染方法，近年来倍受关注。这种渲染风格能够给人以独特的感染力与<br>童趣。这种风格很受欢迎的原因之一是 McCloud 的经典著作《Understanding Comics》中所讲述到的“通过简化进行增强（Amplification Through Simplification）”。通过简化并剔除所包含的混杂部分，可以突出于主题相关的信息，而大部分观众都会认同那些用简单风格描绘出来的卡通形象。</p><p>可以将最<strong>卡通渲染基本的三个要素</strong>概括为：</p><ul><li>锐利的阴影（Sharp shadows）</li><li>少有或没有高亮的点（Little or no highlight）</li><li>对物体轮廓进行描边（Outline around objects）</li></ul><p>卡通渲染有许多不同的实现方法：</p><ul><li>对于含有纹理但没有光照的模型来说，可以通过对纹理进行量化来近似具有实心填充颜色的卡通风格。</li><li>对于明暗处理，有两种最为常见的方法，一种是用实心颜色填充多边形区域。但这种方式实用价值不大。另一种是使用 2-tone 方法来表示光照效果和阴影区域。也称为硬着色方法（Hard Shading），可以通过将传统光照方程元素重新映射到不同的调色板上来实现。此外，一般用黑色来绘制图形的轮廓，可以达到增强卡通视觉效果的目的。</li></ul><p>具体的着色方法，可以理解为在 Fragment shader 中测试每个像素漫反射 diffuse 中的 NdotL 值，让漫反射形成一个阶梯函数，不同的 NdotL 区域对应不同的颜色。下图显示了不同的漫反射强度值的着色部分阶梯指定了不同的像素颜色。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518150810699.png" alt="image-20220518150810699"></p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中实现了一个简单的 NPR 渲染。</p><h3 id="3-轮廓描边方法总结"><a href="#3-轮廓描边方法总结" class="headerlink" title="3 轮廓描边方法总结"></a>3 轮廓描边方法总结</h3><p>轮廓描边的渲染方法可以分为以下五种：</p><ul><li>基于视点方向的描边</li><li>基于过程几何方法的描边</li><li>基于图像处理的描边</li><li>基于轮廓边缘检测的描边</li><li>混和轮廓描边</li></ul><h4 id="3-1-基于视点方向的描边"><a href="#3-1-基于视点方向的描边" class="headerlink" title="3.1 基于视点方向的描边"></a>3.1 基于视点方向的描边</h4><p>基于视点方向的描边方法，即表面角描边（Surface Angle Silhouetting），其基本思想是使用视点方向（view point）和表面法线（surface normal）之间的点乘结果得到轮廓线信息。如果此点乘结果接近于零，那么可以断定这个表面极大概率是侧向（Edge-on）的视线方向，而我们就将其视做轮廓边缘，进行描边。在实际应用中，通常使用一张一维纹理，也就是使用视角方向与顶点法向的点乘对该纹理进行采样。<br>需要注意，这种技术仅适用于一些特定的模型，这些模型必须保证法线与轮廓边缘之间存在一定关系。诸如立方体这样的模型，此方法并不太适用，因为往往无法得到轮廓边缘。但我们可以通过显式地绘制出折缝边缘，来正确地表现出这类比较明显的特征。</p><h4 id="3-2-基于过程几何方法的描边"><a href="#3-2-基于过程几何方法的描边" class="headerlink" title="3.2 基于过程几何方法的描边"></a>3.2 基于过程几何方法的描边</h4><p>基于过程几何方法生成的描边，即过程几何描边（Procedural Geometry Silhouetting），基本思想是先渲染正向表面（frontfaces），再渲染背向表面（backfaces），从而使得轮廓边缘可见，达到描边的目的。</p><p>有多种方法用来渲染背向表面，且各有优缺点。但它们都是先渲染正向表面，然后打开正向表面裁剪（culling）开关，同时关闭背向裁剪开关。这样这个 pass 中的渲染结果便只会显示出背向表面。</p><p>一种基于过程几何方法生成的描边的方法是仅仅渲染出背向表面的边界线（而不是面），使用偏置（Biasing）或者其他技术来确保这些线条恰好位于正向表面之前。这样就可以将除轮廓边缘之外的其他所有线条全部隐藏起来。这种方法非常适合单像素宽的线条，但如果线条的宽度超过这个值，那么通常会出现无法连接独立线段的情况，从而造成明显的缝隙。</p><p>另一种渲染较宽描边线条的方法是直接将背面表面本身渲染成黑色。但没有任何偏置操作，背向表面就会保持不可见，所以需要做的就是通过偏置将这些背向表面沿屏幕 Z 方向向前移动，这样，便只有背向表面的三角形边缘是可见的，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518151628850.png" alt="image-20220518151628850"></p><h4 id="3-3-基于图像处理的描边"><a href="#3-3-基于图像处理的描边" class="headerlink" title="3.3 基于图像处理的描边"></a>3.3 基于图像处理的描边</h4><p>基于图像处理生成轮廓描边（Silhouetting by Image Processing），即通过在各种缓冲区上执行图像处理技术，来实现非真实渲染的方法。可以将其理解为一种后处理操作。通过寻找相邻 Z 缓冲数值的不连续性，就可以确定大多数轮廓线的位置。同样，借助邻接表面法线向量的不连续性，可以确定出分界线（往往也是轮廓线）边缘的位置。此外，利用环境色对场景进行绘制，也可以用来检测前两种方法可能会漏掉的边缘。</p><h4 id="3-4-基于轮廓边缘检测的描边"><a href="#3-4-基于轮廓边缘检测的描边" class="headerlink" title="3.4 基于轮廓边缘检测的描边"></a>3.4 基于轮廓边缘检测的描边</h4><p>可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的具体介绍。</p><h4 id="3-5-混合轮廓描边"><a href="#3-5-混合轮廓描边" class="headerlink" title="3.5 混合轮廓描边"></a>3.5 混合轮廓描边</h4><p>混和轮廓描边（Hybrid Silhouetting），即结合了图像处理方法和几何要素方法，来渲染轮廓的方法。<br>这种方法的具体思想是：首先，找到一系列轮廓边缘的列表。其次，渲染出所有物体的三角形和轮廓边缘，同时为他们指定一个不同的 ID 值（也就是说，赋予不同的颜色）。接着读取该 ID 缓冲器并从中判断出可见的轮廓边缘，随之对这些可见线段进行重叠检测，并将它们连接起来形成平滑的笔划路径。最后就可以对这些重建起来的路径进行风格化笔划渲染，其中，这些笔划本身可以用很多方法来进行风格化处理，包括变细、火焰、摆动、淡化等效果，同时还有深度和距离信息。如下图是使用混合轮廓描边方法生成的图像，其中可以将找到的轮廓边缘连接起来作为笔划进行渲染：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152106468.png" alt="image-20220518152106468"></p><h3 id="4-其他风格的-NPR-技术"><a href="#4-其他风格的-NPR-技术" class="headerlink" title="4 其他风格的 NPR 技术"></a>4 其他风格的 NPR 技术</h3><p>除了卡通渲染这种比较受欢迎的模拟风格之外，还存在其他各式各样的风格。NPR 效果涵盖的范围非常广泛，RTR3 中主要谈了 3 种不同的其他风格的 NPR 渲染技术：</p><ul><li>纹理调色板（Palette of Textures）</li><li>色调艺术图（Tonal Art Maps，TAM）</li><li>嫁接（Graftals）</li></ul><h4 id="4-1-纹理调色板（Palette-of-Textures）"><a href="#4-1-纹理调色板（Palette-of-Textures）" class="headerlink" title="4.1 纹理调色板（Palette of Textures）"></a>4.1 纹理调色板（Palette of Textures）</h4><p>纹理调色板（palette of textures）由 Lake 等人讨论提出，基本思想是通过漫反射着色项（diffuse shading term）的不同，来选择应用于物体表面上的不同纹理。随着漫反射项逐渐变暗，可以选用相应更暗的纹理，而为了能够产生手绘的效果，可以使用屏幕空间坐标来采样纹理。同时，为了增强绘制效果，可以在屏幕空间上的所有表面上运用纸纹理。随着物体的运动，他们就可以在纹理之间进行穿梭。原因在于这个纹理是在屏幕空间中实现的。此外，也可以在世界空间中运用这个纹理，这样就能够得到一个与屏幕空间完全不同的效果。</p><p>下图是使用纹理调色板、纸纹理，以及轮廓边缘绘制生成的一幅图像：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152605870.png" alt="image-20220518152605870"></p><h4 id="4-2-色调艺术图（Tonal-Art-Maps）"><a href="#4-2-色调艺术图（Tonal-Art-Maps）" class="headerlink" title="4.2 色调艺术图（Tonal Art Maps）"></a>4.2 色调艺术图（Tonal Art Maps）</h4><p>通过在纹理之间进行切换形成的硬着色效果和卡通着色效果之间的一种混合，Praun 等人提出了一种可以实时生成笔划纹理分级细化图的方法，并可以将其以平滑的方式运用到物体表面上。第一步是生成即时使用的纹理，称为色调艺术图（Tonal Art Maps，TAM）,主要思想是将笔划绘制为分级细分图层次。下图是使用 TAM 渲染的过程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152848606.png" alt="image-20220518152848606"></p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的素描风格就使用了简化的 TAM 算法。</p><h4 id="4-3-嫁接（Graftals）"><a href="#4-3-嫁接（Graftals）" class="headerlink" title="4.3  嫁接（Graftals）"></a>4.3  嫁接（Graftals）</h4><p>嫁接（Graftals）的基本思想，是将几何或者贴花纹理应用到物体表面，从而产生某种特殊效果。可以通过所需要的细节层次，物体表面相对视点的方位或者其他因素，对纹理进行控制。这种方法可以用来模拟钢笔或者画刷的笔刷，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152954390.png" alt="image-20220518152954390"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中的非真实感渲染技术进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非真实感渲染（NPR）的基本思想&lt;/li&gt;
&lt;li&gt;卡通渲染&lt;/li&gt;
&lt;li&gt;轮廓描边方法总结&lt;/li&gt;
&lt;li&gt;其他风格的 NPR 渲染技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】基于图像的渲染技术总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T06:47:58.000Z</published>
    <updated>2022-05-18T06:51:09.216Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中基于图像的渲染技术进行概括总结和扩展。以综述形式为主，许多内容已经实现过或学习过，其他概念只需了解即可，主要内容包括：</p><ul><li>谱渲染 The Rendering Spectrum</li><li>固定视角的渲染 Fixed-View Rendering</li><li>天空盒 Skyboxes</li><li>光场渲染 Light Field Rendering</li><li>精灵与层 Sprites and Layers</li><li>公告板 Billboarding</li><li>粒子系统 Particle System</li><li>颜色校正 Color Correction</li><li>色调映射 Tone Mapping</li><li>镜头眩光和泛光 Lens Flare and Bloom</li><li>景深 Depth of Field</li><li>运动模糊 Motion Blur</li><li>体渲染 Volume Rendering</li></ul><p><em><span id="more"></span></em></p><h3 id="1-谱渲染"><a href="#1-谱渲染" class="headerlink" title="1 谱渲染"></a>1 谱渲染</h3><p>众所周知，渲染的目的就是在屏幕上渲染出物体，至于如何达到结果，主要依赖于用户的选择，白猫黑猫，抓到老鼠的就是好猫。而用多边形将三维物体显示在屏幕上，并非是进行三维渲染的唯一方法，也并非是最合适的方法。多边形具有从任何视角以合理的方式表示对象的优点，当移动相机的时候，物体的表示可以保持不变。但是，当观察者靠近物体的时候，为了提高显示质量，往往希望用比较高的细节层次来表示模型。与之相反，当物体位于比较远的地方时，就可以用简化形式来表示模型。这就是细节层次技术 (Level Of Detail,LOD)。使用 LOD 技术主要目的是为了加快场景的渲染速度。还有很多技术可以用来表示物体逐渐远离观察者的情形，比如，可以用图像而不是多边形来表示物体，从而减少开销，加快渲染速度。另外，单张图片可以很快地被渲染到屏幕上，用来表示物体往往开销很小。</p><p>Lengyel 于 1998 在《The Convergence of Graphics and Vision》一文中提出了一种表示渲染技术连续性的方法，名为 The Rendering Spectrum  渲染谱，如下图所示。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135741473.png" alt="image-20220518135741473"></p><p>下面是论文中更具体的图示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135757327.png" alt="image-20220518135757327"></p><p>可以将渲染谱理解为渲染的金字塔。从左到右，由简单到复杂，由二维图像到几何模型，从外观特征到物理渲染。</p><h3 id="2-固定视角的渲染"><a href="#2-固定视角的渲染" class="headerlink" title="2 固定视角的渲染"></a>2 固定视角的渲染</h3><p>固定视角的渲染（Fixed-View Rendering）技术，通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量渲染时间与性能。<br>对于复杂的几何和着色模型，每帧去重新渲染整个场景很可能是昂贵的。可以通过限制观看者的移动能力来对渲染进行加速。 最严格的情况是相机固定在位置和方位，即根本不移动。而在这种情况下，很多渲染可以只需做一次。<br>例如，想象一个有栅栏的牧场作为静态场景，一匹马穿过它。牧场和栅栏渲染仅一次，存储其颜色和 Z 缓冲区。每帧将这些 buffer 复制到可显示的颜色和 Z 缓冲中。为了获得最终的渲染效果，马本身是需要渲染的。如果马在栅栏后面，存储和复制的 z 深度值将把马遮挡住。请注意，在这种情况下，马不能投下阴影，因为场景无法改变。可以进行进一步的处理，例如，可以确定出马影子的区域，根据需求进行处理。关键是对于要显示的图像的颜色何时或如何设置这点上，是没有限制的。固定视角的特效（Fixed-View Effects）可以通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量时间。</p><h3 id="3-天空盒"><a href="#3-天空盒" class="headerlink" title="3 天空盒"></a>3 天空盒</h3><p>对于一些远离观众的物体，观众移动时几乎没有任何视差效果。换言之，如果你移动一米，甚至一千米，一座遥远的山本身看起来通常不会有明显的不同。当你移动时，它可能被附近的物体挡住视线，但是把那些物体移开，山本身看起来也依旧一样。天空盒就属于这种类型的物体。</p><p>环境贴图（environment map）可以代表本地空间入射光亮度。虽然环境贴图通常用于模拟反射，但它们也可以直接用来表示环绕环境的远处物体。任何独立于视图的环境地图表示都可以用于此目的；立方体贴图（cubic maps）是最为常见的一种环境贴图。环境贴图放置在围绕着观察者的网格上，并且足够大以包含场景中所有的对象。且网格的形状并不重要，但通常是立方体贴图。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518140529046.png" alt="image-20220518140529046"></p><h3 id="4-光场渲染"><a href="#4-光场渲染" class="headerlink" title="4 光场渲染"></a>4 光场渲染</h3><p>所谓光场（Light Field），可以理解为空间中任意点发出的任意方向的光的集合。而光场渲染（Light Field Rendering），可以理解为在不需要图像的深度信息或相关性的条件下，通过相机阵列或由一个相机按设计的路径移动，把场景拍摄下来作为输出图像集。对于任意给定的新视点，找出该视点邻近的几个采样点进行简单的重新采样和插值，就能得到该视点处的视图。</p><h3 id="5-精灵与层"><a href="#5-精灵与层" class="headerlink" title="5 精灵与层"></a>5 精灵与层</h3><p>最基本的基于图像的渲染的图元之一便是精灵（sprite）。精灵（sprite）是在屏幕上移动的图像，例如鼠标光标。精灵不必具有矩形形状，而且一些像素可以以透明形式呈现。对于简单的精灵，屏幕上会显示一个一对一的像素映射。存储在精灵中的每个像素将被放在屏幕上的像素中。可以通过显示一系列不同的精灵来生成动画。</p><p>更一般的精灵类型是将其渲染为应用于总是面向观看者的多边形的图像纹理。图像的 Alpha 通道可以为 sprite 的各种像素提供全部或部分透明度。这种类型的精灵可以有一个深度，所以在场景本身，可以顺利地改变大小和形状。一组精灵也可以用来表示来自不同视图的对象。对于大型物体，这种用精灵来替换的表现效果会相当弱，因为从一个精灵切换到另一个时，会很容易穿帮。也就是说，如果对象的方向和视图没有显着变化，则给定视图中的对象的图像表示可以对多个帧有效。而如果对象在屏幕上足够小，存储大量视图，即使是动画对象也是可行的策略。</p><p>考虑场景的一种方法是将其看作一系列的层（layers），而这种思想也通常用于二维单元动画。每个精灵层具有与之相关联的深度。通过这种从前到后的渲染顺序，我们可以渲染出整个场景而无需 Z 缓冲区，从而节省时间和资源。</p><h3 id="6-公告板"><a href="#6-公告板" class="headerlink" title="6 公告板"></a>6 公告板</h3><p>我们将根据观察方向来确定多边形面朝方向的技术叫做公告板（Billboarding）。而随着观察角度的变化，公告板多边形的方向也会根据需求随之改变。与 alpha 纹理和动画技术相结合，可以用公告板技术表示许多不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，能量盾（Energy Shields），水蒸气痕迹，以及云朵等。比如下图的树：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141422780.png" alt="image-20220518141422780"></p><p>给定表面的法线向量 n 和近似向上方向的向量 u，通过创建一组由三个相互垂直的向量，就可以确定公告板的方向。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141522323.png" alt="image-20220518141522323"></p><p>其中，左图是互相垂直的 u 和 n。中图是 r 向量通过 u 和 n 的叉乘得到，因此同时垂直于 u 和 n，而在右图中，对固定向量 n 和 r 进行叉乘就可以得到与他们都垂直的的向上向量  u’。</p><p>有三种不同类型的 Billboard，分别是：</p><ul><li><strong>Screen-Aligned Billboard  对齐于屏幕的公告板</strong>：这里的 n 是镜头视平面法线的逆方向，u 是镜头的 up 方向</li><li><strong>World-Oriented Billboard  面向世界的公告板</strong>：不能直接使用镜头的 up 做 up，因为镜头旋转了，并且所画的 billboard 原本是应该相对世界站立的，按 Screen-Aligned 的做法就会随镜头旋转，所以此时应该 r &#x3D; u * n(u 是其在世界上的 up，n 是镜头视线方向的逆方向)，最后再计算一次 u‘ &#x3D; r * n，即 u’ 才是最后的 up，即非物体本身相对世界的 up，亦非镜头的 up。</li><li><strong>Axial Billboard  轴向公告板</strong></li></ul><p>所以公告板技术是一种看似简单其实较为复杂的技术,它的实现变种较多。归其根本在于：</p><ul><li>View Oriented &#x2F; View plane oriented 的不同</li><li>Sphere&#x2F; Axial 的不同</li><li>Camera up &#x2F; World up 的不同</li></ul><p>如 View Oriented 和 View plane oriented 的不同，得到的公告板效果就完全不同：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142041015.png" alt="image-20220518142041015"></p><p>下图是使用公告板技术渲染的云层：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142105766.png" alt="image-20220518142105766"></p><p>另外还有一种特殊的公告板技术：替代物（Impostors），替代物是通过从当前视点将一个复杂物绘制到一幅图像纹理上来创建的，其中的图像纹理用于映射到公告板上，渲染过程与替代物在屏幕上覆盖的像素点数成正比，而不是与顶点数或者物体的复杂程度成正比。替代物可以用于物体的一些实例上或者渲染过程的多帧上，从而使整体性能获得提升。</p><p>使用 Imposters 的一个问题是渲染的图像必须持续地面向观察者。如果远处的物体正在改变方向，则必须重新计算 Imposters 的朝向。而为了模拟更像他们所代表的三角形网格的远处物体，D´ecoret 等人提出了公告板云（Billboard Clouds）的想法，即一个复杂的模型通常可以通过一系列的公告板集合相互交叉重叠进行表示。我们知道，一个真实物体可以用一个纸模型进行模拟，而公告板云可以比纸模型更令人信服，比如公告板云可以添加一些额外的信息，如法线贴图、位移贴图和不同的表面材质。另外，裂纹沿裂纹面上的投影也可以由公告板进行处理。而  D´ecoret 等人也提出了一种在给定误差容限内对给定模型进行自动查找和拟合平面的方法。</p><h3 id="7-粒子系统"><a href="#7-粒子系统" class="headerlink" title="7 粒子系统"></a>7 粒子系统</h3><p>粒子系统（Particle System）是一组分散的微小物体集合，其中这些微小物体按照某种算法运动。粒子系统的实际运用包括模拟火焰，烟，爆炸，流水，树木，瀑布，泡沫，旋转星系和其他的一些自然现象。粒子系统并不是一种渲染形式，而是一种动画方法，这种方法的思想是在粒子的生命周期内控制他们的产生，运动，变化和消失。</p><p>除了爆炸，瀑布，泡沫以及其他现象以外，还可以使用粒子系统进行渲染。例如，可以使用粒子系统来创建树木模型，也就是表示树木的几何形状，当视点距离模型较近时，就会产生更多的粒子来生成逼真的视觉效果。下图是用粒子系统渲染的树木：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142415857.png" alt="image-20220518142415857"></p><h3 id="8-图像处理"><a href="#8-图像处理" class="headerlink" title="8 图像处理"></a>8 图像处理</h3><p>图像处理的过程，一般在像素着色器中进行，因为在像素着色器中，可以很好地将渲染过程和纹理结合起来，而且在 GPU 上跑像素着色器，速度和性能都可以满足一般所需。<br>一般而言，首先需要将场景渲染成 2D 纹理或者其他图像的形式，再进行图像处理，这里的图像处理，往往指的是后处理（post effects）。而下文将介绍到的颜色校正（Color Correction）、色调映射（Tone Mapping）、镜头眩光和泛光（Lens Flare and Bloom）、景深（Depth of Field）、运动模糊（Motion Blur），一般而言都是后处理效果。</p><h3 id="9-颜色校正"><a href="#9-颜色校正" class="headerlink" title="9 颜色校正"></a>9 颜色校正</h3><p>色彩校正(Color correction)是使用一些规则来转化给定的现有图像的每像素颜色到其他颜色的一个过程。颜色校正有很多目的，例如模仿特定类型的电影胶片的色调，在元素之间提供一致的外观，或描绘一种特定的情绪或风格。一般而言，通过颜色校正，游戏画面会获得更好的表现效果。</p><p>颜色校正通常包括将单个像素的 RGB 值作为输入，并向其应用算法来生成一个新的 RGB。颜色校正的另一个用途是加速视频解码，如 YUV 色彩空间到 RGB 色彩空间的转换。基于屏幕位置或相邻像素的更复杂的功能也可行，但是大多数操作都是使用每像素的颜色作为唯一的输入。</p><p>对于一个计算量很少的简单转换，如亮度的调整，可以直接在像素着色器程序中基于一些公式进行计算，应用于填充屏幕的矩形。而对于复杂的计算函数，一个通常使用的方法是使用查找表（Look-Up Table，LUT）。由于从内存中提取数值经常要比复杂的计算速度快很多，所以使用查找表进行颜色校正操作，速度提升是很显著的。</p><h3 id="10-色调映射"><a href="#10-色调映射" class="headerlink" title="10 色调映射"></a>10 色调映射</h3><p>计算机屏幕具有特定的亮度范围，而真实图像具有更巨大的亮度范围。色调映射（Tonemapping），也称为色调复制（tone reproduction），便是将宽范围的照明级别拟合到屏幕有限色域内的过程。色调映射与表示高动态范围的  HDR 和  HDRI 密切相关：</p><ul><li>HDR，是 High-Dynamic Range（高动态范围）的缩写</li><li>HDRI 是 High-Dynamic Range Image 的缩写，即 HDR 图像，高动态范围图像</li><li>实际过程中，HDR 和 HDRI 两者经常会被混用，都当做高动态范围成像的概念使用，这也是被大众广泛接受的</li></ul><p>本质上来讲，色调映射要解决的问题是进行大幅度的对比度衰减以将场景亮度变换到可以显示的范围，同时要保持图像细节与颜色等表现原始场景的重要信息。</p><p>根据应用的不同，色调映射的目标可以有不同的表述。在有些场合，生成“好看”的图像是主要目的，而在其它一些场合可能会强调生成尽可能多的细节或者最大的图像对比度。在实际的渲染应用中可能是要在真实场景与显示图像中达到匹配，尽管显示设备可能并不能够显示整个的亮度范围。</p><p>简单来说，整个 Tone Mapping 的过程就是首先要根据当前的场景推算出场景的平均亮度，再根据这个平均亮度选取一个合适的亮度域，再将整个场景映射到这个亮度域得到正确的结果。</p><p>具体关于色调映射算法可以查看：</p><ul><li><a href="https://blog.csdn.net/qq_37363005/article/details/103593541">Tone Mapping—色调映射算法</a></li><li><a href="https://blog.csdn.net/qq_21842097/article/details/121035017">色调映射（Tone Mapping）</a></li></ul><h3 id="11-镜头眩光和泛光"><a href="#11-镜头眩光和泛光" class="headerlink" title="11 镜头眩光和泛光"></a>11 镜头眩光和泛光</h3><p>镜头眩光（Lens flare）是由于眼睛的晶状体或者相机的透镜直接面对强光所产生的一种现象，由一圈光晕（halo）和纤毛状的光环（ciliary corona）组成。光晕的出现是因为透镜物质（如三棱镜）对不同波长光线折射数量的不过而造成的，看上去很像是光周围的一个圆环，外圈是红色，内圈是紫红色。纤毛状的光环源于透镜的密度波动，看起来像是从一个点发射出来的光线。Lens flare 是近来较为流行的一种图像效果，自从我们认识到它是一种实现真实感效果的技术后，计算机便开始模拟此效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143849029.png" alt="image-20220518143849029"></p><p>泛光（Bloom）效果，是由于眼睛晶状体和其他部分的散光而产生，在光源附近出现的一种辉光。在现实世界中，透镜无法完美聚焦是泛光效果的物理成因；理想透镜也会在成像时由于衍射而产生一种名为艾里斑的光斑。在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">【Unity Shader】（七）基础屏幕特效</a>中实现过 Bloom 效果。<br>常见的一个误解便是将 HDR 和 Bloom 效果混为一谈。Bloom 可以模拟出 HDR 的效果，但是原理上和 HDR 相差甚远。HDR 实际上是通过映射技术，来达到整体调整全局亮度属性的，这种调整是颜色，强度等都可以进行调整，而 Bloom 仅仅是能够将光照范围调高达到过饱和，也就是让亮的地方更亮。不过 Bloom 效果实现起来简单，性能消耗也小，却也可以达到不错的效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143939832.png" alt="image-20220518143939832"></p><h3 id="12-景深"><a href="#12-景深" class="headerlink" title="12 景深"></a>12 景深</h3><p>在光学领域，特别是摄影摄像领域，景深（Depth of field，DOF），也叫焦点范围（focus range）或有效焦距范围（effective focus），是指场景中最近和最远的物体之间出现的可接受的清晰图像的距离。换言之，景深是指相机对焦点前后相对清晰的成像范围。在相机聚焦完成后，在焦点前后的范围内都能形成清晰的像，这一前一后的距离范围，便叫做景深。</p><p>景深通常由物距、镜头焦距，以及镜头的光圈值所决定（相对于焦距的光圈大小）。除了在近距离时，一般来说景深是由物体的放大率以及透镜的光圈值决定。固定光圈值时，增加放大率，不论是更靠近拍摄物或是使用长焦距的镜头，都会减少景深的距离；减少放大率时，则会增加景深。如果固定放大率时，增加光圈值（缩小光圈）则会增加景深；减小光圈值（增大光圈）则会减少景深。</p><p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/">【RayTracer】（七）景深效果</a>中有代码实现。</p><h3 id="13-运动模糊"><a href="#13-运动模糊" class="headerlink" title="13 运动模糊"></a>13 运动模糊</h3><p>实现运动模糊的方法大致分  3 种：</p><ul><li>直接渲染模糊本身。通过在对象移动之前和之后添加几何体来完成，并通过次序无关的透明，避免 Alpha 混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/">【RayTracer】（九）运动模糊</a>中的实现就是使用的这种方法。</li><li>基于累积缓冲区（accumulationbuffer），通过平均一系列图像来创建模糊。</li><li>基于速度缓冲器（velocity buffer）。目前这个方法最为主流。创建此缓冲区，需插入模型三角形中每个顶点的屏幕空间速度。通过将两个建模矩阵应用于模型来计算速度，一个用于最后一帧，一个用于当前模型。顶点着色器程序计算位置的差异，并将该向量转换为相对的屏幕空间坐标。</li></ul><p>运动模糊对于由摄像机运动而变得模糊的静态物体来说比较简单，因为往往这种情况下不需要速度缓冲区。如果需要的是摄像机移动时的运动感，可以使用诸如径向模糊（radial blur）之类的固定效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518144557566.png" alt="image-20220518144557566"></p><h3 id="14-体渲染"><a href="#14-体渲染" class="headerlink" title="14 体渲染"></a>14 体渲染</h3><p>体渲染（Volume Rendering），又称立体渲染，体绘制，是一种用于显示离散三维采样数据集的二维投影的技术。体渲染技术中的渲染数据一般用体素（Volumeric Pixel，或  Voxel）来表示，每个体素表示一个规则空间体。例如，要生成人头部的医学诊断图像（如 CT 或 MRI），同时生成 256 x256 个体素的数据集合，每个位置拥有一个或者多个值，则可以将其看做三维图像。因此，体渲染也是基于图像的渲染技术中的一种。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中基于图像的渲染技术进行概括总结和扩展。以综述形式为主，许多内容已经实现过或学习过，其他概念只需了解即可，主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谱渲染 The Rendering Spectrum&lt;/li&gt;
&lt;li&gt;固定视角的渲染 Fixed-View Rendering&lt;/li&gt;
&lt;li&gt;天空盒 Skyboxes&lt;/li&gt;
&lt;li&gt;光场渲染 Light Field Rendering&lt;/li&gt;
&lt;li&gt;精灵与层 Sprites and Layers&lt;/li&gt;
&lt;li&gt;公告板 Billboarding&lt;/li&gt;
&lt;li&gt;粒子系统 Particle System&lt;/li&gt;
&lt;li&gt;颜色校正 Color Correction&lt;/li&gt;
&lt;li&gt;色调映射 Tone Mapping&lt;/li&gt;
&lt;li&gt;镜头眩光和泛光 Lens Flare and Bloom&lt;/li&gt;
&lt;li&gt;景深 Depth of Field&lt;/li&gt;
&lt;li&gt;运动模糊 Motion Blur&lt;/li&gt;
&lt;li&gt;体渲染 Volume Rendering&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【Real-Time Rendering】全局光照总结</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E6%80%BB%E7%BB%93/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-18T05:47:51.000Z</published>
    <updated>2022-05-18T05:48:41.302Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对《Real-Time Rendering》一书中全局光照相关知识进行概括总结和扩展。主要内容包括：</p><ul><li>全局光照概述</li><li>光线投射、光线追踪和路径追踪的区别</li><li>环境光遮蔽</li></ul><p><em><span id="more"></span></em></p><h3 id="1-全局光照"><a href="#1-全局光照" class="headerlink" title="1 全局光照"></a>1 全局光照</h3><p>全局光照 (Global Illumination，GI)，是指既考虑场景中直接来自光源的光照（Direct Light）又考虑经过场景中其他物体反射后的光照（Indirect Light）的一种渲染技术。使用全局光照能够有效地增强场景的真实感。<br>可以理解为：全局光照    &#x3D;  直接光照(Direct Light) +  间接光照(Indirect Light)</p><p>虽说实际应用中只有漫反射全局照明的模拟算法被称为全局照明算法，但其实理论上说反射、折射、阴影都属于全局光照的范畴，因为模拟它们的时候不仅仅要考虑光源对物体的直接作用还要考虑物体与物体之间的相互作用。也是因为，镜面反射、折射、阴影一般不需要进行复杂的光照方程求解，也不需要进行迭代的计算。因此，这些部分的算法已经十分高效，甚至可以做到实时。不同于镜面反射，光的漫反射表面反弹时的方向是近似“随机”，因此不能用简单的光线跟踪得到反射的结果，往往需要利用多种方法进行多次迭代，直到光能分布达到一个基本平衡的状态。</p><p>经过几十年的发展，全局光照现今已有多种实现方向，常见的全局光照主要流派列举如下：</p><ul><li>Ray tracing  光线追踪</li><li>Path tracing  路径追踪</li><li>Photon mapping  光子映射</li><li>Point Based Global Illumination  基于点的全局光照</li><li>Radiosity  辐射度</li><li>Metropolis light transport  梅特波利斯光照传输</li><li>Spherical harmonic lighting  球谐光照</li><li>Ambient occlusion  环境光遮蔽</li><li>Voxel-based Global Illumination  基于体素的全局光照</li><li>Light Propagation Volumes Global Illumination</li><li>Deferred Radiance Transfer Global Illumination</li><li>Deep G-Buffer based Global Illumination</li></ul><p>而其中的每种流派，又可以划分为 N 种改进和衍生算法。<br>如光线追踪（Ray Tracing）派系，其实就是一个框架，符合条件的都可称为光线追踪，其又分为递归式光线追踪（Whitted-style Ray Tracing），分布式光线追踪（Distribution Ray Tracing），蒙特卡洛光线追踪（Monte Carlo Ray Tracing）等。<br>而路径追踪（Path tracing）派系，又分为蒙特卡洛路径追踪（Monte Carlo Path Tracing），双向路径追踪（Bidirectional Path Tracing），能量再分配路径追踪（Energy Redistribution Path Tracing）等。<br>其中有些派系又相互关联，如路径追踪，就是基于光线追踪，结合了蒙特卡洛方法而成的一种新的派系。</p><h3 id="2-光线投射、光线追踪和路径追踪的区别"><a href="#2-光线投射、光线追踪和路径追踪的区别" class="headerlink" title="2 光线投射、光线追踪和路径追踪的区别"></a>2 光线投射、光线追踪和路径追踪的区别</h3><p>关于光线追踪和路径追踪可以查看之前的笔记：</p><ul><li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a></li><li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a></li><li><a href="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/">RayTracer 系列</a>前半部分实现的是光线追踪，后半部分加入蒙特卡洛后最终实现的是一个路径追踪器</li></ul><p>这里总结一下光线追踪、光线投射和路径追踪的区别：</p><ul><li><strong>光线追踪 Ray Tracing</strong>：这其实是个框架，而不是个方法。符合这个框架的都叫 ray tracing。这个框架就是从视点发射 ray，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。</li><li><strong>光线投射 Ray Casting</strong>：它就是 ray tracing 的第一步，发射光线，与物体相交。这个可以做的很快，也可以用来做遮挡、阴影等。</li><li><strong>路径追踪 Path Tracing</strong>：路径追踪就是 ray tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据 BRDF 计算颜色。运算量也不小。还有一些小分类，比如 Bidirectional path tracing。</li></ul><h3 id="3-环境光遮蔽"><a href="#3-环境光遮蔽" class="headerlink" title="3 环境光遮蔽"></a>3 环境光遮蔽</h3><p>环境光遮蔽（Ambient Occlusion，简称 AO）是全局光照明的一种近似替代品，可以产生重要的视觉明暗效果，通过描绘物体之间由于遮挡而产生的阴影， 能够更好地捕捉到场景中的细节，可以解决漏光，阴影漂浮等问题，改善场景中角落、锯齿、裂缝等细小物体阴影不清晰等问题，增强场景的深度和立体感。<br>可以说，环境光遮蔽在直观上给玩家的主要感觉体现在画面的明暗程度上，未开启环境光遮蔽特效的画面光照稍亮一些；而开启环境光遮蔽特效之后， 局部的细节画面尤其是暗部阴影会更加明显一些。</p><p>Ambient Occlusion 的细分种类有：</p><ul><li>SSAO-Screen space ambient occlusion</li><li>SSDO-Screen space directional occlusion</li><li>HDAO-High Definition Ambient Occlusion</li><li>HBAO+-Horizon Based Ambient Occlusion+</li><li>AAO-Alchemy Ambient Occlusion</li><li>ABAO-Angle Based Ambient Occlusion</li><li>PBAO</li><li>VXAO-Voxel Accelerated Ambient Occlusion</li></ul><p>一般而言，Ambient Occlusion 最常用方法是 SSAO，如 Unreal Engine 4 中的 AO，即是用 SSAO 实现。关于 SSAO 的原理可以查看这篇文章简要了解：<a href="https://zhuanlan.zhihu.com/p/46633896">环境遮罩之SSAO原理</a></p><p>总的来说 SSAO 是在屏幕空间进行的环境光遮蔽计算，以牺牲部分渲染效果和精度的代价，来换取高时效性，适用于游戏等实时渲染领域。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇对《Real-Time Rendering》一书中全局光照相关知识进行概括总结和扩展。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局光照概述&lt;/li&gt;
&lt;li&gt;光线投射、光线追踪和路径追踪的区别&lt;/li&gt;
&lt;li&gt;环境光遮蔽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Real-Time Rendering" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Real-Time-Rendering/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
