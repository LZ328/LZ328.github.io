<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-05-11T08:12:51.045Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++对象模型】（七）模板和RTTI</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/</id>
    <published>2022-05-11T08:08:23.000Z</published>
    <updated>2022-05-11T08:12:51.045Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第七章重点梳理。主要内容包括：</p><ul><li>模板（Template）</li><li>执行期类型识别（Runtime Type Identification，RTTI）</li></ul><p><em><span id="more"></span></em></p><h3 id="1-模板（Template）"><a href="#1-模板（Template）" class="headerlink" title="1 模板（Template）"></a>1 模板（Template）</h3><h4 id="1-1-模板的实例化"><a href="#1-1-模板的实例化" class="headerlink" title="1.1 模板的实例化"></a>1.1 模板的实例化</h4><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++ 标准才要求实例化他们。其原因，有两点：</p><ul><li>空间和时间效率的考虑，如果模板类中有 100 个成员函数，对某个特定类型只有 2 个函数会被使用，针对另一个特定类型只会使用 3 个，那么如果将剩余的 195 个函数实例化将浪费大量的时间和空间。</li><li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li></ul><h4 id="1-2-模板的名称决议"><a href="#1-2-模板的名称决议" class="headerlink" title="1.2 模板的名称决议"></a>1.2 模板的名称决议</h4><p>对于一个模板类来说，需要明确两个范围：一个是定义模板的范围（scope of the template definition），另一个是实例化模板的范围（scope of the template instantiation）。</p><p>下面来举例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeRules</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        _member = <span class="built_in">foo</span>( _val );  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>( _member );  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _val;  </span><br><span class="line">    type _member;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope of the template instantiation  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;  </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ScopeRules&lt; <span class="type">int</span> &gt; sr0;  </span><br><span class="line"><span class="comment">/*(1)*/</span>sr0.<span class="built_in">invariant</span>();</span><br><span class="line"><span class="comment">/*(2)*/</span>sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></table></figure><p>对于上面的语句（1），将会调用哪一个 <code>foo()</code> 函数呢？答案是 <code>double foo ( double )</code>，这是一个完全反直觉的答案，原因在于 <code>invariant()</code> 函数调用了一个外部函数 <code>foo()</code> ，但传入的参数是模板类中固定类型的成员 <code>_val</code>，无论模板被实例化为什么类型，其中的 <code>_val</code> 都是 int 型，也就是说它完全与实例化模板的参数的类型无关，此时对于外部函数名称的决议会在定义模板的范围内进行，在上面的例子中，定义模板的范围内只有一个 <code>foo()</code> 函数的声明，所以即使 <code>_val</code> 是 int 型，也会调用 double 作为参数的 <code>foo()</code> 函数。</p><p>而对于语句（2），会调用 <code>int foo( int )</code>，因为 <code>type_dependent()</code> 函数将与实例化模板的参数类型有关的成员作为参数传给了外部函数，此时就无法在定义模板类的范围内决议使用哪个 <code>foo()</code> 函数，所以要推迟到模板被实例化之后再决议，因此会在实例化模板的范围内寻找合适的函数，上面的例子中，实例化模板的范围中有两个声明的 <code>foo()</code> 函数，所以会选择和模板类型匹配的 <code>foo(int)</code> 函数进行调用。</p><p>总结一下，在模板中，一个非成员名称的决议在于它适不适合在当前决议，当它完全与实例化模板的参数类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，于是将被推迟到实例化这个模板的时候才决议。</p><h3 id="2-执行期类型识别（Runtime-Type-Identification）"><a href="#2-执行期类型识别（Runtime-Type-Identification）" class="headerlink" title="2 执行期类型识别（Runtime Type Identification）"></a>2 执行期类型识别（Runtime Type Identification）</h3><p>在一开始学习多态的时候就已经了解过 RTTI，这里最后进行总结：</p><ol><li>RTTI  只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI 的，这是因为 RTTI 的实现是通过 vptr 来获取存储在虚函数表中的 <code>type_info*</code> ，事实上为非多态类提供 RTTI 也没有多大意义</li><li>对指针进行 <code>dynamic_cast</code> 失败会返回 NULL，而对引用的话，失败会抛出 <code>bad_cast exception</code>，这是由于指针可以被赋值为 0，以表示 no object，但是引用不行</li><li><code>typeid</code> 可以返回 <code>const type_info&amp;</code>，用以获取类型信息。虽然第一点指出 RTTI 只支持多态类，但 <code>typeid</code> 和 <code>type_info</code> 同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的 <code>type_info</code> 对象是静态取得（所以不能叫“执行期类型识别”），而多态类的是在执行期获得。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第七章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板（Template）&lt;/li&gt;
&lt;li&gt;执行期类型识别（Runtime Type Identification，RTTI）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（六）关于执行期</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/</id>
    <published>2022-05-11T07:17:16.000Z</published>
    <updated>2022-05-11T07:19:14.225Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第六章重点梳理。主要内容包括：</p><ul><li>执行期对象的构造与析构</li><li>详解 new 和 delete</li></ul><p><em><span id="more"></span></em></p><h3 id="1-对象的构造与析构"><a href="#1-对象的构造与析构" class="headerlink" title="1 对象的构造与析构"></a>1 对象的构造与析构</h3><p>一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    Point point; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// point.Point::Point() 一般被安插在这儿      </span></span><br><span class="line">    </span><br><span class="line">    ...      </span><br><span class="line">             </span><br><span class="line">    <span class="comment">// point.Point::~Point() 一般被安插在这儿 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方</strong>，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。</p><h4 id="1-1-全局对象（Global-Objects）"><a href="#1-1-全局对象（Global-Objects）" class="headerlink" title="1.1 全局对象（Global Objects）"></a>1.1 全局对象（Global Objects）</h4><p>一个全局对象，C++ 保证它在 <code>main()</code> 第一次使用它之前将其构造，而在 <code>main()</code> 结束之前，将之析构掉。C++ 程序中所有的 global objects 都被放置在程序的 data segment (数据段) 中，如果明确指定给它一个值， object 将以该值为初值。否则 object 所配置到的内存内容为 0.</p><p>虽然全局对象在编译期被即被置为 0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是静态初始化。所谓静态初始化，是因为全局变量被放在 data segment，data segment 是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为 0，存储在数据段，而等到程序激活时，就可以通过构造函数对在数据段的全局对象进行初始化了.</p><blockquote><p>以下引用自原书：</p><p>静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置于 try 块中，我们知道一个没有得到 catch 的异常默认的调用 <code>terminate()</code> 函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…</p><p>Lippman 甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。</p></blockquote><h4 id="1-2-局部静态对象（Local-Static-Objects）"><a href="#1-2-局部静态对象（Local-Static-Objects）" class="headerlink" title="1.2 局部静态对象（Local Static Objects）"></a>1.2 局部静态对象（Local Static Objects）</h4><p>下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Matrix&amp;  <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> Matrix mat_identity;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>static</code> 语意保证了 mat_identity 对象在整个程序周期都存在，而不会在函数 <code>identity()</code>退出时被析构，所以：</p><ul><li>mat_identity 的构造函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li><li>mat_identity 的析构函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li></ul><p>那么 mat_identity 的构造函数和析构函数到底在什么时候被调用？答案是：mat_identity 的构造函数只有在  <code>identity()</code> 第一次被调用时才被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。</p><h4 id="1-3-对象数组（Array-of-Objects）"><a href="#1-3-对象数组（Array-of-Objects）" class="headerlink" title="1.3 对象数组（Array of Objects）"></a>1.3 对象数组（Array of Objects）</h4><p>对于定义的一个对象数组，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际上背后做的工作是：</p><ol><li>分配充足的内存以存储 10 个 Point 对象；</li><li>为每个 Point 对象调用它们的默认构造函数（如果有的话，且不论是合成的还是显式定义的）。编译器一般以一个或多个函数来完成这个任务。当数组的生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。而关于具体细节，不必要死扣了，每个编译器肯定都有些许差别。</li></ol><h3 id="2-new-和-delete"><a href="#2-new-和-delete" class="headerlink" title="2 new 和 delete"></a>2 new 和 delete</h3><p>C++ 中一个经常容易混淆的问题是关于：operator new、new expression 和 placement operator new。这一节来详细讨论这三者的区别和联系。</p><h4 id="2-1-operator-new-和-new-expression"><a href="#2-1-operator-new-和-new-expression" class="headerlink" title="2.1 operator new 和 new expression"></a>2.1 operator new 和 new expression</h4><p>首先要明确，operator new 是一个运算符，和 +、-、*、% 等一样，是可以被重载的，而 new expression 不可以被重载，new expression 是对 operator new 的又一层封装。</p><p>C 语言中 <code>malloc</code> 函数我们非常熟悉，函数原型为 <code>void* malloc(size_t size)</code> ，参数 size 为要分配的字节数，返回值是 void*，通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址，失败会返回 NULL，但是申请成功后并不进行初始化，每个数据都是随机值。</p><p>operator new 是对 malloc 的封装，因此功能和 malloc 完全一样，只有一点细微的不同，operator new 在内存申请失败时会抛出异常，除此之外完全相同，也就是说，operator new 只用于分配内存。</p><p>而当我们使用非常熟悉的 new expression，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>实际上包含了两个步骤：</p><ul><li>调用 operator new 分配内存</li><li>调用合适的构造函数初始化这块内存，如果不是自定义的类，那么初始化就是简单的赋值操作</li></ul><p>由此可见， new expression 是对 operator new 的又一层封装。</p><p>我们当然也可以直接使用 operator new，比如只想分配内存的时候，完全可以替代 C 语言中的 <code>malloc</code> 操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T* newelements = <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line"><span class="comment">// 等同于T* pa = (T*)malloc(sizeof(T));</span></span><br><span class="line"><span class="comment">// static_cast表示明确的显式转换，可以告诉编译器和阅读程序的人这样的转换是故意为之</span></span><br></pre></td></tr></table></figure><p>STL 中重载有两个版本的 operator new，分别为单个对象和数组对象服务，单个对象版本提供给分配单个对象的 <code>new</code> 表达式调用，数组版提供给分配数组的 <code>new[]</code> 表达式调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;     <span class="comment">// allocate an object</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// allocate an array</span></span><br></pre></td></tr></table></figure><p>我们可以分别重载这两个版本，来自定义单个对象或对象数组的内存分配方式。当我们自己在重载 operator new 时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个 <code>void*</code> 类型和第一个参数的类型必须为 <code>size_t</code>。</p><p>同样的，operator delete 和 delete expression 的关系和上述 operator new 和 new expression 的关系完全一样，delete expression 会先调用析构函数，再调用 operator delete 释放内存。operator delete 的功能和 C 中的 <code>free</code> 完全一样，是对 <code>free</code> 的封装。</p><p>需要注意的是，在类中重载的 operator new 和 operator delete 必须是静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个 this 指针来存取对象成员。另外，new expression 默认调用的是单参数的 operator new，即上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p><h4 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h4><p>有下面两种关于 delete expression 的情况，第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// p为什么能delete两次，而程序运行的时候还不报错。</span></span><br></pre></td></tr></table></figure><p>第二种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> ;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">5</span>;     <span class="comment">//delete后为什么还可以对*p进行再赋值？</span></span><br></pre></td></tr></table></figure><p>在回答这两个问题之前，我们先想想 <code>delete p</code>  这一语句意味着什么？p 指向一个地址，以该地址为起始地址保存有一个 <code>int</code> 变量（虽然该变量并没有进行初始化，因此默认为 0），<code>delete p</code> 之后 p 所指向的地址空间被释放，也就是说这个 int 变量的生命结束，但是 p 仍是一个合法的指针，它仍指向原来的地址，而且该地址仍代表着一个合法的程序空间。与 <code>delete</code> 之前唯一不同的是，你已经丧失了那块程序空间的所有权。但你依然可以通过指针对这块空间进行操作，因为你还保留有这块空间的“钥匙” p。</p><p>此时通过指针 p 对这块空间进行操作虽然从语法上来说是合法的，但是暗藏着很大的逻辑错误。不论是对一块已经释放的内存再度 <code>delete</code>，还是再度给它赋值，都暗含着很大的危险，因为当你 <code>delete</code> 后，就代表着将这块内存归还，而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度 <code>delete</code> 还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，完全取决于编译器够不够“聪明”。</p><p>上述情况下的指针 p 被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。避免野指针的一个好方法是，当一个指针变为野指针的时候，马上赋值为 <code>NULL</code>，其缘由在于，你可以很容易的判断一个指针是否为 <code>NULL</code>，却难以抉择其是否为野指针。而且，<code>delete</code> 一个空指针，不会做任何操作，因此总是安全的。</p><h4 id="2-3-placement-operator-new-和-placement-new-expression"><a href="#2-3-placement-operator-new-和-placement-new-expression" class="headerlink" title="2.3 placement operator new 和 placement new expression"></a>2.3 placement operator new 和 placement new expression</h4><p>placement new expression 的功能是对已经存在的空间进行初始化，即用来在指定地址上构造对象，因此它并不分配内存，仅仅是对指定地址调用构造函数。</p><p>而 placement operator new 是对 operator new 的重载，它的功能就是返回给定的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 p 指针指向的内存已经存在，不需要再分配内存，因此只要返回这个指针即可。</p><p>placement new expression 先调用 placement operator new 返回指针 p，然后调用构造函数初始化这个指针指向的内存，这样也就完成了对已经存在的空间进行初始化的工作。</p><p>需要注意的是，通过 placement new expression 构建的一个对象，如果你使用 delete 来删除对象，那么其内存也会被回收，如果想保留内存而只析构对象，好的办法是显式调用其析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* pa = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="comment">// 使用 placement new expression 初始化内存</span></span><br><span class="line"><span class="built_in">new</span>(pa) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 显式调用析构函数析构对象</span></span><br><span class="line">pa-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// 此时内存还在，手动使用delete释放内存，如果直接使用delete则其自动先调用析构，再释放内存</span></span><br><span class="line"><span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上并没有 placement new expression 这么一说，上面的说法只是为了便于理解，从头到尾都只有一个 new expression，并且 new expression 永远都只进行以下两个步骤：</p><ul><li>调用一个合适参数的 operator new 来分配内存，可以是普通的 operator new，也可以是 operator new[]，还可以是 placement  operator new</li><li>调用一个合适参数的构造函数初始化 operator new 分配的内存</li></ul><h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><p>operator new、new expression 和 placement operator new 三者的关系现在非常明了，总结如下：</p><ul><li>operator new 相当于 malloc 分配内存，区别在于申请失败时抛出异常而不是返回空指针</li><li>placement operator new 将给定的指针直接返回，相当于返回一块已经存在的内存</li><li>new expression 首先调用合适的 operator new 分配内存（可能是新分配的，也可能是已经存在的），然后调用构造函数初始化这块内存</li><li>operator delete 相当于 free 释放内存</li><li>delete expression 首先调用析构函数，然后调用 operator delete 释放内存</li></ul><h4 id="2-5-内存池"><a href="#2-5-内存池" class="headerlink" title="2.5 内存池"></a>2.5 内存池</h4><p>关于内存池技术有必要的话可以再做深入学习，这里只做简单了解即可。</p><p>利用默认的内存管理操作符 new 和 delete 在堆上分配和释放内存会有一些额外的开销。</p><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。</p><p>可见，如果程序频繁地使用 new 和 delete 在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。</p><p>C++ 引入了内存池（Memory Pool）来提高内存管理和运行效率。内存池是一种高效的内存分配方式，其工作原理是先向系统一次性申请比较大的空间，当我们每次去申请空间时就直接使用内存池里的空间，而省略了申请和释放的两个动作开销，也减少了系统内存碎片，从而提高了系统效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第六章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行期对象的构造与析构&lt;/li&gt;
&lt;li&gt;详解 new 和 delete&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（五）对象复制和析构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/</id>
    <published>2022-05-09T08:37:15.000Z</published>
    <updated>2022-05-11T07:16:51.387Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第五章重点梳理。主要内容包括：</p><ul><li>关于对象复制操作（Copy Assignment Operator）</li><li>关于对象析构（Destruction）</li><li>几点类的设计原则</li></ul><p><em><span id="more"></span></em></p><h3 id="1-关于-Copy-Assignment-Operator"><a href="#1-关于-Copy-Assignment-Operator" class="headerlink" title="1 关于 Copy Assignment Operator"></a>1 关于 Copy Assignment Operator</h3><p>Copy Assignment Operator 是指类中对 <code>operator=</code> 的重载，用来将一个对象指定给另一个对象。如果我们希望不允许将该类的对象指定给另一个对象，只需要将 <code>operator=</code> 设定为 private，并且不提供函数体即可。</p><p>当然大部分情况下，类的设计者可以选择不显式提供 copy assignment operator，使用默认的逐成员复制（类似于拷贝构造函数），因为这样既方便，效率又高。copy assignment operator 和拷贝构造函数一样，只在有用（nontrivial）的时候会真正被编译器产生或合成出来，而其他情况下由于保持有 bitwise copy semantics，不需要以函数调用的形式进行复制，也就无须合成。在四种情况下 copy assignment operator 会被视为 nontrivial 而被合成出来：</p><ul><li>当 class 中包含一个对象成员而后者的类声明有一个 copy assignment operator 时，因为需要调用对象成员的 copy assignment operator</li><li>当 class 继承自一个 base class 而后者存在有一个 copy assignment operator 时，因为需要调用基类的 copy assignment operator</li><li>当 class 声明了一个或多个 virtual functions 时，因为我们一定不能直接拷贝等号右边对象的 vptr，因为等号左边可能是基类对象，而右边是派生类对象</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时（不论虚基类有没有 copy assignment operator）</li></ul><h3 id="2-关于析构（Destruction）"><a href="#2-关于析构（Destruction）" class="headerlink" title="2 关于析构（Destruction）"></a>2 关于析构（Destruction）</h3><p>如果 class 没有显式定义析构函数，那么只有在 class 内包含的 member object（或是 class 自己的 base class）拥有析构函数时，编译器才会自动合成一个析构函数，否则，析构函数会被视为不需要，也就不需被合成（当然更不需要被调用）。析构函数的扩展和执行顺序类似于之前构造函数的执行顺序，并且与构造函数的顺序完全相反：</p><ol><li>构造函数本身首先被执行</li><li>如果有对象成员，且其有析构函数，按照它们声明顺序的相反顺序调用它们的析构函数</li><li>如果有 vptr，则重设 vptr，指向适当的基类的虚函数表</li><li>如果有任何直接的（上一层） nonvirtual base classes 拥有 destructor，它们会以其声明顺序的相反顺序被调用</li><li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个类是继承链最尾端 (most-derived) 的类，那么它们会以其原来的构造顺序的相反顺序被调用</li></ol><p>对于如下类继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220509161840825.png" alt="image-20220509161840825"></p><p>那么一个 PVertex 对象的构造过程是：首先构造一个 Point 对象，然后变成一个 Vertex 和一个 Point3d 对象，然后变成一个 Vertex3d 对象，最后变成一个 PVertex 对象；而一个 PVertex 对象的析构过程正相反：依次变成一个 Vertex3d 对象、一个 Vertex 对象、 一个 Point3d 对象，最后成为一个 Point 对象。</p><p>所以对象的构造是一个逐步进化的过程，从构建一个最基础的对象开始，一步步构建成一个目标对象，而对象的析构则是相反的逐步退化的过程。</p><h3 id="3-几点类的设计原则"><a href="#3-几点类的设计原则" class="headerlink" title="3 几点类的设计原则"></a>3 几点类的设计原则</h3><ul><li><strong>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。</strong>或许你可以通过其派生类来初始化它的数据成员（假如 non-static data member 为 publish 或 protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的 data member 应当被初始化，且只在其构造函数或其 member function 中初始化。</li><li><strong>只在有必要的时候才使用虚函数，不要滥用虚函数</strong>。虚函数意味着不小的成本，编译器很可能给你的类带来一连串的膨胀效应：<ul><li>每一个对象要多负担一个 vptr</li><li>给每一个构造函数（不论是显式的还是编译器合成的），插入一些代码来初始化 vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前</li><li>生成或合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对 vptr 的初始化代码</li><li>如果类原本具有 bitwise copy 语意，将失去该语义，然后是上面所述，更大的对象、没有那么高效的构造函数、没有那么高效的复制操作</li></ul></li><li><p><strong>不能决定一个虚函数是否需要 const ，那么就不要 const。</strong></p></li><li><p><strong>不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义，但还是必须实现该纯虚析构函数，否则所有的派生类都将遇到链接错误。这是因为，每一个派生类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显式的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义，所以当编译器看到一个其基类的析构函数声明，就去调用它的实体，而不管它有没有被定义。</p></li><li><strong>决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个基类的构造函数含有对虚函数的调用，当其派生类的构造函数调用基类的构造函数时，其中调用的虚函数是基类中的实体，而不是派生类中的实体。这是由 vptr 初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因为构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象，析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第五章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于对象复制操作（Copy Assignment Operator）&lt;/li&gt;
&lt;li&gt;关于对象析构（Destruction）&lt;/li&gt;
&lt;li&gt;几点类的设计原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（四）关于函数成员</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/</id>
    <published>2022-05-09T07:22:16.000Z</published>
    <updated>2022-05-11T07:16:45.856Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第四章重点梳理。主要内容包括：</p><ul><li>调用不同成员函数的背后工作</li><li>虚函数详解</li><li>内联函数的背后工作</li></ul><p><em><span id="more"></span></em></p><h3 id="1-调用不同成员函数的背后工作"><a href="#1-调用不同成员函数的背后工作" class="headerlink" title="1 调用不同成员函数的背后工作"></a>1 调用不同成员函数的背后工作</h3><p>C++ 类中包括三种成员函数：非静态成员函数、静态成员函数和虚函数。这三种成员函数被调用时，编译器会进行不同的背后工作。</p><h4 id="1-1-非静态成员函数"><a href="#1-1-非静态成员函数" class="headerlink" title="1.1 非静态成员函数"></a>1.1 非静态成员函数</h4><p>C+＋的设计准则之一就是：非静态成员函数必须至少和一般的非成员函数有相同的效率。所以 C++ 的做法就是在非静态成员函数被调用时，编译器将其转化为一般的非成员函数，并传入一个对象的指针。</p><p>假设有一个成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x * _x + _y * _y +  _z * _z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是转化步骤：</p><ol><li>改写函数的 signature（函数原型）以安插一个额外的参数到成员函数中，作为对对象成员的存取管道，该额外参数即为 this 指针，如果成员函数是 const，则传入参数也为 const</li><li>将对每一个成员变量的存取操作改为经由 this 指针的存取操作</li><li>将成员函数重写为一个外部非成员函数，并对函数名进行编码，使其有一个独一无二的内部名称</li></ol><p>转化后的的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">(<span class="type">const</span> Point3d* <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">        <span class="keyword">this</span>-&gt;_x * <span class="keyword">this</span>-&gt;_x + </span><br><span class="line">        <span class="keyword">this</span>-&gt;_y * <span class="keyword">this</span>-&gt;_y +  </span><br><span class="line">        <span class="keyword">this</span>-&gt;_z * <span class="keyword">this</span>-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对函数的调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">magnitude</span>();</span><br></pre></td></tr></table></figure><p>也被转化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magnitude_7Point3dFv</span>(ptr);</span><br></pre></td></tr></table></figure><h4 id="1-2-静态成员函数"><a href="#1-2-静态成员函数" class="headerlink" title="1.2 静态成员函数"></a>1.2 静态成员函数</h4><p>静态成员函数类似于非静态成员函数，编译器同样将其转化为一般的外部非成员函数，唯一的区别在于，传入的参数不是 this 指针，而是一个被强制转化后的指针，编译器将 0 强制转化为对象指针传入函数，所以一个静态成员函数转化后是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">((Point3d*) <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也正因为这样的转化，决定了我们所熟悉的静态成员函数的特性：</p><ul><li>无需经由类对象调用，通过类名即可调用，因为无需传入具体的对象指针，0 指针只作为一个执行静态成员函数的绑定对象指针，除此之外没有任何功能</li><li>不能够直接存取类中的非静态成员，因为指针是 0，实际不指向任何对象实体</li><li>不能声明为 const，virtual 等</li></ul><h4 id="1-3-虚拟成员函数"><a href="#1-3-虚拟成员函数" class="headerlink" title="1.3 虚拟成员函数"></a>1.3 虚拟成员函数</h4><p>虚成员函数在调用时被转化为经由 vptr 指向的虚函数表中的索引值调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>]) (ptr);</span><br></pre></td></tr></table></figure><p>其中传入的 ptr 也是 this 指针，1 是该函数在虚函数表中的索引。</p><h3 id="2-虚函数详解"><a href="#2-虚函数详解" class="headerlink" title="2 虚函数详解"></a>2 虚函数详解</h3><p>之前我们已经了解了虚函数的一般模型：每一个类有一个虚函数表，其中存放该类中所有有作用的虚函数地址，然后每个对象内含一个成员变量 vptr，指向虚函数表。这一节中我们根据不同继承情况，深入了解该模型内部原理。</p><h4 id="2-1-单一继承"><a href="#2-1-单一继承" class="headerlink" title="2.1 单一继承"></a>2.1 单一继承</h4><p>任何情况下，一个 class 只会有一个 virtual table 。每一个 table 内含其对应的 class object 中所有 active virtual functions 函数实体的地址。这些 active virtual functions 包括：</p><ul><li>这个 class 所定义的函数实体。它会改写 (overriding) 一个可能存在的 base class virtual function 实体</li><li>继承自 base class 的函数实体。这是在 derived class 决定不改写 base class virtual function 时才会出现的情况</li><li>一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序</li></ul><p>单一继承情况下的虚函数表布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220509102615749.png" alt="image-20220509102615749"></p><p>可以看到 Point2d 继承自 Point 类，重写的函数会覆盖基类虚函数，比如析构函数，以及在 Point2d 中实现的纯虚函数等，而没有重写的函数则直接复制基类虚函数表中该函数的地址，比如 Point::z() 函数。</p><p>回顾上一节提到的虚函数在编译时的转化，假设现在有如下调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure><p>则会被编译器转化为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>]) (ptr);</span><br></pre></td></tr></table></figure><p>于是这样的形式就可以提供给程序足够的信息，使其在执行期知道调用哪一个函数实体，因为：</p><ul><li>虽然不知道 ptr 指向的具体对象类型，但是我们知道经由 ptr 可以访问到该对象的 vptr，从而访问到类的虚函数表</li><li>虽然不知道哪一个函数实体 z() 会被调用，但是所有类的 z() 函数实体地址都放在虚函数表中下标为 4 的地方</li></ul><p>这正是指针和虚函数所支持的多态的内部原理之一。在一个单一继承体系中，这样的机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，就没有这么简单了。</p><h4 id="2-2-多重继承"><a href="#2-2-多重继承" class="headerlink" title="2.2 多重继承"></a>2.2 多重继承</h4><p>在多重继承之下，一个 derived class 内含 n 个虚函数表，n 表示上一层基类数目，其中第一个基类子对象指向的表为主要表格，其他的为次要表格，第一个基类的虚函数和派生类自己的虚函数都放在主要表格中。针对每一个虚函数表，派生类对象中都有对应的 vptr，当我们将一个派生类对象指定给第一个基类或者派生类的指针时，处理的是主要表格，其他情况处理的是次要表格。</p><p>多重继承情况下，虚函数表布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220509105025788.png" alt="image-20220509105025788"></p><p>上图中的 * 表示需要调整 this 指针，当我们将派生类对象指定给第二个或之后的基类指针时，会存在一些需要调整 this 指针以支持正确的虚函数的情况，一般来说有以下三种情况（对应上面三个星号）：</p><ol><li>第一种情况：通过指向第二个基类的指针调用派生类的虚函数：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure><p>上面的代码中 ptr 首先会被编译器调整至指向基类对象中的第二个基类子对象，编译器的调整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *ptr = temp ? temp + <span class="built_in">sizeof</span>(Base1) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这样才能保证后续正确地访问或调用与第二个基类有关的成员和方法。但接下来的 <code>delete ptr</code> 需要调用析构函数，此时需要将 ptr 再向后调整至指向派生类对象起始地址，才能正确执行析构函数删除整个派生类对象。</p><ol><li>第二种情况：通过一个指向派生类的指针，调用第二个基类中一个继承而来的虚函数，在这种情况派生类指针需要调整至指向第二个基类子对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line">pder-&gt;<span class="built_in">mumble</span>();</span><br><span class="line"><span class="comment">//pedr必须向前调整sizeof(Base1)个字节以指向第二个基类子对象</span></span><br></pre></td></tr></table></figure><ol><li>第三种情况发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化，可能是 base type，也可能是 publicly derived type。这一点可以通过上图中的 clone() 函数说明，clone() 函数的派生版本返回一个派生类对象，默默地改写了两个基类函数实体，当我们通过第二个基类指针调用 clone() 函数时，需要调整 this 指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">// 返回值必须调整以指向第二个基类子对象</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure><p>当进行 <code>pb1-&gt;clone()</code> 时，pb1 会被调整指向派生类对象的起始地址，于是会调用 clone() 函数的派生版本，它会传回一个新的派生类对象，当该对象被指定给第二个基类的指针时，需要调整以指向第二个基类子对象。</p><h4 id="2-3-虚拟继承"><a href="#2-3-虚拟继承" class="headerlink" title="2.3 虚拟继承"></a>2.3 虚拟继承</h4><p>虚拟继承的情况非常复杂，即使只有唯一的一个虚基类，他们的关系也不会像单一继承情况那样简单，因为虚基类和派生类不再相符，两者之间同样需要进行 this 指针转化。</p><p>当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual functions 和 nonstatic data members 时，编译器对于 virtual base class 的支持简直就像进了迷宫一样。总之一个建议是，<strong>不要在虚基类中声明非静态成员变量</strong>。</p><h3 id="3-内联函数的背后工作"><a href="#3-内联函数的背后工作" class="headerlink" title="3 内联函数的背后工作"></a>3 内联函数的背后工作</h3><p>下表对比了不同类型成员函数的执行效率：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220509112026194.png" alt="image-20220509112026194"></p><p>可以看到内联函数的效率占据绝对优势。在以往的学习中我们被告知，inline 函数将会在被调用的时候在调用处产生函数实体，这个操作称为扩展，即把内联函数代码扩展到调用处替换函数调用代码。</p><p>但实际上不是所有声明为 inline 的函数都能成为内联函数，inline 只是一种请求，只有这个请求被接受才会在函数调用处扩展 inline 代码。那么编译器如何决定是否接受这个请求呢？</p><p>编译器有一套复杂的算法来决定是否将函数认定为 inline，通常是计算 assignments、function calls、virtual function calls 等操作的次数。每个操作（表达式）种类有一个权值，而 inline 函数的复杂度就以这些操作的总和来决定。当其执行成本比一般的函数调用及返回机制所带来的负荷低，就被认定为 inline。</p><p>一般而言，处理一个 inline 函数包括以下两个阶段：</p><ul><li>分析函数定义，以决定是否认定为 inline，如果函数因其复杂度，或因其建构问题，被判断为不可成为 inline，则它会被转为一个 static 函数，并在被编译模块内产生对应的函数定义。</li><li>真正的 inline 函数扩展操作是在调用的那个地方进行，这会带来参数的求值操作以及临时性对象的管理问题，接下来具体讨论。</li></ul><h4 id="3-1-有副作用的参数"><a href="#3-1-有副作用的参数" class="headerlink" title="3.1 有副作用的参数"></a>3.1 有副作用的参数</h4><p>inline 函数是如何被扩展的？下面一个例子可以说明问题，假设有如下内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是三个调用操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**（1）**/</span>minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line"><span class="comment">/**（3）**/</span>minval = <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">bar</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>以上三个调用会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**（1）**/</span>minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**（3）**/</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">bar</span>() + <span class="number">1</span>;</span><br><span class="line">minval = t1 &lt; t2 ? t1 : t2;</span><br></pre></td></tr></table></figure><p>第（3）个调用把函数调用作为参数传入 inline 函数，这可能导致实际参数的多次求值操作，因此被认为是有副作用的参数，所以在扩展时使用了临时变量。而传入常量则会直接执行表达式，并将内联函数扩展为赋值操作。</p><h4 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h4><p>如果我们修改 inline 函数，引入局部变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> minval = i &lt; j ? i : j</span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">minval = <span class="built_in">min</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>则会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min_lv_minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">minval = min_lv_minval</span><br></pre></td></tr></table></figure><p>inline 函数中的局部变量会被保留，并产生一个拥有唯一编码名字的临时变量。如果 inline 函数在同一个 scope 中被调用多次，那么每次都会产生一组名字不同的临时变量。</p><p>inline 函数中的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生。特别是它被调用多次的时候，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minval = <span class="built_in">min</span>(val1, val2) + <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">foo</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为局部变量产生的临时变量</span></span><br><span class="line"><span class="type">int</span> min_lv_minval_00;</span><br><span class="line"><span class="type">int</span> min_lv_minval_01;</span><br><span class="line"><span class="comment">// 为副作用参数产生的临时变量</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">foo</span>() + <span class="number">1</span>;</span><br><span class="line">min_lv_minval_00 = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">min_lv_minval_01 = t1 &lt; t2 ? t1 : t2;</span><br><span class="line">minval = min_lv_minval_00 + min_lv_minval_01;</span><br></pre></td></tr></table></figure><p>内联函数对于封装提供了一种必要的支持，可以有效存取封装于 class 中的 nonpublic 数据。它同时也是 C 程序中大量使用的<code>#define</code> （前置处理宏）的一个安全代替品，特别是如果宏中的参数有副作用的话。然而一个 inline 函数如果被调用太多次的话，会产生大量的扩展码，使程序的大小暴涨，并且由于参数带有副作用或者 inline 函数中有局部变量，会产生大量临时对象，编译器无法将它们移除。此外，inline 中再有 inline，可能会使一个表面上看起来简单的 inline 因其连锁复杂度而没办法扩展开来。对于既要安全又要效率的程序， inline 函数提供了一个强而有力的工具。然而，与 non-inline 函数比起来，它们需要更加小心地处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第四章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用不同成员函数的背后工作&lt;/li&gt;
&lt;li&gt;虚函数详解&lt;/li&gt;
&lt;li&gt;内联函数的背后工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（三）关于数据成员</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</id>
    <published>2022-05-07T08:49:49.000Z</published>
    <updated>2022-05-11T07:16:25.586Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第三章重点梳理。主要内容包括：</p><ul><li>C++ 字节对齐和类大小计算</li><li>数据成员的布局、虚函数表和虚基类表的布局</li></ul><p><em><span id="more"></span></em></p><h3 id="1-C-字节对齐"><a href="#1-C-字节对齐" class="headerlink" title="1 C++ 字节对齐"></a>1 C++ 字节对齐</h3><p>关于 C++ 字节对齐这篇文章讲得非常细致：<a href="https://blog.csdn.net/sweetfather/article/details/78487563">C++ 字节对齐的总结(原因和作用)</a></p><p>这里只做简要总结：</p><ul><li><p>字节对齐的原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是，如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个 int 型数据存放在偶地址开始的地方，那么一个读周期就可以读出这 32 位数据，而如果存放在奇地址开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32 位数据，显然在读取效率上下降很多</p></li><li><p>可以使用 <code>pragma pack(n)</code> 指定以 n 字节方式对齐，不指定则按默认方式对齐</p></li><li><p>字节对齐是要看变量所在偏移地址是否为变量字节数（或指定对齐字节数 n，取二者较小值）的整数倍</p></li><li>对于结构成员，要按照结构成员中对齐长度最大的一个对齐</li><li>对齐后还要看结构或类的总大小是否为其中最长变量（或指定对齐字节数 n，取二者较小值）的整数倍</li></ul><p>按照以上规则可以保证对齐后整个结构或类对象所占空间最小，并保证读取效率。</p><h3 id="2-C-类大小计算"><a href="#2-C-类大小计算" class="headerlink" title="2 C++ 类大小计算"></a>2 C++ 类大小计算</h3><p>关于 C++ 类的大小计算这篇文章讲的非常全面：<a href="https://www.cnblogs.com/fengyaoyao/p/10262312.html">C++类的大小计算汇总</a></p><p>这里只做简要总结：</p><p>C++ 中的类由于涉及虚函数、静态成员、虚拟继承、多继承、空类等情况，类对象的大小较为复杂，但总结起来遵循以下几个原则：</p><ul><li>类的大小是指类对象实体的大小，类大小的计算遵循字节对齐原则</li><li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员，均对类的大小无影响；静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区</li><li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响</li><li>空类的大小为 1，因为 C++ 要为某一个实体分配内存就要求这个实体必须有大小，不能为大小为 0 的实体分配内存，所以 C++ 会为空类指定 1 个字节作为其大小，防止 sizeof 为 0，含有虚函数，虚继承，多继承是特殊情况</li></ul><h4 id="2-1-关于空类"><a href="#2-1-关于空类" class="headerlink" title="2.1 关于空类"></a>2.1 关于空类</h4><p>C++ 空类大小为 1，这之中有两种情况需要注意：</p><ul><li>如果一个派生类继承自空类，且派生类有自己的数据成员，则基类子对象的一个字节不会加入到派生类中，因为派生类有自己的数据成员意味着有大小，可以分配内存，所以不需要空类的 1 个字节</li><li>一个类包含一个空类对象成员，这时空类的一个字节是要被计算进去的，因为空类对象必须有自己大小</li></ul><h4 id="2-2-关于虚函数"><a href="#2-2-关于虚函数" class="headerlink" title="2.2 关于虚函数"></a>2.2 关于虚函数</h4><p>虚函数是通过一张虚函数表来实现的。编译器必需要<strong>保证虚函数表的指针存在于对象实例中最前面的位置</strong>（这是为了保证正确取到虚函数的偏移量）。</p><p>每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就会为这个类创建一个虚函数表保存该类所有虚函数的地址，其实这个虚函数表的作用就是保存自己类中所有虚函数的地址，可以把虚函数表形象地看成一个函数指针数组，这个数组的每个元素存放的就是虚函数的地址。在每个带有虚函数的类中，编译器秘密地置入一指针，称为 vptr，指向这个对象的虚函数表。 当构造该派生类对象时，其成员 vptr 被初始化指向该派生类的虚函数表。所以可以认为<strong>虚函数表是该类的所有对象共有的</strong>，在定义该类时被初始化；而 <strong>vptr 则是每个类对象都有独立一份的</strong>，且在该类对象被构造时被初始化。</p><p>含有虚函数的时候，类的大小计算要注意以下几点：</p><ul><li>由于指针大小为 8 字节，因此含有虚函数的任何类的大小都是原本大小加上 8 字节</li><li>当继承的基类含有虚函数时，在派生类中不对基类的虚函数进行覆盖，同时派生类中还拥有自己的虚函数。此时派生类的虚函数表中首先存放基类虚函数地址，再存放派生类虚函数地址，所有虚函数地址顺序与声明顺序一致。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507102541174.png" alt="image-20220507102541174"></p><ul><li>如果派生类中对基类的虚函数进行了覆盖，同时派生类中还拥有自己的虚函数。此时虚函数表中原本存放基类虚函数的位置会被覆盖为派生类重写的虚函数地址，其他顺序不变。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507102558864.png" alt="image-20220507102558864"></p><ul><li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数无重载，此时派生类虚函数被放在第一个积累虚函数表后面，派生类的大小就是原本大小加上基类数量 * 8 字节</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507102738036.png" alt="image-20220507102738036"></p><ul><li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数有重载，情况和上述一致，这时任意一个基类指针指向派生类对象都可以调用派生类重载的基类虚函数</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507102832628.png" alt="image-20220507102832628"></p><p>上面文章中的一个例子，在 Visual C++ 中的运行结果和文章中不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>    </span><br><span class="line">&#123;    </span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>    </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch1; </span><br><span class="line">    <span class="type">char</span> ch2; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> d;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> e;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;    <span class="comment">//result=1 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;    <span class="comment">//result=16     </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;C=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl;    <span class="comment">//result=16 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(D)&lt;&lt;endl;    <span class="comment">//result=24 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;E=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(E)&lt;&lt;endl;    <span class="comment">//result=40 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关于类 E 的大小，有必要再详细分析一下：类 E 包含一个类 B 子对象 16字节，一个类 C 子对象 16 字节，以及自身的 int 4 字节，现在一共是 36字节，但因为要跟成员中最大变量虚函数表指针 8 字节对齐，最终补齐到 40 字节。</p><blockquote><p>可以在 VS 中输出类的布局，打开 vs项目属性-&gt;配置属性-&gt; c/c++ -&gt;命令行，在其它选项中添加如下命令：</p><ul><li><code>/d1 reportAllClassLayout</code> 是查看所有类的布局</li><li><code>/d1 reportSingleClassLayoutXX</code> 是查看名为XX的类的布局</li></ul><p>配置之后重新编译项目，会在编译输出中打印类布局。</p></blockquote><p>上面例子中，类 E 的布局打印出来如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507113905627.png" alt="image-20220507113905627"></p><p>和我们的分析一致，同时还可以看到类 E 的两个虚函数表的布局：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507113943452.png" alt="image-20220507113943452"></p><p>其中 <code>E::$vftable@B@</code> 是基类 B 的虚函数表，存放的是被 E 重载后的函数 func0 的指针， <code>E::$vftable@C@</code> 是基类 C 的虚函数表，存放的是 C 的函数 func 和被 E 重载的函数 func1 的指针。</p><h4 id="2-3-关于虚继承"><a href="#2-3-关于虚继承" class="headerlink" title="2.3 关于虚继承"></a>2.3 关于虚继承</h4><p>Visual C++ 中虚继承的情况比较简单，只是多了一个指向虚基类表的指针 vbptr，而真正的指向虚基类的指针存放在虚基类表中。</p><h3 id="3-数据成员的布局"><a href="#3-数据成员的布局" class="headerlink" title="3 数据成员的布局"></a>3 数据成员的布局</h3><p>最后通过一个例子总结 C++ 数据成员布局，通过下面这个例子可以清晰的认识 C++ 类数据成员布局、虚函数表和虚基类表的布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class X is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Y is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Y) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Z is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Z) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class A is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中包含了虚继承、多重继承、虚函数的情况，运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size of class X is 4</span><br><span class="line">size of class Y is 24</span><br><span class="line">size of class Z is 32</span><br><span class="line">size of class A is 56</span><br></pre></td></tr></table></figure><p>我们打印类 A 的布局：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507115635356.png" alt="image-20220507115635356"></p><p>可以看到类 A 的布局：</p><ul><li>首先是基类 Y 的子对象，Y 包含一个虚函数，同时有一个虚基类，所以 Y 的内存中就是两个指针，一个是虚函数表指针 vfptr，一个是虚基类表指针 vbptr，共 16 字节；</li><li>然后是基类 Z 的子对象，Z 同样包含 vfptr 和 vbptr，以及一个 int 成员，字节对齐后一共是 24 字节，此时类 A 总共偏移 40 字节</li><li>然后是类 A 自己的数据成员，char 类型一个字节，类 A 总共偏移 41 字节，最终要和类中最长成员 8 字节对齐，因此对齐到 48 字节</li><li>类 A 的全部成员都存放完后，最后存放虚基类成员，int 占 4 字节，此时类 A 总共 52 字节，但输出是 56 字节，实际又做了一次 8 字节对齐，因为打印出的内存布局把类 A 和虚基类子对象作为两个独立的部分，所以打印 48 + 4 = 52 字节，但实际还要做一次 8 字节对齐，所以 sizeof 输出 56 字节</li></ul><p>然后是类 A 的虚函数表：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507120353989.png" alt="image-20220507120353989"></p><p>虚函数表的第一项表示派生类对象指针相对于虚函数表指针的偏移，这里派生类 A 相对于基类 Y 的虚函数表指针的偏移是 0 字节，相对于基类 Z 的虚函数表指针的偏移是 -16 字节。</p><p>最后是类 A 的虚基类表：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507120419152.png" alt="image-20220507120419152"></p><p>虚基类表原理与虚函数表类似，表的第一项表示派生类对象指针相对于虚基类表指针的偏移，这里是 -8 字节，因为虚基类表指针前面还有一个虚函数表指针占用了 8 个字节，所以派生类 Y 对象的指针相对于其虚基类表指针的偏移量是 -8，派生类 Z 对象的指针相对于其虚基类表指针的偏移也是 -8，注意这里的派生类不再是指 A 了，而是指虚基类的派生类，所以就是 Y 和 Z；虚基类表从第二项开始，表示各个虚基类地址相对于虚基类表指针的偏移。这里虚基类 X 相对于 Y 的虚基类表指针偏移了 40 个字节，因此虚基类 X 相对于派生类 Y 的地址总共偏移了 48 字节，对于派生类 Z 也同样如此，总共偏移了 24 + 8 = 32 个字节，从上面的内存布局可以清晰地看出这一点。</p><p>可以看到，Y 和 Z 的虚基类表都指向同一个虚基类 X 的子对象，正如之前所说的，虚基类无论在继承链中被继承多少次，都只产生一个实体，即虚基类子对象，但是“不同的派生类中虚基类子对象的位置不同”这句话，一方面是指虚基类子对象相对于派生类的起始地址偏移量不同，并不是存在多个虚基类子对象；另一方面，随着类的派生，虚基类子对象的位置确实可能变化，但所有派生类的虚基类表中都指向那同一个虚基类子对象。</p><p>最后总结一下，C++ 中数据成员布局与编译器有关，但总体原理一致，Visual C++ 中数据成员布局顺序为：</p><ul><li>基类子对象<ul><li>虚函数表指针 vfptr</li><li>虚基类表指针 vbptr</li><li>基类成员</li></ul></li><li>数据成员</li><li>虚基类成员</li></ul><blockquote><p>注：有的编译器不存在虚基类表指针 vbptr，而是把虚基类的偏移放在虚函数表中，这样只需要一个虚函数表指针</p></blockquote><p>最最后附上一个简单的问题：为什么不把派生类的成员填到基类子对象由于字节对齐而填充的空白内存中，而是要保留基类子对象的空白内存？</p><p>直接借用书中的图解释：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220507164044837.png" alt="image-20220507164044837"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第三章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 字节对齐和类大小计算&lt;/li&gt;
&lt;li&gt;数据成员的布局、虚函数表和虚基类表的布局&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（二）关于构造函数</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</id>
    <published>2022-05-06T07:48:21.000Z</published>
    <updated>2022-05-11T07:16:12.268Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索C++对象模型》第二章重点梳理。主要内容包括：</p><ul><li>默认构造函数的构建操作</li><li>拷贝构造函数的构建操作</li><li>使用列表进行初始化的背后工作</li></ul><p><em><span id="more"></span></em></p><h2 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1 默认构造函数"></a>1 默认构造函数</h2><p>有一种常见的说法是，如果定义一个类的时候没有显式的为其声明构造函数，那么编译器将会自动生成默认的构造函数，但一般来说编译器生成的默认构造函数对于程序而言是没有任何用处的，编译器生成默认构造函数完全是为了满足编译器的需要，而不是我们所编写的程序的需要。但在一些情况下，编译器生成的默认构造函数是有用的，下面将讨论这些情况。</p><h3 id="1-1-带有默认构造函数的类对象成员"><a href="#1-1-带有默认构造函数的类对象成员" class="headerlink" title="1.1 带有默认构造函数的类对象成员"></a>1.1 带有默认构造函数的类对象成员</h3><p>如果一个类没有显式声明构造函数，但包含一个声明了构造函数的类对象成员，那么这个类的默认构造函数就是有用的。编译器会为这个类生成一个默认构造函数，但这个生成操作只在构造函数真正需要被调用的时候才进行。</p><p>例如，有下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>)... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">if</span>(str) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 Bar 中包含一个对象成员 foo，该对象有显式声明的构造函数，因此编译器会为 Bar 生成默认构造函数，这个默认构造函数会调用 Foo 的构造函数来初始化对象成员 foo，但不会初始化 Bar 的 str 成员，因为初始化对象成员是编译器需要的，编译器必须为每个对象分配内存，而初始化一个字符指针对于编译器来说不需要。所以编译器生成的默认构造函数看起来就是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器自动生成的构造函数、析构函数、拷贝构造、assignment 等都被指定为内联函数，如果函数太复杂不适合做成内联，就会生成一个显式的非内联静态（explicit non-inline static）函数实体。</p><p>为了让程序正确运行，我们需要把 str 成员也初始化，但这不能指望编译器来生成，需要手动实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;str = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>这时，虽然显式声明了构造函数，但这个构造函数没有初始化对象成员 foo，所以也还是没有满足编译器的需求，因此编译器还是会自动生成构造函数，但这时编译器不会单独生成一个函数了，而是会在用户定义的构造函数上进行扩展，加入编译器需要的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();   <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    str = <span class="number">0</span>;          <span class="comment">// 用户定义的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类中有多个对象成员，这些成员都有显式定义的构造函数，那么编译器自动生成构造函数时会按照对象成员的声明顺序调用他们的构造函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: <span class="built_in">Dopey</span>(); ...);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ...); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ...) ;</span><br><span class="line">               </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy; </span><br><span class="line">    Bashful bashful;</span><br><span class="line">    <span class="comment">// 显式定义的构造函数</span></span><br><span class="line">    <span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mumble = <span class="number">2048</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mumble; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时编译器自动扩展后的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    dopey.Dopey::<span class="built_in">dopey</span>();</span><br><span class="line">    sneezy.Sneezy::<span class="built_in">sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::<span class="built_in">bashful</span>();</span><br><span class="line">    <span class="comment">// 用户定义的代码</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-带有默认构造函数的基类"><a href="#1-2-带有默认构造函数的基类" class="headerlink" title="1.2 带有默认构造函数的基类"></a>1.2 带有默认构造函数的基类</h3><p>如果一个没有显式定义构造函数的类派生于一个有显式构造函数的基类，那么这个派生类的默认构造函数是有用的。派生类自动生成的默认构造函数将调用上一层基类的默认构造函数（根据声明次序）。</p><p>如果程序员为这个派生类声明了多个构造函数，但就是没有默认构造函数，那么编译器会扩展程序员声明的所有构造函数，将调用所有必要的默认构造函数的代码加入这些构造函数中，这些必要的默认构造函数就包括其父类的默认构造函数，以及其对象成员的默认构造函数。</p><h3 id="1-3-带有虚函数的类"><a href="#1-3-带有虚函数的类" class="headerlink" title="1.3 带有虚函数的类"></a>1.3 带有虚函数的类</h3><p>对于以下两种情况，默认构造函数也是有用的：</p><ul><li>带有虚函数的类</li><li>该类派生自一个继承链，这个继承链中有一个或多个带有虚函数的基类</li></ul><p>这两种情况下编译器将会在默认构造函数中加入对虚函数表的操作，因此是有用的。</p><p>例如有下图的继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505163329344.png" alt="image-20220505163329344"></p><p>执行下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.<span class="built_in">flip</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译期间，编译器会进行如下两个扩展操作：</p><ol><li>编译器会产生一张虚函数表 vtbl，其中存放类的虚函数地址</li><li>每一个类对象中，编译器会生成一个额外的指针成员 vptr，指向类的虚函数表</li></ol><p>此外，<code>widget.flip()</code> 的虚拟引发（virtual invocation）操作会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip() 条目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*widget.vptr[<span class="number">1</span>]) (&amp;widget)</span><br></pre></td></tr></table></figure><p>其中 1 表示 flip() 在虚函数表中的索引，<code>&amp;widget</code> 表示要交给被调用的某个 flip() 函数实体的 this 指针。</p><p>为了让这个机制发挥功效，编译器必须为每一个 Widget （或其派生类）的对象的 vptr 设定初值，放置适当的 virtual table 地址。对于 class 所定义的每一个构造函数，编译器会安插一些代码来做这样的事情。对于那些未声明任何构造函数的类，编译器会为它们生成一个默认构造函数，以便正确地初始化每一个 class object 的 vptr。</p><h3 id="1-4-继承于虚拟基类的类"><a href="#1-4-继承于虚拟基类的类" class="headerlink" title="1.4 继承于虚拟基类的类"></a>1.4 继承于虚拟基类的类</h3><p>虚拟继承的实现方法在不同的编译器之间有极大的差异，但是每一种实现方法都必须保证虚拟基类（virtual base class）子对象（subobject）在其每一个派生类对象中的位置能够在执行期准备妥当。例如有如下继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505165553286.png" alt="image-20220505165553286"></p><p>有下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> i;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">int</span> j;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">double</span> d;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;<span class="keyword">public</span>: <span class="type">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译期间编译器无法确定函数 foo 中 <code>pa-&gt;X::i</code> 的实际位置，因为 pa 的类型可以改变，其中包含的基类子对象的位置并不确定，因此编译器必须改变<strong>对虚拟基类成员进行存取操作的代码</strong>（例如上面的 <code>pa-&gt;i = 1024</code> 就是在对虚拟基类的成员进行存取操作），使得 <code>pa-&gt;X::i</code> 可以延迟到执行期才确定下来。</p><p>编译器通过在派生类对象中添加一个指向虚拟基类的指针来完成上述操作，任何对虚拟基类成员的存取操作都可以通过该指针完成，比如上面的代码会被编译器改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>__vbcX</code> 是编译器为派生类对象生成的指向 virtual base class X 的指针。 <code>__vbcX</code> 是在对象构造期间产生的，对于类中声明的每一个构造函数，编译器都会加入构建 <code>__vbcX</code> 的代码，如果类中没有声明任何构造函数，那么编译器会生成一个默认构造函数来完成这件事。</p><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>以上四种情况，会导致 C++ 编译器必须为没有显式声明构造函数的类生成（合成）一个默认构造函数。C++ 将这些默认构造函数称为 implicit nontrivial default constructors。</p><p>被生成（合成）出来的 constructor 只能满足编译器（而非程序）的需要，这样的构造函数之所以被称为 nontrivial ，是因为他们完成了一些对编译器来说必要的工作：</p><ul><li>调用对象成员的构造函数</li><li>调用基类的构造函数</li><li>为对象初始化指向虚函数表的指针</li><li>为对象初始化其 virtual base class 的指针</li></ul><p>至于不存在这四种情况而又没有显式声明构造函数的类，我们说它拥有的是 implicit trivial default constructors，这样的构造函数没有任何用处，实际上也不会被生成出来。</p><p>在生成（合成）的构造函数中，只有基类子对象和对象成员会被初始化，其他所有的非静态成员变量，如 int，*int，int[] 等，都不会被初始化，因为这些初始化或许对程序而言有用，但对编译器来说并不必要。</p><p><strong>因此，以下两种常见说法是完全错误的：</strong></p><ul><li>任何没有显式声明默认构造函数的类都会由编译器产生一个默认构造函数</li><li>编译器生成的默认构造函数会将类中所有成员明确初始化</li></ul><h2 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2 拷贝构造函数"></a>2 拷贝构造函数</h2><p>有三种情况，会以一个对象的内容作为另一个对象的初值：</p><ul><li>使用一个对象对另一个对象进行初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;...&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// 明确以一个对象对另一个对象初始化</span></span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure><ul><li>对象作为函数参数传递：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(X x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 以对象作为函数参数</span></span><br><span class="line">    <span class="built_in">foo</span>(xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象作为函数返回值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序员在类中明确定义了一个拷贝构造函数（copy constructor），即以本类型作为参数的构造函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>(<span class="type">const</span> X&amp; X);</span><br><span class="line">Y::<span class="built_in">Y</span>(<span class="type">const</span> Y&amp; y, <span class="type">int</span> = <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>那么在上述情况下，拷贝构造函数将被调用。但如果类中没有用户显式定义的拷贝构造函数，编译器将如何完成拷贝操作呢？</p><h3 id="2-1-Default-Memberwise（逐成员的）-Initialization"><a href="#2-1-Default-Memberwise（逐成员的）-Initialization" class="headerlink" title="2.1 Default Memberwise（逐成员的） Initialization"></a>2.1 Default Memberwise（逐成员的） Initialization</h3><p>当用户没有显式定义拷贝构造函数时，编译器内部是以 Default Memberwise Initialization（默认逐成员初始化） 方法完成该操作的。也就是把每一个内建的或派生的成员变量（指针或其他变量）的值，从某个对象拷贝到另一个对象身上，但它并不会拷贝其中的类对象成员（member class object），而是以递归的方式进行 Memberwise Initialization。</p><p>例如，有一个字符串类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们把一个字符串对象作为另一个对象的初值时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure><p>Default Memberwise Initialization 将会像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure><p>如果一个 String 对象作为另一个类的成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    String _word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 word 对象的 Default Memberwise Initialization 将会直接拷贝成员 <code>_occurs</code>，然后在 <code>_word</code> 身上递归的进行 Memberwise Initialization，即递归的调用 String 对象的 Default Memberwise Initialization。</p><p>一个类对象可以从两种方式复制得到，一种是被初始化（即我们现在讨论的），另一种是被指定（assignment），将会之后的章节讨论。这两个操作分别是以 copy constructor 和 copy assignment operator 完成的。拷贝构造函数和上一节的默认构造函数一样，只在必要的时候才由编译器产生出来，因此“如果一个 class 未定义出 copy constructor，编译器就自动为它自动生成一个”这句话是不对的。并且拷贝构造函数也被分为有用的（nontrivial）和无用的（trivial），只有 nontrivial 的拷贝构造函数才会被生成或者合成到现有代码中，而决定一个拷贝构造函数是否是 nontrivial 的标准在于这个类是否展现出所谓的 “bitwise copy semantics”。</p><h3 id="2-2-bitwise-copy-semantics（逐位次拷贝语义）"><a href="#2-2-bitwise-copy-semantics（逐位次拷贝语义）" class="headerlink" title="2.2 bitwise copy semantics（逐位次拷贝语义）"></a>2.2 bitwise copy semantics（逐位次拷贝语义）</h3><p>现有下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;word.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    word verb = noun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然 verb 是根据 noun 来初始化的，但是在没有看过 word 类的声明之前，我们无法预测这个初始化操作的程序行为，如果 word 类的设计者定义了一个拷贝构造函数，verb 的初始化就会调用它，但如果没有显式定义的拷贝构造函数，编译器是否会为 word 类生成一个拷贝构造函数呢？这就得视 word 类是否展现出 “bitwise copy semantics” 而定。</p><p>举例说明，比如 word 类有如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    ~<span class="built_in">word</span>() &#123;<span class="keyword">delete</span> [] str;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种情况下并不需要合成出一个拷贝构造函数，因为上面的声明展现出了 default copy semantics，于是 verb 的初始化也就不需要以一个函数调用进行。但如果 word 类的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明没有展现 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">word</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 String 类显式声明了拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);    <span class="comment">//显式声明了拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个情况下，编译器必须合成出一个拷贝构造函数，以便调用对象成员的拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">word::word</span><span class="params">(<span class="type">const</span> word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到生成出来的拷贝构造函数也会将非对象成员进行复制。</p><p>一个类在四种情况下不会展现出 bitwise copy semantics，即会由编译器生成拷贝构造函数：</p><ul><li>当 class 中包含一个对象成员而后者的类声明有一个拷贝构造函数时（这个拷贝构造函数可以是被用户显式声明的，就像前面的 String 那样，也可以是被编译器合成的，像 word 那样）</li><li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（同样可以是用户定义的，也可以是编译器生成的）</li><li>当 class 声明了一个或多个 virtual functions 时</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时</li></ul><p>前两种情况中，编译器必须将对象成员或基类的拷贝构造函数调用代码安插到生成的拷贝构造函数中，而后两种情况较为复杂，下面具体讨论。</p><h3 id="2-3-重新设定-Virtual-Table-指针"><a href="#2-3-重新设定-Virtual-Table-指针" class="headerlink" title="2.3 重新设定 Virtual Table 指针"></a>2.3 重新设定 Virtual Table 指针</h3><p>首先是第三种情况。当类中声明了虚函数时，编译器会为类生成一个虚函数表，并在每一个类对象中增加一个指向虚函数表的指针 vptr，因此在拷贝构造函数中必须要对对象的 vptr 进行正确的赋值，否则后果不堪设想，所以这种情况下编译器必须生成拷贝构造函数。</p><p>假设有下面的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ZooAnimal 对象以另一个 ZooAnimal 对象作为初值，或者 Bear 对象以另一个 Bear 对象作为初值都可以直接靠 bitwise copy semantics 来完成，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure><p>yogi 会被 Bear 的默认构造函数初始化，在构造函数中，yogi 的 vptr 被设定指向 Bear 类的虚函数表（靠编译器安插代码完成），因此直接把 yogi 的 vptr 值复制给 winnie 是完全没问题的，二者的关系如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220506105047329.png" alt="image-20220506105047329"></p><p>但是当一个基类对象以一个派生类对象作为初值进行初始化时，其 vptr 复制操作就不是这么简单了，如果直接把派生类对象的 vptr 复制给基类对象，就会发生严重错误。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal franny = yogi;</span><br><span class="line">franny.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure><p>如果 franny 的 vptr 被复制为 yogi 的 vptr，那么相当于一个 ZooAnimal 类的对象会调用 Bear 派生类的函数实体，这就会发生严重错误。因此编译器必须保证在拷贝构造函数中为基类对象设定正确的 vptr 值。</p><p>事实上，上述代码执行的会是 ZooAnimal 的 draw 方法，因为 franny 是一个 ZooAnimal 对象，yogi 中的 Bear 部分已经在 franny 初始化时被切割（sliced）掉了，如果 franny 被声明为一个指针或者引用，那么 <code>franny.draw()</code> 才会调用 Bear 的 draw 方法。</p><p>也就是说，编译器自动生成的拷贝构造函数会明确设定基类对象的 vptr 指向基类的虚函数表，而不是直接从派生类中复制 vptr 的值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220506110202874.png" alt="image-20220506110202874"></p><h3 id="2-4-处理-Virtual-Base-Class-Subobject"><a href="#2-4-处理-Virtual-Base-Class-Subobject" class="headerlink" title="2.4 处理 Virtual Base Class Subobject"></a>2.4 处理 Virtual Base Class Subobject</h3><p>接下来讨论第四种情况。一个类对象以另一个对象作为初值，而后者有一个 virtual base class subobject，那么也会使 bitwise copy semantics 失效，从而编译器必须生成拷贝构造函数。</p><p>之前学习过，编译器必须保证 virtual base class subobject 在其每一个派生类对象中的位置能够在执行期准备妥当，但 bitwise copy semantics 可能会破坏这个位置，所以编译器必须生成一个拷贝构造函数来处理这一事件。</p><p>比如有下面的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Raccoon</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">Raccoon</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类之间的继承关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220506110945550.png" alt="image-20220506110945550"></p><p>显然，编译器首先会安插一些代码在 Raccoon 的构造函数中，包括：调用基类 ZooAnimal 的默认构造函数，设定 Raccoon 的 vptr 值，定位出 Raccoon 中 ZooAnimal 子对象的位置等。</p><p>虽然 Raccoon 类中含有一个虚拟基类子对象，但当我们用 Raccoon 对象初始化另一个 Raccoon 对象时，也不会出现额外的问题，只依靠 bitwise copy 即可。问题在于“用派生类对象初始化一个基类对象”，比如现在有一个 RedPanda 类继承于 Raccoon 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedPanda</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">RedPanda</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220506111610997.png" alt="image-20220506111610997"></p><p>使用一个 RedPanda 对象初始化 Raccoon 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure><p>这时，只依靠 bitwise copy 就不够了，编译器必须明确的将 little_critter 的 virtual base class subobject 指针初始化，以指出 virtual base class subobject 在哪。</p><p>这种情况下，为了正确完成 little_critter 的初值设定，编译器必须生成一个拷贝构造函数，安插一些代码以设定 virtual base class subobject 指针的初值，对每一个成员执行必要的逐成员初始化，以及其他内存相关工作。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220506112328821.png" alt="image-20220506112328821"></p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>我们已经讨论过所有四种情况，这四种情况实际上和上一节默认构造函数的四种情况一致。在这些情况下，类不再保持 bitwise copy semantics，并且默认拷贝构造函数未被声明的话，会被视为 nontrivial，于是编译器为了正确处理“以一个对象作为另一个对象初值”的情况，必须生成或合成一个拷贝构造函数。</p><h2 id="3-使用列表初始化成员"><a href="#3-使用列表初始化成员" class="headerlink" title="3 使用列表初始化成员"></a>3 使用列表初始化成员</h2><p>C++ 中书写构造函数有一种特殊的写法，就是使用列表对类成员进行初始化，这一节来了解使用列表对成员进行初始化的背后发生了什么。</p><p>首先来看这样的一个类的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line">    <span class="comment">//不声明访问权限默认为private</span></span><br><span class="line">    String _name;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>() &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写构造函数自然没有问题，但效率很低，编译器会先产生一个临时的 String 对象，然后将它初始化，再以一个 assigment 运算符将临时的对象指定给 <code>_name</code> 成员，最后再摧毁临时对象。所以经过编译器扩展后的代码看起来就是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用String的默认构造函数</span></span><br><span class="line">    _name.String::<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//产生临时对象</span></span><br><span class="line">    String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//降临时对象指定给_name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    <span class="comment">//摧毁临时对象</span></span><br><span class="line">    temp.String::~<span class="built_in">String</span>();</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果我们把构造函数写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将会将代码扩展成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用列表是较好的方式，因此最好坚持列表初始化的代码习惯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>但有时我们不得不在函数体中指定成员初始值，比如要用一个成员初始化另一个成员，这时我们需要了解列表初始化背后到底发生了什么。</p><p>编译器会逐个操作初始化列表，以适当的次序将代码安插在构造函数体内，并且安插的代码会在用户定义的代码之前。这里的“适当的次序”是指成员变量在类中声明的次序，而不是初始化列表中书写的顺序。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里看起来是用 val 初始化 j，再用 j 初始化 i，但实际上列表初始化会按照成员声明次序扩展代码，因此会先为 i 赋值，但此时 j 还没有被赋值，因此会得到错误的结果。这时我们可以将构造函数写成这样，来避免问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为编译器扩展的代码会在用户定义代码之前，所以会先为 j 赋值，再为 i 赋值。</p><p>总结一下，当存在以下情况时，尽量选择使用列表队成员进行初始化：</p><ul><li>初始化一个 reference 成员时</li><li>初始化一个 const 成员时</li><li>当调用一个基类的构造函数，而它拥有一组参数时</li><li>当调用一个对象成员的构造函数，而它拥有一组参数时</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>最后总结构造函数的执行过程：</p><ol><li>在派生类构造函数中，所有虚基类和上一层基类的构造函数首先会按顺序被调用，以生成基类子对象</li><li>上述完成后，对象的 vptr 会被初始化，指向正确的虚函数表</li><li>如果有成员初始化列表的话，将在 vptr 被设定后扩展开来，以免其中调用了虚函数</li><li>如果有对象成员且其有构造函数，调用对象成员的构造函数</li><li>最后执行程序员提供的初始化代码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索C++对象模型》第二章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认构造函数的构建操作&lt;/li&gt;
&lt;li&gt;拷贝构造函数的构建操作&lt;/li&gt;
&lt;li&gt;使用列表进行初始化的背后工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【C++对象模型】（一）关于对象</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-05-05T07:33:58.000Z</published>
    <updated>2022-05-11T07:15:59.208Z</updated>
    
    <content type="html"><![CDATA[<p>《深度探索 C++ 对象模型》第一章重点梳理。主要内容包括：</p><ul><li>C++ 封装对象的布局成本</li><li>C++ 对象模型，详述 C++ 如何组织类对象及其成员</li><li>C++ 继承简述，简述 C++ 三种继承关系和三种继承方式，关于继承布局模型会在之后的章节详述</li><li>C++ 支持多态的三种方式</li><li>指针类型和多态的实现原理</li></ul><p><em><span id="more"></span></em></p><h3 id="1-C-封装对象的布局成本"><a href="#1-C-封装对象的布局成本" class="headerlink" title="1 C++ 封装对象的布局成本"></a>1 C++ 封装对象的布局成本</h3><p>C++ 将数据和对数据的操作封装为一个类，相比于 C 语言不封装，<strong>并没有增加成本</strong>。因为类的数据成员直接内含在每一个实例化的对象中，而方法成员虽然含在类的声明中，但却不出现在每一个对象中，每一个非内联（non-inline）的成员函数只产生一个函数实体，而内联函数自然在使用的地方产生函数实体，因此不会有任何空间或执行的不良效应。</p><p>C++ 在布局以及存取时间上的主要额外负担是由 virtual 引起的，包括：</p><ul><li>virtual function 机制：用以支持一个高效的“执行期绑定”（runtime binding）</li><li>virtual base class：用以实现“多次出现在继承体系中的 base class，只存在一个被共享的实体”</li></ul><p>后面将会对这两种情况进行解释。</p><h3 id="2-C-对象模型"><a href="#2-C-对象模型" class="headerlink" title="2 C++ 对象模型"></a>2 C++ 对象模型</h3><p>C++ 对象模型按照以下方式组织类对象及其成员：</p><ul><li>非静态成员变量（non-static data member）存放于类对象内部</li><li>静态成员变量（static data member）存放于所有类对象之外</li><li>静态和非静态的成员函数（member function）存放于所有类对象之外</li><li>虚函数（virtual function）通过<strong>虚函数表（virtual table）</strong>管理：每一个类产生出一堆指向虚函数的指针，放在表格之中构成虚函数表，接下来每一个类对象拥有一个指向虚函数表的指针，称为 <strong>vptr</strong>，vptr 的设定（set）和重置（reset）都由类的构造函数、析构函数、拷贝构造等完成。并且每一个类所关联的 type_info 对象（用来支持 runtime type identification，简称 RTTI）也经由虚函数表指出，通常放在虚函数表的第一位。</li></ul><blockquote><p><strong>什么是 RTTI ？</strong></p><p>RTTI 即运行阶段类型识别（Runtime Type Identification），旨在为程序在运行阶段确定对象类型提供一种标准方式。</p><p>RTTI 可以在只有一个指向基类的指针或引用时，确定所指对象的准确类型。C++ 有两种支持 RTTI 的运算：</p><ul><li>dynamic_cast 运算符，如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则该运算符返回空指针。</li><li>typeid 运算符，返回一个指出对象类型的 type_info 对象的引用，其中存储了有关对象类型的信息，比如类名等。</li></ul><p>需要注意的是，只能将 RTTI 用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才会将派生类对象的地址赋给基类指针（多态），即 <strong>RTTI 只适用于包含虚函数的类（实现多态）</strong>。</p></blockquote><p>以下面的类为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其对象模型如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505095707450.png" alt="image-20220505095707450"></p><p>C++ 这样构建对象模型的主要优点在于空间和存取时间效率高，但缺点在于如果程序代码本身没有更改，但所用到的类对象的非静态成员变量有所修改，那么代码就需要重新编译。</p><p>另一种没有应用在 C++ 中的对象模型——双表格模型可以解决这个问题，双表格模型把所有成员变量放在数据表格中，把所有指向函数的指针放在函数表格中，每一个类对象只包含指向这两个表格的指针。这样虽然更灵活，但也因此付出了空间和执行效率两方面的代价。</p><h3 id="3-C-继承简述"><a href="#3-C-继承简述" class="headerlink" title="3 C++ 继承简述"></a>3 C++ 继承简述</h3><p>C++ 支持单一继承、多重继承和虚拟继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单一继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library_Materials</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Library_Materials &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rental_Book</span> : <span class="keyword">public</span> Book &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span> : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么需要虚拟继承？</strong></p><p>虚拟继承是为了防止多重继承中，一个派生类继承自两个相同的基类的情况。</p><p>如上面的例子，类 iostream 继承自类 istream 和类 ostream，这两个类都继承自基类 ios，如果不使用虚拟继承，则类 iostream 中会出现两个基类 ios 的对象，而在虚拟继承中，无论基类在继承链中被派生多少次，都只产生一个实体（称为子对象，subobject），即在类 iostream 中，istream 对象和 ostream 对象共享一个 ios 基类对象，从而避免了重复继承的情况。</p></blockquote><p>之后的章节中我们会具体讨论这些继承情况分别对应的继承模型，即派生对象和基类对象的组织关系和内存管理。</p><p>顺便讨论一下类成员的三种访问级别和三种继承方式。众所周知 C++ 类成员可以拥有三种访问级别：</p><ul><li>public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问</li><li>protected：可以被该类中的函数、子类的函数、其友元函数访问，但不能被该类的对象访问</li><li>private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问</li></ul><p>在类继承中，也包含三种继承方式，不同的继承方式会导致类中成员的访问级别变化：</p><ul><li>public 继承：父类中的成员属性不发生改变</li><li>protected 继承：父类的 protected 和 public 成员在子类中变为 protected，private 成员不变</li><li>private 继承：父类的所有成员在子类中变为 private</li></ul><h3 id="4-C-支持多态的三种方式"><a href="#4-C-支持多态的三种方式" class="headerlink" title="4 C++ 支持多态的三种方式"></a>4 C++ 支持多态的三种方式</h3><p>C++ 通过以下三种方式支持多态：</p><ul><li>隐式转换：将派生类指针转化为一个指向其基类的指针：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure><ul><li>虚函数机制：基类中定义虚函数（纯虚函数），派生类进行重载，在运行时决定调用哪个函数对象：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure><ul><li>dynamic_cast 和 type_id 运算符，在上面的虚拟继承提到过，用来将指向基类的指针转化为指向派生类对象的指针，或者获取对象的 type_info</li></ul><h3 id="5-指针类型和多态原理"><a href="#5-指针类型和多态原理" class="headerlink" title="5 指针类型和多态原理"></a>5 指针类型和多态原理</h3><p>指向类的指针和指向其他变量类型（比如 int, string）的指针有什么不同？</p><p>以内存需求的观点来说，没有什么不同，它们都需要有足够的内存来放置一个机器地址，指向不同类型的指针之间的差异既不在其声明方法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的 object 类型不同。也就是说，”指针类型”会告诉编译器如何解释某个特定地址中的内存内容及其大小。</p><p>例如下面的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么指向类 ZooAnimal 的对象的指针将会包含：</p><ul><li>指向 int 类型的指针，在 32 位计算机上，int 占 4 字节</li><li>指向 string 类型的指针，占 8 字节（4 字节的字符指针和 4 字节的表示字符串长度的整数）</li><li>指向虚函数表的指针，占 4 字节</li></ul><p>因此类 ZooAnimal 的对象一共占用 16 字节，如果 ZooAnimal 对象存放在内存地址 1000，那么一个指向 ZooAnimal 对象的指针将会知道它需要涵盖内存的内存范围是 1000~1015.</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505112402307.png" alt="image-20220505112402307"></p><p>如果不告诉编译器这个指针指向什么类型，比如泛型指针 void*，那么编译器将不知道指针涵盖的地址范围，也就不能通过指针访问到正确的内存内容。</p><p>现在我们定义一个 Bear 类继承自 ZooAnimal 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Dances</span> &#123; ... &#125;;<span class="comment">//枚举类型默认使用int方式存储，占用4字节</span></span><br><span class="line">    </span><br><span class="line">    Dances dances_known;</span><br><span class="line">    <span class="type">int</span> cell_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么指向 Bear 对象的指针覆盖的内存大小是其基类子对象的大小（16字节）加上该对象成员变量的大小（4 + 4 字节）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505112658895.png" alt="image-20220505112658895"></p><p>假设 Bear 对象存放在内存地址 1000 处，那么指向基类 ZooAnimal 的指针 pz 和指向派生类 Bear 的指针 pb 都指向内存地址 1000，区别在于 pz 指针涵盖的内存范围只包含基类成员的 16 字节，而 pb 指针涵盖的内存范围包含整个 Bear 对象。</p><p>除了 ZooAnimal 对象中出现的成员，我们不能使用 pz 来处理 Bear 对象的任何成员，除非使用 virtual 机制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以，虽然 pz 指向一个 bear 对象的地址</span></span><br><span class="line">pz-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以，经过显式转换</span></span><br><span class="line">((Bear*)pz)-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的方式是使用 RTTI，dynamic_cast返回一个指定派生类的指针，如果无法转换则返回空指针</span></span><br><span class="line"><span class="keyword">if</span>(Bear* pb2 = <span class="built_in">dynamic_cast</span>&lt;Bear*&gt;(pz))</span><br><span class="line">    pb2-&gt;cell_block;</span><br></pre></td></tr></table></figure><p>现在来看这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal za = b;</span><br><span class="line"><span class="comment">// 这将会调用 ZooAnimal 的 rotate 方法而不是 Bear 的</span></span><br><span class="line">za.<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure><p>为什么 za 调用的是 ZooAnimal 的 rotate 方法？这是由于当一个基类对象直接被初始化为一个派生类对象时，会发生切割（sliced），以塞入较小的基类内存中，而无法体现出任何派生类的痕迹。这时多态就“失效”了，实际上这是由于多态不能够发挥在“直接存取对象”这件事情上，<strong>因为多态机制是依靠指针（pointer）或引用（reference）完成的</strong>。</p><p>举例来说明，比如有下面的类继承关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505150626835.png" alt="image-20220505150626835"></p><p>然后我们使用下面一组定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ZooAnimal za;</span><br><span class="line">    ZooAnimal *pza;</span><br><span class="line">    </span><br><span class="line">    Bear b;</span><br><span class="line">    Panda *pp = <span class="keyword">new</span> Panda;</span><br><span class="line">    </span><br><span class="line">    pza = &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组定义可能的内存布局如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220505150739142.png" alt="image-20220505150739142"></p><p>将对象 za 或者 b 的地址，或者指针 pp 的内容（也是个地址）赋给指针 pza，是完全没有问题的，后续还可以通过各种转换得到想要的不同派生类的对象，也就实现了多态。一个指针或者引用之所以支持多态，就是因为他们并不会引发内存配置的资源量的改变，会受到改变的只是它们所指向的内存的“大小和解释方式”而已。</p><p>但如果直接对对象进行操作，就会改变内存中的资源需求量，比如之前的例子，把整个 Bear 对象指定给 za，就会溢出它所配置得到的内存，自然也就无法得到正确的结果。</p><p>总之，多态是一种强大的机制，允许你继一个抽象的 public 接口之后，封装相关的类型。需要付出的代价就是额外的间接性——不论是在“内存的获得”或是在“类型的决断”上。C++ 通过 class 的 pointers 和 references 来支待多态，这种程序设计风格就称为“面向对象”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深度探索 C++ 对象模型》第一章重点梳理。主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 封装对象的布局成本&lt;/li&gt;
&lt;li&gt;C++ 对象模型，详述 C++ 如何组织类对象及其成员&lt;/li&gt;
&lt;li&gt;C++ 继承简述，简述 C++ 三种继承关系和三种继承方式，关于继承布局模型会在之后的章节详述&lt;/li&gt;
&lt;li&gt;C++ 支持多态的三种方式&lt;/li&gt;
&lt;li&gt;指针类型和多态的实现原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深度探索C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="C++对象模型" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>【STL】关联式容器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-05-03T07:32:18.000Z</published>
    <updated>2022-05-06T07:51:00.702Z</updated>
    
    <content type="html"><![CDATA[<p>标准的 STL 关联式容器分为 set(集合) / map(映射表)两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree（红黑树）或hash table（哈希表）完成。</p><p><em><span id="more"></span></em></p><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h3><p>红黑树是 C++ STL 唯一实现的树状结构，是所有关联式容器的底层容器，关于红黑树的理论知识可以查看<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-二叉树/">【数据结构】二叉树</a>第三部分。</p><h4 id="1-1-红黑树节点"><a href="#1-1-红黑树节点" class="headerlink" title="1.1 红黑树节点"></a>1.1 红黑树节点</h4><p>STL 中红黑树的的节点设计采用了结构和数值分离的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line"></span><br><span class="line">    _Color_type _M_color;    <span class="comment">//颜色</span></span><br><span class="line">    _Base_ptr _M_parent;     <span class="comment">//父节点，红黑树很多操作都需要知道父节点</span></span><br><span class="line">    _Base_ptr _M_left;       <span class="comment">//左孩子</span></span><br><span class="line">    _Base_ptr _M_right;      <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉搜索树获取最大值最小值</span></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_minimum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_left != <span class="number">0</span>) __x = __x-&gt;_M_left;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_maximum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_right != <span class="number">0</span>) __x = __x-&gt;_M_right;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树节点，包括结构和节点值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node</span> : <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">    _Value _M_value_field;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-2-红黑树迭代器"><a href="#1-2-红黑树迭代器" class="headerlink" title="1.2 红黑树迭代器"></a>1.2 红黑树迭代器</h4><p>为了更大的弹性， SGI 将 RB-tree 迭代器也实现为两层，下图所示的便是双层节点结构和双层迭代器结构之间的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220503111534187.png" alt="image-20220503111534187"></p><p>RB-tree 迭代器属于双向迭代器，不具备随机定位能力，其提领操作和成员访间操作与 list 十分近似，较为特殊的是其前进和后退操作。参见源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一级迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">  _Base_ptr _M_node;</span><br><span class="line">  <span class="comment">// 迭代器前进操作</span></span><br><span class="line">  <span class="type">void</span> _M_increment()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_right != <span class="number">0</span>) &#123;</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">      <span class="keyword">while</span> (_M_node-&gt;_M_left != <span class="number">0</span>)</span><br><span class="line">        _M_node = _M_node-&gt;_M_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_right) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_M_node-&gt;_M_right != __y)</span><br><span class="line">        _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//迭代器后退操作</span></span><br><span class="line">  <span class="type">void</span> _M_decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;</span><br><span class="line">        _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_M_node-&gt;_M_left != <span class="number">0</span>) &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_left;</span><br><span class="line">      <span class="keyword">while</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">        __y = __y-&gt;_M_right;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_left) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级迭代器，继承于一级</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>, <span class="keyword">class</span> <span class="title class_">_Ref</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_iterator</span> : <span class="keyword">public</span> _Rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Value&amp;, _Value*&gt;             </span><br><span class="line">    iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, <span class="type">const</span> _Value&amp;, <span class="type">const</span> _Value*&gt; </span><br><span class="line">    const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Ref, _Ptr&gt;                   </span><br><span class="line">    _Self;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  _Rb_tree_iterator() &#123;&#125;</span><br><span class="line">  _Rb_tree_iterator(_Link_type __x) &#123; _M_node = __x; &#125;</span><br><span class="line">  _Rb_tree_iterator(<span class="type">const</span> iterator&amp; __it) &#123; _M_node = __it._M_node; &#125;</span><br><span class="line">  <span class="comment">//迭代器解引用，返回指向值</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> _Link_type(_M_node)-&gt;_M_value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  <span class="comment">//返回迭代器数值域指针</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器++操作，调用底层迭代器_M_increment()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; _M_increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_increment();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//迭代器--操作，调用底层迭代器_M_decrement()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; _M_decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_decrement();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他双目运算定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node == __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node != __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//RB树迭代器是双向迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> _Rb_tree_base_iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-set-amp-map"><a href="#2-set-amp-map" class="headerlink" title="2 set &amp; map"></a>2 set &amp; map</h3><p>set 的所有元素都会根据元素的键值自动排序。set 的元素不像 map 那样可以同时拥有 key 和 value，set 元素的 key 就是 value，value 就是 key，set不允许有两个相同的元素。</p><p>map 的所有元素都会根据元素的键值自动排序。map 的所有元素都是 pair，同时拥有 key 和 value。pair 的第一元素为 key，第二元素为 value。map不允许有两个相同的键值。如果通过map的迭代器改变元素的键值，这样是不行的，因为 map 元素的键值关系到 map 元素的排列规则。任意改变 map 元素键值都会破坏 map 组织。如果修改元素的实值，这是可以的，因为 map 元素的实值不影响 map 元素的排列规则。</p><h3 id="3-multiset-amp-multimap"><a href="#3-multiset-amp-multimap" class="headerlink" title="3 multiset &amp; multimap"></a>3 multiset &amp; multimap</h3><p>multiset 和 multimap 的特性以及用法和 set 与 map 完全相同，唯一的差别在于它们允许键值重复，因此它的插入操作采用的是底层机制 RB-tree 的<code>insert_equal()</code> 而非 <code>insert_unique()</code>。</p><h3 id="4-hash-table"><a href="#4-hash-table" class="headerlink" title="4 hash table"></a>4 hash table</h3><p>hash table 是 STL 实现的另一种底层数据结构。之前的二叉搜索树具有对数平均时间表现，但这样的表现构造在一个假设上：输入数据有足够的随机性。hashtable 这种结构在插入、删除、查找具有“常数平均时间”，而且这种表现是以统计为基础，不需依赖元素的随机性。</p><p>hash table 底层数据结构为分离连接法的 hash 表，如下所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/772134-20160714231649779-234679385.png" alt="772134-20160714231649779-234679385"></p><p>hash table 中的 buckets 使用的是vector数据结构，当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射（常见的为取模），找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就返回；否则的话就将该元素插入到该链表的头部。当然，如果是 multi 版本的话，是可以插入重复元素的，此时插入过程为：当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射，找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就将新节点插入到该相同元素的后面；如果没有相同的元素，产生新节点，插入到链表头部。</p><p>对应的查询过程也是同理。此外，当调用成员函数 clear() 后，buckets vector 并未释放空间，仍保留原来大小，只是删除了 buckets 所连接的链表。</p><h3 id="5-hash-set-amp-hash-map"><a href="#5-hash-set-amp-hash-map" class="headerlink" title="5 hash_set &amp; hash_map"></a>5 hash_set &amp; hash_map</h3><p>hash_set 和 hash_map 以 hashtable 为底层结构，由于 RB-tree 有自动排序功能而 hash table 没有，反映出来的结果就是，set 和 map的元素有自动排序功能而hash_set 和 hash_map 没有。</p><h3 id="6-hash-multiset-amp-hash-multimap"><a href="#6-hash-multiset-amp-hash-multimap" class="headerlink" title="6 hash_multiset &amp; hash_multimap"></a>6 hash_multiset &amp; hash_multimap</h3><p>hash_multiset 和 hash_multimap 的特性与 multiset 和 multimap 完全相同，唯一的差别在于它们的底层机制是 hash table，因此，hash_multiset 和 hash_multimap 的元素是不会自动排序的。</p><h3 id="7-unordered-set-amp-unordered-map"><a href="#7-unordered-set-amp-unordered-map" class="headerlink" title="7 unordered_set &amp; unordered_map"></a>7 unordered_set &amp; unordered_map</h3><p>unordered_set 和 unordered_map 是 C++11 标准新增的容器，底层同样使用 hash table 实现，但一般来说效率比 hash_set 和 hash_map 更高，原因在于二者 rehash 实现不同。因此 hash_set 和 hash_map 基本已弃用。</p><h3 id="8-红黑树和-hash-table-对比"><a href="#8-红黑树和-hash-table-对比" class="headerlink" title="8 红黑树和 hash table 对比"></a>8 红黑树和 hash table 对比</h3><p>虽然大多数情况下 hash table 实现的 map 都会比红黑树实现的 map 查找快，但不是绝对的，因为冲突过多的话，可能耗费时间比 map 还要多。</p><p>另外，hash table 的实现决定了其使用的空间会比实际数据空间大。红黑树初始化时，节点只需要一个，后续的插入只是插入新的节点，但是哈希表初始化时就不是那么简单了，哈希表初始化时需要申请一个数组，数组的每个元素都指向一条链表，所以初始化时需要申请很多内存，相比于红黑树，的确更耗时。</p><p>相对于红黑树，hash table的优点很明显：插入，查找，删除复杂度为常数时间，大规模查询时，性能差距更为明显。</p><p>但相比于hash table，平衡树也是有优点的:</p><ul><li>首先，尽管我们都说 hash 查找插入删除复杂度是常数时间，但这仅仅是个统计上的概念，最差情况下，也是会达到 O(n)，而红黑树最差的情况下也是 O(logn)；</li><li>其次，hash table 实际上是空间换时间的做法，空间越小，操作的时间复杂度越大，操作时间越不稳定，而平衡树则稳定很多；</li><li>还有一个就是序，红黑树是查找树，因此中序遍历的结果就是排好序的。这就使得其在范围查找方面性能优秀，而 hash 却需要遍历全部数据，之后统计才能得出范围查找的结果。另外，如果你知道一个元素在树中的位置，和它大小相近的元素也在它周围，这就使得获取相近元素的时间很少。另外，我们知道，中序遍历的时间复杂度也只是 O(n)，这个性质非常有用。</li></ul><p>map 和 unordered_map 的使用场景基本上就是根据上述各自的特性决定了：</p><ul><li>map 一般就是用在数据量小于1000或者对内存使用要求比较高的情况下。因为 hash table 需要申请的空间比较大，而红黑树则是新增一个节点就申请一个节点的空间。</li><li>如果数据量大的话并且需要频繁查找的话，就可以使用 hash table 实现的 map 了。这个时候内存已经不是主要的问题所在，而是查找时间了，这种情况下 hash table 的查找速度是常数而红黑树是 O(logN)，对于后者，1024个数据最坏情况下要10次比较，在频繁查找的情况下这种时间耗费是很大的。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;标准的 STL 关联式容器分为 set(集合) / map(映射表)两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree（红黑树）或hash table（哈希表）完成。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【STL】序列式容器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-30T08:44:36.000Z</published>
    <updated>2022-05-06T07:51:21.803Z</updated>
    
    <content type="html"><![CDATA[<p>容器（Containers）是 STL 六大组件中最被人熟知和常用的一个神器，根据组织方式大概分为序列式容器和关联式容器两大类。</p><p><em><span id="more"></span></em></p><h3 id="1-STL-容器概览"><a href="#1-STL-容器概览" class="headerlink" title="1 STL 容器概览"></a>1 STL 容器概览</h3><p>STL 提供的容器如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430153405060.png" alt="image-20220430153405060"></p><p>其中内缩表达基层与衍生层的关系，这里所谓的衍生，并非派生 (inheritance) 关系，而是内含 (containment) 关系。例如 heap 内含一个 vector，priority_queue 内含一个 heap 、stack 和 queue 都含一个 deque，set/map/multiset/multimap 都内含一个 RB-tree，hast_x 都内含一个 hashtable。</p><h3 id="2-序列式容器"><a href="#2-序列式容器" class="headerlink" title="2 序列式容器"></a>2 序列式容器</h3><p>所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted），C++ 本身内建了一个序列式容器array，STL 另外提供了vector、list、deque、stack、queue、priority-queue 等序列式容器。其中 stack 和 queue 由于只是 deque 改头换面而来，技术上被归为一种配接器 (adapter)。接下来了解各序列式容器的具体实现。</p><h3 id="3-vector"><a href="#3-vector" class="headerlink" title="3 vector"></a>3 vector</h3><p>vector 采用的数据结构非常简单：线性连续空间。它以两个迭代器 start 和 finish 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 end_of_storage 指向整块连续空间（含备用空间）的尾端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;             <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">    iterator finish;            <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">    iterator end_of_storage;    <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了降低空间配置时的速度成本， vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量 (capacity) 的观念。换句话说，一个 vector 的容量永远大于或等于其大小。一旦容量等于大小，下次再有新增元素，整个 vector 就得进行动态增加容量。</p><p>所谓动态增加容量，并不是在原来空间之后接续新空间（因为无法保证原空间之后尚有可供分配的空间），而是以原来大小的的两倍另外分配一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430154445332.png" alt="image-20220430154445332"></p><p>当我们以 <code>push_back()</code> 将新元素插入于 vector 尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新配置、移动数据、释放原空间）。</p><h3 id="4-list"><a href="#4-list" class="headerlink" title="4 list"></a>4 list</h3><p>相对于 vector 的连续线性空间，list 就显得复杂许多，它的好处就是插入或删除一个元素，就配置或删除一个元素空间。对于任何位置的元素的插入或删除，list 永远是常数时间。</p><p>List 不仅是一个双向链表，而且是一个双向循环链表，只需一个指针就可遍历整个链表。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430155828333.png" alt="image-20220430155828333"></p><p>对于迭代器，只能通过 <code>++</code> 或 <code>--</code> 操作将迭代器移动到后继/前驱节点元素处，而不能对迭代器进行 +n 或 -n 的操作。因此 List 的迭代器是双向迭代器。在 List 中增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p><h3 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h3><p>vector 是单向开口的连续线性空间，deque 则是一种双向开口的线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，虽然 vector 也支持从头端插入元素，不过效率奇差。deque 容器类与 vector 类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。</p><p>deque 与 vector 最大差异：</p><ul><li>deque 允许常数时间内对头部进行元素的插入或移除操作。</li><li>deque 没有所谓的容量观念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并拼接起来。</li></ul><p>deque 由一段一段连续空间组成，一旦有必要在 deque 的前端或尾端增加新空间，便配置一段连续空间，串接在整个 deque 的前端或尾端。deque 的最大任务，便是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价是复杂的迭代器结构。</p><p>deque 采用一块所谓的 map（不是 STL 的 map 容器）作为主控。这里所谓 map 是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是 deque 的储存空间主体。 SGI STL 允许我们指定缓冲区大小，默认值 0 表示将使用 512 bytes 缓冲区。deque 最初状态（无任何元素）保有一个缓冲区，因此，clear() 完成之后回到初始状态，也一样会保留一个缓冲区。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430160922218.png" alt="image-20220430160922218"></p><p>由于以上结构，deque 的迭代器实现也较为复杂，deque 的迭代器首先必须指出分段连续空间在哪里，其次它必须能够判断自己是否已经处在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃下一个缓冲区，为了能够正常跳跃，deque 必须随时掌握管控中心（map）。下图展示了 deque 的中控器、迭代器和缓冲区的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430161351783.png" alt="image-20220430161351783"></p><p>假设一个 deque 存储 20 个元素，每个缓冲区可以存储 8 个元素，则它的迭代器关系如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220430161627317.png" alt="image-20220430161627317"></p><p>迭代器 start 内的 cur 指针指向第一块缓冲区的第一个元素，迭代器 finish 内的 cur 指针指向最后一块缓冲区的最后一个元素（的下一位置）。</p><p>下面来分析 deque 常用操作对迭代器的影响：</p><ul><li>在队前或队后插入元素时（push_back()和push_front()），由于可能缓冲区的空间不够，需要增加 map 中控器，而中控器的个数如果也不够，就需要新开辟更大的空间来容纳中控器，所以可能会使迭代器失效；但指针、引用仍有效，因为缓冲区已有的元素没有重新分配内存。</li><li>在队列其他位置插入元素时，由于会造成缓冲区的一些元素的移动，所以肯定会造成迭代器的失效；并且指针、引用都会失效。</li><li>删除队头或队尾的元素时，由于只是对当前的元素进行操作，所以其他元素的迭代器不会受到影响，所以一定不会失效，而且指针和引用也都不会失效。</li><li>删除其他位置的元素时，也会造成元素的移动，所以其他元素的迭代器、指针和引用都会失效。</li></ul><h3 id="5-stack"><a href="#5-stack" class="headerlink" title="5 stack"></a>5 stack</h3><p>stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口。stack 允许增加元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其他方法可以存取 stack 的其他元素，换言之，stack 不允许有遍历行为，因此 stack 没有迭代器。stack 默认以 deque 为底层容器。stack 是对 deque 的又一层封装，因此 stack 并不是容器，而被称作配接器。</p><p>除了 deque 外，stack 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p><h3 id="6-queue"><a href="#6-queue" class="headerlink" title="6 queue"></a>6 queue</h3><p>queue 是一种先进先出（First In First Out，FIFO）的数据结构，它有两个出口，允许增加元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其他方法可以存取 queue 的其他元素，换言之，queue不允许有遍历行为，因此 queue 没有迭代器。queue 默认以 deque 为底层容器。</p><p>除了 deque 外，queue 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p><h3 id="7-heap"><a href="#7-heap" class="headerlink" title="7 heap"></a>7 heap</h3><p>heap 使用 vector 作为底层容器，关于 heap 的算法可在专题<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-优先队列和堆/">【数据结构】优先队列和堆</a>中找到。STL 默认建立大顶堆。</p><h3 id="8-priority-queue"><a href="#8-priority-queue" class="headerlink" title="8 priority_queue"></a>8 priority_queue</h3><p>priority_queue 底层使用 heap 实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;容器（Containers）是 STL 六大组件中最被人熟知和常用的一个神器，根据组织方式大概分为序列式容器和关联式容器两大类。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【STL】迭代器</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-04-30T07:26:19.000Z</published>
    <updated>2022-05-06T07:51:38.932Z</updated>
    
    <content type="html"><![CDATA[<p>STL的中心思想是：将数据容器和算法分隔开，彼此独立设计，最后再用黏合剂将它们撮合在一起。容器和算法的泛型化，可以用 C++ 的 class template 和 function template 来实现，而迭代器（Iterator）就是二者的黏合剂了。</p><p><em><span id="more"></span></em></p><h3 id="1-迭代器的实现"><a href="#1-迭代器的实现" class="headerlink" title="1 迭代器的实现"></a>1 迭代器的实现</h3><p>迭代器是一种智能指针，它将指针进行了一层封装，既包含了原生指针的灵活和强大，也加上很多重要的特性，使其能发挥更大的作用以及能更好的使用。指针最常见也最为重要的行为就是内容提领 (dereference) 和成员访问 (member access)，迭代器对指针的一些基本操作如*、-&gt;、++、==、!=、=进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构。</p><p>迭代器的“智能”体现在，针对不同的数据容器能够使用统一的方法、函数进行操作，以达到相同的目的。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++();  </span><br><span class="line"></span><br><span class="line">    ...  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    T *m_ptr;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>对于不同的数据容器，以上 Iterator 类中的成员函数 operator++ 的实现会各不相同，例如，对于数组的可能实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于数组的实现  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;   </span><br><span class="line">   ++m_ptr;   </span><br><span class="line">   retrun *<span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于链表，它会有一个类似于 next 的成员函数用于获取下一个结点，其可能实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;  </span><br><span class="line">   m_ptr = m_ptr-&gt;<span class="built_in">next</span>();<span class="comment">//next()用于获取链表的下一个节点   </span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>iterator 的实现首先要对其所指向的对象的实现细节有非常丰富的了解，所以 iterator 为了不暴露所指向对象的信息，干脆就将 iterator 的实现由各个容器的设计者来实现好了。STL 将迭代器的实现交给了容器，每种容器都会以嵌套的方式在内部定义专属的迭代器。各种迭代器的接口相同，内部实现却不相同，这也直接体现了泛型编程的概念。</p><h3 id="2-迭代器的类别"><a href="#2-迭代器的类别" class="headerlink" title="2 迭代器的类别"></a>2 迭代器的类别</h3><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p><p>常用的迭代器按功能强弱分为：</p><ul><li>输入迭代器：只读</li><li>输出迭代器：只写</li><li>正向迭代器：正向遍历迭代器，假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</li><li>双向迭代器：双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code> 都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</li><li>随机访问迭代器：随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：<ul><li>p+=i：使得 p 往后移动 i 个元素。</li><li>p-=i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul></li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p><p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><p>下表是不同容器的迭代器功能类型：</p><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器功能</th></tr></thead><tbody><tr><td>vector</td><td>随机访问</td></tr><tr><td>deque</td><td>随机访问</td></tr><tr><td>list</td><td>双向</td></tr><tr><td>set / multiset</td><td>双向</td></tr><tr><td>map / multimap</td><td>双向</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr><tr><td>priority_queue</td><td>不支持迭代器</td></tr></tbody></table></div><p>在以上功能的基础上，迭代器根据定义方式还分为：</p><ul><li>正向迭代器：容器类名::iterator </li><li>常量正向迭代器：容器类名::const_iterator</li><li>反向迭代器：容器类名::reverse_iterator</li><li>常量反向迭代器：容器类名::const_reverse_iterator</li></ul><p>反向迭代器和正向迭代器的区别在于：对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</p><h3 id="3-迭代器辅助函数"><a href="#3-迭代器辅助函数" class="headerlink" title="3 迭代器辅助函数"></a>3 迭代器辅助函数</h3><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p><ul><li><code>advance(p, n)</code>：使迭代器 p 向前或向后移动 n 个元素。</li><li><code>distance(p, q)</code>：计算两个迭代器之间的距离，即迭代器 p 经过多少次 <code>++</code> 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li><li><code>iter_swap(p, q)</code>：用于交换两个迭代器 p、q 指向的值。</li></ul><p>要使用上述模板，需要包含头文件 <code>&lt;algorithm&gt;</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;STL的中心思想是：将数据容器和算法分隔开，彼此独立设计，最后再用黏合剂将它们撮合在一起。容器和算法的泛型化，可以用 C++ 的 class template 和 function template 来实现，而迭代器（Iterator）就是二者的黏合剂了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【C++】基础知识汇总</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2022-04-30T02:59:06.000Z</published>
    <updated>2022-05-06T07:53:59.102Z</updated>
    
    <content type="html"><![CDATA[<p>C++中琐碎的基础知识，原理，用法汇总，用于快速查询知识点。持续更新。</p><p><em><span id="more"></span></em></p><h3 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1 智能指针"></a>1 智能指针</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/150555165">现代 C++：一文读懂智能指针</a></li><li><a href="https://blog.csdn.net/K346K346/article/details/81478223">C++ STL 四种智能指针</a></li><li><a href="https://blog.csdn.net/u012442719/article/details/55045583">C++ weak ptr解除指针循环引用</a></li></ul><h3 id="2-auto-和-decltype"><a href="#2-auto-和-decltype" class="headerlink" title="2 auto 和 decltype"></a>2 auto 和 decltype</h3><ul><li><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></li><li><p><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></p></li><li><p><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></p></li></ul><h3 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3 Lambda表达式"></a>3 Lambda表达式</h3><ul><li><p><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C++ Lambda表达式原理及应用</a></p></li><li><p><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></p></li><li><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></li></ul><h3 id="4-仿函数"><a href="#4-仿函数" class="headerlink" title="4 仿函数"></a>4 仿函数</h3><ul><li><a href="https://blog.csdn.net/JMW1407/article/details/107130600">仿函数(functors)</a></li><li><a href="https://blog.csdn.net/toby54king/article/details/105103111">C++中的仿函数有点难，这篇文章却讲的通俗易懂</a></li><li><a href="https://zhuanlan.zhihu.com/p/362323211">C++ 仿函数为何而生</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中琐碎的基础知识，原理，用法汇总，用于快速查询知识点。持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/categories/STL/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（一）游戏引擎架构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2022-04-28T08:47:37.000Z</published>
    <updated>2022-04-28T08:58:22.544Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。</p><p><em><span id="more"></span></em></p><h3 id="1-游戏引擎分层架构"><a href="#1-游戏引擎分层架构" class="headerlink" title="1 游戏引擎分层架构"></a>1 游戏引擎分层架构</h3><p>现代游戏引擎的架构极为复杂，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428155123811.png" alt="image-20220428155123811"></p><p>但大致可分为以下几个层次：</p><ul><li>工具层：工具层是面向游戏开发者，能够让游戏开发者使用引擎制作游戏的接口，包括一些系列可视化的编辑器，比如角色编辑器、纹理编辑器、动画编辑器等等。</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428155356486.png" alt="image-20220428155356486"></p><ul><li>功能层：功能层包含一个游戏需要的各种功能，包括物理碰撞、动画、渲染、音效、逻辑脚本等等，是能够让一款游戏充满可玩性的核心驱动。</li><li>资源层：资源层负责管理游戏引擎中的各种资源，比如纹理、模型、音频、视频、脚本等，资源层需要将这些资源合理的、有层次的组织起来，并管理他们的生命周期，在合适的时间加载某些资源，在另外一些时候释放某些资源。</li><li>核心层：核心层包含上面几层在实现的过程中需要频繁使用的一些工具函数，比如数学、数据结构、常用的算法等，核心层是游戏引擎中所有上层结构的支撑，由于游戏引擎对效率的要求很高，所以有时并不能直接使用 C++ STL 提供的一些容器或者算法，而需要根据需求编写更高效的数据结构实现和算法函数供上层调用，因此核心层也是对代码质量要求最高的一层。</li><li>平台层：平台层是最容易被忽略的一层，但也是非常重要的一层，平台层负责处理不同平台的差异，包括软件平台和硬件平台，比如不同的操作系统、不同的 CPU/GPU 架构、不同的游戏输入设备等等，保证游戏能够在所有平台完美运行。</li><li>第三方库：第三方库一方面用于实现一些基本功能，比如 GUI、图像处理等，另外也可以将功能层中某些模块直接用第三方库来实现，比如一些专门做物理、动画的第三方插件，直接集成到引擎中既方便开发，得到的效果也更好。</li></ul><p>游戏引擎架构当然没有这么简单，但是大致总结起来可以认为就是由这几部分组成的，分层架构的设计要求必须由上层调用下层功能，这样既便于开发，也便于管理。接下来我们对其中的重要模块稍作深入了解。</p><h3 id="2-资源层"><a href="#2-资源层" class="headerlink" title="2 资源层"></a>2 资源层</h3><p>游戏开发中需要利用各种资源来达到目的，而各类资源有不同的格式，即使是同一类资源，它们的格式也不尽相同，比如不同的 3D 建模软件导出的模型就存在各种各样的格式差异，资源层需要将这些不同的资源，统一转化为游戏引擎使用的格式，转换后的资源被称为 Asset，从资源到 Asset 的过程可以认为是对资源文件的提纯过程，这个过程会去掉那些游戏引擎不需要的信息，比如 3D 模型中的编辑信息，而只保留游戏引擎中需要的信息，并组织成统一的格式。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428161522013.png" alt="image-20220428161522013"></p><p>除此之外，资源层还要对海量的资源进行合理的管理，包括每个资源的唯一标识（GUID）、不同资源之间的关系、资源的生命周期等等。高效的管理资源是一个游戏稳定运行的基础，比如在游戏场景切换的时候就需要卸载大量资源再加载大量资源，如果资源管理做的不好，轻则加载时间长，影响游戏体验，重则出现卡顿，甚至崩溃。</p><h3 id="3-功能层"><a href="#3-功能层" class="headerlink" title="3 功能层"></a>3 功能层</h3><p>从某种程度上说，功能层是游戏引擎最核心的部分，因为它实现了一个游戏之所以能称之为游戏的全部重要功能，包括渲染、物理、动画、音效、网络、游戏性等等。因此功能层也是构建游戏世界的核心。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428162147284.png" alt="image-20220428162147284"></p><p>游戏世界是依靠 Tick 来驱动的，类似于秒针走动一下，我们的世界就会发生一次改变。在游戏世界中，“秒针”每次走动，我们的计算机就会将所有的功能全部运行一遍，来计算这一秒游戏世界中发生的事情，因此在游戏引擎的代码中，入口就是 Tick：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428162301962.png" alt="image-20220428162301962"></p><p>Tick 一般分为逻辑 Tick 和渲染 Tick，逻辑 Tick 负责计算相机、运动、动画、物理等功能，相当于在构建整个游戏世界；渲染 Tick 则负责将游戏在世界呈现在玩家面前，包括剔除、渲染、后处理等等。因此在每一个 Tick 中，都是先计算逻辑 Tick，再计算渲染 Tick。</p><p>功能层的许多功能可以在游戏中实现，也可以在游戏引擎中实现，这完全取决于需求，对于一些通用的商业引擎，它们可能会用于制作各种类型的游戏，因此功能层提供的功能要尽可能的丰富，而对于一些专用的引擎，比如寒霜、RED ENGINE等，它们被用于制作特定类型的游戏，因此就会在功能层对特定的功能进行实现，而抛弃一些不需要的功能。</p><h3 id="4-核心层"><a href="#4-核心层" class="headerlink" title="4 核心层"></a>4 核心层</h3><p>核心层为上层实现提供核心驱动，在核心层会实现包括数学计算、数据结构、内存管理、线程管理在内的基本代码，这部分要保证绝对的安全、稳定、高效。因此对编码要求也极高，一般核心层的代码不会轻易修改。</p><p>数学计算包括一些基本运算、向量、矩阵、四元数、随机数等的实现，游戏中许多计算可能并不要求结果的绝对精确，而是更需要计算的高效性，结果允许存在一定误差，因此在实现上就和 C++ 提供的数学库完全不同了。</p><p>数据结构也是同样，STL 提供的各种数据结构和容器实现有时候可能在内存、效率上达不到游戏中的要求，比如 C++11 中的 vector 在扩容时就可能造成大量的空间碎片，因此我们需要实现更高效、内存管理更严格的数据结构和容器供上层使用。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220428163516740.png" alt="image-20220428163516740"></p><h3 id="5-平台层"><a href="#5-平台层" class="headerlink" title="5 平台层"></a>5 平台层</h3><p>平台层需要处理不同软硬件平台的差异，使得游戏和引擎能够在不同平台上运行。平台之间的差异说起来简单，但是实际情况却非常复杂，比如图形 API 之间的差异，DirectX 11、OpenGL、Vulkan 等图形接口就有相当大的差异，即便是同为微软的 DirectX 11 和 DirectX 12 也有着完全不同的实现框架，并且不同的显卡架构也完全不同，因此需要一个统一的渲染接口将这些差异统一起来，使得上层使用者只需要关注功能实现，而不需要关注底层接口和硬件之间的差异。</p><p>除此之外，平台差异还包括核心处理器架构的差异，PS、XBox、PC 等平台的核心处理架构设计是完全不同的，需要对这样的差异进行处理；另外还有游戏输入设备之间的差异，键鼠、手柄、方向盘、感应器等等，需要一个统一的接口处理这些设备的输入，使它们能得到相同的响应效果。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>总而言之，游戏引擎架构极为复杂，但概括来说就是由分层架构搭建而成，并且只允许上层功能调用下层功能，不允许下层功能调用上层功能。越底层的功能越稳定，越上层的功能越灵活。</p><p>游戏世界依靠 Tick 驱动，每一个 Tick 都计算一次逻辑功能和渲染功能，这样整个游戏世界就能够构建起来、运行起来并且呈现在玩家面前了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二十二）最后一步</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/</id>
    <published>2022-04-27T12:37:47.000Z</published>
    <updated>2022-04-27T12:39:32.494Z</updated>
    
    <content type="html"><![CDATA[<p>到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。</p><p><em><span id="more"></span></em></p><h3 id="1-统一管理散射光线"><a href="#1-统一管理散射光线" class="headerlink" title="1 统一管理散射光线"></a>1 统一管理散射光线</h3><p>对于镜面反射和折射，如果用新的渲染方程会出现 pdf 值为 0 的情况，因此我们使用之前隐式的渲染方程，也就是采样 pdf 和光线散射 pdf 一致。为此我们首先需要新增一个结构体来统一管理散射光线，然后根据散射光线的类型选择对应的渲染方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一管理散射光线</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> &#123;</span><br><span class="line">    ray specular_ray;           <span class="comment">// 散射光线</span></span><br><span class="line">    <span class="type">bool</span> is_specular;           <span class="comment">// 是否是镜面反射，金属或者电介质为true</span></span><br><span class="line">    color attenuation;          <span class="comment">// 反射率</span></span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;    <span class="comment">// 散射光线pdf，如果是金属或者电介质就是空指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改材质抽象类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自发光，可选</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来用新的结构体和方法改写之前实现的 Lambertian 材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样散射光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 材质本身散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> lights = <span class="built_in">make_shared</span>&lt;hittable_list&gt;();</span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line"><span class="comment">// 对透光的玻璃也进行额外采样</span></span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-金属和电介质"><a href="#2-金属和电介质" class="headerlink" title="2 金属和电介质"></a>2 金属和电介质</h3><p>有了统一管理散射光线的方法，我们可以修改之前的金属材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        srec.attenuation = albedo;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时修改电介质材质类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        srec.attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line">        </span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pdf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> color&amp; background, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> depth, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> RR)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, srec))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是高光反射或折射，采用之前的渲染方程，隐式的使采样pdf和散射pdf保持一致</span></span><br><span class="line">    <span class="keyword">if</span> (srec.is_specular) &#123;</span><br><span class="line">        <span class="keyword">return</span> srec.attenuation</span><br><span class="line">            * <span class="built_in">ray_color</span>(srec.specular_ray, background, world, lights, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对光源采样的pdf</span></span><br><span class="line">    <span class="keyword">auto</span> light_ptr = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="comment">// 混合pdf</span></span><br><span class="line">    <span class="function">mixture_pdf <span class="title">p</span><span class="params">(light_ptr, srec.pdf_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样光线</span></span><br><span class="line">    ray scattered = <span class="built_in">ray</span>(rec.p, p.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 采样光线的pdf值</span></span><br><span class="line">    <span class="keyword">auto</span> pdf_val = p.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + srec.attenuation * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;material&gt; aluminum = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.88</span>), <span class="number">0.0</span>);</span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), aluminum);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> glass = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, glass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-对球体和物体列表采样"><a href="#3-对球体和物体列表采样" class="headerlink" title="3 对球体和物体列表采样"></a>3 对球体和物体列表采样</h3><p>上面的主函数中我们对透明玻璃球也进行了额外采样，因此类似于之前光源所在的 zx 平面，现在我们需要实现球体和物体列表的 <code>pdf_value</code> 函数和 <code>random</code> 函数，对球体采样的具体推导过程可以查看《RayTracingTheRestOfYourLife》第 12.3 节，这里直接给出代码，首先修改球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / (center0 - o).<span class="built_in">length_squared</span>());</span><br><span class="line">        <span class="keyword">auto</span> solid_angle = <span class="number">2</span> * pi * (<span class="number">1</span> - cos_theta_max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        vec3 direction = center0 - o;</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>工具函数新增：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在球体外对球体随机采样</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2 * (<span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是物体列表 <code>hittable_list</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> weight = <span class="number">1.0</span> / objects.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">            sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size - <span class="number">1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-最后一步"><a href="#4-最后一步" class="headerlink" title="4 最后一步"></a>4 最后一步</h3><p>最后一步我们来处理掉之前图片中有时会出现的黑点或者异常像素，这是因为一些不好的采样计算出了很大的或者 NaN 的颜色，使得整个像素受损，因此我们可以在写颜色的时候处理这种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常像素值</span></span><br><span class="line">    <span class="keyword">if</span> (r != r) r = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g != g) g = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != b) b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看一下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxConv.png" alt="CornellBoxConv"></p><h3 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二十一）混合概率密度</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/</id>
    <published>2022-04-26T03:29:53.000Z</published>
    <updated>2022-04-26T09:59:13.537Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。</p><p><em><span id="more"></span></em></p><p>因为我们要混和多种 pdf，最好的方法就是新建一个类去管理他们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 概率密度函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PDF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后我们将之前的随机散射的 pdf 作为派生类实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法线周围随机散射的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) &#123; uvw.<span class="built_in">build_from_w</span>(w); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">normalize</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个向场景中某个物体的方向采样光线的 pdf 类，这样我们可以不只向光源方向采样，还可以支持场景中的其他物体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向场景中某个物体方向采样的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> point3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们新调用了 <code>hittable</code> 类中的两个方法 <code>value</code> 和 <code>random</code>，因此要在抽象类中声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="comment">// 计算光线与物体的交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚函数，不要求所有派生类都实现</span></span><br><span class="line">    <span class="comment">// 计算对该物体方向采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成对该物体方向采样的随机光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在 xz 平面物体类中实现这两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********作为光源平面用到的方法*********/</span></span><br><span class="line">    <span class="comment">// 计算随机采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 光源平面面积</span></span><br><span class="line">        <span class="keyword">auto</span> area = (x1 - x0) * (z1 - z0);</span><br><span class="line">        <span class="comment">// 光源采样点到着色点的距离平方</span></span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="comment">// 光线和光源平面法线cos</span></span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 概率密度</span></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机采样一点，作为随机采样的方向</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(x0, x1), k, <span class="built_in">random_double</span>(z0, z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后开始实现混合 pdf 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) &#123;</span><br><span class="line">        p[<span class="number">0</span>] = p0;</span><br><span class="line">        p[<span class="number">1</span>] = p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> * p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们这里只是简单的把两个 pdf 平均起来。</p><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合 pdf</span></span><br><span class="line">    <span class="keyword">auto</span> p0 = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">    <span class="function">mixture_pdf <span class="title">mixed_pdf</span><span class="params">(p0, p1)</span></span>;</span><br><span class="line">    <span class="comment">// 使用混合pdf采样光线</span></span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, mixed_pdf.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    pdf_val = mixed_pdf.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line">shared_ptr&lt;hittable&gt; lights;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">        world = <span class="built_in">cornell_box</span>();</span><br><span class="line">        lights = <span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;());</span><br><span class="line">        aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">        image_width = <span class="number">600</span>;</span><br><span class="line">        samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">        min_bounce = <span class="number">95</span>;</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">40.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxFinal.png" alt="CornellBoxFinal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二十）直接对光源采样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/</id>
    <published>2022-04-26T02:38:08.000Z</published>
    <updated>2022-04-26T03:26:55.431Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，这一节我们将直接对光源进行采样。</p><p><em><span id="more"></span></em></p><h3 id="1-对光源采样的-PDF"><a href="#1-对光源采样的-PDF" class="headerlink" title="1 对光源采样的 PDF"></a>1 对光源采样的 PDF</h3><p>对光源直接采样就是把渲染方程中的对 $\omega$ 的积分改为对光源面积 $A$ 的积分，因此要做一个积分变量的替换，图形学中我们用立体角公式已经推导过 $d\omega$ 和 $dA$ 的关系：</p><script type="math/tex; mode=display">d\omega = \frac{dA·cos\theta'}{||x - p||^2}</script><p>回顾我们之前改写的蒙特卡洛计算渲染方程：</p><script type="math/tex; mode=display">color_{out} = \frac{albedo·s(direction)·color_{in}}{p(direction)}</script><p>我们只需要解出对光源采样的 $p(direction)$ 即可。因为无论对 $\omega$ 采样还是对光源 $A$ 采样，得到的方向的概率应该都是一样的，所以：</p><script type="math/tex; mode=display">p(direction)·d\omega = \frac{1}{A}·dA</script><p>其中 $\frac{1}{A}$ 是对光源面积 $A$ 均匀采样的概率密度，把上面 $d\omega$ 和 $dA$ 的关系式带入即可得到：</p><script type="math/tex; mode=display">p(direction) = \frac{||x-p||^2}{cos\theta'·A}</script><p>也就是对光源采样的概率密度函数。这实际上和我们图形学中推导的，通过积分变量替换改写渲染方程，再用对光源采样的 $pdf=\frac{1}{A}$ 进行蒙特卡洛积分计算是完全一样的，只是这里我们把整个积分替换的系数和对光源采样的 pdf 统一写成了对方向 $\omega$ 在光源方向上采样的 pdf。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>有了上面的公式我们可以改写 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源平面随机采样一点</span></span><br><span class="line">    <span class="keyword">auto</span> on_light = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(<span class="number">213</span>, <span class="number">343</span>), <span class="number">554</span>, <span class="built_in">random_double</span>(<span class="number">227</span>, <span class="number">332</span>));</span><br><span class="line">    <span class="comment">// 光源到着色点p的方向</span></span><br><span class="line">    <span class="keyword">auto</span> to_light = on_light - rec.p;</span><br><span class="line">    <span class="comment">// 得到距离用于之后计算pdf</span></span><br><span class="line">    <span class="keyword">auto</span> distance_squared = to_light.<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">// 方向归一化用于得到cos(theta&#x27;)</span></span><br><span class="line">    to_light = <span class="built_in">normalize</span>(to_light);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(to_light, rec.normal) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="keyword">auto</span> light_cosine = <span class="built_in">fabs</span>(to_light.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">if</span> (light_cosine &lt; <span class="number">0.000001</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="comment">// 光源面积</span></span><br><span class="line">    <span class="type">double</span> light_area = (<span class="number">343</span> - <span class="number">213</span>) * (<span class="number">332</span> - <span class="number">227</span>);</span><br><span class="line">    <span class="comment">// 计算直接对光源采样的pdf</span></span><br><span class="line">    pdf = distance_squared / (light_cosine * light_area);</span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, to_light, r.<span class="built_in">time</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">world = <span class="built_in">cornell_box</span>();</span><br><span class="line">aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">image_width = <span class="number">600</span>;</span><br><span class="line">samples_per_pixel = <span class="number">10</span>;</span><br><span class="line">min_bounce = <span class="number">45</span>;</span><br><span class="line">background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">vfov = <span class="number">40.0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每个像素只采样 10 根光线，得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxLight.png" alt="CornellBoxLight"></p><p>比之前每个像素采样 100 根光线的噪声还要小很多。</p><h3 id="3-单向光源"><a href="#3-单向光源" class="headerlink" title="3 单向光源"></a>3 单向光源</h3><p>可以看到上面的结果中，噪声主要集中在光源附近，这是因为光源是双面的，光源和天花板之间有一个很小的缝隙，为了解决这个问题我们可以让光源只向下发光，修改光源材质的 <code>emitted</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自发光材质，用作光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有正面发光</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rec.front_face)</span><br><span class="line">            <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个翻转类，使得我们能够翻转光源法线，使它的法线全部指向 -y 方向：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转光源法线，使其只有正面发光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flip_face</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">flip_face</span>(shared_ptr&lt;hittable&gt; p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        rec.front_face = !rec.front_face;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在场景中调用翻转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light)));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    ...</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxLightFlip.png" alt="CornellBoxLightFlip"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，这一节我们将直接对光源进行采样。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十九）随机方向</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/</id>
    <published>2022-04-24T03:15:20.000Z</published>
    <updated>2022-04-24T07:35:14.855Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们实现了基于蒙特卡洛积分的渲染方程并了解了重要性采样在光线追踪中的作用。这一节我们根据不同的概率密度来直接生成随机方向。经过上一节的推导，我们知道了之前实现的散射函数中的随机方向对应的概率密度是什么，但是没有显式的用概率密度去直接产生随机方向，而是用一个均匀分布（单位球面上随机取点）加上一个法线偏移达到这样的效果。这一节我们来实现直接生成给定概率密度的随机方向。</p><p><em><span id="more"></span></em></p><h3 id="1-相对于-Z-轴的随机方向"><a href="#1-相对于-Z-轴的随机方向" class="headerlink" title="1 相对于 Z 轴的随机方向"></a>1 相对于 Z 轴的随机方向</h3><p>我们先实现相对于 Z 轴的随机方向，也就是假设所有着色点的法线都是 Z 轴，之后再将他们转换到真实法线方向上。</p><p>在之前的推导中我们知道，球面上的随机方向的概率密度是和俯仰角 $\theta$ 有关的，对于给定的随机方向概率密度 $p(direction)=f(\theta)$，方位角和俯仰角的一维概率密度函数为：</p><script type="math/tex; mode=display">p(\phi) = \frac{1}{2\pi},\ p(\theta) = 2\pi f(\theta)sin\theta</script><p>对于两个均匀生成的随机数 $r_1$ 、$r_2$，有：</p><script type="math/tex; mode=display">r_1 = \int_0^\phi \frac{1}{2\pi} dt</script><p>可以求得：</p><script type="math/tex; mode=display">\phi = 2\pi r_1</script><p>同理：</p><script type="math/tex; mode=display">r_2 = \int_0^\theta2\pi f(t)sin(t)dt</script><p>之前推到过， lambertian 材质的散射光线的概率密度函数为：</p><script type="math/tex; mode=display">p(direction)=f(\theta)=\frac{cos\theta}{\pi}</script><p>代入上式中得：</p><script type="math/tex; mode=display">r_2 = \int_0^\theta2\pi \frac{cost}{\pi}sin(t)dt=1-cos^2\theta</script><p>于是可以求得：</p><script type="math/tex; mode=display">cos\theta = \sqrt{1-r_2}</script><p>极坐标和直角坐标的转换公式为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220424111850258.png" alt="image-20220424111850258"></p><p>将解出来的 $\phi$ 和 $\theta$ 带入得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220424111709272.png" alt="image-20220424111709272"></p><p>于是我们可以实现该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_cosine_direction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line"><span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line"><span class="comment">// 方向是单位向量，所以z坐标就是cos(theta)</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span> - r2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"><span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用这个方法生成其他概率分布的随机方向，只要替换推导过程中的 $f(\theta)$ 即可，比如均匀半球分布 $\frac{1}{2\pi}$，均匀球面分布 $\frac{1}{4\pi}$ 等。</p><h3 id="2-相对于法线的随机方向"><a href="#2-相对于法线的随机方向" class="headerlink" title="2 相对于法线的随机方向"></a>2 相对于法线的随机方向</h3><p>接下来我们将上面生成的围绕 z 轴的随机方向转换为围绕着色点法线的随机方向。这实际上就是一个坐标系转化的过程，回顾最简单的线性代数知识，向量 (x, y, z) 表示的是三个方向上的标准正交基的和，标准正交基就是一个坐标系的三个坐标轴，由于向量只有方向，没有位置，因此用这三个数组合任意的标准正交基都可以得到这个标准正交基下的一个向量，所以我们只要求出法线所在的坐标系下的三个标准正交基，再用 (x, y, z) 组合，就可以得到法线坐标系下的随机方向了。</p><p>得到法线坐标系的标准正交基很简单，类似于之前相机类中实现的方法，我们可以随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，二者叉乘得到一个向量 $\vec t$，再用 $\vec t$ 和法线 $\vec n$ 叉乘得到向量 $\vec s$，则 $\vec n$ 、 $\vec s$ 、 $\vec t$  就构成一组标准正交基。</p><p>至于随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，我们可以直接给定  $\vec a$ 就是 (1, 0, 0)，为了保证不和法线平行，当法线接近 (1, 0, 0) 的时候，  $\vec a$ 就改为 (0, 1, 0)。</p><p>标准正交基的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 标准正交基Orthonormal basis类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">onb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">onb</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> vec3 <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> axis[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * <span class="built_in">u</span>() + b * <span class="built_in">v</span>() + c * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> vec3&amp; a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">x</span>() * <span class="built_in">u</span>() + a.<span class="built_in">y</span>() * <span class="built_in">v</span>() + a.<span class="built_in">z</span>() * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 axis[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onb::build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    axis[<span class="number">2</span>] = <span class="built_in">normalize</span>(n);</span><br><span class="line">    vec3 a = (<span class="built_in">fabs</span>(<span class="built_in">w</span>().<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) ? <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>) : <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    axis[<span class="number">1</span>] = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(<span class="built_in">w</span>(), a));</span><br><span class="line">    axis[<span class="number">0</span>] = <span class="built_in">cross</span>(<span class="built_in">w</span>(), <span class="built_in">v</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>现在我们可以修改 lambertian 材质的散射函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建法线空间的标准正交基</span></span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(rec.normal);</span><br><span class="line">        <span class="comment">// 得到法线空间下概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line">        <span class="keyword">auto</span> direction = uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度，即cos(theta)/pi</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(uvw.<span class="built_in">w</span>(), scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBox3.png" alt="CornellBox3"></p><p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，下一节我们将直接对光源进行采样。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们实现了基于蒙特卡洛积分的渲染方程并了解了重要性采样在光线追踪中的作用。这一节我们根据不同的概率密度来直接生成随机方向。经过上一节的推导，我们知道了之前实现的散射函数中的随机方向对应的概率密度是什么，但是没有显式的用概率密度去直接产生随机方向，而是用一个均匀分布（单位球面上随机取点）加上一个法线偏移达到这样的效果。这一节我们来实现直接生成给定概率密度的随机方向。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十八）重要性采样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/</id>
    <published>2022-04-24T02:42:48.000Z</published>
    <updated>2022-04-26T03:27:34.823Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈渲染方程"><a href="#1-再谈渲染方程" class="headerlink" title="1 再谈渲染方程"></a>1 再谈渲染方程</h3><p>首先我们来回顾图形学中学过的渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220320143225898.png" alt="image-20220320143225898"></p><p>实际上在前面的光线追踪器中我们已经实现了这个渲染方程，但是只实现了一个特殊情况，现在我们来深入分析一下我们是如何实现的。</p><p>我们是在 <code>ray_color</code> 函数中实现这个渲染方程的，渲染方程中的入射光线和出射光线的强度在我们的代码中其实就是 <code>ray_color</code> 函数计算的颜色。</p><p><code>ray_color</code> 函数的<code>r_in</code> 参数最开始传入的是我们从像素中投射出的视线，也就是观察方向，我们根据观察方向通过材质的散射函数随机采样出一条对于我们来说真正的入射光线，然后递归的计算这个入射光线的颜色，并返回 <code>albedo * ray_color</code>，其中反射率 <code>albedo</code> 就是出射光线和入射光线的比值，乘以入射光线颜色，自然就得到了出射光线的颜色，也就是我们最终观察到的颜色。整个过程不断递归，每次传入 <code>ray_color</code> 函数的入射光线实际上是上一次计算的入射光线，是本次计算的出射光线。</p><p>但是我们发现在 <code>ray_color</code> 函数中并没有体现出 BRDF 的存在。这是由于我们实现的是一个特殊情况。</p><p>首先我们对渲染方程中的 BRDF 项做一些变形。我们知道 BRDF 可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220320141430022.png" alt="image-20220320141430022"></p><p>从公式上看，BRDF 计算的是从每个散射方向 $\omega_r$ 出射的光的能量，和从每个入射方向 $\omega_i$ 上入射的光被着色点吸收的全部能量（在法线方向上投影的能量）的比值。<strong>双向反射分布函数的意义在于既描述了光线能量的反射比率，也描述了光线散射方向的分布。</strong></p><p>如果一个材质会发生散射，那么就会存在一个散射光线的分布，这个分布是关于方向的，我们称之为散射光线的概率密度函数 $s(direction)$，根据上面的 BRDF 公式，我们可以把 BRDF 改写为：</p><script type="math/tex; mode=display">BRDF = \frac{albedo·s(direction)}{cos\theta}</script><p>其中反射率是出射光线和入射光线的比值，描述光线的能量反射比率，散射光线的概率密度函数描述了光线散射方向的概率分布，这和上面的 BRDF 表达式是一致的。</p><p>接下来将这个 BRDF 表达式带入渲染方程中，其中夹角余弦可以写成表面法线和入射光线的点乘。于是我们可以得到：</p><script type="math/tex; mode=display">color_{out} = color_{emit} + \int_{\Omega^+}albedo·s(direction)·color_{in}</script><p>这和我们代码中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一致的，只是代码中缺少了散射光线的概率密度函数 $s(direction)$。这是为什么呢？</p><p>在我们实现的材质中，以漫反射 lambertian 材质为例，它的计算散射方向的方法是：使用表面法线偏移着色点 p 作为单位球的球心，在该单位球面上均匀采样一点并连接该点和点 p ，形成的向量即为散射方向。这样计算出的散射方向并不是在以点 p 为球心的半球上均匀分布的，所以概率密度并不是的 $\frac{1}{2\pi}$，而是与散射光线和法线的夹角余弦 $cos\theta$ 成正比的，我们可以推导出这个概率密度函数。</p><blockquote><p><strong>为什么概率密度和 $cos\theta$ 成正比？</strong></p><p>可以这样理解，首先概率密度函数的积分是概率，对于 cos 函数，从 0 到 $\pi/4$ 的积分和从 $\pi/4$ 到 $\pi/2$ 的积分显然是不同的，这说明我们取到的散射方向和法线的夹角在 0 到 $\pi/4$ 的概率比在 $\pi/4$ 到 $\pi/2$ 的概率更大。</p><p>在我们的代码中， lambertian 材质的散射光线方向是法线方向加上一个单位球面上随机生成的方向，也就是说，最终得到的散射光线方向是两个向量的和。如果单位球面上随机生成的方向和法线的夹角刚好是 45 度，那么他和法线的和向量与法线的夹角一定小于 45 度，如果想要和向量的夹角为 45 度，那么随机生成的向量夹角就要大于 45 度。这说明我们在一个单位球面上均匀的取随机点作为一个向量与法线相加得到散射方向，大部分的点得到的散射方向会在 0 到 $\pi/4$ 范围内，只有一小部分才会使最终的散射方向在 $\pi/4$ 到 $\pi/2$ 范围内，因此也就对应了不均匀的概率。</p></blockquote><p>接下来我们推导这个概率密度函数是什么。首先我们知道，方向表示为单位立体角 $d\omega$，单位立体角是球面上的一块面积 $dA$ 和半径平方的比值，在图形学中我们推导过：</p><script type="math/tex; mode=display">d\omega = \frac{dA}{r^2} = \frac{r^2sin\theta \ d\theta \ d\phi}{r^2} = sin\theta \ d\theta \ d\phi</script><p>于是对于半球面上的均匀采样，有：</p><script type="math/tex; mode=display">\int_0^{2\pi}\int_0^{\pi/2}pdf·sin\theta \ d\theta \ d\phi = 1</script><p>而单位半球面的积分就是半球的表面积 $2\pi$，于是半球面上的均匀分布就是：</p><script type="math/tex; mode=display">pdf(x) = \frac{1}{2\pi}</script><p>同理，我们现在要求的概率密度函数和 $cos\theta$ 成正比，于是可以表示为：</p><script type="math/tex; mode=display">pdf(x) = C·cos\theta</script><p>带入上面的积分有：</p><script type="math/tex; mode=display">\int_0^{2\pi}\int_0^{\pi/2}C·cos\theta·sin\theta \ d\theta \ d\phi = 1</script><p>半球面上对 $cos\theta$ 积分结果为 $\pi$，因此：</p><script type="math/tex; mode=display">C·\pi = 1</script><p>于是可以得到我们实现的 lambertian 材质的散射光线的概率密度函数为：</p><script type="math/tex; mode=display">s(direction) = \frac{cos\theta}{\pi}</script><p>接下来继续回顾图形学中的知识，我们求解渲染方程使用的是蒙特卡洛积分的方法，也就是按照某个概率分布 $p(x)$ 对被积变量进行随机采样，于是原积分可以通过如下方式计算：</p><script type="math/tex; mode=display">F_N = \frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)</script><p>那么现在的渲染方程就可以通过蒙特卡洛积分计算：</p><script type="math/tex; mode=display">color_{out} = color_{emit} + \sum \frac{albedo·s(direction)·color_{in}}{p(direction)}</script><p>如果我们选择对光线随机采样的概率密度和散射光线本身的概率密度分布一致，即：</p><script type="math/tex; mode=display">p(direction) = s(direction) = \frac{cos\theta}{\pi}</script><p>显然渲染方程变为：</p><script type="math/tex; mode=display">color_{out} = color_{emit} + \sum albedo·color_{in}</script><p>也就是我们现在代码中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在我们之前的实现中，<strong>隐式的把对光线随机采样的概率密度设置为了永远和散射光线的概率密度一样</strong>，无论是漫反射材质还是金属材质又或者是其他材质，我们不关注他们散射光线的概率密度什么，反正我们采样的概率密度和它们一致，所以渲染方程永远可以表示为上面那样。</p><p>那么这样做为什么可以得到正确的结果呢？之前我们在图形学中也提到过，随机采样的概率分布越接近该变量原本的概率分布，蒙特卡洛积分收敛的也就越好，这会在之后展开讨论。</p><p>现在为了实现更一般的渲染方程，我们需要改写现在的代码。</p><p>首先修改材质抽象类，为散射光线的计算加入采样光线的 pdf：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 带有采样pdf的散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 lambertian 材质的散射函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到和之前一样的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBox.png" alt="CornellBox"></p><p>如果我们把采样光线改为在半球上均匀采样，此时采样光线的 pdf 就是 $\frac{1}{2\pi}$ ，于是我们只要修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//auto scatter_direction = rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 改为半球均匀采样 </span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        <span class="comment">//pdf = dot(rec.normal, scattered.direction()) / pi;</span></span><br><span class="line">        pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBox2.png" alt="CornellBox2"></p><p>使用什么样的采样 pdf 完全取决于我们的选择，但是使用什么样的 pdf 效果好刚才已经给出了答案，随机采样的 pdf 形状越接近函数原本的形状，蒙特卡洛估计收敛的效果就会越好。下面我们来推导这是为什么。</p><h3 id="2-重要性采样"><a href="#2-重要性采样" class="headerlink" title="2 重要性采样"></a>2 重要性采样</h3><p>要了解重要性采样的原理就要先深入理解蒙特卡洛积分，首先我们来分析为什么蒙特卡洛积分可以得到原积分的估计值。根据蒙特卡洛积分的计算方法：</p><script type="math/tex; mode=display">F_N = \frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)</script><p>首先我们把积分变量看做了一个随机变量 X，然后构造了一个随机采样的分布 p(X)，利用这个分布我们可以构造一个新的随机变量：</p><script type="math/tex; mode=display">Y = \frac{f(X)}{p(X)}</script><p>概率论告诉我们的如果一个随机变量 X 的期望是 E(X)，那么随机变量 f(X) 的期望就是 E(f(X))，于是蒙特卡洛积分 $F_N$ 的期望就是：</p><script type="math/tex; mode=display">E[F_N] = E[\frac{1}{N}\sum_{i=1}^N\frac{f(X_i)}{p(X_i)}]</script><p>也就是：</p><script type="math/tex; mode=display">E[F_N] = \frac{1}{N} \sum_{i=1}^NE[Y_i]</script><p>连续型随机变量的期望就是对概率密度函数的积分，所以：</p><script type="math/tex; mode=display">E[Y_i] = \int_a^b \frac{f(x)}{p(x)}p(x)dx = \int_a^b{f(x)}dx</script><p>带入上式得：</p><script type="math/tex; mode=display">E[F_N] = \frac{1}{N} \sum_{i=1}^N\int_a^b{f(x)}dx = \int_a^b{f(x)}dx</script><p>以上证明过程表明，若我们根据公式来构造一个新的随机变量 $F_N$ ，则 $F_N$ 的期望就是原积分的结果，随着 N 的增加，$F_N$ 就越逼近理论上的积分值，即蒙特卡洛积分是原积分的一个无偏估计。</p><p>接下来我们看蒙特卡洛估计的方差：</p><script type="math/tex; mode=display">\sigma^2[F_N] = \sigma^2[\frac{1}{N}\sum_{i=1}^N\frac{f(X_i)}{p(X_i)}]</script><p>即：</p><script type="math/tex; mode=display">\sigma^2[F_N] = \frac{1}{N^2}\sum_{i=1}^N\sigma^2[Y_i]</script><p>于是可以得到：</p><script type="math/tex; mode=display">\sigma^2[F_N] = \frac{1}{N^2}N\sigma^2[Y]=\frac{1}{N}\sigma^2[Y]</script><p>所以蒙特卡洛积分的标准差就是：</p><script type="math/tex; mode=display">\sigma[F_N] = \frac{1}{\sqrt{n}}\sigma[Y]</script><p>这个结果告诉我们，估计值的不稳定来源于随机变量 Y 的取值不稳定。换句话说，如果随机变量：</p><script type="math/tex; mode=display">Y_i = \frac{f(X_i)}{p(X_i)}</script><p>因不同 $X_i$ 的取值变化地越剧烈，就会造成 Y 的方差较大，也就导致估计值的收敛速度越慢。这证明了，<strong>如果 p(x) 的形状越接近 f(x)，则有益于最终结果的收敛</strong>。</p><p><strong>上述思想就是“重要性采样”的方法，即对积分值有重要贡献，即 f(x) 较大的被积函数区间，我们以较大概率生成处于这个区间附近的随机变量，就可以快速逼近理论值。</strong> </p><p>应用到光线追踪中，光源方向的光线对最终渲染方程积分结果的贡献更大，如果使用我们现在的均匀随机采样，由于光源很小，得到光源方向的光线的概率就很小，自然对最终结果的估计就会产生较大的偏差，体现在画面上就是有很大的噪声。于是为了消除噪声，我们应该使用重要性采样，生成更多光源方向的光线。</p><p>当然，如果我们采样更多的随机光线到光源，会导致积分结果过大，也就是画面过亮，而产生不正确的效果，因此我们需要降低这些样本的权重，在蒙特卡洛积分的公式中，除以概率密度函数就是为了解决这个问题，概率密度大的样本取到的相对概率大，除以这个概率可以削弱该样本的权重，以抵消这种不均衡。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十七）新特性最终场景</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/</id>
    <published>2022-04-22T12:46:58.000Z</published>
    <updated>2022-04-23T11:39:14.771Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。</p><p><em><span id="more"></span></em></p><h3 id="1-创建新场景"><a href="#1-创建新场景" class="headerlink" title="1 创建新场景"></a>1 创建新场景</h3><p>创建一个包含所有特性的场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新特性最终场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高低起伏的盒子组成地面</span></span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i * w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j * w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(x0, y0, z0), <span class="built_in">point3</span>(x1, y1, z1), ground));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line">    <span class="comment">// 构建地面的BVH树</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 光源</span></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line">    <span class="comment">// 移动的球体</span></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line">    <span class="comment">// 透明球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    <span class="comment">// 金属球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">1.0</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与介质</span></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>)));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">.0001</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地球</span></span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(</span><br><span class="line">        <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, emat));</span><br><span class="line">    <span class="comment">// 噪声纹理</span></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一堆小球</span></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> center = <span class="built_in">random_vec</span>(<span class="number">0</span>, <span class="number">165</span>);</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">            center, center, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, white));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旋转平移一堆小球</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">270</span>, <span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-渲染效果"><a href="#2-渲染效果" class="headerlink" title="2 渲染效果"></a>2 渲染效果</h3><p>修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            world = <span class="built_in">final_scene</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">800</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">            min_bounce = <span class="number">95</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">478</span>, <span class="number">278</span>, <span class="number">-600</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/FinalSence.png" alt="FinalSence"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十六）参与介质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/</id>
    <published>2022-04-22T12:45:02.000Z</published>
    <updated>2022-04-22T12:47:38.346Z</updated>
    
    <content type="html"><![CDATA[<p>之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。</p><p><em><span id="more"></span></em></p><h3 id="1-恒定密度介质"><a href="#1-恒定密度介质" class="headerlink" title="1 恒定密度介质"></a>1 恒定密度介质</h3><p>因为我们之前所有的实现都是基于“表面”的，而参与介质是基于“体积”的，这二者之间还是有很大的不同的，但是一个简单的办法是可以把整个参与介质看作是由表面构成的，但这个表面可以在物体内部，只要在一定范围内的点都算作该物体的表面，所以都可以和光线发生作用。</p><p>我们在图形学中学过，光线穿过烟雾会在其内部发生各种散射，我们可以用一个概率模型来描述这种过程，如果一个烟雾的密度越大，那么光线在其中发生散射的几率也就越大，如果光线越稀薄，光线就越有可能直接穿过介质而不发生散射，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/fig-2.08-ray-vol.jpg" alt="fig-2.08-ray-vol"></p><p>我们认为光线在烟雾中走过 $\Delta L$ 距离发生散射的几率是：</p><script type="math/tex; mode=display">probability = C·\Delta L</script><p>其中 $C$ 与介质的密度成正比，于是对于一个随机数就可以用上面的式子计算得到概率，并把这个概率认为是散射发生的距离。如果散射发生的距离大于光线在介质中传播的距离，说明光线没有击中介质，而是直接穿过。</p><p>因此一个恒定密度的介质只需要一个密度和边界就可以描述，边界使用另一个物体来确定，相当于该物体形状的烟雾，一个恒定密度的介质类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 恒定密度的参与介质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(a))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, color c)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(c))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; boundary;          <span class="comment">// 边界</span></span><br><span class="line">    shared_ptr&lt;material&gt; phase_function;    <span class="comment">// 各向同性材质，保证光线向各个方向等概率均匀散射</span></span><br><span class="line">    <span class="type">double</span> neg_inv_density;                 <span class="comment">// 密度的负倒数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于debug</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求光线和边界的两个交点</span></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t + <span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">&quot;\nt_min=&quot;</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">&quot;, t_max=&quot;</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线在介质中的距离</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="comment">// 光线发生散射的距离，两个相乘的数都是小于1的负数，所以密度越大值越小</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生散射的距离大于光线在介质中的距离则没有发生散射，直接穿过介质</span></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散射发生的位置</span></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;hit_distance = &quot;</span> &lt;&lt; hit_distance &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.t = &quot;</span> &lt;&lt; rec.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.p = &quot;</span> &lt;&lt; rec.p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法线方向这些属性可以随便设置</span></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.front_face = <span class="literal">true</span>;</span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的实现中我们默认光线一旦出了介质就不会再在介质中弹射了，因此只适用于凸多边形物体，不适用于凹多边形物体。其中控制光线向各个方向等概率散射的材质在 <code>material.h</code> 中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各向同性材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">isotropic</span>(color c) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line">    <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 光线向各个方向等概率均匀散射</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-用烟雾渲染-Cornell-Box"><a href="#2-用烟雾渲染-Cornell-Box" class="headerlink" title="2 用烟雾渲染 Cornell Box"></a>2 用烟雾渲染 Cornell Box</h3><p>我们使用上面实现的介质新建一个 Cornell Box 场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 烟雾Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            world = <span class="built_in">cornell_smoke</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxSmoke.png" alt="CornellBoxSmoke"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十五）立方体和变换</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/</id>
    <published>2022-04-22T11:40:41.000Z</published>
    <updated>2022-04-22T11:46:22.765Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。</p><p><em><span id="more"></span></em></p><h3 id="1-轴对齐立方体"><a href="#1-轴对齐立方体" class="headerlink" title="1 轴对齐立方体"></a>1 轴对齐立方体</h3><p>先使用轴对齐矩形实现一个轴对齐立方体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 box_min;</span><br><span class="line">    point3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr) &#123;</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后将 box 添加到 Cornell Box 场景中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxComplete.png" alt="CornellBoxComplete"></p><h3 id="2-Instances"><a href="#2-Instances" class="headerlink" title="2 Instances"></a>2 Instances</h3><p>接下来我们要实现立方体的旋转，更一般地，我们不止要让立方体旋转，而是要让场景中的所有物体都能够运动，运动包括平移和旋转。在光线追踪器中，这些都是通过 Instances 来实现的，Instances 可以认为是一个几何变换器，可以将传入的物体按照给定的参数和方式进行变换，因此我们要实现这些几何变换的 Instances 类。</p><h4 id="2-1-平移"><a href="#2-1-平移" class="headerlink" title="2.1 平移"></a>2.1 平移</h4><p>首先是平移变换类，在光线追踪器中实现物体平移不是通过真的把物体移动到某个位置，因为物体一旦被放入场景再去变换位置就需要费很大的功夫，所以实现物体平移是通过向反方向移动光线来实现的，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/fig-2.06-ray-box.jpg" alt="fig-2.06-ray-box"></p><p>要把粉色的正方形沿 x 轴向右移动两个单位，我们可以通过把光线沿 x 轴向左移动两个单位来实现。</p><p>注意和之前实现的移动的球体做区分，这里的移动不是在一段时间内的运动，而是改变场景中物体的摆放方式。</p><p>平移变换类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平移变换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">        : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    vec3 offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 光线向反方向平移</span></span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算交点，这里计算出的交点是相对坐标，物体还在原本的地方</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把物体和光线的交点加上偏移，得到平移后的物体和光线的交点在世界空间的绝对坐标</span></span><br><span class="line">    <span class="comment">// 这才相当于把物体移动了</span></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><p>旋转的思路和平移一样，也是先反方向旋转光线，得到交点后对交点再进行正向旋转，不同的是旋转后交点法线也要相应变换，在 Shader 学习中我们知道对法线变换要用变换矩阵的逆转置矩阵，旋转矩阵是正交矩阵，逆转置矩阵就是其本身。</p><p>绕 y 轴旋转的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绕y轴旋转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = bbox;</span><br><span class="line">        <span class="keyword">return</span> hasbox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    <span class="type">double</span> sin_theta;</span><br><span class="line">    <span class="type">double</span> cos_theta;</span><br><span class="line">    <span class="type">bool</span> hasbox;</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，计算旋转后的bounding box及其他的基本成员</span></span><br><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) &#123;</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degrees_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">(infinity, infinity, infinity)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bounding box的每个顶点，并进行变换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = i * bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span> - i) * bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j * bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span> - j) * bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k * bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span> - k) * bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx = cos_theta * x + sin_theta * z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta * x + cos_theta * z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line">                    min[c] = <span class="built_in">fmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">fmax</span>(max[c], tester[c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    <span class="keyword">auto</span> direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线向反方向旋转</span></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 因为光线方向实际上是两个点的差，所以也可以直接应用变换矩阵</span></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到的交点同样是相对的坐标</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = rec.p;</span><br><span class="line">    <span class="keyword">auto</span> normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将交点进行旋转</span></span><br><span class="line">    p[<span class="number">0</span>] = cos_theta * rec.p[<span class="number">0</span>] + sin_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta * rec.p[<span class="number">0</span>] + cos_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 法线也要旋转，法线变换应该用原变换矩阵的逆转置矩阵，旋转矩阵正交因此逆转置矩阵就是原矩阵</span></span><br><span class="line">    normal[<span class="number">0</span>] = cos_theta * rec.normal[<span class="number">0</span>] + sin_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta * rec.normal[<span class="number">0</span>] + cos_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-完整的-Cornell-Box"><a href="#3-完整的-Cornell-Box" class="headerlink" title="3 完整的 Cornell Box"></a>3 完整的 Cornell Box</h3><p>利用实现的立方体和几何变换类，来得到完整的 Cornell Box 场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/CornellBoxComplete-16506279092151.png" alt="CornellBoxComplete"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
</feed>
