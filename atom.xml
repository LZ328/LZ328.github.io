<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-07-13T06:20:18.938Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Piccolo代码解读】渲染系统（二）渲染路径的实现</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/13/20220713-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/13/20220713-Piccolo-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-07-13T06:19:05.000Z</published>
    <updated>2022-07-13T06:20:18.938Z</updated>
    
    <content type="html"><![CDATA[<p>上一次我们了解了 Piccolo 引擎中渲染的基本流程，包括 Logic Tick 和 Render Tick 的数据交换和 RenderTick 的大致过程，这一节我们来详细看这些过程都是如何实现的，在此基础上下一节尝试为整个渲染流程加入一个 Color Grading Pass。</p><p><em><span id="more"></span></em></p><h3 id="1-Render-Tick-整体流程"><a href="#1-Render-Tick-整体流程" class="headerlink" title="1 Render Tick 整体流程"></a>1 Render Tick 整体流程</h3><p>首先回顾上一节中看过的 Render Tick 整体流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process swap data between logic and render contexts</span></span><br><span class="line">    <span class="built_in">processSwapData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare render command context</span></span><br><span class="line">    m_rhi-&gt;<span class="built_in">prepareContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame buffer</span></span><br><span class="line">    m_render_resource-&gt;<span class="built_in">updatePerFrameBuffer</span>(m_render_scene, m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame visible objects</span></span><br><span class="line">    m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                         m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare pipeline&#x27;s render passes data</span></span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">preparePassData</span>(m_render_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render one frame</span></span><br><span class="line">    <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>processSwapData()</code> 上一节中已经学习过， <code>m_rhi-&gt;prepareContext()</code> 用来准备渲染命令，其内部就是初始化 command buffer：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VulkanRHI::prepareContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_p_current_frame_index  = &amp;m_current_frame_index;</span><br><span class="line">    m_current_command_buffer = m_command_buffers[m_current_frame_index];</span><br><span class="line">    m_p_command_buffers      = m_command_buffers;</span><br><span class="line">    m_p_command_pools        = m_command_pools;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一些需要具体看的操作，我们一一探究。</p><h3 id="2-updatePerFrameBuffer"><a href="#2-updatePerFrameBuffer" class="headerlink" title="2 updatePerFrameBuffer"></a>2 updatePerFrameBuffer</h3><p><code>m_render_resource-&gt;updatePerFrameBuffer(m_render_scene, m_render_camera)</code> 负责准备每一帧渲染中的场景数据，包括 VP 矩阵，相机位置，环境光，点光源数量，每个点光源的强度、位置、半径衰减以及平行光属性，把这些数据存到 <code>RenderResource</code> 类的对应成员中用于之后渲染使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderResource::updatePerFrameBuffer</span><span class="params">(std::shared_ptr&lt;RenderScene&gt;  render_scene,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          std::shared_ptr&lt;RenderCamera&gt; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix4x4 view_matrix      = camera-&gt;<span class="built_in">getViewMatrix</span>();</span><br><span class="line">    Matrix4x4 proj_matrix      = camera-&gt;<span class="built_in">getPersProjMatrix</span>();</span><br><span class="line">    Vector3   camera_position  = camera-&gt;<span class="built_in">position</span>();</span><br><span class="line">    glm::mat4 proj_view_matrix = GLMUtil::<span class="built_in">fromMat4x4</span>(proj_matrix * view_matrix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ambient light</span></span><br><span class="line">    Vector3  ambient_light   = render_scene-&gt;m_ambient_light.m_irradiance;</span><br><span class="line">    <span class="type">uint32_t</span> point_light_num = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(render_scene-&gt;m_point_light_list.m_lights.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set ubo data</span></span><br><span class="line">    m_mesh_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.camera_position  = GLMUtil::<span class="built_in">fromVec3</span>(camera_position);</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.ambient_light    = ambient_light;</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.point_light_num  = point_light_num;</span><br><span class="line"></span><br><span class="line">    m_mesh_point_light_shadow_perframe_storage_buffer_object.point_light_num = point_light_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// point lights</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; point_light_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 point_light_position = render_scene-&gt;m_point_light_list.m_lights[i].m_position;</span><br><span class="line">        Vector3 point_light_intensity =</span><br><span class="line">            render_scene-&gt;m_point_light_list.m_lights[i].m_flux / (<span class="number">4.0f</span> * glm::<span class="built_in">pi</span>&lt;<span class="type">float</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> radius = render_scene-&gt;m_point_light_list.m_lights[i].<span class="built_in">calculateRadius</span>();</span><br><span class="line"></span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].position  = point_light_position;</span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].radius    = radius;</span><br><span class="line">        m_mesh_perframe_storage_buffer_object.scene_point_lights[i].intensity = point_light_intensity;</span><br><span class="line"></span><br><span class="line">        m_mesh_point_light_shadow_perframe_storage_buffer_object.point_lights_position_and_radius[i] =</span><br><span class="line">            <span class="built_in">Vector4</span>(point_light_position, radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// directional light</span></span><br><span class="line">    m_mesh_perframe_storage_buffer_object.scene_directional_light.direction =</span><br><span class="line">        render_scene-&gt;m_directional_light.m_direction.<span class="built_in">normalisedCopy</span>();</span><br><span class="line">    m_mesh_perframe_storage_buffer_object.scene_directional_light.color = render_scene-&gt;m_directional_light.m_color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pick pass view projection matrix</span></span><br><span class="line">    m_mesh_inefficient_pick_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line"></span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.proj_view_matrix = proj_view_matrix;</span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.eye_position     = GLMUtil::<span class="built_in">fromVec3</span>(camera_position);</span><br><span class="line">    m_particlebillboard_perframe_storage_buffer_object.up_direction     = GLMUtil::<span class="built_in">fromVec3</span>(camera-&gt;<span class="built_in">up</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-updateVisibleObjects"><a href="#3-updateVisibleObjects" class="headerlink" title="3 updateVisibleObjects"></a>3 updateVisibleObjects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                             m_render_camera);</span><br></pre></td></tr></table></figure><p>这个函数负责预先计算可见的物体，将完全不可见的物体剔除掉，不送入之后的渲染流程中，将可见物体的属性设置好便于之后使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderScene::updateVisibleObjects</span><span class="params">(std::shared_ptr&lt;RenderResource&gt; render_resource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       std::shared_ptr&lt;RenderCamera&gt;   camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">updateVisibleObjectsDirectionalLight</span>(render_resource, camera);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsPointLight</span>(render_resource);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsMainCamera</span>(render_resource, camera);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsAxis</span>(render_resource);</span><br><span class="line">    <span class="built_in">updateVisibleObjectsParticle</span>(render_resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中调用了各种可见性检测函数，包括对平行光的物体可见性、对点光源的物体可见性，对相机的物体可见性以及坐标轴可见性，坐标轴可见性是为了我们在编辑模式选中物体的时候显示坐标轴，所以也要绘制，而最后一个 <code>updateVisibleObjectsParticle</code> 还没有实现， 我们以 <code>updateVisibleObjectsMainCamera</code> 为例来看可见性检测具体干了什么，其他的也是大同小异，最后会提到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void RenderScene::updateVisibleObjectsMainCamera(std::shared_ptr&lt;RenderResource&gt; render_resource,</span><br><span class="line">                                                     std::shared_ptr&lt;RenderCamera&gt;   camera)</span><br><span class="line">&#123;</span><br><span class="line">    m_main_camera_visible_mesh_nodes.clear();</span><br><span class="line"></span><br><span class="line">    Matrix4x4 view_matrix      = camera-&gt;getViewMatrix();</span><br><span class="line">    Matrix4x4 proj_matrix      = camera-&gt;getPersProjMatrix();</span><br><span class="line">    Matrix4x4 proj_view_matrix = proj_matrix * view_matrix;</span><br><span class="line"></span><br><span class="line">    ClusterFrustum f = CreateClusterFrustumFromMatrix(GLMUtil::fromMat4x4(proj_view_matrix), -1.0, 1.0, -1.0, 1.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">    for (const RenderEntity&amp; entity : m_render_entities)</span><br><span class="line">    &#123;</span><br><span class="line">        BoundingBox mesh_asset_bounding_box &#123;entity.m_bounding_box.getMinCorner(),</span><br><span class="line">                                                 entity.m_bounding_box.getMaxCorner()&#125;;</span><br><span class="line"></span><br><span class="line">        if (TiledFrustumIntersectBox(f, BoundingBoxTransform(mesh_asset_bounding_box, GLMUtil::fromMat4x4(entity.m_model_matrix))))</span><br><span class="line">        &#123;</span><br><span class="line">            m_main_camera_visible_mesh_nodes.emplace_back();</span><br><span class="line">            RenderMeshNode&amp; temp_node = m_main_camera_visible_mesh_nodes.back();</span><br><span class="line"></span><br><span class="line">            temp_node.model_matrix = GLMUtil::fromMat4x4(entity.m_model_matrix);</span><br><span class="line"></span><br><span class="line">            assert(entity.m_joint_matrices.size() &lt;= m_mesh_vertex_blending_max_joint_count);</span><br><span class="line">            for (size_t joint_index = 0; joint_index &lt; entity.m_joint_matrices.size(); joint_index++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_node.joint_matrices[joint_index] = GLMUtil::fromMat4x4(entity.m_joint_matrices[joint_index]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp_node.node_id = entity.m_instance_id;</span><br><span class="line"></span><br><span class="line">            VulkanMesh&amp; mesh_asset           = render_resource-&gt;getEntityMesh(entity);</span><br><span class="line">            temp_node.ref_mesh               = &amp;mesh_asset;</span><br><span class="line">            temp_node.enable_vertex_blending = entity.m_enable_vertex_blending;</span><br><span class="line"></span><br><span class="line">            VulkanPBRMaterial&amp; material_asset = render_resource-&gt;getEntityMaterial(entity);</span><br><span class="line">            temp_node.ref_material            = &amp;material_asset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取相机的 PV 矩阵，然后根据矩阵构建世界空间下的视锥体，这部分内容我们在之前学过，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-渲染器-剔除与裁剪/">【光栅化渲染器】（六）剔除与裁剪</a>第 2 部分，有了视锥体就可以利用视锥体和 bounding box 求交来判断是否可见了，如果可见就将该物体的模型矩阵，骨骼矩阵、材质等属性记录下来。</p><p>对于平行光的可见性检测，需要先计算平行光覆盖的范围的 Bounding Box，然后后后续的操作都一样；对于点光源，需要分别计算每一个点光源覆盖的球体范围，计算一个 Bounding Sphere，然后逐点光源进行上述步骤即可。</p><p>至于求交函数，分为视锥体与 Bounding Box 求交以及 Bounding Box 与 Bounding Sphere 求交，前者我们学习过，利用点和视锥体六个平面的关系判断，后者利用球心到 Bounding Box 六个面的距离和球的半径判断即可，具体函数实现可以自行查看工程中的代码。</p><h3 id="4-preparePassData"><a href="#4-preparePassData" class="headerlink" title="4 preparePassData"></a>4 preparePassData</h3><p><code>m_render_pipeline-&gt;preparePassData(m_render_resource)</code> 负责准备渲染所需的 pass 数据，包括相机的 pass，编辑模式下选中物体时的显示 pass（主要是绘制坐标轴），平行光的 shadow pass，点光源的 shadow pass 等：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipelineBase::preparePassData</span><span class="params">(std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_main_camera_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_pick_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_directional_light_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">    m_point_light_shadow_pass-&gt;<span class="built_in">preparePassData</span>(render_resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-forwardRender"><a href="#5-forwardRender" class="headerlink" title="5 forwardRender"></a>5 forwardRender</h3><p>经过上面的场景光源信息、相机信息、物体信息和渲染的 pass 的准备，我们就可以进行渲染了，于是接下来根据渲染路径选择不同的渲染 pipeline：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render one frame</span></span><br><span class="line"><span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">&#123;</span><br><span class="line">    m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">&#123;</span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看前向渲染 <code>forwardRender</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipeline::forwardRender</span><span class="params">(std::shared_ptr&lt;RHI&gt; rhi, std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VulkanRHI*      vulkan_rhi      = <span class="built_in">static_cast</span>&lt;VulkanRHI*&gt;(rhi.<span class="built_in">get</span>());</span><br><span class="line">    RenderResource* vulkan_resource = <span class="built_in">static_cast</span>&lt;RenderResource*&gt;(render_resource.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    vulkan_resource-&gt;<span class="built_in">resetRingBufferOffset</span>(vulkan_rhi-&gt;m_current_frame_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">waitForFences</span>();</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">resetCommandPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> recreate_swapchain =</span><br><span class="line">        vulkan_rhi-&gt;<span class="built_in">prepareBeforePass</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (recreate_swapchain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;DirectionalLightShadowPass*&gt;(m_directional_light_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;PointLightShadowPass*&gt;(m_point_light_shadow_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    ColorGradingPass&amp; color_grading_pass = *(<span class="built_in">static_cast</span>&lt;ColorGradingPass*&gt;(m_color_grading_pass.<span class="built_in">get</span>()));</span><br><span class="line">    FXAAPass&amp;         fxaa_pass          = *(<span class="built_in">static_cast</span>&lt;FXAAPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    ToneMappingPass&amp;  tone_mapping_pass  = *(<span class="built_in">static_cast</span>&lt;ToneMappingPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    UIPass&amp;           ui_pass            = *(<span class="built_in">static_cast</span>&lt;UIPass*&gt;(m_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line">    CombineUIPass&amp;    combine_ui_pass    = *(<span class="built_in">static_cast</span>&lt;CombineUIPass*&gt;(m_combine_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;MainCameraPass*&gt;(m_main_camera_pass.<span class="built_in">get</span>())</span><br><span class="line">        -&gt;<span class="built_in">drawForward</span>(color_grading_pass,</span><br><span class="line">                      fxaa_pass,</span><br><span class="line">                      tone_mapping_pass,</span><br><span class="line">                      ui_pass,</span><br><span class="line">                      combine_ui_pass,</span><br><span class="line">                      vulkan_rhi-&gt;m_current_swapchain_image_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">submitRendering</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在一切准备工作完成之后，首先进行了平行光的 shadow pass 和点光源的 shadow pass 生成光照阴影，然后是主相机的 pass，在主相机 pass 的 <code>drawForward(...)</code> 函数中依次执行了：</p><ul><li><code>drawMeshLighting()</code></li><li><code>drawSkybox()</code></li><li><code>drawBillboardParticle()</code>（未实现）</li><li><code>tone_mapping_pass.draw()</code></li><li><code>color_grading_pass.draw()</code> </li><li><code>if (m_enable_fxaa) fxaa_pass.draw()</code></li><li><code>drawAxis()</code></li><li><code>ui_pass.draw()</code>（未实现）</li><li><code>combine_ui_pass.draw()</code>（未实现）</li></ul><h3 id="6-deferredRender"><a href="#6-deferredRender" class="headerlink" title="6 deferredRender"></a>6 deferredRender</h3><p>延迟渲染的代码和前向渲染基本一致，只是最后调用的是主相机 pass 中的 <code>draw(...)</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderPipeline::deferredRender</span><span class="params">(std::shared_ptr&lt;RHI&gt; rhi, std::shared_ptr&lt;RenderResourceBase&gt; render_resource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VulkanRHI*      vulkan_rhi      = <span class="built_in">static_cast</span>&lt;VulkanRHI*&gt;(rhi.<span class="built_in">get</span>());</span><br><span class="line">    RenderResource* vulkan_resource = <span class="built_in">static_cast</span>&lt;RenderResource*&gt;(render_resource.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    vulkan_resource-&gt;<span class="built_in">resetRingBufferOffset</span>(vulkan_rhi-&gt;m_current_frame_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">waitForFences</span>();</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">resetCommandPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> recreate_swapchain =</span><br><span class="line">        vulkan_rhi-&gt;<span class="built_in">prepareBeforePass</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">if</span> (recreate_swapchain)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;DirectionalLightShadowPass*&gt;(m_directional_light_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;PointLightShadowPass*&gt;(m_point_light_shadow_pass.<span class="built_in">get</span>())-&gt;<span class="built_in">draw</span>();</span><br><span class="line"></span><br><span class="line">    ColorGradingPass&amp; color_grading_pass = *(<span class="built_in">static_cast</span>&lt;ColorGradingPass*&gt;(m_color_grading_pass.<span class="built_in">get</span>()));</span><br><span class="line">    FXAAPass&amp;         fxaa_pass          = *(<span class="built_in">static_cast</span>&lt;FXAAPass*&gt;(m_fxaa_pass.<span class="built_in">get</span>()));</span><br><span class="line">    ToneMappingPass&amp;  tone_mapping_pass  = *(<span class="built_in">static_cast</span>&lt;ToneMappingPass*&gt;(m_tone_mapping_pass.<span class="built_in">get</span>()));</span><br><span class="line">    UIPass&amp;           ui_pass            = *(<span class="built_in">static_cast</span>&lt;UIPass*&gt;(m_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line">    CombineUIPass&amp;    combine_ui_pass    = *(<span class="built_in">static_cast</span>&lt;CombineUIPass*&gt;(m_combine_ui_pass.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;MainCameraPass*&gt;(m_main_camera_pass.<span class="built_in">get</span>())</span><br><span class="line">        -&gt;<span class="built_in">draw</span>(color_grading_pass,</span><br><span class="line">               fxaa_pass,</span><br><span class="line">               tone_mapping_pass,</span><br><span class="line">               ui_pass,</span><br><span class="line">               combine_ui_pass,</span><br><span class="line">               vulkan_rhi-&gt;m_current_swapchain_image_index);</span><br><span class="line"></span><br><span class="line">    vulkan_rhi-&gt;<span class="built_in">submitRendering</span>(std::<span class="built_in">bind</span>(&amp;RenderPipeline::passUpdateAfterRecreateSwapchain, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主相机 pass 的 <code>draw(...)</code> 函数中依次执行了：</p><ul><li><code>drawMeshGbuffer()</code></li><li><code>drawDeferredLighting()</code></li><li><code>drawBillboardParticle()</code>（未实现）</li><li><code>tone_mapping_pass.draw()</code></li><li><code>color_grading_pass.draw()</code> </li><li><code>if (m_enable_fxaa) fxaa_pass.draw()</code></li><li><code>drawAxis()</code></li><li><code>ui_pass.draw()</code>（未实现）</li><li><code>combine_ui_pass.draw()</code>（未实现）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一次我们了解了 Piccolo 引擎中渲染的基本流程，包括 Logic Tick 和 Render Tick 的数据交换和 RenderTick 的大致过程，这一节我们来详细看这些过程都是如何实现的，在此基础上下一节尝试为整个渲染流程加入一个 Color Grading Pass。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Piccolo引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Piccolo%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（四）游戏引擎中的物理系统</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-07-04T08:44:26.000Z</published>
    <updated>2022-07-04T08:45:38.002Z</updated>
    
    <content type="html"><![CDATA[<p>物理系统是游戏引擎中最重要的逻辑系统，也是游戏引擎中极为复杂和庞大的系统，物理决定了游戏世界是否符合人对真实世界的认知，好的物理系统能让游戏可玩性大幅提升，这一节来简单了解游戏引擎中的物理系统和简单的碰撞检测思路。因为物理系统非常复杂，因此我们先学习基础的概念和思想，之后如果有必要会在专门的物理专题中进一步学习详细的算法和实现。</p><p><em><span id="more"></span></em></p><h3 id="1-物理系统的基本概念"><a href="#1-物理系统的基本概念" class="headerlink" title="1 物理系统的基本概念"></a>1 物理系统的基本概念</h3><p>在游戏引擎中，物理世界和玩家看到的游戏世界是有一定区别的，渲染和动画是为了让物理世界以更酷炫的方式呈现在玩家面前，而整个游戏世界的运行可能是像下图中右边的样子：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704104605567.png" alt="image-20220704104605567"></p><p>游戏世界中的所有物体在物理世界中都被称为 Actor，Actor 通常都是一些简单的几何形状，而不是精细的模型，Actor 具体分为几种类型，首先是静态的 Actor，也就是静止不动的物体，比如墙体：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704104753035.png" alt="image-20220704104753035"></p><p>还有动态的 Actor，比如角色和 NPC：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704104828190.png" alt="image-20220704104828190"></p><p>还有一类特殊的 Actor 叫做触发器（Trigger），比如我们走到某个位置，门就会自动打开，或者老头环中升降梯的触发方块；最后还有一些 Actor 可能不符合现实世界的运动规律，但却是游戏性需要的，这类 Actor 称为 Kinematic。</p><p>这些 Actor 的形状一般都非常简单，因为物理系统需要计算物体之间的碰撞和力的作用，复杂的模型是不便于计算的，因此 Actor 一般都是球体、胶囊体、立方体等，复杂一点的还有不规则凸面体和三角形片面等：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704105231249.png" alt="image-20220704105231249"></p><p>一般来说游戏中比较小的物体都会用球体，而角色用胶囊体，房屋和箱子或者墙面就使用立方体，其他比较复杂的需要相对比较精细计算的物体才使用凸包等。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704105406867.png" alt="image-20220704105406867"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704105357458.png" alt="image-20220704105357458"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704105348630.png" alt="image-20220704105348630"></p><p>对于每一个 Actor，要进行物理计算，就需要有他们的 Shape 以及重心，还有其他物理材质属性，比如摩擦系数、弹力系数等等。</p><h3 id="2-物理模拟"><a href="#2-物理模拟" class="headerlink" title="2 物理模拟"></a>2 物理模拟</h3><p>物理模拟最重要的就是模拟物体在不同力作用下的运动，由于游戏中几乎不存在规则运动，因为各种力是与游戏交互息息相关的，在游戏运行之前我们不知道这些力会是什么样，因此也没有办法建立解析的物理运动模型，比如标准的圆周运动等，于是就需要根据物体当前的运动状态和力的作用，模拟物体的运动。</p><p>对于真实世界理想的运动，在任何时间根据位置就可以通过求导就算出速度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110022222.png" alt="image-20220704110022222"></p><p>但游戏世界我们不知道物体是怎样运动的，我们知道的只有物体在当前时刻的位置和速度，要以此来估算下一时刻的位置和速度，从而模拟物体的真实运动：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704105959737.png" alt="image-20220704105959737"></p><p>从数学上严格的来计算，下一时刻物体的位置应该是从当前时刻到下一时刻速度的积分加上当前位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110120510.png" alt="image-20220704110120510"></p><p>但我们不知道下一时刻的速度和这之间速度的变化，所以要去进行估算，显式欧拉积分的思想是利用当前时刻的力估计下一时刻的速度，然后用当前时刻的速度估算下一时刻的位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110255149.png" alt="image-20220704110255149"></p><p>但这样的问题是会使得模拟出的轨迹向外偏离，因为我们用的是当前时刻的力进行的估计，而对于圆周运动当前时刻的力肯定要比下一时刻的力的方向向外：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110406179.png" alt="image-20220704110406179"></p><p>由此也说明显式欧拉积分是不稳定的，很难收敛，除非步长非常小，但那样又会增大计算量，不过好处是计算简单。</p><p>另一种隐式欧拉积分正好相反，假设我们已知下一时刻的力和速度，来反向逼近结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110612974.png" alt="image-20220704110612974"></p><p>这样做相比于显式积分更加稳定，但求解也更困难。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110632409.png" alt="image-20220704110632409"></p><p>物理引擎中一般使用半隐式欧拉积分，即使用当前时刻的力估计下一时刻的速度，再用下一时刻的速度估计下一时刻的位置，相当于结合了显式和隐式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704110807928.png" alt="image-20220704110807928"></p><p>这样的方法被证明是稳定的，而且模拟结果非常好，并且易于计算。</p><p>当然在游戏中，物体不是一个质点，是有体积的，收到力的作用后，物体的运动也不仅仅是在世界空间的运动，还包含物体本身的旋转等运动，因此还涉及到刚体动力学的许多知识，这里就不展开了。</p><h3 id="3-碰撞检测"><a href="#3-碰撞检测" class="headerlink" title="3 碰撞检测"></a>3 碰撞检测</h3><p>碰撞检测一般分为两个阶段，首先是粗检测，利用 AABB 来进行初步检测，判断物体是否相交，如果相交再进行精细的计算二者的相交位置，深度等。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111213558.png" alt="image-20220704111213558"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111147867.png" alt="image-20220704111147867"></p><h4 id="3-1-粗检测阶段"><a href="#3-1-粗检测阶段" class="headerlink" title="3.1 粗检测阶段"></a>3.1 粗检测阶段</h4><p>粗检测阶段一般可以利用 BVH，类似于渲染中的视锥体剔除，但更好的方法是 Sort and Sweep 方法，分为两个阶段：</p><p>首先是 Sort 阶段，对场景中所有的 AABB 的边界在不同维度上进行排序，从而可以轻松的判断是否相交，类似于判断重复区间：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111410029.png" alt="image-20220704111410029"></p><p>由于场景中大部分物体的位置都是固定不变的，因此一旦排好序之后，只需要调整移动的物体在排序中的位置即可，而对于一个有序数组，调整某些元素的位置是很快的，这就是第二个 Sweep 阶段：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111521998.png" alt="image-20220704111521998"></p><h4 id="3-2-精细检测阶段"><a href="#3-2-精细检测阶段" class="headerlink" title="3.2 精细检测阶段"></a>3.2 精细检测阶段</h4><p>经过粗检测之后就要具体求解交点深度、位置和朝向等信息，从而施加碰撞力了，这部分求交相对比较困难，对于简单形体的 Actor 来说还比较简单，比如球体之间的求交或者胶囊体的求交：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111722150.png" alt="image-20220704111722150"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111732053.png" alt="image-20220704111732053"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111748168.png" alt="image-20220704111748168"></p><p>但对于凸多面体就比较困难了，这里简单了解两个算法的思路，这两个算法不仅适用于碰撞检测，还适用于其它系统。</p><h5 id="3-2-1-Minkowski-Difference-based-Methods"><a href="#3-2-1-Minkowski-Difference-based-Methods" class="headerlink" title="3.2.1 Minkowski Difference-based Methods"></a>3.2.1 Minkowski Difference-based Methods</h5><p>明可夫斯基和是集合论中的概念，两个集合的明可夫斯基和定义为集合中全部元素两两相加形成的新的集合：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704111957916.png" alt="image-20220704111957916"></p><p>对于几何中的点集来说，如果是一个无穷点集 B，比如三角形覆盖的点和一个点 A 的明可夫斯基和表示的就是点集 B 中的所有点加上点 A 所形成的新的三角形覆盖的所有点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112125293.png" alt="image-20220704112125293"></p><p>而一个无穷点集 B 和一条线段 A 的明可夫斯基和表示的就是点集 B 中的所有点在线段 A 方向上进行移动，所形成的新的多边形覆盖的所有点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112253484.png" alt="image-20220704112253484"></p><p>同理，一个无穷点集 B 和另一个无穷点集 A 的明可夫斯基和表示的就是点集 B 中的所有点在 A 各个边方向上进行移动，所形成的新的多边形覆盖的所有点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112344185.png" alt="image-20220704112344185"></p><p>也就是两个凸多边形的明可夫斯基和会形成一个新的凸多边形。并且这个新的凸多边形实际上就是两个凸多边形所有顶点之和所对应的点的凸包：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112514203.png" alt="image-20220704112514203"></p><p>有了加法自然可以定义减法，将一个点集中的所有点取反再相加即可：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112547495.png" alt="image-20220704112547495"></p><p>于是当两个凸多边形有交点的时候，他们的明可夫斯基差形成的凸多边形一定会过原点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112633775.png" alt="image-20220704112633775"></p><p>由此可以判断二者是否相交，并且可以求出相交的具体深度、位置等属性。至于如何快速判断凸多边形过原点，一个著名的方法是 GJK 算法，是通过迭代不断逼近原点的方法，这里不展开。</p><h5 id="3-2-2-Separating-Axis-Theorem-SAT"><a href="#3-2-2-Separating-Axis-Theorem-SAT" class="headerlink" title="3.2.2 Separating Axis Theorem (SAT)"></a>3.2.2 Separating Axis Theorem (SAT)</h5><p>分离轴算法也是常用的凸多面体求交算法，二维情况下如果两个凸多边形没有交点，那么一定存在一个轴可以使得；两个多边形的顶点分列两侧：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220704112931417.png" alt="image-20220704112931417"></p><p>于是遍历多边形的每条边作为轴，判断顶点和直线关系，如果存在任何一条轴能把两个多边形的顶点完全分开就说明二者没有交点，三维中的情况更加复杂一些，这里也不再赘述了。</p><p>碰撞检测结束后，还要根据算出来的碰撞点、力的朝向等对碰撞的物体做出响应，最简单的就是分别给物体一个力让他们分开，具体如何计算也不展开了，之后如果有必要，会在物理专题中详细学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;物理系统是游戏引擎中最重要的逻辑系统，也是游戏引擎中极为复杂和庞大的系统，物理决定了游戏世界是否符合人对真实世界的认知，好的物理系统能让游戏可玩性大幅提升，这一节来简单了解游戏引擎中的物理系统和简单的碰撞检测思路。因为物理系统非常复杂，因此我们先学习基础的概念和思想，之后如果有必要会在专门的物理专题中进一步学习详细的算法和实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构深度解析</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</id>
    <published>2022-07-03T10:36:37.000Z</published>
    <updated>2022-07-03T10:41:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以 NVIDIA 为代表详细解析现代 GPU 架构，深入理解 GPU 运行机制，有助于理解大型引擎的渲染系统构建和渲染优化思路。</p><p><em><span id="more"></span></em></p><h3 id="1-GPU-架构发展"><a href="#1-GPU-架构发展" class="headerlink" title="1 GPU 架构发展"></a>1 GPU 架构发展</h3><p>NVIDIA GPU 架构历经多次变革，从起初的 Tesla 发展到最新的 Turing 架构，发展史可分为以下时间节点：</p><ul><li><p><strong>2008 - Tesla</strong></p><p>Tesla最初是给计算处理单元使用的，应用于早期的CUDA系列显卡芯片中，并不是真正意义上的普通图形处理芯片。</p></li><li><p><strong>2010 - Fermi</strong></p><p>Fermi是第一个完整的GPU计算架构。首款可支持与共享存储结合纯cache层次的GPU架构，支持ECC的GPU架构。</p></li><li><p><strong>2012 - Kepler</strong></p><p>Kepler相较于Fermi更快，效率更高，性能更好。</p></li><li><p><strong>2014 - Maxwell</strong></p><p>其全新的立体像素全局光照 (VXGI) 技术首次让游戏 GPU 能够提供实时的动态全局光照效果。基于 Maxwell 架构的 GTX 980 和 970 GPU 采用了包括多帧采样抗锯齿 (MFAA)、动态超级分辨率 (DSR)、VR Direct 以及超节能设计在内的一系列新技术。</p></li><li><p><strong>2016 - Pascal</strong></p><p>Pascal 架构将处理器和数据集成在同一个程序包内，以实现更高的计算效率。1080系列、1060系列基于Pascal架构</p></li><li><p><strong>2017 - Volta</strong></p><p>Volta 配备640 个Tensor 核心，每秒可提供超过100 兆次浮点运算(TFLOPS) 的深度学习效能，比前一代的Pascal 架构快5 倍以上。</p></li><li><p><strong>2018 - Turing</strong></p><p>Turing 架构配备了名为 RT Core 的专用光线追踪处理器，能够以高达每秒 10 Giga Rays 的速度对光线和声音在 3D 环境中的传播进行加速计算。Turing 架构将实时光线追踪运算加速至上一代 NVIDIA Pascal™ 架构的 25 倍，并能以高出 CPU 30 多倍的速度进行电影效果的最终帧渲染。2060系列、2080系列显卡也是跳过了Volta直接选择了Turing架构。</p></li></ul><p>各架构的微观物理结构可以查看<a href="https://www.cnblogs.com/timlly/p/11471507.html#32-gpu微观物理结构">深入GPU硬件架构及运行机制-gpu微观物理结构</a>。</p><h3 id="2-GPU-的功能"><a href="#2-GPU-的功能" class="headerlink" title="2 GPU 的功能"></a>2 GPU 的功能</h3><p>现代GPU除了绘制图形外，还担当了很多额外的功能，综合起来如下几方面：</p><ul><li><p><strong>图形绘制。</strong></p><p>这是GPU最传统的拿手好戏，也是最基础、最核心的功能。为大多数PC桌面、移动设备、图形工作站提供图形处理和绘制功能。</p></li><li><p><strong>物理模拟。</strong></p><p>GPU硬件集成的物理引擎（PhysX、Havok），为游戏、电影、教育、科学模拟等领域提供了成百上千倍性能的物理模拟，使得以前需要长时间计算的物理模拟得以实时呈现。</p></li><li><p><strong>海量计算。</strong></p><p>计算着色器及流输出的出现，为各种可以并行计算的海量需求得以实现，CUDA就是最好的例证。</p></li><li><p><strong>AI运算。</strong></p><p>近年来，人工智能的崛起推动了GPU集成了AI Core运算单元，反哺AI运算能力的提升，给各行各业带来了计算能力的提升。</p></li><li><p><strong>其它计算。</strong></p><p>音视频编解码、加解密、科学计算、离线渲染等等都离不开现代GPU的并行计算能力和海量吞吐能力。</p></li></ul><h3 id="3-GPU-逻辑架构"><a href="#3-GPU-逻辑架构" class="headerlink" title="3 GPU 逻辑架构"></a>3 GPU 逻辑架构</h3><p>下图是图形架构的微观结构：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001056361-789565826.png" alt="1617944-20190906001056361-789565826"></p><p>从 Fermi 开始 NVIDIA 都使用类似的原理架构，使用一个 Giga Thread Engine 来管理所有正在进行的工作，GPU 被划分成多个 GPCs(Graphics Processing Cluster)，每个 GPC 拥有多个 SM（或者SMX、SMM）和一个光栅化引擎（Raster Engine）。</p><p>程序员编写的 shader 是在 SM 上完成的。每个 SM 包含许多为线程执行数学运算的 Core，一个线程可以是顶点或像素着色器调用。这些 Core 包括整数运算的 ALU，浮点运算的 FPU，特殊函数运算的 SFU，用于深度学习的 Tensor Core 和用于光线追踪的 RT Core 等等。这些 Core 和其它单元由 Warp Scheduler  驱动，Warp Scheduler 管理一组 32 个线程作为 Warp（线程束）并将要执行的指令移交给 Dispatch Units。</p><p>例如下图是图灵架构单个 SM 的结构：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001113377-1820574161.png" alt="1617944-20190906001113377-1820574161"></p><p>其中包含：</p><ul><li>4 个 Warp Schedulers：这个模块负责 warp 调度，一个 warp 由 32 个线程组成，warp 调度器的指令通过 Dispatch Units 送到 Core 执行</li><li>64 CUDA 核，每个 CUDA 核包含一个整数运算单元（上图中 INT32）和一个浮点数运算单元（上图中 FP32）</li><li>16 个 LD/ST（load/store）模块来加载和存储数据</li><li>4 个 SFU（Special function units）执行特殊数学运算（sin、cos、log 等）</li><li>256KB 寄存器（4 个 16384 * 32 bit 的 Register File）</li><li>96KB L1缓存（共享内存）</li><li>4 个纹理读取单元及纹理缓存（上图中 TEX）</li><li>若干光线追踪核心（RT Core）</li></ul><p>其他上图中没有标出的还包括：</p><ul><li>PolyMorph Engine：多边形引擎负责属性装配（attribute Setup）、顶点拉取(VertexFetch)、曲面细分、栅格化（这个模块可以理解专门处理顶点相关的东西）</li><li>指令缓存（Instruction Cache）</li><li>内部链接网络（Interconnect Network）</li></ul><p>Fermi 架构的单个 SM 更清晰的包含了上述的大部分结构：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001212393-1848942244.png" alt="1617944-20190906001212393-1848942244"></p><h3 id="4-GPU-逻辑管线"><a href="#4-GPU-逻辑管线" class="headerlink" title="4 GPU 逻辑管线"></a>4 GPU 逻辑管线</h3><p>接下来以 Fermi 架构的 SM 为例，进行逻辑管线的详细说明。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001228274-379363267.png" alt="1617944-20190906001228274-379363267"></p><p>1、首先程序通过图形 API（DX、GL等）发出 Drawcall 指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到 GPU 可以读取的 Pushbuffer 中。</p><p>2、经过一段时间或者显式调用 flush 指令后，驱动程序把 Pushbuffer 的内容发送给 GPU，GPU 通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令。</p><p>3、在图元分配器（Primitive Distributor）中开始工作分配，处理 indexbuffer 中的顶点产生三角形分成批次（batches），然后发送给多个 GPCs。这一步的理解就是提交上来 n 个三角形，分配给这几个 GPC 同时处理。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906000842367-1857714844.png" alt="1617944-20190906000842367-1857714844"></p><p>4、在 GPC 中，每个 SM 中的 Poly Morph Engine 负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)，即上图中的Vertex Fetch模块。</p><p>5、在获取数据之后，在 SM 中以 32 个线程为一组的线程束(Warp)来调度，来开始处理顶点数据。Warp 是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是 32 个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个 warp 只需要一个套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快，之所以可以这么做是由于 GPU 需要处理的任务是天然并行的。</p><p>6、SM 的 warp 调度器会按照顺序分发指令给整个 warp，单个 warp 中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked out)。被遮掩的原因有很多，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），<strong>因此在shader中的分支会显著增加时间消耗</strong>，在一个 warp 中的分支除非 32 个线程都走到同一个分支里面，否则相当于所有的分支都走了一遍，任何一个线程都不能独立执行指令，而是以 warp 为单位，这些 warp 之间才是独立的。</p><p>7、warp 中的指令可以被一次完成，也可能经过多次调度，例如通常 SM 中的 LD/ST(加载存取) 单元数量明显少于基础数学操作单元。</p><p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp 调度器可能会简单地切换到另一个没有内存等待的 warp，这是 GPU 如何克服内存读取延迟的关键，只是简单地切换活动线程组。为了使这种切换非常快，调度器管理的所有 warp 在寄存器文件中都有自己的寄存器。这里就会有个矛盾产生，shader 需要越多的寄存器，就会给 warp 留下越少的空间，就会产生越少的 warp，这时候在碰到内存延迟的时候就会只是等待，而没有可以运行的 warp 可以切换。    </p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001241355-608845528.png" alt="1617944-20190906001241355-608845528"></p><p>9、一旦 warp 完成了 vertex-shader 的所有指令，运算结果就会被 Viewport Transform 模块处理，三角形会被裁剪然后准备光栅化，GPU 会使用 L1 和 L2 缓存来进行 vertex-shader 和 pixel-shader 的数据通信。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001250059-1971914812.png" alt="1617944-20190906001250059-1971914812"></p><p>10、接下来这些三角形将被分割，再分配给多个 GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个 raster engines 覆盖了多个屏幕上的 tile，这等于把三角形的渲染分配到多个 tile 上面。也就是一个三角形并不是完全由一个 GPC 处理，而是根据覆盖的屏幕区域会被分配给不同的 GPC 计算。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001300961-1313843419.png" alt="1617944-20190906001300961-1313843419"></p><p>11、然后 SM 中的 Attribute Setup 对从 vertex-shader 来的数据进行插值并保证插值后对 pixel-shader 是可读的。</p><p>12、GPC 上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些三角形的片元信息的生成，同时还会处理裁剪Clipping、背面剔除和 Early-Z 等。</p><p>13、接下来 32 个像素线程将被分成一组，或者说 8 个 2x2 的像素块，这是在像素着色器上面的最小工作单元，在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM 中的 warp 调度器会管理像素着色器的任务。</p><p>14、接下来的阶段就和vertex-shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能可以获取一个像素内的值，导致锁步执行非常便利，所有的线程可以保证所有的指令可以在同一点。</p><p>15、最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始 api 顺序，然后才将数据移交给 ROP(render output unit，渲染输出单元)，一个 ROP 内部有很多 ROP 单元，在 ROP 单元中处理深度测试，和 framebuffer 的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p><h3 id="5-技术要点"><a href="#5-技术要点" class="headerlink" title="5 技术要点"></a>5 技术要点</h3><p>上面的流程中有很多细节没有展开阐述，这里分别补充。</p><h4 id="5-1-SIMD和SIMT"><a href="#5-1-SIMD和SIMT" class="headerlink" title="5.1 SIMD和SIMT"></a>5.1 SIMD和SIMT</h4><p><strong>SIMD</strong>（Single Instruction Multiple Data）是单指令多数据，在GPU的ALU单元内，一条指令可以处理多维向量（一般是4D）的数据。比如，有以下shader指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 c = a + b; // a, b都是float4类型</span><br></pre></td></tr></table></figure><p>对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD c.x, a.x, b.x</span><br><span class="line">ADD c.y, a.y, b.y</span><br><span class="line">ADD c.z, a.z, b.z</span><br><span class="line">ADD c.w, a.w, b.w</span><br></pre></td></tr></table></figure><p>但有了 SIMD 技术，只需一条指令即可处理完：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIMD_ADD c, a, b</span><br></pre></td></tr></table></figure><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001330348-1982690439.png" alt="1617944-20190906001330348-1982690439"></p><p><strong>SIMT</strong>（Single Instruction Multiple Threads，单指令多线程）是SIMD的升级版，可对 GPU 中单个 SM 中的多个 Core 同时处理同一指令，并且每个 Core 存取的数据可以是不同的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001403077-1969715914.png" alt="1617944-20190906001403077-1969715914"></p><h4 id="5-2-co-issue"><a href="#5-2-co-issue" class="headerlink" title="5.2 co-issue"></a>5.2 co-issue</h4><p><strong>co-issue</strong>是为了解决SIMD运算单元无法充分利用的问题。例如下图，由于float数量的不同，ALU利用率从100%依次下降为75%、50%、25%。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001418746-831705203.png" alt="1617944-20190906001418746-831705203"></p><p>为了解决着色器在低维向量的利用率低的问题，可以通过合并 1D 与 3D 或 2D 与 2D 的指令。例如下图，<code>DP3</code>指令用了 3D 数据，<code>ADD</code>指令只有 1D 数据，co-issue会自动将它们合并，在同一个 ALU 只需一个指令周期即可执行完。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001427705-915501113.png" alt="1617944-20190906001427705-915501113"></p><h4 id="5-3-if-else-语句"><a href="#5-3-if-else-语句" class="headerlink" title="5.3 if-else 语句"></a>5.3 if-else 语句</h4><p>如下图，SM中有 8 个ALU（Core），由于 SIMD 的特性，每个 ALU 的数据不一样，导致<code>if-else</code>语句在某些ALU中执行的是<code>true</code>分支（黄色），有些ALU执行的是<code>false</code>分支（灰蓝色），这样导致很多 ALU 的执行周期被浪费掉了（即masked out），拉长了整个执行周期。最坏的情况，同一个SM中只有1/8（8 是同一个 SM 的线程数，不同架构的 GPU 有所不同）的利用率。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001457351-743980317.png" alt="1617944-20190906001457351-743980317"></p><p>同样，<code>for</code>循环也会导致类似的情形，例如以下shader代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func(int count, int breakNum)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0; i&lt;count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">if (i == breakNum)</span><br><span class="line">break;</span><br><span class="line">else</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个ALU的<code>count</code>不一样，加上有<code>break</code>分支，导致最快执行完shader的ALU可能是最慢的N分之一的时间，但由于SIMD的特性，最快的那个ALU依然要等待最慢的ALU执行完毕，才能接下一组指令的活！也就白白浪费了很多时间周期。<strong>因此在shader中的分支会显著增加时间消耗</strong></p><h4 id="5-4-Early-Z"><a href="#5-4-Early-Z" class="headerlink" title="5.4 Early-Z"></a>5.4 Early-Z</h4><p>关于 Early-Z 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-模板测试和深度测试/">【Real-Time Rendering】模板测试和深度测试</a>，这里要强调的是 Early-Z 剔除的最小单位不是 1 像素，而是像素块（pixel quad，2x2个像素）。</p><p>此外，从硬件角度讲 Early-Z 还存在<strong>深度数据冲突</strong>（depth data hazard）问题，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001537033-642734220.png" alt="1617944-20190906001537033-642734220"></p><p>假设数值深度值 5 已经经过 Early-Z 即将写入 Frame Buffer，而深度值 10 刚好处于 Early-Z 阶段，读取并对比当前缓存的深度值 15，结果就是 10 通过了 Early-Z 测试，会覆盖掉比自己小的深度值 5，最终 frame buffer 的深度值是错误的结果。</p><p>避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001545523-562795391.png" alt="1617944-20190906001545523-562795391"></p><h4 id="5-5-统一着色器架构（Unified-shader-Architecture）"><a href="#5-5-统一着色器架构（Unified-shader-Architecture）" class="headerlink" title="5.5 统一着色器架构（Unified shader Architecture）"></a>5.5 统一着色器架构（Unified shader Architecture）</h4><p>在早期的 GPU，顶点着色器和像素着色器的硬件结构是独立的，它们各有各的寄存器、运算单元等部件。这样很多时候，会造成顶点着色器与像素着色器之间任务的不平衡。对于顶点数量多的任务，像素着色器空闲状态多；对于像素多的任务，顶点着色器的空闲状态多。</p><p>于是，为了解决 VS 和 PS 之间的不平衡，引入了统一着色器架构（Unified shader Architecture）。用了此架构的 GPU，VS 和 PS 用的都是相同的 Core。也就是，同一个 Core 既可以是 VS 又可以是 PS。这样就解决了不同类型着色器之间的不平衡问题，还可以减少 GPU 的硬件单元，压缩物理尺寸和耗电量。此外，VS、PS 可还可以和其它着色器（几何、曲面、计算）统一为一体。</p><h4 id="5-6-像素块（Pixel-Quad）"><a href="#5-6-像素块（Pixel-Quad）" class="headerlink" title="5.6 像素块（Pixel Quad）"></a>5.6 像素块（Pixel Quad）</h4><p>前文说到，在像素着色器中，会将相邻的四个像素作为不可分割的一组，送入同一个 SM 内 4 个不同的 Core 中。为什么这样做呢？可能有以下几点原因：</p><p>1、简化和加速像素分派的工作。</p><p>2、精简 SM 的架构，减少硬件单元数量和尺寸。</p><p>3、降低功耗，提高效能比。</p><p>4、无效像素虽然不会被存储结果，但可辅助有效像素求导函数。</p><p>这种设计虽然有其优势，但同时，也会激化过绘制（Over Draw）的情况，损耗额外的性能。比如下图中，白色的三角形只占用了 3 个像素（绿色），按我们普通的思维，只需要 3 个 Core 绘制 3 次就可以了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001651573-804337756.png" alt="1617944-20190906001651573-804337756"></p><p>但是，由于上面的 3 个像素分别占据了不同的像素块（橙色分隔），实际上需要占用 12 个 Core 绘制 12 次（下图）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001659282-1154417522.png" alt="1617944-20190906001659282-1154417522"></p><p>这就会额外消耗 300% 的硬件性能，导致了更加严重的过绘制情况。</p><h3 id="6-GPU-资源管理"><a href="#6-GPU-资源管理" class="headerlink" title="6 GPU 资源管理"></a>6 GPU 资源管理</h3><h4 id="6-1-GPU-内存架构"><a href="#6-1-GPU-内存架构" class="headerlink" title="6.1 GPU 内存架构"></a>6.1 GPU 内存架构</h4><p>有些 GPU 的内存架构和 CPU 类似，分为寄存器，L1 缓存，L2 缓存，GPU 显存和系统显存：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001709237-945454718.png" alt="1617944-20190906001709237-945454718"></p><p>它们的存取速度从寄存器到系统内存依次变慢：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703174542534.png" alt="image-20220703174542534"></p><p>由此可见，shader直接访问寄存器、L1、L2缓存还是比较快的，但访问纹理、常量缓存和全局内存非常慢，会造成很高的延迟。</p><p>由于 SIMT 技术的引入，导致很多同一个 SM 内的很多 Core 并不是独立的，当它们当中有部分 Core 需要访问到纹理、常量缓存和全局内存时，就会导致非常大的卡顿（Stall）。</p><p>如下图，有 4 组上下文（Context），它们共用同一组运算单元ALU：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001735780-1606282901.png" alt="1617944-20190906001735780-1606282901"></p><p>假设第一组 Context 需要访问缓存或内存，会导致 2~3 个周期的延迟，此时调度器会激活第二组 Context 以利用ALU：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001744570-1497753939.png" alt="1617944-20190906001744570-1497753939"></p><p>当第二组Context访问缓存或内存又卡住，会依次激活第三、第四组Context，直到第一组Context恢复运行或所有都被激活：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001752475-1100477295.png" alt="1617944-20190906001752475-1100477295"></p><p>延迟的后果是每组Context的总体执行时间被拉长了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001800006-1870518462.png" alt="1617944-20190906001800006-1870518462"></p><p>但是，越多Context可用就越可以提升运算单元的吞吐量。</p><h4 id="6-2-CPU-GPU-异构系统"><a href="#6-2-CPU-GPU-异构系统" class="headerlink" title="6.2 CPU-GPU 异构系统"></a>6.2 CPU-GPU 异构系统</h4><p>根据CPU和GPU是否共享内存，可分为两种类型的CPU-GPU架构：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001850363-356121869.png" alt="1617944-20190906001850363-356121869"></p><p>上图左是<strong>分离式架构</strong>，CPU和GPU各自有独立的缓存和内存，它们通过PCI-e等总线通讯。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>上图右是<strong>耦合式架构</strong>，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p><p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 CPU 共享系统内存，由 MMU 进行存储管理。</p><h4 id="6-3-GPU-资源管理模型"><a href="#6-3-GPU-资源管理模型" class="headerlink" title="6.3 GPU 资源管理模型"></a>6.3 GPU 资源管理模型</h4><p>下图是分离式架构的资源管理模型：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001903861-1080252910.png" alt="1617944-20190906001903861-1080252910"></p><ul><li><strong>MMIO（Memory Mapped IO）</strong><ul><li>CPU与GPU的交流就是通过MMIO进行的。CPU 通过 MMIO 访问 GPU 的寄存器状态。</li><li>DMA传输大量的数据就是通过MMIO进行命令控制的。</li><li>I/O端口可用于间接访问MMIO区域，像Nouveau等开源软件从来不访问它。</li></ul></li><li><strong>GPU Context</strong><ul><li>GPU Context代表了GPU计算的状态。</li><li>在GPU中拥有自己的虚拟地址。</li><li>GPU 中可以并存多个活跃态下的Context。</li></ul></li><li><strong>GPU Channel</strong><ul><li>任何命令都是由CPU发出。</li><li>命令流（command stream）被提交到硬件单元，也就是GPU Channel。</li><li>每个GPU Channel关联一个context，而一个GPU Context可以有多个GPU channel。</li><li>每个GPU Context 包含相关channel的 GPU Channel Descriptors ， 每个 Descriptor 都是 GPU 内存中的一个对象。</li><li>每个 GPU Channel Descriptor 存储了 Channel 的设置，其中就包括 Page Table 。</li><li>每个 GPU Channel 在GPU内存中分配了唯一的命令缓存，这通过MMIO对CPU可见。</li><li>GPU Context Switching 和命令执行都在GPU硬件内部调度。</li></ul></li><li><strong>GPU Page Table</strong><ul><li>GPU Context在虚拟基地空间由Page Table隔离其它的Context 。</li><li>GPU Page Table隔离CPU Page Table，位于GPU内存中。</li><li>GPU Page Table的物理地址位于 GPU Channel Descriptor中。</li><li>GPU Page Table不仅仅将 GPU虚拟地址转换成GPU内存的物理地址，也可以转换成CPU的物理地址。因此，GPU Page Table可以将GPU虚拟地址和CPU内存地址统一到GPU统一虚拟地址空间来。</li></ul></li><li><strong>PCI-e BAR</strong><ul><li>GPU 设备通过PCI-e总线接入到主机上。 Base Address Registers(BARs) 是 MMIO的窗口，在GPU启动时候配置。</li><li>GPU的控制寄存器和内存都映射到了BARs中。</li><li>GPU设备内存通过映射的MMIO窗口去配置GPU和访问GPU内存。</li></ul></li><li><strong>PFIFO Engine</strong><ul><li>PFIFO是GPU命令提交通过的一个特殊的部件。</li><li>PFIFO维护了一些独立命令队列，也就是Channel。</li><li>此命令队列是Ring Buffer，有PUT和GET的指针。</li><li>所有访问Channel控制区域的执行指令都被PFIFO 拦截下来。</li><li>GPU驱动使用Channel Descriptor来存储相关的Channel设定。</li><li>PFIFO将读取的命令转交给PGRAPH Engine。</li></ul></li><li><strong>BO</strong><ul><li>Buffer Object (BO)，内存的一块(Block)，能够用于存储纹理（Texture）、渲染目标（Render Target）、着色代码（shader code）等等。</li></ul></li></ul><h4 id="6-4-CPU-GPU-数据流"><a href="#6-4-CPU-GPU-数据流" class="headerlink" title="6.4 CPU-GPU 数据流"></a>6.4 CPU-GPU 数据流</h4><p>下图是分离式架构的 CPU-GPU 的数据流程图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001916357-1658595620.webp" alt="1617944-20190906001916357-1658595620"></p><p>1、将主存的处理数据复制到显存中。</p><p>2、CPU指令驱动GPU。</p><p>3、GPU中的每个运算单元并行处理。此步会从显存存取数据。</p><p>4、GPU将显存结果传回主存。</p><p>更加详细的 GPU 数据流程可以查看最后的参考文章。</p><h4 id="6-5-显像机制"><a href="#6-5-显像机制" class="headerlink" title="6.5 显像机制"></a>6.5 显像机制</h4><p>计算机显示图像的过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001947961-1190125231.png" alt="1617944-20190906001947961-1190125231"></p><p>显示器通常以固定频率进行刷新，CPU 将计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照屏幕刷新信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><h4 id="6-6-双重缓冲"><a href="#6-6-双重缓冲" class="headerlink" title="6.6 双重缓冲"></a>6.6 双重缓冲</h4><p>在单缓冲下，帧缓冲区的读取和刷新都都会有比较大的效率问题，经常会出现相互等待的情况，导致帧率下降。</p><p>为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会交换缓冲区内容。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906001957832-296063271.png" alt="1617944-20190906001957832-296063271"></p><h4 id="6-7-垂直同步"><a href="#6-7-垂直同步" class="headerlink" title="6.7 垂直同步"></a>6.7 垂直同步</h4><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当 GPU 渲染速度大于屏幕刷新速度时，视频控制器还未读取完成，即屏幕内容刚显示一半时，GPU 就将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换，此时视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906002006570-2008054292.jpg" alt="1617944-20190906002006570-2008054292"></p><p>为了解决这个问题，GPU 通常有一个机制叫做<strong>垂直同步</strong>（V-Sync），当开启垂直同步后，GPU 会等待显示器的刷新信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h3 id="7-Shader-运行机制"><a href="#7-Shader-运行机制" class="headerlink" title="7 Shader 运行机制"></a>7 Shader 运行机制</h3><p>Shader 代码也跟传统的 C++ 等语言类似，需要将面向人类的高级语言（GLSL、HLSL、CGSL）通过编译器转成面向机器的二进制指令，二进制指令可转译成汇编代码，以便技术人员查阅和调试。</p><p>由高级语言编译成汇编指令的过程通常是在离线阶段执行，以减轻运行时的消耗。</p><p>在执行阶段，CPU端将shader二进制指令经由PCI-e推送到GPU端，GPU在执行代码时，会用Context将指令分成若干Channel推送到各个Core的存储空间。</p><p>对现代GPU而言，可编程的阶段越来越多，包含但不限于：顶点着色器（Vertex Shader）、曲面细分控制着色器（Tessellation Control Shader）、几何着色器（Geometry Shader）、像素/片元着色器（Fragment Shader）、计算着色器（Compute Shader）等等。总体流程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/1617944-20190906002027360-504150984.png" alt="1617944-20190906002027360-504150984"></p><h3 id="8-渲染优化建议"><a href="#8-渲染优化建议" class="headerlink" title="8 渲染优化建议"></a>8 渲染优化建议</h3><p>由以上分析，可以得出以下渲染优化建议：</p><ul><li><strong>减少CPU和GPU的数据交换：</strong><ul><li>批处理（Batch）</li><li>减少顶点数、三角形数</li><li>视锥裁剪<ul><li>BVH</li><li>Portal</li><li>BSP</li><li>OSP</li></ul></li><li>避免每帧提交Buffer数据<ul><li>CPU版的粒子、动画会每帧修改、提交数据，可移至GPU端。</li></ul></li><li>减少渲染状态设置和查询<ul><li>例如：<code>glGetUniformLocation</code>会从GPU内存查询状态，耗费很多时间周期。</li><li>避免每帧设置、查询渲染状态，可在初始化时缓存状态。</li></ul></li><li>启用GPU Instance</li><li>开启LOD</li><li>避免从显存读数据</li></ul></li><li><strong>减少过绘制：</strong><ul><li>避免Tex Kill操作</li><li>避免Alpha Test</li><li>避免Alpha Blend</li><li>开启深度测试<ul><li>Early-Z</li><li>层次Z缓冲（Hierarchical Z-Buffering，HZB）</li></ul></li><li>开启裁剪：<ul><li>背面裁剪</li><li>遮挡裁剪</li><li>视口裁剪</li><li>剪切矩形（scissor rectangle）</li></ul></li><li>控制物体数量<ul><li>粒子数量多且面积小，由于像素块机制，会加剧过绘制情况</li><li>植物、沙石、毛发等也如此</li></ul></li></ul></li><li><strong>Shader优化：</strong><ul><li>避免if、switch分支语句</li><li>避免<code>for</code>循环语句，特别是循环次数可变的</li><li>减少纹理采样次数</li><li>禁用<code>clip</code>或<code>discard</code>操作</li><li>减少复杂数学函数调用</li></ul></li></ul><h3 id="9-参考"><a href="#9-参考" class="headerlink" title="9 参考"></a>9 参考</h3><ul><li><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制 - 0向往0 - 博客园 (cnblogs.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/61358167">GPU并行架构及渲染优化 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇以 NVIDIA 为代表详细解析现代 GPU 架构，深入理解 GPU 运行机制，有助于理解大型引擎的渲染系统构建和渲染优化思路。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（三）游戏引擎中的动画系统</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-07-03T05:37:44.000Z</published>
    <updated>2022-07-03T07:34:58.655Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎中的动画系统是最重要的系统之一，直接决定了角色动作是否自然，酷炫的动画也是一个游戏最能吸引人的地方，这一节来简单了解游戏引擎中的动画系统，蒙皮动画的数学原理以及动画压缩技术。</p><p><em><span id="more"></span></em></p><h3 id="1-游戏引擎中的动画系统"><a href="#1-游戏引擎中的动画系统" class="headerlink" title="1 游戏引擎中的动画系统"></a>1 游戏引擎中的动画系统</h3><p>引擎中的动画技术来自于动画电影，但相比于动画电影，游戏中的动画还要和玩家进行交互，根据玩家的输入来执行不同的动作，并且游戏需要实时运行，动画的计算也要在极短的时间内完成，大量的游戏对象也会有大量的动画数据，动画数据的存储和使用也是一个极大的挑战。</p><p>最早的动画利用人的视觉残留，通过快速播放关键帧来实现，这种方式也叫做精灵动画（Sprite Animation），现在的许多简单 2D 动画，比如 2D 角色的动作和一些特效等，也可以使用这种方式来实现：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703104804654.png" alt="image-20220703104804654"></p><p>此外还有比较热门的 Live2D 动画，将 2D 人物的各个部分分别作为不同的组件，通过调整各组件的顶点或者利用动作捕捉生成关键帧，然后在这些帧之间插值来形成流畅的动画，因为 2D 动作捕捉控制点较少，可以快速实时计算，因此 Live2D 广泛用于现在的虚拟直播中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703105116202.png" alt="image-20220703105116202"></p><p>当然现在游戏引擎中使用最多的还是 3D 动画，3D 动画依赖于对模型添加骨骼，然后利用骨骼的运动（旋转、平移、缩放）来控制模型表面顶点的运动，从而使模型动起来，对于一些比较复杂的布料、流体运动，不方便添加骨骼来控制，于是会使用顶点动画，将物体表面顶点在每一帧的运动存入一张纹理中，渲染时直接通过纹理就可以改变顶点的位置从而形成动画：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703105453426.png" alt="image-20220703105453426"></p><h3 id="2-蒙皮动画"><a href="#2-蒙皮动画" class="headerlink" title="2 蒙皮动画"></a>2 蒙皮动画</h3><p>蒙皮动画是目前最常用的动画技术，蒙皮动画的流程非常简单，大概分为以下几步：</p><ul><li>首先是创建一个模型的 binding pose 的 Mesh 网格，所谓 binding pose 就是指用于后续绑定骨骼的姿势，一般分为 T Pose 和 A Pose，由于 T Pose 在肩部会有一些顶点的重合，可能导致之后的动画表现不完整，因此目前大多使用 A Pose：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703105729235.png" alt="image-20220703105729235"></p><ul><li>第二步是为 Mesh 创建绑定的骨骼，更精确地说是关节，所有的动画都是关节在动，骨骼是两个关节之间的部分：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703110627378.png" alt="image-20220703110627378"></p><p>每个顶点会和多个关节绑定，关节动的时候，顶点就随之移动，同一个顶点受到不同关节的影响自然也不同。此外，除了模型本身的关节，还会为角色的衣服、武器等 Game Play 的部分生成关节：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703110821902.png" alt="image-20220703110821902"></p><ul><li>第三步就是蒙皮，所谓蒙皮就是为每个顶点生成受到不同关节影响的权重</li><li>第四步就是对关节进行动画设计生成动画矩阵</li><li>第五步对每个顶点，根据不同权重应用相应的关节动画来计算得到顶点的位置</li></ul><p>整个蒙皮动画流程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703110247889.png" alt="image-20220703110247889"></p><h4 id="2-1-骨骼层次结构"><a href="#2-1-骨骼层次结构" class="headerlink" title="2.1 骨骼层次结构"></a>2.1 骨骼层次结构</h4><p>一般来说会为骨骼生成层次结构以便于关节间动画的传递，对于人类（双足）模型来说，一般用尾椎骨的关节作为中心关节（Pelvis Joint），因为尾椎骨关节向下就是腿部关节，向上就是上身和胳膊关节，对于动物（四足）模型，也是类似的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703110553383.png" alt="image-20220703110553383"></p><p>一般的层次结构中，在尾椎骨关节点之上还会有一个 root 节点，root 节点一般取人的两腿之间或者动物的四肢之间的中心和地地面接触的地方：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111025886.png" alt="image-20220703111025886"></p><p>因为这样的 root 节点在模型运动的时候高度不会发生改变，有了层次结构我们就可以知道每个关节的父关节和子关节，从而将运动传递下去。</p><p>对于绑定的模型，比如人和载具，还会将他们的 Pelvis Joint 对接到一起，从而使他们的动画能够进行传递，对接不仅是指关节的位置重合，他们的局部坐标系也要变换到完全一致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111310429.png" alt="image-20220703111310429"></p><h4 id="2-2-蒙皮动画矩阵"><a href="#2-2-蒙皮动画矩阵" class="headerlink" title="2.2 蒙皮动画矩阵"></a>2.2 蒙皮动画矩阵</h4><p>接下来推导动画矩阵，首先明确三个坐标系：局部空间、模型空间和世界空间。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111423781.png" alt="image-20220703111423781"></p><p>局部空间是指以关节为中心的空间，每个关节的局部空间自然是不同的，模型空间和世界空间不必多说，在渲染中已经非常熟悉了。</p><p>对于关节的运动，只有三种：旋转、平移和缩放。旋转改变关节的朝向（Orientation）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111819051.png" alt="image-20220703111819051"></p><p>平移改变关节的位置：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111835096.png" alt="image-20220703111835096"></p><p>缩放改变关节的尺寸：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111900765.png" alt="image-20220703111900765"></p><p>于是对于关节的变换通常就是三个矩阵的结合：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703111927064.png" alt="image-20220703111927064"></p><p>于是一个关节当前的 pose 就可以表示为从根节点开始到该节点的所有运动的作用的叠加，也就是矩阵相乘：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703112129521.png" alt="image-20220703112129521"></p><p>这里需要注意的是对于关节的两个 pose 中间状态的插值要在局部空间进行，而不能在模型空间将进行，因为对于关节来说模型空间是一个全局坐标系，直接对关节的位置插值会是不平滑的，而局部空间是相对坐标系，插值会是均匀的，下图左是在局部空间插值的效果，下图右是在模型空间插值的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703112421587.png" alt="image-20220703112421587"></p><p>有了关节的运动，接下来就是如何利用关节运动计算顶点运动，我们先假设每个顶点只和一个关节绑定。</p><p>计算顶点运动的关键就在于顶点相对于关节的位置是永远不可能发生变化的，也就是说顶点在绑定的关节的局部空间的坐标是永远不变得，这样才能保证模型动画的正确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703112652270.png" alt="image-20220703112652270"></p><p>于是我们可以得出以下关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703112723067.png" alt="image-20220703112723067"></p><p>也就是顶点在 Bind Pose 时相对于绑定的关节 J 的局部空间的坐标 $V_b^l$ 和顶点在任何时间 t 时相对于绑定的关节 J 的局部空间的坐标 $V^l(t)$ 恒相等。</p><p>如果把顶点在 Bind Pose 时模型空间的坐标表示为 $V<em>b^m$，关节从局部空间到模型空间的变换矩阵（也就是关节在 Bind Pose 时模型空间下的 pose）表示为 $M^m</em>{b(j)}$，因为顶点和关节的相对位置不变，利用关节的变换矩阵的逆矩阵和顶点在关节局部空间下的坐标也可以将顶点变换到模型空间，于是顶点在任何时间 t 时相对于绑定的关节 J 的局部空间的坐标就等于 $V<em>b^m$ 乘上 $M^m</em>{b(j)}$ 的逆矩阵，即为上式所表示的含义。</p><p>上面说过，任何一个关节在模型空间的 pose 可以表示为从根节点到当前关节的 pose 的叠加：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703113522897.png" alt="image-20220703113522897"></p><p>而关节和顶点的相对位置不变，于是对顶点施加和关节相同的运动就可以完成顶点的运动：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703113632960.png" alt="image-20220703113632960"></p><p>蒙皮动画矩阵就是关节在 t 时刻的 pose 矩阵和关节在 Bind Pose 时的 pose 矩阵的逆矩阵的乘积。有了这个矩阵，我们只要知道任何一个顶点在 Bind Pose 时的模型空间位置，就可以得到该顶点在任何时刻 t 的模型空间坐标，从而实现动画效果。</p><p>对于关节在 Bind Pose 时的模型空间的 pose 矩阵，也就是关节在 Bind Pose 时从关节的局部空间到模型空间的变换矩阵，是很容易得到的，但因为我们要用的是该矩阵的逆矩阵，求逆操作代价较大，所以一般提前算好存在每个关节的结构体中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703114728451.png" alt="image-20220703114728451"></p><p>最后对于渲染，我们要知道的是顶点的世界空间坐标，还要在上面的矩阵上乘上一个物体从模型空间到世界空间的变换矩阵，这个矩阵自然还包含了模型在世界空间中的运动，这样一来就可以实现模型在世界空间的运动和模型本身的运动的动画了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703114951451.png" alt="image-20220703114951451"></p><p>上面的推导是对于一个顶点只绑定一个关节的情况，实际为了动画更加自然，一个顶点会绑定多个关节，然后将通过不同关节运动计算出的顶点模型空间坐标进行加权平均得到最终的顶点坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703124251350.png" alt="image-20220703124251350"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703124316201.png" alt="image-20220703124316201"></p><h4 id="2-3-pose-插值"><a href="#2-3-pose-插值" class="headerlink" title="2.3 pose 插值"></a>2.3 pose 插值</h4><p>通过上面的方法可以生成一个动作的多个关键帧 pose，这些关键帧 pose 组成序列叫做 Clip，对 Clip 中的 pose 进行插值就可以得到连续的动画。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703124737356.png" alt="image-20220703124737356"></p><p>插值实际上是对不同 pose 的运动之间的插值，最难处理的就是旋转的插值。</p><p>之前学习过四元数的球面线性插值，球面线性插值通过旋转角度的正弦进行插值，当角度很小的时候正弦值也很小，可能造成插值不稳定，因此游戏引擎一般使用球面线性插值对较大的旋转角度进行插值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703125107407.png" alt="image-20220703125107407"></p><p>而对于较小的角度，使用 NLERP 进行插值，也就是先进行线性插值，对插值结果再做归一化：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703125034152.png" alt="image-20220703125034152"></p><p>NLERP 插值速度变换不均匀，但插值结果比较稳定，所以非常适合和 SLERP 搭配使用。</p><p>无论使用哪种插值方法，都需要使用两个四元数的点乘来判断插值方向，以此保证每次都是向最近的方向插值，因为角度是以 $2\pi$ 为周期的，所以存在插值方向的问题，如果不进行方向判断，就可能出现某个骨骼角度突变的情况。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703124922689.png" alt="image-20220703124922689"></p><h3 id="3-动画管线"><a href="#3-动画管线" class="headerlink" title="3 动画管线"></a>3 动画管线</h3><p>最后总结一下最简单的动画管线，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703125320376.png" alt="image-20220703125320376"></p><p>首先就是生成模型、骨骼和蒙皮，然后设计动作的 Clip，然后对 Clip 中的 Key Pose 之间进行插值得到每一帧的 pose，然后利用 pose 的动画矩阵计算顶点在世界空间的位置，之后就可以进行渲染，从而使模型动起来了。</p><p>上图中大部分计算都是在 CPU 中进行的，但实际上在现代引擎中这些计算几乎都由 GPU 完成。</p><p>对于美术人员或者动画设计师来说，建模工具已经提供了模型网格、骨骼结构和蒙皮生成工具，只要在自动生成的蒙皮上稍微修改一些权重就可以得到想要的动画效果，然后再设计骨骼动画生成 Clip，之后将这些数据导出为我们的引擎能够处理的文件，再进行上面的动画管线流程即可。</p><h3 id="4-动画压缩"><a href="#4-动画压缩" class="headerlink" title="4 动画压缩"></a>4 动画压缩</h3><p>动画压缩是为了减少 Clip 的数据存储，我们知道 Clip 包含一个动画的关键 pose 的所有 joint 的运动数据，这些运动数据又包含旋转、缩放、平移，对于一个模型来说，正常情况下有几十个到几百个 joint，而一个动画的 Clip 通常又包含几十帧关键 pose，整个游戏资源中的游戏对象又有成百上千个，于是光是动画数据可能就要达到数十 G，如果不进行压缩，存储空间的问题先不说，光是不停的读取这些资源就要消耗大量带宽从而影响游戏性能。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703125937121.png" alt="image-20220703125937121"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703130039721.png" alt="image-20220703130039721"></p><p>但是通过观察，人们发现，实际上大量的动画 pose 中，许多数据是几乎不变的，比如人走路的动画，所有关节的位置和尺寸完全不会发生改变，只有关节的朝向在变，也就是人走路的过程中，所有关节只进行了旋转变换：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703130212666.png" alt="image-20220703130212666"></p><p>如果还把每个关键 pose 的所有数据存下来，那很多数据都是重复的，于是对于大多数动画，可以舍弃位移和缩放的数据，除非有面部的骨骼变化，然后对于旋转可以对关键 pose 进行压缩，也就是合并一些可以通过插值得到的关键 pose，只要插值结果和关键 pose 结果的误差在一定范围内，我们就不需要这个关键 pose 了，这样一来可以减少很多数据的存储。</p><p>此外，对于旋转的角度随时间的变化曲线，还可以通过 Catmull-Rom 样条等曲线进行拟合，这样只需要通过极少的控制点，就可以得到误差在可接受范围内的旋转角度曲线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703130759588.png" alt="image-20220703130759588"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703130812422.png" alt="image-20220703130812422"></p><p>对于四元数的存储，通常是四个浮点数，四个浮点数就需要 4 * 32 个 bit 来存储，但通过观察，人们发现如果不考虑四元数最大的一个分量，其他三个分量的范围都在 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703131014403.png" alt="image-20220703131014403"></p><p>并且因为表示旋转的都是单位四元数，因此当我们知道三个分量的时候就可以利用模为 1 来求得第四个分量。</p><p>这样一来我们可以用 2 bit 来表示最大的维度是哪个，然后只存储其他三个维度，并且因为其他三个维度的范围我们是知道的，我们可以利用定点数的方式存储他们，将 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内的小数均匀的分成若干个，映射到整数范围内，比如用 15 位来存储 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内的小数，那么 0 就对应 $-\frac{1}{\sqrt 2}$，32767 就对应 $\frac{1}{\sqrt 2}$，数据精度就是 $\sqrt2 / 32767 = 0.000043$。</p><p>于是需要用 128 bit 来存储的四元数，经过压缩就只需要 2 + 3 * 15 = 47 bit，为了内存对齐，最终使用 48 bit 存储：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703131709781.png" alt="image-20220703131709781"></p><p>当然这样存储会产生一定误差，在运动不断传递的过程中就会产生越来越大的累计误差：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703131842087.png" alt="image-20220703131842087"></p><p>因此还需要进行误差的修正，这就相对来说比较的复杂了，这里不再讨论，不过一般矫正误差不会从运动参数方面进行矫正，而是从视觉误差方面校正，只要视觉上看起来动画是合理的，即便运动参数有误差，也不需要做额外的矫正操作。</p><h3 id="5-动画融合"><a href="#5-动画融合" class="headerlink" title="5 动画融合"></a>5 动画融合</h3><p>动画融合是指在不同动画的 Clip 之间进行插值融合，而之前我们讨论的都是在 Clip 内部的关键 pose 之间的插值。不同动画之间的融合就涉及到更多复杂的问题，比如两个动画需要在时间和骨骼位置上有对应关系，这样融合起来的过渡动画才更加自然，而且对于角色在三维空间的运动，通常会有前后左右各个方向的运动，需要融合的动画可能不是两个动画，而是更多的动画，这时就需要构造融合空间，当角色在空间中移动的时候，选用离的最近的三个动画进行插值融合：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151402089.png" alt="image-20220703151402089"></p><p>除了全身动画融合之外，有时还需要将动画只应用到上半身或者下半身，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151517898.png" alt="image-20220703151517898"></p><p>这时可以对骨骼动画进行一个 Mask 操作：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151503298.png" alt="image-20220703151503298"></p><p>还有的情况需要让同一个动画在不同的朝向执行，比如朝不同方向点头：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151624831.png" alt="image-20220703151624831"></p><p>这时可以只存储骨骼的相对运动，再进行融合。</p><h3 id="6-动画状态机和动画树"><a href="#6-动画状态机和动画树" class="headerlink" title="6 动画状态机和动画树"></a>6 动画状态机和动画树</h3><p>在游戏过程中设计许多动画的切换，即便是一个动画，也需要分为很多部分进行循环切换，比如一个跳跃的动作，分为起跳，空中循环和落地三个动作，这三个动作需要在不同的时间进行切换，这样的切换可以用状态机来描述：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151854905.png" alt="image-20220703151854905"></p><p>而目前游戏引擎中使用最多的动画切换和融合模型是动画树，动画树类似于运算树：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703151951269.png" alt="image-20220703151951269"></p><p>动画树将各个动画 pose 视为节点，在融合节点进行融合，融合的条件和权重可以依据游戏进行的过程进行调节，比如角色当前的状态，游戏中发生的事件等等：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703152052410.png" alt="image-20220703152052410"></p><p>动画状态机和动画树还可以结合起来表达更加复杂的动画切换。</p><h3 id="7-反向动力学"><a href="#7-反向动力学" class="headerlink" title="7 反向动力学"></a>7 反向动力学</h3><p>反向动力学（Inverse Kinematics, IK）是指，有时候角色动画还依赖于和场景的互动，比如攀岩的时候我们的某只手或者脚要固定在山体上，走路的时候一只脚要固定在地面上，这时我们就要求解在某个 joint 固定的情况下，要达到某个目标点，其他 joint 要如何变化，这就是反向动力学。</p><p>IK 是动画中比较难的部分，首先要判断能否到达目标点，一般可以用骨骼拉直判断到目标点的距离或者将其他骨骼折叠起来和最长的骨骼对比长度等方法：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703152516324.png" alt="image-20220703152516324"></p><p>当能够到达目标点的时候，就需要求解各个 joint 的变化，比较常用的算法有 CCD (Cyclic Coordinate Decent)、FABRIK (Forward And Backward Reaching Inverse Kinematics) 和雅可比矩阵（Jacobian Matrix）等，基本都是靠多次迭代不断逼近目标点，同时调整路径上的各个 joint，具体的算法比较复杂，这里不再展开了。</p><p>此外计算 IK 的时候还得考虑整个身体的平衡，要符合物理事实，因此 IK 是一个非常困难的领域。也因为有动画融合和 IK 的存在，整个动画管线就变得更加复杂：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703152759121.png" alt="image-20220703152759121"></p><p>还需要考虑不同动画的融合以及动画和世界场景的交互。</p><h3 id="8-动画重定向"><a href="#8-动画重定向" class="headerlink" title="8 动画重定向"></a>8 动画重定向</h3><p>动画重定向是为了将一个模型的骨骼动画应用到另一个模型上：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703152943879.png" alt="image-20220703152943879"></p><p>这只中还要考虑模型骨骼关系、骨骼数量的差异甚至模型骨骼结构的差异：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703153118965.png" alt="image-20220703153118965"></p><p>因为体型不同，还要考虑身体自身的碰撞，比如通过样的走路动画，一个较小的角色动画应用到体型比较大的角色身上就会穿模，鼓掌的时候可能原本首长可以碰到，但换到另一个模型上就碰不到了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220703153301117.png" alt="image-20220703153301117"></p><p>所以如何能够将一个动画应用到体型不同的其他角色上还不出现错误也是一个比较复杂的工作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎中的动画系统是最重要的系统之一，直接决定了角色动作是否自然，酷炫的动画也是一个游戏最能吸引人的地方，这一节来简单了解游戏引擎中的动画系统，蒙皮动画的数学原理以及动画压缩技术。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【知识汇总】图形学和API相关</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/07/02/20220702-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E9%83%A8%E5%88%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/07/02/20220702-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E9%83%A8%E5%88%86/</id>
    <published>2022-07-02T03:42:18.000Z</published>
    <updated>2022-07-16T02:20:53.365Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结图形学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p><p><em><span id="more"></span></em></p><h4 id="GPU-渲染管线"><a href="#GPU-渲染管线" class="headerlink" title="GPU 渲染管线"></a>GPU 渲染管线</h4><p>可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-图形渲染管线/">【Real-Time Rendering】图形渲染管线</a> 和 <a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU管线/">【Real-Time Rendering】GPU 管线</a></p><p>图形渲染管线是抽象的图像渲染流程，GPU 渲染管线是现代 GPU 对该流程的具体实现。</p><h4 id="图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵"><a href="#图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵" class="headerlink" title="图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵"></a>图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵</h4><p>包括模型空间、世界空间、观察空间、裁剪空间、NDC和屏幕空间</p><p>M 变换从模型空间到世界空间</p><p>V 变换从世界空间到观察空间</p><p>P 变换从观察空间到裁剪空间</p><p>透视除法从裁剪空间到 NDC</p><p>视口变换从 NDC 到屏幕空间</p><p>各种矩阵的推导查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-渲染器-变换与深度测试/">【光栅化渲染器】（三）变换与深度测试</a></p><h4 id="变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化"><a href="#变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化" class="headerlink" title="变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化"></a>变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化</h4><p>模型空间和世界空间是什么坐标系不重要，描述的都是一样的世界，但观察空间就取决于我们的定义了，OpenGL 中模型、世界、相机坐标系使用的都是右手系，即沿 -Z 轴方向观察，经过投影之后变换到裁剪空间是左手系，因为在观察空间中，沿 -Z 方向观察，距离我们近的物体 Z 坐标更大，距离我们远的物体 Z 坐标更小，经过投影矩阵的变换，所有物体的 Z 坐标被变换到 -w 到 w 之间，其中较大的  Z 值 被映射到 -w，较小的 Z 值被映射到 w，也就是距离我们近的物体 Z 会更小，距离我们远的物体 Z 会更大，这正是左手坐标系的 Z 轴走向。</p><h4 id="正交投影和透视投影有什么区别"><a href="#正交投影和透视投影有什么区别" class="headerlink" title="正交投影和透视投影有什么区别"></a>正交投影和透视投影有什么区别</h4><p>正交投影的视锥体是一个立方体，进行的是平行投影，相当于只做了平移和缩放，透视投影的视锥体是一个四棱台，近大远小，本质上相当于利用 Z 坐标对其他坐标进行了缩放。</p><h4 id="NDC-是什么"><a href="#NDC-是什么" class="headerlink" title="NDC 是什么"></a>NDC 是什么</h4><p>归一化设备坐标系，x 和 y 都是 -1 到 1 之间，Z 在 -1 到 1 （OpenGL）或 0 到 1 之间（DirectX），方便通过视口变换得到屏幕坐标。</p><h4 id="视口变换的作用是什么，空间的维度是如何变化的"><a href="#视口变换的作用是什么，空间的维度是如何变化的" class="headerlink" title="视口变换的作用是什么，空间的维度是如何变化的"></a>视口变换的作用是什么，空间的维度是如何变化的</h4><p>视口变换将 NDC 坐标变换到屏幕空间上，也叫屏幕映射，虽然屏幕坐标可以认为是二维的，但是依然保留了每个片段的深度。</p><h4 id="顶点着色器的作用"><a href="#顶点着色器的作用" class="headerlink" title="顶点着色器的作用"></a>顶点着色器的作用</h4><p>顶点着色器用于进行顶点处理，必须完成的就是将顶点坐标变换到裁剪空间，也可以做顶点的着色、移动等处理。</p><h4 id="片元和像素的区别"><a href="#片元和像素的区别" class="headerlink" title="片元和像素的区别"></a>片元和像素的区别</h4><p>片元是像素的候选</p><h4 id="逐顶点光照和逐片元光照"><a href="#逐顶点光照和逐片元光照" class="headerlink" title="逐顶点光照和逐片元光照"></a>逐顶点光照和逐片元光照</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-着色/">【计算机图形学】（六）着色</a></p><h4 id="光栅化的作用"><a href="#光栅化的作用" class="headerlink" title="光栅化的作用"></a>光栅化的作用</h4><p>生成片元。找到三角形覆盖哪些像素，生成对应的片元。</p><h4 id="常用的光栅化算法"><a href="#常用的光栅化算法" class="headerlink" title="常用的光栅化算法"></a>常用的光栅化算法</h4><p>扫描线和边界函数算法，具体查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-渲染器-框架搭建/">【光栅化渲染器】（二）框架搭建</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-渲染器-改进光栅化/">【光栅化渲染器】（九）改进光栅化</a></p><h4 id="Phong-和-Blinn-Phong-的区别，为什么这么改进"><a href="#Phong-和-Blinn-Phong-的区别，为什么这么改进" class="headerlink" title="Phong 和 Blinn Phong 的区别，为什么这么改进"></a>Phong 和 Blinn Phong 的区别，为什么这么改进</h4><p>区别在于高光项的计算，改进的原因一方面在于计算量，另一方面因为视线方向可能和反射方向夹角大于 90 度，从而导致高光截断或者过渡不自然，而正常情况下半程向量和法线夹角不可能大于 90 度，从而使得高光过度更加自然。</p><h4 id="走样产生的原因，如何解决"><a href="#走样产生的原因，如何解决" class="headerlink" title="走样产生的原因，如何解决"></a>走样产生的原因，如何解决</h4><p>光栅化的走样和纹理走样</p><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-反走样/">【计算机图形学】（四）反走样</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-纹理映射/">【计算机图形学】（七）纹理映射</a></p><h4 id="MipMap-的作用、原理、如何确定使用哪一层"><a href="#MipMap-的作用、原理、如何确定使用哪一层" class="headerlink" title="MipMap 的作用、原理、如何确定使用哪一层"></a>MipMap 的作用、原理、如何确定使用哪一层</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-纹理映射/">【计算机图形学】（七）纹理映射</a></p><p>一般使用 ddx 和 ddy 确定使用的层级，ddx 和 ddy 可以快速求出像素某一属性的变化率，因为 GPU 在执行片段着色的时候不是逐像素进行的，是以 2 <em> 2 的块为单位执行的，每个 wrap 被分为 8 </em> 4 个线程组，每个像素快就被分配到一个包含 4 个线程的线程组执行，所以可以快速得到相邻像素某属性的变化率，通过计算相邻像素纹理坐标的差值可以得出：</p><ul><li>相邻像素纹理坐标差值越大，说明纹理在屏幕上对应的空间越小，因此就使用越大的 mipmap 层级</li><li>相邻像素纹理坐标差值越小，说明纹理在屏幕上对应的空间越大，因此就使用更小的 mipmap 层级</li></ul><p>更多细节可以查看<a href="https://zhuanlan.zhihu.com/p/70269212">在shader中计算贴图mipmap级别</a>中的公式和代码</p><h4 id="法线贴图的种类，优缺点"><a href="#法线贴图的种类，优缺点" class="headerlink" title="法线贴图的种类，优缺点"></a>法线贴图的种类，优缺点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-纹理总结/">【Real-Time Rendering】纹理总结</a>第七部分</p><h4 id="伽马校正是什么，为什么需要"><a href="#伽马校正是什么，为什么需要" class="headerlink" title="伽马校正是什么，为什么需要"></a>伽马校正是什么，为什么需要</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-漫反射材质/">【RayTracer】（四）漫反射材质</a>第三部分</p><h4 id="HDR-和色调映射，常用的映射算法"><a href="#HDR-和色调映射，常用的映射算法" class="headerlink" title="HDR 和色调映射，常用的映射算法"></a>HDR 和色调映射，常用的映射算法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-基于图像的渲染技术总结/">【Real-Time Rendering】基于图像的渲染技术总结</a>第 10 部分</p><h4 id="Shadow-Map-的实现、缺点、有哪些改进"><a href="#Shadow-Map-的实现、缺点、有哪些改进" class="headerlink" title="Shadow Map 的实现、缺点、有哪些改进"></a>Shadow Map 的实现、缺点、有哪些改进</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-实时阴影/">【高质量实时渲染】实时阴影</a></p><h4 id="PCF-和-PCSS"><a href="#PCF-和-PCSS" class="headerlink" title="PCF 和 PCSS"></a>PCF 和 PCSS</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-实时阴影/">【高质量实时渲染】实时阴影</a></p><h4 id="常用的抗锯齿方法"><a href="#常用的抗锯齿方法" class="headerlink" title="常用的抗锯齿方法"></a>常用的抗锯齿方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-图形渲染和视觉外观/">【Real-Time Rendering】图形渲染和视觉处理</a>第三部分和<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-反走样/">【计算机图形学】（四）反走样</a></p><h4 id="什么是模板测试"><a href="#什么是模板测试" class="headerlink" title="什么是模板测试"></a>什么是模板测试</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-模板测试和深度测试/">【Real-Time Rendering】模板测试和深度测试</a></p><h4 id="透明度混合和透明度测试"><a href="#透明度混合和透明度测试" class="headerlink" title="透明度混合和透明度测试"></a>透明度混合和透明度测试</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-透明效果/">【Unity Shader】（三）透明效果</a></p><h4 id="各种物体的的渲染顺序"><a href="#各种物体的的渲染顺序" class="headerlink" title="各种物体的的渲染顺序"></a>各种物体的的渲染顺序</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-透明效果/">【Unity Shader】（三）透明效果</a></p><h4 id="顺序无关的透明渲染算法"><a href="#顺序无关的透明渲染算法" class="headerlink" title="顺序无关的透明渲染算法"></a>顺序无关的透明渲染算法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-图形渲染和视觉外观/">【Real-Time Rendering】图形渲染和视觉处理</a>第 4 部分</p><h4 id="compute-shader-是干嘛的"><a href="#compute-shader-是干嘛的" class="headerlink" title="compute shader 是干嘛的"></a>compute shader 是干嘛的</h4><p>在图形管线之外的，但可以将计算数据传入管线或回传给自己，实现利用 GPU 进行通用计算任务</p><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>经典渲染方程和实时渲染中的渲染方程（带 visibility 项）</p><h4 id="BRDF-简介"><a href="#BRDF-简介" class="headerlink" title="BRDF 简介"></a>BRDF 简介</h4><p>描述入射光和出射光关系的函数，分为经验模型、物理模型和测量模型，各类常用的模型举例，以及各向同性各向异性</p><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF总结/">【Real-Time Rendering】BRDF 总结</a></p><h4 id="菲涅尔项-F0-的意义"><a href="#菲涅尔项-F0-的意义" class="headerlink" title="菲涅尔项 F0 的意义"></a>菲涅尔项 F0 的意义</h4><p>F0 是基础反射率，与介质的折射率有关，可以代表物体本身的颜色，从 SG 模型的 Specular 纹理中得到或者从 MR 模型的 base color 纹理中采样再经过 metalic 插值得到</p><h4 id="PBR-的原理"><a href="#PBR-的原理" class="headerlink" title="PBR 的原理"></a>PBR 的原理</h4><p>基于物理的渲染，关键在于能量守恒，菲涅尔项和 BRDF 的计算（cook-torrance 模型）</p><h4 id="PBR-的计算需要哪些量"><a href="#PBR-的计算需要哪些量" class="headerlink" title="PBR 的计算需要哪些量"></a>PBR 的计算需要哪些量</h4><p>基础反射率 F0，粗糙程度，光线和法线夹角，观察方向和法线夹角</p><h4 id="光线追踪和路径追踪"><a href="#光线追踪和路径追踪" class="headerlink" title="光线追踪和路径追踪"></a>光线追踪和路径追踪</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted风格光线追踪/">【计算机图形学】（十一）Whitted 风格光线追踪</a>、<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-路径追踪/">【计算机图形学】（十三）路径追踪</a>、<a href="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-实时光线追踪/">【高质量实时渲染】实时光线追踪</a></p><h4 id="蒙特卡洛积分方法"><a href="#蒙特卡洛积分方法" class="headerlink" title="蒙特卡洛积分方法"></a>蒙特卡洛积分方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-重要性采样/">【RayTracer】（十八）重要性采样</a></p><h4 id="延迟渲染的原理，对比正向渲染，延迟渲染的改进"><a href="#延迟渲染的原理，对比正向渲染，延迟渲染的改进" class="headerlink" title="延迟渲染的原理，对比正向渲染，延迟渲染的改进"></a>延迟渲染的原理，对比正向渲染，延迟渲染的改进</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-延迟渲染总结/">【Real-Time Rendering】延迟渲染总结</a></p><h4 id="延迟渲染和-MSAA"><a href="#延迟渲染和-MSAA" class="headerlink" title="延迟渲染和 MSAA"></a>延迟渲染和 MSAA</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-延迟渲染总结/">【Real-Time Rendering】延迟渲染总结</a></p><h4 id="一些提高渲染效率的方法"><a href="#一些提高渲染效率的方法" class="headerlink" title="一些提高渲染效率的方法"></a>一些提高渲染效率的方法</h4><p>固定视角渲染只渲染一次固定物体，剔除被 UI 遮挡的物体</p><p>双缓冲或者三重缓冲保持帧率稳定</p><p>其他查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-渲染加速技术总结/">【Real-Time Rendering】渲染加速技术总结</a></p><h4 id="如何优化-shader-代码"><a href="#如何优化-shader-代码" class="headerlink" title="如何优化 shader 代码"></a>如何优化 shader 代码</h4><p>尽量避免分支语句、条件判断和循环，尽量减少纹理采样次数，减少复杂数学函数调用，少在片段着色器做矩阵运算，降低浮点数精度等</p><p>具体查看<a href="https://zhuanlan.zhihu.com/p/210221918">Shader中的代码优化原理分析</a></p><h4 id="GLFW-的作用"><a href="#GLFW-的作用" class="headerlink" title="GLFW 的作用"></a>GLFW 的作用</h4><p>用于创建窗口，创建 OpenGL 上下文、接收一些鼠标键盘事件的第三方库</p><p>所谓上下文是指保存了一系列的变量用来描述 OpenGL 此刻需要如何运行的信息，因为 OpenGL 本身就是一个非常庞大的状态机(State Machine) ，其状态通常被称为 OpenGL 上下文(Context)，应用程序中可以创建多个不同的上下文，他们分别在各自的线程中使用。上下文之间共享纹理，缓冲区等资源，采用这中方案更为高效，因为它避免了反复切换上下文，或者大量修改渲染状态所造成的较大的开销。</p><h4 id="GLAD-和-GLEW"><a href="#GLAD-和-GLEW" class="headerlink" title="GLAD 和 GLEW"></a>GLAD 和 GLEW</h4><p>对底层 OpenGL 接口的封装，可以让代码跨平台</p><h4 id="DirectX-和-OpenGL"><a href="#DirectX-和-OpenGL" class="headerlink" title="DirectX 和 OpenGL"></a>DirectX 和 OpenGL</h4><p>查看<a href="https://cloud.tencent.com/developer/article/1532783">微软DirectX和OpenGL的区别（比较详细）</a></p><p>总结来说 OpenGL 只提供核心的渲染功能，至于窗口显示，设备输入处理等都需要第三方库，但 OpenGL 有良好的跨平台特性</p><p>DirectX 并不是一个单纯的图形API，它是由微软公司开发的用途广泛的API，它可让以 windows 为平台的游戏或多媒体程序获得更高的执行效率，加强 3d 图形和声音效果。</p><h4 id="后处理方法"><a href="#后处理方法" class="headerlink" title="后处理方法"></a>后处理方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-基础屏幕特效/">【Unity Shader】（七）基础屏幕特效</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-高级屏幕特效/">【Unity Shader】（八）高级屏幕特效</a></p><h4 id="NPR-基本原理、描边算法"><a href="#NPR-基本原理、描边算法" class="headerlink" title="NPR 基本原理、描边算法"></a>NPR 基本原理、描边算法</h4><p><a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-非真实感渲染/">【Unity Shader】（九）非真实感渲染</a></p><h4 id="利用深度和屏幕坐标算世界坐标"><a href="#利用深度和屏幕坐标算世界坐标" class="headerlink" title="利用深度和屏幕坐标算世界坐标"></a>利用深度和屏幕坐标算世界坐标</h4><p>利用屏幕坐标得到 NDC 坐标，或者将纹理坐标映射到 NDC 坐标 -1 到 1 范围内，再乘以投影矩阵的逆矩阵得到投影前的坐标，记得除以 w 值进行坐标归一化，然后再乘以 V 矩阵的逆矩阵得到世界空间坐标</p><p>具体查看<a href="https://blog.csdn.net/ag_cill/article/details/61428172">Unity根据深度值计算世界坐标</a></p><h4 id="深度精度问题和-reversed-Z"><a href="#深度精度问题和-reversed-Z" class="headerlink" title="深度精度问题和 reversed-Z"></a>深度精度问题和 reversed-Z</h4><p>查看<a href="https://www.cnblogs.com/jackmaxwell/p/6851728.html">Reversed-Z详解</a>和<a href="https://juejin.cn/post/6844904053193834503">Depth精度问题分析</a></p><h4 id="延迟渲染具体实现"><a href="#延迟渲染具体实现" class="headerlink" title="延迟渲染具体实现"></a>延迟渲染具体实现</h4><p>查看<a href="https://blog.csdn.net/lengyoumo/article/details/104489830"> unity shader 实现延迟渲染代码加注释</a></p><h4 id="延迟渲染实现-AO"><a href="#延迟渲染实现-AO" class="headerlink" title="延迟渲染实现 AO"></a>延迟渲染实现 AO</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/86443667">SSAO 屏幕空间环境光遮蔽（与延迟渲染的pass结合）</a></p><p>简单来说就是利用 G-Buffer 中的信息生成一张 AO 贴图，之后在渲染 Pass 中利用这张帖图乘到光照结果上即可</p><h4 id="延迟渲染透明物体"><a href="#延迟渲染透明物体" class="headerlink" title="延迟渲染透明物体"></a>延迟渲染透明物体</h4><p>查看<a href="https://blog.csdn.net/zju_fish1996/article/details/102333692"> OpenGL延迟渲染下的简单透明渲染机制</a></p><h4 id="Unity-有哪些管线"><a href="#Unity-有哪些管线" class="headerlink" title="Unity 有哪些管线"></a>Unity 有哪些管线</h4><p>Unity 提供以下渲染管线：</p><ul><li><a href="https://docs.unity.cn/cn/2019.4/Manual/built-in-render-pipeline.html">内置渲染管线</a>是 Unity 的默认渲染管线。这是通用的渲染管线，其自定义选项有限。</li><li><a href="https://docs.unity.cn/cn/2019.4/Manual/universal-render-pipeline.html">通用渲染管线 (URP)</a> 是一种可快速轻松自定义的可编程渲染管线，允许您在各种平台上创建优化的图形。</li><li><a href="https://docs.unity.cn/cn/2019.4/Manual/high-definition-render-pipeline.html">高清渲染管线 (HDRP)</a> 是一种可编程渲染管线，可让您在高端平台上创建出色的高保真图形。</li><li>可以使用 Unity 的可编程渲染管线 API 来创建自定义的<a href="https://docs.unity.cn/cn/2019.4/Manual/ScriptableRenderPipeline.html">可编程渲染管线 (SRP)</a>。这个过程可以从头开始，也可以修改 URP 或 HDRP 来适应具体需求。</li></ul><h4 id="OpenGL-的渲染管线"><a href="#OpenGL-的渲染管线" class="headerlink" title="OpenGL 的渲染管线"></a>OpenGL 的渲染管线</h4><p>和正常管线基本一致，具体查看<a href="https://www.cnblogs.com/yyxt/p/4056417.html">OpenGL渲染管线</a></p><h4 id="帧缓冲有哪些，什么是离屏渲染"><a href="#帧缓冲有哪些，什么是离屏渲染" class="headerlink" title="帧缓冲有哪些，什么是离屏渲染"></a>帧缓冲有哪些，什么是离屏渲染</h4><p>帧缓冲包含颜色缓冲、深度缓冲和模板缓冲，离屏渲染就是将渲染结果存到自定义的帧缓冲中进行一些后处理，再将该缓冲中的内容发送到默认缓冲显示到屏幕上。 </p><p>具体查看<a href="https://zhuanlan.zhihu.com/p/373993587">帧缓冲详解</a></p><h4 id="BVH-划分维度造成的问题"><a href="#BVH-划分维度造成的问题" class="headerlink" title="BVH 划分维度造成的问题"></a>BVH 划分维度造成的问题</h4><p>对于走廊一样的场景，如果不沿着最长的维度分割，就会造成物体在某一个维度上被分开了，集中在一定范围内，但是其他维度上这些物体分布非常分散，导致最终的 AABB 会很大，每个节点的 AABB 都覆盖了很大的范围，并且各个 BVH 节点之间的 AABB 就会有很大的重合，导致 BVH 的加速效果不好。</p><h4 id="纹理坐标到纹理的映射公式"><a href="#纹理坐标到纹理的映射公式" class="headerlink" title="纹理坐标到纹理的映射公式"></a>纹理坐标到纹理的映射公式</h4><p>直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纹理采样，使用重复寻址方式,等同于OpenGL的GL_REPEAT</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">Sample2D</span><span class="params">(<span class="type">const</span> glm::vec2&amp; texcoord)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> x = texcoord.x - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.x);</span><br><span class="line">    <span class="type">float</span> y = texcoord.y - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.y);</span><br><span class="line">    x = x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">    y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetColor</span>(x * (width - <span class="number">1</span>), y * (height - <span class="number">1</span>)) / <span class="number">255.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例化渲染和批处理"><a href="#实例化渲染和批处理" class="headerlink" title="实例化渲染和批处理"></a>实例化渲染和批处理</h4><p>参考：</p><ul><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/04 Advanced OpenGL/10 Instancing/">实例化 - LearnOpenGL-CN</a></li><li><a href="https://blog.csdn.net/chenweiyu11962/article/details/121340711">合批/批量渲染 （Batch）、实例化Instancing</a></li><li><a href="https://www.jianshu.com/p/4bf2e680dd35">OpenGL学习24——实例化渲染</a></li><li><a href="https://blog.csdn.net/Victor_Li_/article/details/122662110">U3D性能优化之实例化渲染(GPU Instancing)</a></li></ul><h4 id="Vulkan-中-Pass-和-SubPass-的关系"><a href="#Vulkan-中-Pass-和-SubPass-的关系" class="headerlink" title="Vulkan 中 Pass 和 SubPass 的关系"></a>Vulkan 中 Pass 和 SubPass 的关系</h4><p><a href="https://zhuanlan.zhihu.com/p/539718382">Vulkan学习笔记(四）厘清Pipeline和RenderPass的关系 - 知乎 (zhihu.com)</a></p><h4 id="从-cache-角度讲-Mipmap-为什么比直接采样纹理效率高"><a href="#从-cache-角度讲-Mipmap-为什么比直接采样纹理效率高" class="headerlink" title="从 cache 角度讲 Mipmap 为什么比直接采样纹理效率高"></a>从 cache 角度讲 Mipmap 为什么比直接采样纹理效率高</h4><p>首先影响采样效率的主要原因并不是在于纹理采样有多耗时，纹理采样主要是通过 TMU 模块进行执行的，TMU 模块是一种有限的硬件资源， 因此你采样更多（不一样的）纹理，就需要消耗更多的周期。这是因为当采样纹理的时候要加载纹理数据，TMU 会首先向 Texture Cache 中去加载，如果 Cache Miss 就会从 L2 加载到 Textuer Cache，如果 L2 也 Cache Miss，就会从 DRAM(显存) 中加载纹理，然后依次填充 L2 和 Texture Cache。</p><p>而我们知道从Thread 读到 Texture Cache 只需要几十个周期，而从 L2 向 DRAM 加载则需要几百个周期。在这些周期内，需要采样纹理的 Warp Scheduler 都需要被换出(swap out)。</p><p>更多可以查看<a href="https://zhuanlan.zhihu.com/p/385585791">更新一些GPU相关知识 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结图形学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【知识汇总】数学相关</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/28/20220628-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-3D%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/28/20220628-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-3D%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/</id>
    <published>2022-06-28T04:51:19.000Z</published>
    <updated>2022-07-01T07:15:20.569Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结图形学中常用的数学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p><p><em><span id="more"></span></em></p><h4 id="给定点集如何求凸包"><a href="#给定点集如何求凸包" class="headerlink" title="给定点集如何求凸包"></a>给定点集如何求凸包</h4><p>求凸包算法可以查看<a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552"> 凸包（Convex Hull）问题算法详解</a>，其中比较重要的是分治法、步进法和扫描法：</p><ul><li>分治法首先找到一定在凸包上的两个点，然后连线将凸包分为上包和下包，在上包和下包中分别找到距离直线最远的点，连线继续划分，直到找到全部凸包上的点</li><li>步进法从一个凸包上的点出发，逆时针寻找其他凸包上的点，每次找到一个点，再从该点出发继续寻找，寻找时是通过连线夹角判断是否为凸包上的点的</li><li>Graham 扫描法先找到一个凸包上的点，然后以该点为原点对其他点做平移，然后根据各点相对于原点的辐角和距离排序，然后扫描该序列中的点，利用类似单调栈的思路维护凸包点，直到扫描完全部点</li></ul><h4 id="向量点乘和叉乘的几何意义"><a href="#向量点乘和叉乘的几何意义" class="headerlink" title="向量点乘和叉乘的几何意义"></a>向量点乘和叉乘的几何意义</h4><p>点乘代表一个向量在另一个向量方向上的投影，同时也可以快速求得两向量的夹角，进而判断向量是否同向等等；</p><p>叉乘得到的自然是平面法向量，此外叉乘向量的模是两向量构成的平行四边形的面积。</p><h4 id="判断点在三角形内的方法"><a href="#判断点在三角形内的方法" class="headerlink" title="判断点在三角形内的方法"></a>判断点在三角形内的方法</h4><p>向量叉乘，判断 z 坐标是否同向</p><p>代数几何判断点和直线的位置，本质上和向量叉乘一样</p><p>重心坐标，其实就是求面积，三个小三角形面积和为大三角形面积说明点在内部，其实就是重心坐标非负</p><h4 id="判断点在矩形内部的方法"><a href="#判断点在矩形内部的方法" class="headerlink" title="判断点在矩形内部的方法"></a>判断点在矩形内部的方法</h4><p>同样是叉乘，判断点在四条边的内部即可</p><p>面积法也可以，可以看作是重心坐标的推广</p><h4 id="如何判断凸多边形"><a href="#如何判断凸多边形" class="headerlink" title="如何判断凸多边形"></a>如何判断凸多边形</h4><p>逆时针遍历每三个点，判断点在前两个点连线的哪一侧，都在左侧就是凸多边形，都在右侧就是凹多边形</p><p>向量叉乘，每三个点组成两个向量，依次叉乘，结果都为正方向为凸多边形</p><p>也可以对多边形求凸包，凸包点数和多边形顶点数一样就是凸多边形，少于多边形点数就是凹多边形，但是这种方法没必要</p><h4 id="叉乘求多边形面积"><a href="#叉乘求多边形面积" class="headerlink" title="叉乘求多边形面积"></a>叉乘求多边形面积</h4><p>叉乘求的是有向面积，只要逆时针每三个点求叉乘再累加起来就是多边形面积的二倍。</p><h4 id="空间两直线的距离"><a href="#空间两直线的距离" class="headerlink" title="空间两直线的距离"></a>空间两直线的距离</h4><p>可以查看<a href="https://blog.csdn.net/zhyh1435589631/article/details/52960121">求空间两条直线之间的距离</a>，主要分为两种情况：</p><ul><li>平行直线间的距离，相当于求点到直线的距离</li><li>异面不平行直线距离，求两条直线上任意两点间连线在两直线方向向量叉乘方向上的投影长度</li></ul><h4 id="点到三角形的最近距离"><a href="#点到三角形的最近距离" class="headerlink" title="点到三角形的最近距离"></a>点到三角形的最近距离</h4><p>求点和三角形任意一点连线在三角形平面法向上的投影长度即可，平面法向通过三角形三点叉乘可以得到</p><h4 id="给定法线和入射光线求反射光线"><a href="#给定法线和入射光线求反射光线" class="headerlink" title="给定法线和入射光线求反射光线"></a>给定法线和入射光线求反射光线</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-金属材质/">【RayTracer】（五）金属材质</a>中的 3.1 部分</p><h4 id="行列式为-0-有什么意义"><a href="#行列式为-0-有什么意义" class="headerlink" title="行列式为 0 有什么意义"></a>行列式为 0 有什么意义</h4><p>行列式的几何意义和叉乘一样，都代表面积（二维）或者体积（三维），为 0 意味着二维中中两向量重合或者三位重量平面重合，具体的行列式几何意义可以查看<a href="https://www.cnblogs.com/AndyJee/p/3491487.html">【线性代数的几何意义】行列式的几何意义</a></p><h4 id="齐次坐标的意义"><a href="#齐次坐标的意义" class="headerlink" title="齐次坐标的意义"></a>齐次坐标的意义</h4><p>为了让所有变换都表示成矩阵向量乘法的形式，引入了齐次坐标。</p><p>关于齐次坐标可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-变换/">【计算机图形学】（一）变换</a>的 1.3 部分</p><h4 id="光线和球体求交点及优化"><a href="#光线和球体求交点及优化" class="headerlink" title="光线和球体求交点及优化"></a>光线和球体求交点及优化</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-物体类/">【RayTracer】（二）实现物体类</a></p><h4 id="光线和三角形求交点"><a href="#光线和三角形求交点" class="headerlink" title="光线和三角形求交点"></a>光线和三角形求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted风格光线追踪/">【计算机图形学】（十一）Whitted 风格光线追踪</a>的 3.3 部分</p><h4 id="光线和-AABB-求交点"><a href="#光线和-AABB-求交点" class="headerlink" title="光线和 AABB 求交点"></a>光线和 AABB 求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted风格光线追踪/">【计算机图形学】（十一）Whitted 风格光线追踪</a>第 4 部分</p><h4 id="M-矩阵对模型的变换顺如何确定"><a href="#M-矩阵对模型的变换顺如何确定" class="headerlink" title="M 矩阵对模型的变换顺如何确定"></a>M 矩阵对模型的变换顺如何确定</h4><p>M 矩阵将模型坐标从模型空间变换到世界空间，一般涉及缩放、旋转、平移三种操作，操作顺序不同得到的变换结果也不同，一般要先缩放、后旋转最后平移，因为在物体刚刚放入世界坐标系的时候使用的是本地坐标，也就是本地和全局坐标系的原点和坐标轴都是重合的，此时所有物体都“把世界坐标系当做自己的本地坐标系”。而经过了坐标变换之后：</p><ul><li>缩放变换不改变坐标轴的走向，也不改变原点的位置，所以两个坐标系仍然重合。</li><li>旋转变换改变坐标轴的走向，但不改变原点的位置，所以两个坐标系坐标轴不再处于相同走向。</li><li>平移变换不改变坐标轴走向，但改变原点位置，两个坐标系原点不再重合。</li></ul><p>这样就可以解释问什么缩放不能在旋转之后，而缩放和旋转都不能在平移之后了。 于是符合直觉的的顺序只能是 缩放 -&gt; 旋转 -&gt; 平移 。</p><h4 id="法线矩阵是什么"><a href="#法线矩阵是什么" class="headerlink" title="法线矩阵是什么"></a>法线矩阵是什么</h4><p>法线变换矩阵是原变换矩阵的逆转置，具体可以查看<a href="https://blog.csdn.net/Qinhaifu/article/details/102476692">法线矩阵</a>以及笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-变换/">【计算机图形学】（一）变换</a></p><h4 id="为什么矩阵-4-维但向量只用-3-维就可以"><a href="#为什么矩阵-4-维但向量只用-3-维就可以" class="headerlink" title="为什么矩阵 4 维但向量只用 3 维就可以"></a>为什么矩阵 4 维但向量只用 3 维就可以</h4><p>向量的齐次坐标第 4 维为 0，矩阵 4 维是为了可以同时对向量和点进行变换，对于向量不存在平移变化，所以三维就够了</p><h4 id="特征值和特征向量的意义"><a href="#特征值和特征向量的意义" class="headerlink" title="特征值和特征向量的意义"></a>特征值和特征向量的意义</h4><p>查看<a href="https://blog.csdn.net/qq_32742009/article/details/82217051">矩阵的特征向量、特征值及其含义</a></p><h4 id="正交矩阵的特征"><a href="#正交矩阵的特征" class="headerlink" title="正交矩阵的特征"></a>正交矩阵的特征</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/120170892">正交矩阵学习小结</a></p><h4 id="旋转矩阵的特征值"><a href="#旋转矩阵的特征值" class="headerlink" title="旋转矩阵的特征值"></a>旋转矩阵的特征值</h4><p>三维旋转矩阵的特征值为 1 和与旋转角有关的一对共轭复数，具体可以查看<a href="https://blog.csdn.net/lewif/article/details/105110720">坐标变换(7)—旋转矩阵和特征向量</a></p><h4 id="欧拉角和万向锁"><a href="#欧拉角和万向锁" class="headerlink" title="欧拉角和万向锁"></a>欧拉角和万向锁</h4><p>欧拉角优势在于简单，但旋转顺序影响结果并且存在万向锁问题，四元数可以解决万向锁问题</p><h4 id="四元数的概念、作用和插值方法"><a href="#四元数的概念、作用和插值方法" class="headerlink" title="四元数的概念、作用和插值方法"></a>四元数的概念、作用和插值方法</h4><p>四元数的概念和理解查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-旋转与四元数/">【计算机图形学】（二）旋转与四元数</a></p><p>四元数的球面线性插值查看<a href="https://blog.csdn.net/weixin_42595073/article/details/100704061">四元数的插值方法</a></p><h4 id="最小二乘法的几何意义"><a href="#最小二乘法的几何意义" class="headerlink" title="最小二乘法的几何意义"></a>最小二乘法的几何意义</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqaure method）</a></p><h4 id="矩阵特征值分解和奇异值分解"><a href="#矩阵特征值分解和奇异值分解" class="headerlink" title="矩阵特征值分解和奇异值分解"></a>矩阵特征值分解和奇异值分解</h4><p>特征值分解只适用于方阵，奇异值分解适用于任意矩阵</p><p>查看<a href="https://zhuanlan.zhihu.com/p/480389473">【彻底搞懂】矩阵奇异值分解（SVD）</a>和<a href="https://zhuanlan.zhihu.com/p/122259109">强大的矩阵奇异值分解(SVD)</a></p><h4 id="多元函数全微分"><a href="#多元函数全微分" class="headerlink" title="多元函数全微分"></a>多元函数全微分</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/485956707">通俗理解多元函数的全微分</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结图形学中常用的数学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="3D数学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【知识汇总】C++相关</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/</id>
    <published>2022-06-25T09:01:46.000Z</published>
    <updated>2022-07-10T06:24:09.118Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结 C++ 相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p><p><em><span id="more"></span></em></p><h1 id="1-多态"><a href="#1-多态" class="headerlink" title="1 多态"></a>1 多态</h1><h4 id="多态的定义、种类、如何实现"><a href="#多态的定义、种类、如何实现" class="headerlink" title="多态的定义、种类、如何实现"></a>多态的定义、种类、如何实现</h4><p>多态简单概括就是“一种接口，多种方法”，是面向对象编程的核心，主要指不同的对象收到相同的消息做出不同的动作。C++ 通过指针或引用实现多态，具体查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-对象模型-关于对象/">【C++ 对象模型】（一）关于对象</a>。</p><h4 id="虚函数如何实现多态"><a href="#虚函数如何实现多态" class="headerlink" title="虚函数如何实现多态"></a>虚函数如何实现多态</h4><p>基类指针指向派生类对象，可以调用不同派生类的方法，这是通过虚函数来实现的。每一个类都有一张虚函数表，类的对象中包含指向虚函数表的指针，派生类对象中包含基类子对象并且在内存布局的最前面，而虚函数表指针又位于实例对象内存的最前面，因此使用基类指针可以指向任何派生类对象并且正确寻址到虚函数表，这样通过一个基类指针就可以在运行时找到不同派生类的虚函数表从而调用对应的函数，实现多态。</p><h4 id="虚表指针什么时候产生"><a href="#虚表指针什么时候产生" class="headerlink" title="虚表指针什么时候产生"></a>虚表指针什么时候产生</h4><p>首先每一个类的虚函数表在编译期间确定，虚函数表指针在虚函数表确定后，对象被构造出来的时候就可以确定了，实际上编译器会在构造函数时中加入对虚函数表指针的赋值操作，并且这些操作会在用户自己定义的初始化操作之前执行。同样的，虚基类指针也在编译期确定。</p><h4 id="关于纯虚函数"><a href="#关于纯虚函数" class="headerlink" title="关于纯虚函数"></a>关于纯虚函数</h4><p>纯虚函数没有定义，必须在派生类中实现，在虚函数表中会存在一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序。</p><h4 id="重载、重写与覆盖"><a href="#重载、重写与覆盖" class="headerlink" title="重载、重写与覆盖"></a>重载、重写与覆盖</h4><p>重载允许有多个同名的函数，而这些函数可以参数列表不同，返回类型不同，参数个数不同，参数类型不同等等。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。在派生类中重写了基类中的函数会覆盖基类中定义的函数，重写虚函数会覆盖虚函数表对应位置的函数指针。</p><h4 id="多继承的实现及可能出现的问题"><a href="#多继承的实现及可能出现的问题" class="headerlink" title="多继承的实现及可能出现的问题"></a>多继承的实现及可能出现的问题</h4><p>多继承会将基类子对象按照继承顺序放在派生类对象中。菱形继承中可能出现重复继承同一个基类的情况。解决办法是使用虚继承。</p><h4 id="菱形继承类大小的计算"><a href="#菱形继承类大小的计算" class="headerlink" title="菱形继承类大小的计算"></a>菱形继承类大小的计算</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-对象模型-关于数据成员/">【C++ 对象模型】（三）关于数据成员</a>第2部分</p><h4 id="类对象的内存存储形式"><a href="#类对象的内存存储形式" class="headerlink" title="类对象的内存存储形式"></a>类对象的内存存储形式</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-对象模型-关于数据成员/">【C++ 对象模型】（三）关于数据成员</a>第3部分</p><h4 id="override-和-final"><a href="#override-和-final" class="headerlink" title="override 和 final"></a>override 和 final</h4><p>override 关键字告诉编译器这个函数是重写基类的函数，如果该函数和基类函数的标识不是完全一样就会报错，比如基类函数中有 const 修饰，派生类重写的时候忘记了 const，如果没有 override，就会导致我们以为重写了基类的函数，但实际上因为没有加 const ，这是两个完全不同的函数而产生错误。同时因为 override 可以说明这是一个重写的基类虚函数，因此派生类中函数的 virtual 关键字就可以去掉了。</p><p>final 关键字用于类声明可以禁止继承该类，用于方法可以禁止该方法在派生类中被重写。</p><h4 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h4><p>因为虚函数会在放在虚函数表中，构造对象时给对象的 vptr 赋值，如果构造函数是虚函数，那调用构造函数的时候就要用 vptr 去找构造函数，但此时 vptr 还没有被赋值。</p><h4 id="为什么析构函数可以是虚函数"><a href="#为什么析构函数可以是虚函数" class="headerlink" title="为什么析构函数可以是虚函数"></a>为什么析构函数可以是虚函数</h4><p>与构造函数不同，vptr 已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。</p><p>当我们使用基类指针可以指向派生类的对象时，如果删除该指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。而如果析构函数不定义为虚函数，编译器会实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，从而存在内存泄露的风险。</p><p>更多关于析构函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-对象模型-对象复制和析构/">【C++ 对象模型】（五）对象复制和析构</a></p><h4 id="关于构造函数和析构函数的细节"><a href="#关于构造函数和析构函数的细节" class="headerlink" title="关于构造函数和析构函数的细节"></a>关于构造函数和析构函数的细节</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-对象模型-关于构造函数/">【C++ 对象模型】（二）关于构造函数</a>第 1 部分</p><h4 id="关于拷贝构造函数"><a href="#关于拷贝构造函数" class="headerlink" title="关于拷贝构造函数"></a>关于拷贝构造函数</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-对象模型-关于构造函数/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分</p><h4 id="new、placement-new-和-malloc"><a href="#new、placement-new-和-malloc" class="headerlink" title="new、placement new 和 malloc"></a>new、placement new 和 malloc</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-对象模型-关于执行期/">【C++ 对象模型】（六）关于执行期</a></p><h1 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h1><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>指针指向内存后在使用完毕不释放内存导致这块内存既没有用处也无法再被分配出去。智能指针会在对象生命周期结束后自动释放内存。</p><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象。shared_ptr 对资源做引用计数，当引用计数为 0 的时候，自动释放资源。</p><p>shared_ptr 需要维护的信息有两部分：</p><ol><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li></ol><p>所以，一个 shared_ptr 对象有两个指针。一个是指向共享资源的指针，一个是指向控制信息的指针。shared_ptr 的自定义 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220625132147566.png" alt="image-20220625132147566"></p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</p><p>总结一下，std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p><ol><li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li></ol><h4 id="为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？"><a href="#为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？" class="headerlink" title="为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？"></a>为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？</h4><p>不能。 因为在存在继承的情况下，shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</p><p>比如基类指针指向派生类对象，基类指针指向的是派生类中的基类子对象，但控制信息中该基类指针也会为派生类对象的引用计数加 1，并且控制信息中指向的共享资源不是基类子对象，而是派生类对象本身。</p><h4 id="关于循环引用"><a href="#关于循环引用" class="headerlink" title="关于循环引用"></a>关于循环引用</h4><p>引用计数的一个问题就是不能处理循环引用的情况，当两个对象互相引用的时候，引用计数永远为 1，导致二者都无法释放从而造成内存泄露。这时将其中一个 shared_ptr 改为 weak_ptr，在需要获取操作权的时候使用 <code>weak_ptr.lock()</code>函数将 weak_ptr 提升为 shared_ptr 即可，这样既解决了循环引用问题也达到了原本的目的。</p><p>关于循环引用的例子可以查看<a href="https://blog.csdn.net/u012442719/article/details/55045583">c++ weak ptr解除指针循环引用</a>加深理解。</p><h4 id="shared-ptr-的实现"><a href="#shared-ptr-的实现" class="headerlink" title="shared_ptr 的实现"></a>shared_ptr 的实现</h4><p>查看<a href="https://blog.csdn.net/xiaodu655/article/details/85780240">智能指针（shared_ptr的实现）</a>。</p><h4 id="关于野指针"><a href="#关于野指针" class="headerlink" title="关于野指针"></a>关于野指针</h4><p>初始化指针时没有给初始值或者释放内存后没有将指针置空就会产生野指针，具体可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-对象模型-关于执行期/">【C++ 对象模型】（六）关于执行期</a>中 2.2 部分。</p><p>避免野指针的方法是：</p><ul><li>初始化指针的时候将其置为 nullptr，之后再对其操作</li><li>释放指针的时候将其置为 nullptr</li></ul><h1 id="3-STL"><a href="#3-STL" class="headerlink" title="3 STL"></a>3 STL</h1><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-迭代器/">【STL】迭代器</a></p><h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-序列式容器/">【STL】序列式容器</a></p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-关联式容器/">【STL】关联式容器</a></p><h1 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4 多线程"></a>4 多线程</h1><h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><p>线程是操作系统能够进行 CPU 调度的最小单位，它被包含在进程之中，一个进程可包含单个或者多个线程。而进程是资源分配的最小单位，同一个进程内的所有线程共享该进程的资源，因此线程共享进程的地址空间，而进程拥有独立的地址空间。</p><p>综上，一般情况下，存在两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p><ul><li>基于进程的多任务处理是程序的并发执行。</li><li>基于线程的多任务处理是同一程序的片段的并发执行。</li></ul><h4 id="操作系统如何管理进程"><a href="#操作系统如何管理进程" class="headerlink" title="操作系统如何管理进程"></a>操作系统如何管理进程</h4><p>进程控制块（Process Control Block，PCB）是操作系统为了管理进程，在内核中设置的一种的数据结构。PCB 储存了高效管理进程所需的许多不同数据项。虽然这种数据结构的细节因系统而异，但是常见的部分大致可分为3大类：</p><ul><li>进程标识数据</li><li>进程状态数据</li><li>进程控制数据</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220705104317141.png" alt="image-20220705104317141"></p><h4 id="thread-构造"><a href="#thread-构造" class="headerlink" title="thread 构造"></a>thread 构造</h4><p>C++ 的 thread 对象构造需要传入函数名和函数参数，只要创建了线程对象，线程就开始执行。所以不应该在创建了线程后马上 join, 这样会马上阻塞主线程，创建了线程和没有创建一样，应该在晚一点的位置调用 join。另外 thread 类不支持拷贝构造，只支持移动构造，也就是说不能用一个已经存在的 thread 对象初始化另一个 thread 对象，只能用临时的 thread 对象进行初始化，也就是通过右值引用实现的移动构造函数。</p><h4 id="创建线程时是如何处理函数参数的"><a href="#创建线程时是如何处理函数参数的" class="headerlink" title="创建线程时是如何处理函数参数的"></a>创建线程时是如何处理函数参数的</h4><p>创建线程时需要传递函数名作为参数，提供的函数对象会复制到新的线程的内存空间中执行与调用。</p><p>如果用于创建线程的函数为含参函数，那么在创建线程时，要一并将函数的参数传入。常见的，传入的参数的形式有基本数据类型（int，char,string等）、引用、指针、对象等，下面总结了传递不同形式的参数时 std::thread 类的处理机制：</p><ul><li>总体来说，std::thread 的构造函数会拷贝传入的参数</li><li>当传入参数为<strong>基本数据类型(int，char,string等)</strong>时，<strong>会拷贝</strong>一份给创建的线程；</li><li>当传入参数为<strong>指针</strong>时，<strong>会浅拷贝</strong>一份给创建的线程，也就是说，只会拷贝对象的指针，不会拷贝指针指向的对象本身；</li><li>当传入的参数为<strong>引用</strong>时，实参必须<strong>用 ref() 函数处理</strong>后传递给形参，否则编译不通过，<strong>此时不存在“拷贝”行为</strong>，因为引用只是变量的别名，在线程中传递对象的引用，那么该对象始终只有一份，只是存在多个别名罢了；</li><li>当传入的参数为<strong>类对象</strong>时，<strong>会拷贝</strong>一份给创建的线程，此时会调用类对象的拷贝构造函数。</li></ul><h4 id="join-和-detach"><a href="#join-和-detach" class="headerlink" title="join() 和 detach()"></a>join() 和 detach()</h4><p>当线程启动后，一定要在和线程相关联的 std::thread 对象销毁前，对线程运用 <code>join()</code> 或者 <code>detach()</code> 方法。<code>join()</code>与 <code>detach()</code> 都是 std::thread 类的成员函数，是两种线程阻塞方法，两者的区别是是否等待子线程执行结束。</p><ul><li><p><code>join()</code> 等待调用线程运行结束后当前线程再继续运行，例如，主函数中有一条语句 <code>th1.join()</code>，那么执行到这里，主函数阻塞，直到线程 th1 运行结束，主函数再继续运行。</p></li><li><p><code>detach()</code> 将当前线程和主线程分离，主线程无需等待当前线程完成，使用 <code>detach()</code> 时，可能存在<strong>主线程比子线程先结束</strong>的情况，主线程结束后会释放掉自身的内存空间；在创建线程时，如果 std::thread 类传入的参数含有<strong>引用或指针</strong>，则子线程中的数据依赖于主线程中的内存，主线程结束后会释放掉自身的内存空间，则子线程会出现错误。</p></li></ul><p>调用 <code>join()</code> 会清理线程相关的存储部分，这代表了 <code>join()</code> 只能调用一次。使用 <code>joinable()</code> 来判断<code>join()</code> 可否调用。同样，<code>detach()</code> 也只能调用一次，一旦<code>detach()</code> 后就无法<code>join()</code> 了，有趣的是，<code>detach()</code> 可否调用也是使用 <code>joinable()</code> 来判断。</p><h4 id="临界区、互斥量、信号量"><a href="#临界区、互斥量、信号量" class="headerlink" title="临界区、互斥量、信号量"></a>临界区、互斥量、信号量</h4><p>访问共享资源的代码段称为临界区，临界区只能作用于同一进程下不同线程，不能作用于不同进程；临界区可确保某一代码段同一时刻只被一个线程执行。</p><p>互斥量（锁）是使用共享资源的许可，能保证同一时刻只有一个线程访问共享资源，但支持不同进程间的同步与互斥。</p><p>信号量能允许多个线程同一时刻访问共享资源，进行线程的计数，确保同时访问资源的线程数目不超过上限，当访问数超过上限后，不发出信号量。</p><h4 id="什么是同步，什么是互斥"><a href="#什么是同步，什么是互斥" class="headerlink" title="什么是同步，什么是互斥"></a>什么是同步，什么是互斥</h4><p>任务运行时，有些任务片段间存在严格的先后顺序，<strong>同步指维护任务片段的先后顺序</strong>。比如 A 片段执行完才能执行 B 片段，线程 1 执行 A 片段，在 A 片段执行结束后解锁；线程 2 执行 B 片段，在 B 片段执行前申请锁，于是 A 片段解锁了 B 片段才能申请到锁，保证了 A 片段执行结束了 B 片段才能运行，称之为同步.</p><p><strong>互斥就是保证资源同一时刻只能被一个进程使用；</strong>互斥是为了保证数据的一致性，如果 A 线程在执行计算式 A 的时候，某个量被 B 线程改掉了，这可能会出现问题，于是要求资源互斥，我在用它你就不能用，等我用完了你再用，我们彼此互不干扰。</p><h4 id="都有哪些锁，功能是什么"><a href="#都有哪些锁，功能是什么" class="headerlink" title="都有哪些锁，功能是什么"></a>都有哪些锁，功能是什么</h4><ul><li>互斥锁 mutex：加锁的资源支持互斥访问，即同一时刻只能被一个线程访问，通过 lock 加锁， unlock 解锁</li><li>读写锁 shared_mutex：读写锁把对共享资源的访问者划分成读者和写者，多个读线程能同时读取共享资源，但只有一个写线程能同时读取共享资源，shared_mutex 通过 lock_shared，unlock_shared 进行读者的锁定与解锁；通过 lock，unlock 进行写者的锁定与解锁</li><li>自旋锁：如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，因此自旋锁比较适用于锁使用者保持锁时间比较短的情况</li></ul><p>一般不直接去调用成员函数 lock()，因为如果忘记 unlock()，将导致锁无法释放，通常使用 lock_guard 或者 unique_lock 避免忘记解锁带来的问题。</p><h4 id="什么是死锁，产生的条件，解决办法"><a href="#什么是死锁，产生的条件，解决办法" class="headerlink" title="什么是死锁，产生的条件，解决办法"></a>什么是死锁，产生的条件，解决办法</h4><p>死锁就是多个线程争夺共享资源导致每个线程都不能取得自己所需的全部资源，从而程序无法向下执行。</p><p>产生死锁的四个必要条件：</p><ol><li>互斥（资源同一时刻只能被一个进程使用）</li><li>请求并保持（进程在请资源时，不释放自己已经占有的资源）</li><li>不剥夺（进程已经获得的资源，在进程使用完前，不能强制剥夺）</li><li>循环等待（进程间形成环状的资源循环等待关系）</li></ol><p>死锁预防：破坏死锁产生的四个条件</p><p>死锁避免：分配资源时进行安全性检测（银行家算法，预分配并检查状态，安全才正式分配资源）</p><p>死锁检测：允许思索发生，但提供检测算法</p><p>死锁解除：产生死锁后，通过强制剥夺资源或者撤销进程来解除死锁</p><h4 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h4><p>lock_guard 类似于智能指针，能帮助我们自动管理加锁与解锁，当我们声明一个局部的 std::lock_guard 对象时，会在其构造函数中进行加锁，在其析构函数中进行解锁。最终的结果就是：创建即加锁，作用域结束自动解锁。从而使用 std::lock_guard() 就可以替代 lock() 与 unlock()。</p><p>通过设定作用域，使得 std::lock_guard 在合适的地方被析构，通过使用 <code>&#123;&#125;</code> 来调整作用域范围，可使得互斥量 m 在合适的地方被解锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;    <span class="comment">//实例化锁对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用此语句替换了m.lock()，lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;   <span class="comment">//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过使用&#123;&#125;来调整作用域范围，可使得m在合适的地方被解锁</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容5&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造 std::lock_guard 时还可以传入 adopt_lock 标识，表示构造函数中不再进行互斥量锁定，因此此时需要提前手动锁定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();   <span class="comment">//手动锁定</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m,adopt_lock)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;   <span class="comment">//自动解锁</span></span><br></pre></td></tr></table></figure><h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><p>std::unique_lock 类似于 lock_guard，但 std::unique_lock 用法更加丰富，同时支持 std::lock_guard() 的原有功能。 使用 std::lock_guard 后不能手动 lock() 与手动 unlock()，而使用 std::unique_lock 后可以手动 lock() 与手动 unlock()，并且 std::unique_lock 的第二个参数除了可以是 adopt_lock 外，还可以是 try_to_lock 与 defer_lock：</p><ul><li>try_to_lock：尝试去锁定，得保证锁处于unlock的状态，然后尝试现在能不能获得锁；尝试用 mutex 的 lock() 去锁定这个 mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里，并继续往下执行</li><li>defer_lock：初始化一个没有加锁的 mutex，在之后手动加锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc1</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">g1</span><span class="params">(m, defer_lock)</span></span>;<span class="comment">//初始化一个没有加锁的mutex</span></span><br><span class="line">    g1.<span class="built_in">lock</span>();<span class="comment">//手动加锁，注意，不是m.lock()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    g1.<span class="built_in">unlock</span>();<span class="comment">//临时解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;xxxxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g1.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;xxxxxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">proc2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">g2</span><span class="params">(m, try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (g2.<span class="built_in">owns_lock</span>()) &#123;<span class="comment">//锁成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//锁失败则执行这段语句</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;xxxxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件变量-condition-variable"><a href="#条件变量-condition-variable" class="headerlink" title="条件变量 condition_variable"></a>条件变量 condition_variable</h4><p>std::condition_variable 类需要搭配 std::mutex 类来使用，std::condition_variable 对象的作用不是用来管理互斥量的，它的作用是用来同步线程，它的用法相当于编程中常见的 flag 标志，比如 A、B 两个人约定 flag==true 为行动号角，默认 flag 为 false，A 不断的检查 flag 的值，只要 B 将 flag 修改为 true，A就开始行动。类比到 std::condition_variable，A、B两个人约定 notify_one 为行动号角，A 就等着（调用wait()，阻塞）,只要 B 一调用 notify_one，A 就开始行动（不再阻塞）。</p><p>wait(locker)：在线程被阻塞时，该函数会自动调用 locker.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知，通常是另外某个线程调用 notify_* 唤醒了当前线程，wait() 函数此时再自动调用 locker.lock() 来获得锁。</p><p>notify_* 方法包括：</p><ul><li>notify_one()：随机唤醒一个等待的线</li><li>notify_all()：唤醒所有等待的线程</li></ul><h4 id="什么是同步和异步，阻塞和非阻塞"><a href="#什么是同步和异步，阻塞和非阻塞" class="headerlink" title="什么是同步和异步，阻塞和非阻塞"></a>什么是同步和异步，阻塞和非阻塞</h4><p>同步是执行或调用一个方法时，每次都需要拿到对应的结果才会继续往后执行；异步与同步相反，它会在执行或调用一个方法后就继续往后执行，不会等待获取执行结果。二者的区别就是处理请求发出后，是否需要等待请求结果，再去继续执行其他操作。</p><p>以下图为例，红色线条为主线程，其他线条为调用的方法，上面的为同步，下面的为异步。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2019059-20200501234839680-531092492.png" alt="2019059-20200501234839680-531092492"></p><p>阻塞的概念通常会伴随着线程。阻塞是指当前执行的线程调用一个方法，在该方法没有返回值之前，当前执行的线程会被挂起，无法继续进行其他操作。非阻塞是指当前执行的线程调用一个方法，当前执行的线程不受该方法的影响，可以继续进行其他操作。</p><h4 id="async、future-和-shard-future"><a href="#async、future-和-shard-future" class="headerlink" title="async、future 和 shard_future"></a>async、future 和 shard_future</h4><p>async 用于创建一个异步线程，它返回一个 future 类模板对象，future 对象起到了占位的作用，刚实例化的 future 是没有储存值的，但在调用 future 对象的 get() 成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给 future，即通过 FutureObject.get() 获取函数返回值。</p><p>shard_future 和 future 一样，都是为了占位，但 future 的 get() 成员函数是转移数据所有权，而 shared_future 的 get() 成员函数是复制数据。因此 future 对象的 get() <strong>只能调用一次</strong>；无法实现多个线程等待同一个异步线程，一旦其中一个线程获取了异步线程的返回值，其他线程就无法再次获取。shared_future 对象的 get() <strong>可以调用多次</strong>；可以实现多个线程等待同一个异步线程，每个线程都可以获取异步线程的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">t1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> a, <span class="type">const</span> <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">3000</span>); <span class="comment">//假设t1函数是个复杂的计算过程，需要消耗3秒</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">2.3</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">6.7</span>;</span><br><span class="line">    future&lt;<span class="type">double</span>&gt; fu = <span class="built_in">async</span>(t1, a, b);<span class="comment">//创建异步线程线程，并将线程的执行结果用fu占位；</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在进行计算&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计算结果马上就准备好，请您耐心等待&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">//阻塞主线程，直至异步线程return</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;计算结果：&quot; &lt;&lt; fu.get() &lt;&lt; endl;//取消该语句注释后运行会报错，因为future对象的get()方法只能调用一次。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子类型-automic"><a href="#原子类型-automic" class="headerlink" title="原子类型 automic"></a>原子类型 automic</h4><p>原子操作指不可分割的操作；也就是说这种操作状态要么是完成的，要么是没完成的。互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。automic 是一个模板类，使用该模板类实例化的对象，提供了一些保证原子性的成员函数来实现共享数据的常用操作。</p><p>可以这样理解：<br>在以前，定义了一个共享的变量(int i=0)，多个线程会操作这个变量，那么每次操作这个变量时，都是用 lock 加锁，操作完毕使用 unlock 解锁，以保证线程之间不会冲突；<br>现在，实例化了一个类对象(automic i=0)来代替以前的那个变量，每次操作这个对象时，就不用 lock 与 unlock，这个对象自身就具有原子性，以保证线程之间不会冲突。</p><p>automic 对象提供了常见的原子操作（通过调用成员函数实现对数据的原子操作）：store 是原子写操作，load 是原子读操作，exchange 是于两个数值进行交换的原子操作。</p><p><strong>即使使用了automic，也要注意执行的操作是否支持原子性</strong>。一般 atomic 原子操作，针对 ++，–，+=，-=，&amp;=，|=，^= 是支持的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子类型的简单使用</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="原子智能指针"><a href="#原子智能指针" class="headerlink" title="原子智能指针"></a>原子智能指针</h4><p>C++ 20 引入了原子智能指针，使得原子类型支持智能指针，我们知道智能指针 shared_ptr 读写数据不是线程安全的，因为 shared_ptr 的复制操作分为两步，复制指向资源的指针和复制指向控制块的指针，因此这一操作不是原子的，就会存在多线程中的各种冲突问题，具体可以查看<a href="https://blog.csdn.net/weixin_42142630/article/details/121165649">C++ 智能指针线程安全的问题</a>中的例子。</p><p>而使用原子类型的变量可以解决这个问题，但在之前原子类型不支持智能指针操作，C++ 20 引入的原子智能指针 <code>std::atomic&lt;std::shared_ptr&gt;</code> 完美的解决了这个问题。</p><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p>生产者消费者问题是经典的多线程问题，通过该问题来理解上面说到的各种特性。</p><p>生产者用于生产数据，生产一个就往共享数据区存一个，如果共享数据区已满的话，生产者就暂停生产，等待消费者的通知后再启动。</p><p>消费者用于消费数据，一个一个的从共享数据区取，如果共享数据区为空的话，消费者就暂停取数据，等待生产者的通知后再启动。</p><p>生产者与消费者不能直接交互，它们之间所共享的数据使用队列结构来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区存储的数据类型 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 商品id </span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 商品属性 </span></span><br><span class="line">    string data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享缓冲区</span></span><br><span class="line">queue&lt;CacheData&gt; Q;</span><br><span class="line"><span class="comment">// 缓冲区最大空间 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_CACHEDATA_LENGTH = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 互斥量，生产者之间，消费者之间，生产者和消费者之间，同时都只能一个线程访问缓冲区 </span></span><br><span class="line">mutex m;</span><br><span class="line">condition_variable condConsumer;</span><br><span class="line">condition_variable condProducer;</span><br><span class="line"><span class="comment">// 全局商品id </span></span><br><span class="line"><span class="type">int</span> ID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProducerTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lockerProducer</span><span class="params">(m)</span></span>;    <span class="comment">// 获得锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 获取了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>() &gt;= MAX_CACHEDATA_LENGTH)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;因为队列为满，所以生产者Sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 不再持有锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//缓冲区满，生产者停止生产，调用 wait，解锁，唤醒其他线程，等待消费者唤醒之后再加锁</span></span><br><span class="line">            condProducer.<span class="built_in">wait</span>(lockerProducer);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Weak, 重新获取了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        CacheData temp;</span><br><span class="line">        temp.id = ID++;</span><br><span class="line">        temp.data = <span class="string">&quot;*****&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;+ ID:&quot;</span> &lt;&lt; temp.id &lt;&lt; <span class="string">&quot; Data:&quot;</span> &lt;&lt; temp.data &lt;&lt; endl;</span><br><span class="line">        Q.<span class="built_in">push</span>(temp);</span><br><span class="line">        condConsumer.<span class="built_in">notify_one</span>();    <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 释放了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumerTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lockerConsumer</span><span class="params">(m)</span></span>;    <span class="comment">// 获得锁</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 获取了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;因为队列为空，所以消费者Sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 不再持有锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//缓冲区为空，消费者停止，调用 wait，解锁，唤醒其他线程，等待消费者唤醒之后再加锁</span></span><br><span class="line">            condConsumer.<span class="built_in">wait</span>(lockerConsumer);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] Weak, 重新获取了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        CacheData temp = Q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;- ID:&quot;</span> &lt;&lt; temp.id &lt;&lt; <span class="string">&quot; Data:&quot;</span> &lt;&lt; temp.data &lt;&lt; endl;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        condProducer.<span class="built_in">notify_one</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] 释放了锁&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理线程的函数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispatch</span><span class="params">(<span class="type">int</span> ConsumerNum, <span class="type">int</span> ProducerNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;thread&gt; thsC;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ConsumerNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        thsC.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(ConsumerTask));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; thsP;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ProducerNum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        thsP.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(ProducerTask));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ConsumerNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (thsC[i].<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            thsC[i].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ProducerNum; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (thsP[j].<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            thsP[j].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一个消费者线程，5个生产者线程，则生产者经常要等待消费者 </span></span><br><span class="line">    <span class="built_in">Dispatch</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池是什么，解决了什么问题"><a href="#线程池是什么，解决了什么问题" class="headerlink" title="线程池是什么，解决了什么问题"></a>线程池是什么，解决了什么问题</h4><p>不采用线程池时，即使需要使用到大量线程，每个线程都要按照“创建线程 -&gt; 由该线程执行任务 -&gt; 任务执行完毕后销毁线程”的流程来创建、执行与销毁。虽然创建与销毁线程消耗的时间通常远小于线程执行的时间，但是对于需要频繁创建大量线程的任务，创建与销毁线程 所占用的时间与CPU资源也会有很大占比。</p><p>因此使用线程池技术来进行优化，线程池技术的基本思想是：</p><ul><li>程序启动后，预先创建一定数量的线程放入空闲队列中，这些线程都是处于阻塞状态，基本不消耗CPU，只占用较小的内存空间。</li><li>接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。</li><li>任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。</li></ul><p>线程池所解决的问题：</p><ul><li>需要频繁创建与销毁大量线程的情况下，由于线程预先就创建好了，接到任务就能马上从线程池中调用线程来处理任务，减少了创建与销毁线程带来的时间开销和CPU资源占用。</li><li>需要并发的任务很多时候，无法为每个任务指定一个线程（线程不够分），使用线程池可以将提交的任务挂在任务队列上，等到池中有空闲线程时就可以为该任务指定线程。</li></ul><h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h1><h4 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h4><ol><li><strong>预编译</strong>（.cpp -&gt; .i），预编译主要进行代码文本替换工作。编译器执行预编译指令（以 # 开头，例如 #include），这个过程会得到不包含 # 指令的 .i 文件。这个过程会拷贝 #include 包含的文件代码，进行 #define 宏定义的替换 ， 处理条件编译指令（#ifndef、#ifdef、#endif）等等。</li><li><strong>编译优化</strong>（.i -&gt; .s），通过预编译输出的 .i 文件中，只包含常量、字符串、变量的定义，以及关键字：main、if、else、for、while等。编译优化阶段则是通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</li><li><strong>汇编</strong>（.s -&gt; .o 或 .obj），汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件。目标文件中存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成，通常至少有两个段：<ul><li>代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行</li></ul></li><li><strong>链接</strong>（.o -&gt; .exe / .a / .so / .lib / .dll 等），由汇编程序生成的目标文件并不能立即就执行，还要通过链接过程。这是因为某个源文件调用了另一个源文件中的函数或常量或在程序中调用了某个库文件中的函数，链接的主要工作就是将有关的目标文件连接起来，形成最终的可执行文件。</li></ol><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>堆是由程序员控制的内存区域，通过 new 和 delete 来申请堆上的内存和释放堆上的内存。</p><p>栈是由编译器管理的内存，在需要时自动分配，不需要时自动清除。栈通常存放局部变量、函数参数等。</p><p>除了堆和栈之外，还有存储全局变量和静态变量的存储区以及存放常量的存储区。</p><p>堆和栈的对比：</p><div class="table-container"><table><thead><tr><th></th><th>堆（Heap）</th><th>栈（Stack）</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>堆中资源由程序员控制（需要注意内存泄漏）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td><strong>内存管理机制</strong></td><td>系统维护一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序，系统还会将多余的部分重新放入空闲链表中，释放内存时将内存重新加入空闲内存链表中。</td><td>栈是一块连续的内存空间，只要栈的剩余空间大于所申请空间，系统就为程序提供栈内存，否则报错 stack overflow。</td></tr><tr><td><strong>空间大小</strong></td><td>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</td><td>在Windows下，栈是向低地址扩展的数据结构，栈是一块连续的内存区域，大小是操作系统预定好的，在编译时确定，可设置。</td></tr><tr><td><strong>碎片问题</strong></td><td>对于堆，频繁的 new / delete 会造成大量内存碎片，使程序效率降低。</td><td>对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。</td></tr><tr><td><strong>分配方式</strong></td><td>堆都是动态分配，没有静态分配的堆</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由 alloca() 函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td><strong>效率</strong></td><td>堆由 C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是极其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table></div><h4 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-对象模型-关于数据成员/">【C++ 对象模型】（三）关于数据成员</a>第 1 部分。</p><h4 id="内联函数与宏的区别"><a href="#内联函数与宏的区别" class="headerlink" title="内联函数与宏的区别"></a>内联函数与宏的区别</h4><p>宏在预编译时在调用处执行字符串的原样替换（宏展开）。而内联函数在编译时在调用处展开，同时进行<strong>参数类型检查，宏定义不会进行参数类型检查。</strong></p><p>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</p><p>一般来说内联函数可以完全替代宏，更多关于内联函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-对象模型-关于函数成员/">【C++ 对象模型】（四）关于函数成员</a>第 3 部分。</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝就是在拷贝时直接进行简单的对应赋值操作，类似于参数的引用传递，源对象与拷贝对象共用一份实体，对其中任何一个对象的改动都会影响另外一个对象。</p><p>深拷贝则类似于参数的值传递，源对象与拷贝对象互相独立 ，其中任何一个对象的改动都不会对另外一个对象造成影响。</p><h4 id="什么时候需要深拷贝"><a href="#什么时候需要深拷贝" class="headerlink" title="什么时候需要深拷贝"></a>什么时候需要深拷贝</h4><p>当一个类中有对其他类对象成员时需要深拷贝，也就是不能直接将一个类对象的某个对象成员赋值给另一个类对象，而是要单独开辟一块内存，重新构造一个相同的对象成员，否则当类对象析构时，拷贝的类对象的该对象成员也被析构掉了就会产生错误。</p><p>关于拷贝构造函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-对象模型-关于构造函数/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分。</p><h4 id="C-的强制类型转换"><a href="#C-的强制类型转换" class="headerlink" title="C++ 的强制类型转换"></a>C++ 的强制类型转换</h4><p>C++ 提供四种强制类型转换关键字：static_cast、const_cast、reinterpret_cast 和 dynamic_cast。</p><ul><li><strong>static_cast</strong> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。主要用于内置类型之间的转换或者将空指针转化为对应类型的指针，但不能用于基本数据类型指针之间的转化。static_cast 也可以用于类层次结构中基类和派生类之间指针或引用的转换，但<strong>需要注意</strong>：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的，但进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</li><li><strong>const_cast</strong> 用于强制去掉 const 修饰的常量特性，但需要特别注意的是 const_cast 不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。具体的例子可以查看<a href="https://blog.csdn.net/q610098308/article/details/115915802">C++强制类型转换</a>第 2 部分，总之非必要情况下尽量不要使用 const_cast。</li><li><strong>reinterpret_cast</strong> 主要有三种强制转换用途：用于基本数据类型的指针或引用之间的转换、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。reinterpret_cast 可以将指针或引用转换为一个足够长度的整形，这里的足够长度具体是多少则取决于操作系统，如果是 32 位的操作系统，就需要 4 个字节及以上的整型，如果是 64 位的操作系统则需要 8 个字节及以上的整型。 </li><li><strong>dynamic_cast</strong> 是 C++ 支持多态的方式之一，其他三种类型转换都是在编译时进行，而 dynamic_cast 则是在运行时处理。 在 C++ 中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。dynamic_cast 操作符则可以在运行期对可能产生问题的类型转换进行判定。dynamic_cast 具有以下特性：<ul><li>不能用于内置的基本数据类型的强制转换。</li><li>dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr。</li><li>使用 dynamic_cast 进行转换时，基类中一定要有虚函数，否则编译不通过。这是因为类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</li><li>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是完全一样的。在进行下行转换时，由于 dynamic_cast 具有运行时类型检查的功能，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败，因此要比 static_cast 更安全。运行时类型检查需要运行时类型信息，这个信息存储在虚函数表中，关于这部分可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-对象模型-关于对象/">【C++ 对象模型】（一）关于对象</a>第 2 部分和<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-对象模型-模板和RTTI/">【C++ 对象模型】（七）模板和 RTTI</a>第 2 部分。</li></ul></li><li>总结：基本数据类型之间的转换使用 static_cast，基本数据类型指针或引用之间的转换用 reinterpret_cast，类对象的指针或引用之间的转换用 dynamic_cast 最为安全，但上行转换时使用 static_cast 也同样安全，const_cast 用于去掉指针或引用的常量性，较少使用。</li></ul><h4 id="关于模板的声明和实现"><a href="#关于模板的声明和实现" class="headerlink" title="关于模板的声明和实现"></a>关于模板的声明和实现</h4><p>C++ 在写模版函数时（<code>template&lt;class T&gt;</code>之类的），头文件不能与 cpp 文件分离。这就意味者，你头文件定义的含模版的地方必须在头文件中实现，没用模版定义的地方可以放在 cpp 中实现。为什么会这样呢？</p><p>C++ 中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。</p><p>既然是在编译的时候，根据套用的不同类型进行编译，那么，套用不同类型的模板类实际上就是完全不同的类型，也就是说 <code>stack&lt;int&gt;</code> 和 <code>stack&lt;char&gt;</code> 是两个不同的数据类型，他们共同的成员函数也不是同一个函数，只不过具有相似的功能罢了。因此这两个模板类的成员函数也会被编译出完全不同的代码。</p><p>所以模板类的实现，脱离具体的使用，是无法单独的编译的；把声明和实现分开的做法也是不可取的，必须把实现全部写在头文件里面。为了清晰，实现可以不写在 class 后面的花括号里面，可以写在 class 的外面。</p><p>但也可以实现模板声明和实现分离，比如有下面的模板类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTemplate</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">TestTemplate</span>(Node node):</span><br><span class="line">  <span class="built_in">data</span>(node) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  Node data;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> node&gt;</span><br><span class="line"><span class="type">void</span> TestTemplate&lt;node&gt;::<span class="built_in">print</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TestTemplate &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把它们分别放在 .h 和 .cpp 文件中，链接器会报错，提示找不到实现。但在 .h 文件中模板类的声明下加这一句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestTemplate.tpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后把实现放在名为 TestTemplate.tpp 文件中，即可实现模板声明和实现的文件分离。</p><h4 id="类的静态成员变量何时初始化"><a href="#类的静态成员变量何时初始化" class="headerlink" title="类的静态成员变量何时初始化"></a>类的静态成员变量何时初始化</h4><p>在 main 函数运行前，程序加载时进行初始化，分为静态初始化和动态初始化。</p><p>静态初始化是用常量对静态成员初始化，静态初始化在程序加载的过程中完成。</p><p>动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a = foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。</p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p><p>左值是可寻址的变量，有持久性；右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</p><p>左值和右值主要的区别之一是左值可以被修改，而右值不能。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。</p><p>能指向左值，不能指向右值的就是左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure><p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，const 左值引用是可以指向右值的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>const 左值引用不会修改指向值，因此可以指向右值，这也是为什么通常要使用 <code>const &amp;</code> 作为函数参数的原因之一，如 <code>std::vector</code>的 <code>push_back</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有 <code>const</code>，<code>vec.push_back(5)</code> 这样的代码就无法编译通过了。</p><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"> </span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure><h4 id="move-和-forward-的作用"><a href="#move-和-forward-的作用" class="headerlink" title="move 和 forward 的作用"></a>move 和 forward 的作用</h4><p><code>std::move</code> 可以将左值强制转化为右值，从而让右值引用可以指向左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = std::<span class="built_in">move</span>(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure><p>那么 move 到底有什么用处呢？首先来总结一下左右值引用：</p><ol><li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li><li>右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值，但 const 左值引用也能指向右值。</li><li>作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li></ol><p>上面已经给出了 move 的作用之一，就是比左值引用更加灵活，但其本身只是一个类型转换工具，不会对性能有任何提升，但使用 move 可以实现移动语义从而提升性能。</p><p>在没有右值引用之前，当一个类中有其他对象成员的时候，拷贝构造或者赋值运算都需要深拷贝，相当于复制了一份对象成员，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然拷贝构造函数的参数是左值引用的，左值引用就是为了防止拷贝，但函数内还是进行了深拷贝，如果被拷贝者之后就不需要了，那这样的拷贝函数会显得非常呆，于是有人提出是不是可以写一个移动构造函数，进行浅拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用 const 左值引用实现移动构造函数有两个问题：</p><ul><li>不优雅，表示移动语义还需要一个额外的参数(或者其他方式)</li><li>实际根本无法实现，<code>temp_array</code>是个 const 左值引用，无法被修改，所以 <code>temp_array.data_ = nullptr;</code> 这行根本无法编译通过。当然函数参数可以改成非 const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，但这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li></ul><p>可以看出左值引用使用起来非常不方便，而使用右值引用作为参数可以完美的解决这个问题，实现成员数据的移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止 temp_array 析构时 delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时使用 move 转化为右值传入函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做一些操作</span></span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上在 STL 的很多容器中都使用了以右值引用为参数的移动构造函数和移动赋值重载函数，或者其他函数，最常见的如 std::vector 的 <code>push_back</code> 和 <code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;aacasxs&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;axcsddcas&quot;</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非设计不允许移动，STL 中的类大都支持移动语义函数。另外，编译器会默认在用户自定义的类和结构体中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数。因此，<strong>可移动对象在需要拷贝且被拷贝者之后不再被需要的场景中，建议使用 <code>std::move</code> 触发移动语义，提升性能。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line"><span class="comment">// 改为： </span></span><br><span class="line">moveable_objecta = std::<span class="built_in">move</span>(moveable_objectb);</span><br></pre></td></tr></table></figure><p>还有些 STL 类是 <code>move-only</code> 的，比如智能指针中的 <code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动（转移内部对象所有权，或者叫浅拷贝），不能拷贝（深拷贝）。</p><p>与 move 相比，forward 更强大，move 只能将左值转化为右值，forward 都可以。</p><p><code>std::forward&lt;T&gt;(u)</code> 有两个参数 T 与 u。当 T 为左值引用类型时，u 将被转换为 T 类型的左值；否则 u 将被转换为 T 类型右值。</p><h4 id="什么是引用折叠"><a href="#什么是引用折叠" class="headerlink" title="什么是引用折叠"></a>什么是引用折叠</h4><p>右值引用比左值引用更加灵活，但如果右值引用绑定的对象类型是未知的话，就既可能是左值，又可能是右值。比如模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">// 10是右值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// x是左值</span></span><br></pre></td></tr></table></figure><p>由于存在 <code>T&amp;&amp;</code> 这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这时相比普通的右值引用(&amp;&amp;)会发生类型的变化，这种变化就称为引用折叠。</p><p>引用折叠规则如下：</p><p>1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;）</p><p>2.所有的其他引用类型之间的折叠都将变成左值引用。 （A&amp; &amp; 变成 A&amp;; A&amp; &amp;&amp; 变成 A&amp;; A&amp;&amp; &amp; 变成 A&amp;）</p><h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>C++ 中 static 修饰不同的内容会有不同的效果：</p><ul><li>static 修饰变量的时候，被修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。</li><li>static 修饰类中的成员变量的时候，可以直接通过类名访问改变量，该变量值初始化一次，被所有对象共享</li><li>static 修饰类中的函数的时候，该函数可以直接通过类名调用，且静态成员函数只能访问类中的静态成员变量</li></ul><h4 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h4><ul><li>修饰不同变量可以防止变量被修改，通常用于定义程序运行时的常量</li><li>传递参数时常与指向对象的指针或者对象的引用传递使用，避免对象拷贝的同时还可以防止指针或者指向的对象在函数中被意外的修改（const char<em> p 是指针指向的内容不可变，而 char</em> const p 是指针本身不可变，可以根据 const 所在 * 的位置概括为：左定值，右定向），值传递不需要使用 const，因为需要复制一份对象，肯定不会修改原来的对象</li><li>修饰函数返回值时，表示该函数的返回值不能作为左值使用，即不能修改或被赋值</li><li>const 修饰类的成员函数，表示不允许该成员函数修改调用该函数的对象的值，所以 const 不能与 static 同时修饰函数，因为定义为静态的成员函数没有指向对象的指针，而定义为 const 的函数必须由对象调用。另外，如果类中的某些成员变量允许在任何情况下都被修改，可以在声明时加上 <code>mutable</code> 关键字，此时该成员可以在 const 函数中被修改</li><li>const 修饰对象，可以构造一个常量对象，该对象只能调用类中的 const 函数</li><li>const 还用于左值引用指向右值，前面已经提到过</li></ul><h4 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h4><p>extern 可以引用不在同一个文件中的变量或者函数</p><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>指针是一个地址，是一个单独的变量，指针本身和其指向的内容都可以被改变；而引用是对象的别名，依附于某一个对象，可以通过引用改变对象的内容，但引用本身不能改变，即引用在其生命周期内只能依附于固定的对象。</p><p>因此可以有空指针，但不能有空的引用。</p><h4 id="auto-和-decltype"><a href="#auto-和-decltype" class="headerlink" title="auto 和 decltype"></a>auto 和 decltype</h4><ul><li><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></li><li><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></li><li><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></li></ul><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><ul><li><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C++ Lambda表达式原理及应用</a></li><li><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></li><li><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></li></ul><h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><ul><li><a href="https://blog.csdn.net/JMW1407/article/details/107130600">仿函数(functors)</a></li><li><a href="https://blog.csdn.net/toby54king/article/details/105103111">C++中的仿函数有点难，这篇文章却讲的通俗易懂</a></li><li><a href="https://zhuanlan.zhihu.com/p/362323211">C++ 仿函数为何而生</a></li></ul><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/64985296">C++17 新特性之 std::optional（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/251306766">C++干货系列——C++17新特性之std::optional</a></li></ul><h4 id="游戏引擎常用的设计模式简介"><a href="#游戏引擎常用的设计模式简介" class="headerlink" title="游戏引擎常用的设计模式简介"></a>游戏引擎常用的设计模式简介</h4><p>关于设计模式具体的可以查看<a href="https://zhuanlan.zhihu.com/p/431714886">C++各类设计模式及实现详解</a>，这里简单总结游戏引擎中可能用到的几种：</p><ul><li>单例模式（SingletonDesign Pattern）：只允许创建一个类的一个实例。在游戏中，就像在电影里，应该只有一个导演。导演是一个类，这个类在游戏中指挥发生的事情。它控制对象的呈现。它控制位置更新。它将玩家的输入指向正确的游戏角色。引擎应该阻止创建一个以上的导演类的实例，通过单例设计模式来实现。此设计模式确保为给定类实例化有且只有一个对象。</li><li>策略模式（StrategyDesign Pattern）：通过解耦类行为从而提供灵活性。在游戏中，你应该将输入控制器和游戏逻辑之间的交互进行解耦。游戏的逻辑应该接收相同类型的输入，而不管输入控制器是什么（按钮，手势，操纵杆）。尽管对用户每个输入控制器的行为表现不同，但它们必须向游戏的逻辑提供相同的数据。此外，添加或删除输入控制器不应导致游戏崩溃。这种解耦行为和灵活性是可能的，这归功于策略设计模式。这种设计模式允许通过动态方式来改变行为，而不需要修改游戏的任何逻辑，为你的游戏提供了很高的灵活性。</li><li>观察者模式（Observer Design Pattern）：允许类在不知道任何事情的情况下相互交互。在游戏中，你的所有类耦合度应该设计的很低。这意味着你的类应该能够彼此交互且彼此之间应该知道对方尽量少的内容。使得你的类具有低耦合度，使得你的游戏可以模块化和灵活性的添加新的功能，且不会有意外的错误。</li><li>组合模式（CompositeDesign Pattern）：为所有类提供了统一的接入点。游戏通常包含许多视图。主视图中显示角色。有一个子视图，显示玩家的积分。有一个子视图，显示游戏中剩下的时间。如果你在移动设备上玩游戏，那么每个按钮都是一个视图。可维护性应该是游戏开发过程中的主要关注点。每个视图不应具有不同的函数名称或不同的访问点。相反，你想要为每个视图提供一个统一的访问点，即相同的函数调用应该既能够访问主视图也能够访问子视图。这种统一的接入点可以使用复合设计模式。此模式将每个视图放置在树状结构中，从而为每个视图提供统一的访问点。取代了需要用不同的函数来访问不同的子视图，组合模式可以用相同的函数访问任何视图。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结 C++ 相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Piccolo代码解读】渲染系统（一）渲染流程</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/18/20220618-Pilot-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/18/20220618-Pilot-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-06-18T02:56:25.000Z</published>
    <updated>2022-07-02T09:42:53.415Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们了解了引擎的整体运行流程以及反射机制的实现，这一节开始探究 Piccolo 的渲染系统是如何实现的，首先来了解渲染系统的整个流程。</p><p><em><span id="more"></span></em></p><p>回顾上一节中，引擎运行时最核心的函数 <code>tickOneFrame()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到引擎每一帧的流程就是先进行 <code>logicalTick</code>，然后通过 <code>swapLogicRenderData</code> 进行渲染系统的数据更新，最后进行渲染 <code>rendererTick</code>，之后还有一些窗口的事件响应。接下来我们从 <code>logicalTick</code> 开始看看整个系统是如何运行的。</p><h3 id="1-logicalTick"><a href="#1-logicalTick" class="headerlink" title="1 logicalTick"></a>1 logicalTick</h3><p><code>logicalTick</code>  的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::logicalTick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_world_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    g_runtime_global_context.m_input_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>logicalTick</code>  内部调用了世界管理系统的 tick 和输入管理系统的 tick。</p><h4 id="1-1-世界管理系统"><a href="#1-1-世界管理系统" class="headerlink" title="1.1 世界管理系统"></a>1.1 世界管理系统</h4><p>世界管理系统 <code>m_world_manager</code> 属于 <code>WorldManager</code> 类，该类用于管理整个游戏世界，包括编辑世界和运行世界，世界中包含各种关卡（Level），于是  <code>WorldManager</code> 的 tick 实际上就是调用关卡的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorldManager::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_world_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">loadWorld</span>(m_current_world_url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tick the active level</span></span><br><span class="line">    std::shared_ptr&lt;Level&gt; active_level = m_current_active_level.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (active_level)</span><br><span class="line">    &#123;</span><br><span class="line">        active_level-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而关卡类 Level 就是用于管理游戏对象（GO）的类，包含多个 Game Objects，于是 Level 的 tick 函数自然就是调用每个 GO 的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Level::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; id_object_pair : m_gobjects)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(id_object_pair.second);</span><br><span class="line">        <span class="keyword">if</span> (id_object_pair.second)</span><br><span class="line">        &#123;</span><br><span class="line">            id_object_pair.second-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_current_active_character &amp;&amp; g_is_editor_mode == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_current_active_character-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了调用每个 GO 的 tick ，最后还判断了是否有当前激活的角色和是否在编辑模式，如果不在编辑模式且存在激活的角色（也就是可被控制的角色），就调用该角色的 tick。角色 Character 类可以通过游戏对象 GObject 类来创建，因此它们都属于游戏对象，而 GObject 类的成员如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GObjectID   m_id &#123;k_invalid_gobject_id&#125;;</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::string m_definition_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to use the ReflectionPtr due to that the components need to be reflected </span></span><br><span class="line">    <span class="comment">// in editor, and it&#x27;s polymorphism</span></span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br></pre></td></tr></table></figure><p>每一个 GO 包含唯一的 GID 标识，名字，读取的链接以及各种组件，这些组件需要使用反射，因为组件有许多不同的类型，比如动画组件、mesh 组件、运动组件、相机组件等等，并且这些组件还要显示在组件面板，所以需要用到反射机制。于是每一个 GO 的 tick 就是调用它所有组件的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GObject::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : m_components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldComponentTick</span>(component.<span class="built_in">getTypeName</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            component-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不同组件的 tick 自然就是对应于动画、物理、相机运动、物体形变等各个逻辑系统的运算。</p><h4 id="1-2-输入管理系统"><a href="#1-2-输入管理系统" class="headerlink" title="1.2 输入管理系统"></a>1.2 输入管理系统</h4><p>输入管理系统 <code>InputSystem</code> 类自然是用来管理鼠标、键盘的各种输入并作出响应，这里不多赘述。</p><h3 id="2-swapLogicRenderData"><a href="#2-swapLogicRenderData" class="headerlink" title="2 swapLogicRenderData"></a>2 swapLogicRenderData</h3><p>逻辑系统运算完毕后，这一帧的世界就构建完成了，但是逻辑运算是在当前世界上进行的，如果世界的资源发生了改变，那么逻辑系统告诉渲染系统更新了哪些资源，渲染系统要获取这些资源加入到渲染资源中，这是通过渲染系统中的 <code>swapLogicRenderData</code> 函数完成的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::swapLogicRenderData</span><span class="params">()</span> </span>&#123; m_swap_context.<span class="built_in">swapLogicRenderData</span>(); &#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数调用了渲染系统的成员 <code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数， <code>m_swap_context</code> 属于 <code>RenderSwapContext</code> 类，其中包含要交换的数据 <code>RenderSwapData</code>，<code>RenderSwapData</code> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderSwapData</span></span><br><span class="line">&#123;</span><br><span class="line">    std::optional&lt;LevelResourceDesc&gt;      level_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_to_delete;</span><br><span class="line">    std::optional&lt;CameraSwapData&gt;         camera_swap_data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDirtyGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDeleteGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中包含关卡资源、游戏对象、相机数据，这些都是在逻辑系统计算的。这里使用了 C++ 17 的新特性 <code>optional</code>，为了之后可以通过 <code>has_value</code> 函数快速判断是否需要在渲染系统中更新这些资源的数据。</p><p><code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swapLogicRenderData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isReadyToSwap</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RenderSwapContext::isReadyToSwap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(m_swap_data[m_render_swap_data_index].level_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_to_delete.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].camera_swap_data.<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resetLevelRsourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectResourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectToDelete</span>();</span><br><span class="line">    <span class="built_in">resetCameraSwapData</span>();</span><br><span class="line">    std::<span class="built_in">swap</span>(m_logic_swap_data_index, m_render_swap_data_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其功能就是当需要在渲染系统中更新这些资源的数据时就进行数据交换操作。</p><h3 id="3-rendererTick"><a href="#3-rendererTick" class="headerlink" title="3 rendererTick"></a>3 rendererTick</h3><p>接下来就是最重要的 rendererTick 了，rendererTick 调用了渲染系统的 tick 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::rendererTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染系统的 tick 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process swap data between logic and render contexts</span></span><br><span class="line">    <span class="built_in">processSwapData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare render command context</span></span><br><span class="line">    m_rhi-&gt;<span class="built_in">prepareContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame buffer</span></span><br><span class="line">    m_render_resource-&gt;<span class="built_in">updatePerFrameBuffer</span>(m_render_scene, m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame visible objects</span></span><br><span class="line">    m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                         m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare pipeline&#x27;s render passes data</span></span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">preparePassData</span>(m_render_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render one frame</span></span><br><span class="line">    <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是处理从逻辑系统交换来的数据，也就是根据场景或者 GO 是否有变化从硬盘加载对应的资源或者卸载部分资源，然后准备渲染的各种数据。这些数据包括：</p><ul><li>变换矩阵、场景的光源数据，这通过 <code>updatePerFrameBuffer</code> 函数来设定，该函数根据场景和相机来获取矩阵和场景的光照信息，而整个渲染场景的光源在系统初始化的时候会进行构建，之后不会改变，相机会在逻辑 tick 中改变；</li><li>可见的物体数据，这通过 <code>updateVisibleObjects</code> 函数进行，实际上就是在进入渲染之前，把完全不可见的物体剔除掉。</li></ul><p>数据准备完毕后准备渲染的 Pass，最后根据指定的渲染模式进行前向渲染或者延迟渲染。</p><p>下一节开始我们将学习这些流程的具体实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们了解了引擎的整体运行流程以及反射机制的实现，这一节开始探究 Piccolo 的渲染系统是如何实现的，首先来了解渲染系统的整个流程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Piccolo引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Piccolo%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【Piccolo代码解读】整体框架与反射机制</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/</id>
    <published>2022-06-17T02:24:42.000Z</published>
    <updated>2022-07-02T09:43:20.737Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要了解 Piccolo 游戏引擎的代码框架、对象序列化的实现以及反射机制的实现。</p><p><em><span id="more"></span></em></p><h3 id="1-引擎运行结果"><a href="#1-引擎运行结果" class="headerlink" title="1 引擎运行结果"></a>1 引擎运行结果</h3><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220619142030660.png" alt="image-20220619142030660"></p><h3 id="2-代码整体框架"><a href="#2-代码整体框架" class="headerlink" title="2 代码整体框架"></a>2 代码整体框架</h3><p>Pilot 引擎除了第三方库之外，主要包含四部分，分别是编辑器、预编译、引擎运行时核心和 Shader 编译，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220617091342823.png" alt="image-20220617091342823"></p><p>其中预编译部分负责预先生成一些文件，比如用来实现反射的文件，会在后文中提到，Shader 编译部分在之后的渲染系统代码中也会说到。编辑器负责整个引擎的界面、工具等的实现，需要引擎核心部分作为成员，是引擎核心功能对使用者的接口；引擎核心部分按照<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-游戏引擎架构/">【游戏引擎】（一）游戏引擎架构</a>中的分层结构实现，分别是核心层、功能层、平台层、资源层：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220617092113728.png" alt="image-20220617092113728"></p><p>而 engine.cpp 负责将这些系统整合起来构成完整的运行时引擎。</p><p>整个引擎的主函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;runtime/engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;editor/include/editor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_XSTR(s) PILOT_STR(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_STR(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::filesystem::path pilot_root_folder = std::filesystem::<span class="built_in">path</span>(<span class="built_in">PILOT_XSTR</span>(PILOT_ROOT_DIR));</span><br><span class="line"></span><br><span class="line">    Pilot::EngineInitParams params;</span><br><span class="line">    params.m_root_folder      = pilot_root_folder;</span><br><span class="line">    params.m_config_file_path = pilot_root_folder / <span class="string">&quot;PilotEditor.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEngine* engine = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEngine</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">startEngine</span>(params);</span><br><span class="line">    engine-&gt;<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEditor* editor = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEditor</span>();</span><br><span class="line">    editor-&gt;<span class="built_in">initialize</span>(engine);</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    engine-&gt;<span class="built_in">shutdownEngine</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从主函数出发可以大概了解引擎运行时的整体架构。主函数中首先初始化了运行时引擎，然后启动和初始化引擎，之后用运行时引擎初始化编辑器，再让编辑器运行，编辑器运行结束后先清理编辑器内容再清理引擎内容。</p><p>其中关键的函数就是 <code>editor-&gt;run()</code> 了，函数内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEditor::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m_engine_runtime);</span><br><span class="line">    <span class="built_in">assert</span>(m_editor_ui);</span><br><span class="line">    <span class="type">float</span> delta_time;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delta_time = m_engine_runtime-&gt;<span class="built_in">calculateDeltaTime</span>();</span><br><span class="line">        g_editor_global_context.m_scene_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        g_editor_global_context.m_input_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        <span class="keyword">if</span> (!m_engine_runtime-&gt;<span class="built_in">tickOneFrame</span>(delta_time))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断了运行时引擎和引擎 UI 是否初始化成功，然后就是运行时主循环了，循环内就是各种 <code>tick()</code> 函数，其中最重要的是运行时引擎的 <code>tickOneFrame</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中包含 <code>logicalTick()</code> 和 <code>rendererTick()</code> 两部分，和我们之前笔记中描述的流程完全一致，当窗口关闭时函数返回 false，于是引擎主循环就会退出。</p><h3 id="3-代码反射"><a href="#3-代码反射" class="headerlink" title="3 代码反射"></a>3 代码反射</h3><p>代码反射是指允许在运行时检查已知数据类型。 反射允许枚举给定程序集中的数据类型，并且可以发现给定类或值类型的成员。 无论类型在编译时是已知的还是引用的，都是如此。 这使得反射成为开发和代码管理工具的有用功能。</p><p>定义很抽象，通过一个实际场景来理解，比如引擎中对于不同对象要显示出它的组件，但是不同对象的属性不同，我们不可能为每个类都编写一个组件面板，这时通过反射，就可以快速方便的知道一个类中有哪些成员变量，他们都是什么类型。</p><p>反射的另一个作用是在对象序列化时使用，所谓序列化就是存储到磁盘上，将对象变成一定格式的二进制文件或者自定义格式的文件（如json），然后要用的时候再将保存在磁盘上的文件转化成一个内存中的对象，这个过程中总是需要有一个指示来告诉编译器要生成什么样的对象，最简单的方式当然就是类名了，例如：将一个 ClassXXX 对象存储到磁盘上，再从磁盘读取的时候让编译器根据 “ClassXXX” 名称来 new 一个对象。但问题是，C++ 语言本身不支持反射，也就是说不能通过类的名称字符串来生成一个对象，像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassXXX object = <span class="keyword">new</span> “ClassXXX”;</span><br></pre></td></tr></table></figure><p>于是就需要反射机制来实现这个功能。</p><p>反射的实现方法是，提前处理需要反射的类型，生成一个类似配置文件的东西，在 Pilot 引擎中也是一个 C++ 文件，在预编译阶段生成，文件中包含一个类有哪些属性变量、父类。这些属性变量的 get 、set、getFieldName 获取变量的名字、getFieldTypeName 获取变量的类型、isArray_id 是不是数组等方法，都被封装成一个结构体，与类型的名字（字符串类型）做一个映射（map）。<br>在运行的时候加载这些配置表，这样我们其实通过一个类型的名字就可以知道他有什么变量，以及这些变量的具体属性和方法，然后就可以把这个类型当做一个方法集，与类型的实例挂钩就可以方便的处理这个实例的各个属性。</p><p>接下来我们以常用的 Vector3 类为例，来看看 Pilot 中的反射实现。首先是类的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REFLECTION_TYPE</span>(Vector3)</span><br><span class="line"><span class="built_in">CLASS</span>(Vector3, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(Vector3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> y &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> z &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了三个宏定义，他们都在 <code>reflection.h</code> 中定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS(class_name, ...) class class_name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_BODY(class_name) \</span></span><br><span class="line"><span class="meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">    friend class PSerializer;</span></span><br><span class="line">    <span class="comment">// public: virtual std::string getTypeName() override &#123;return #class_name;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_TYPE(class_name) \</span></span><br><span class="line"><span class="meta">    namespace Reflection \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        namespace TypeFieldReflectionOparator \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            class Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br></pre></td></tr></table></figure><p>可以看到首先声明了与类名称有关的 <code>Type##class_name##Operator</code> 类，<code>##</code> 是连接符，将两个字符串连接起来，这里生成的类则Iran就是 <code>TypeVector3Operator</code>，然后将该类和序列化类 <code>PSerializer</code> 作为了 Vector3 类的友元。</p><p><code>TypeVector3Operator</code> 类在 <code>vector3.reflection.gen.h</code> 文件中定义，这个文件是预编译阶段生成的，其中定义的就是对该类的各种回调函数，包括返回类名称，序列化类对象，通过序列化的 json 文件构建该类的对象，获取该类的基类，以及上面说到的对成员变量的各种方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;D:/TechStack/GamesEngine/PilotEngine/Pilot-main/engine/source/runtime/core/math/vector3.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Pilot&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector3</span>;</span><br><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line"><span class="keyword">namespace</span> TypeFieldReflectionOparator&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">TypeVector3Operator</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getClassName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Vector3&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">constructorWithJson</span><span class="params">(<span class="type">const</span> PJson&amp; json_context)</span></span>&#123;</span><br><span class="line">          Vector3* ret_instance= <span class="keyword">new</span> Vector3;</span><br><span class="line">          PSerializer::<span class="built_in">read</span>(json_context, *ret_instance);</span><br><span class="line">          <span class="keyword">return</span> ret_instance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> PJson <span class="title">writeByName</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> PSerializer::<span class="built_in">write</span>(*(Vector3*)instance);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// base class</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getVector3BaseClassReflectionInstanceList</span><span class="params">(ReflectionInstance* &amp;out_list, <span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// fields</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;y&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_y</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_y</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;z&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_z</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_z</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="comment">//namespace TypeFieldReflectionOparator</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">TypeWrapperRegister_Vector3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_x=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_x);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_x);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_y=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_y);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_y);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_z=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_z);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_z);</span><br><span class="line">       ClassFunctionTuple* f_class_function_tuple_Vector3=<span class="keyword">new</span> <span class="built_in">ClassFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getVector3BaseClassReflectionInstanceList,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::constructorWithJson,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::writeByName);</span><br><span class="line">       <span class="built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_class_function_tuple_Vector3);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">namespace</span> TypeWrappersRegister&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Vector3</span><span class="params">()</span></span>&#123; <span class="built_in">TypeWrapperRegister_Vector3</span>();&#125;</span><br><span class="line">&#125;<span class="comment">//namespace TypeWrappersRegister</span></span><br><span class="line">&#125;<span class="comment">//namespace Reflection</span></span><br><span class="line">&#125;<span class="comment">//namespace Pilot</span></span><br></pre></td></tr></table></figure><p>上面的代码中还有注册这些回调函数的函数 <code>TypeWrapperRegister_Vector3</code>，函数中就是对所有成员的方法进行了注册，所谓注册就是将这些函数和类型名称对应起来，放到哈希表中，实现方法是用变量的各种方法初始化一个 <code>FieldFunctionTuple</code> 元组，这个元组的声明同样在 <code>reflection.h</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*, <span class="type">void</span>*)&gt;      SetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">void</span>*)&gt;            GetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">const</span> <span class="type">char</span>*()&gt;           GetNameFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span>*)&gt; SetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">int</span>, <span class="type">void</span>*)&gt;       GetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">void</span>*)&gt;              GetSizeFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">bool</span>()&gt;                  GetBoolFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">const</span> PJson&amp;)&gt;                          ConstructorWithPJson;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;PJson(<span class="type">void</span>*)&gt;                                 WritePJsonByName;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt;</span><br><span class="line">    FieldFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetBaseClassReflectionInstanceListFunc, ConstructorWithPJson, WritePJsonByName&gt;</span><br><span class="line">    ClassFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetArrayFunc, GetArrayFunc, GetSizeFunc, GetNameFuncion, GetNameFuncion&gt; ArrayFunctionTuple;</span><br></pre></td></tr></table></figure><p>元组中存放的就是各类函数的指针，然后通过一个宏定义 <code>REGISTER_FIELD_TO_MAP</code> 注册这些函数，该宏定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_FIELD_TO_MAP(name, value) TypeMetaRegisterinterface::registerToFieldMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_BASE_CLASS_TO_MAP(name, value) TypeMetaRegisterinterface::registerToClassMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_ARRAY_TO_MAP(name, value) TypeMetaRegisterinterface::registerToArrayMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNREGISTER_ALL TypeMetaRegisterinterface::unregisterAll();</span></span><br></pre></td></tr></table></figure><p>实际上宏定义就是调用了 <code>TypeMetaRegisterinterface</code> 类中的方法，该类是用来注册各种回调函数的接口，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeMetaRegisterinterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unregisterAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类中的各种方法就是用来将给定的函数指针元组和类名称关联起来，存放到全局定义的哈希表中，以类名为键，这样之后使用时通过类名就可以找到类中各种成员变量的名称、类型、方法了，这部分在 <code>reflection.cpp</code> 中实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown_type = <span class="string">&quot;UnknownType&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown      = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;      m_class_map;</span><br><span class="line">    <span class="type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt; m_field_map;</span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;      m_array_map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_field_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_array_map.<span class="built_in">find</span>(name) == m_array_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_array_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_class_map.<span class="built_in">find</span>(name) == m_class_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_class_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::unregisterAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_field_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_field_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_class_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_class_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_array_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_array_map.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有需要反射的类都会在运行时引擎启动时进行注册，也就是之前主函数中的 <code>engine-&gt;startEngine()</code> 函数，该函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::startEngine</span><span class="params">(<span class="type">const</span> EngineInitParams&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_init_params = param;</span><br><span class="line"></span><br><span class="line">    Reflection::TypeMetaRegister::<span class="built_in">Register</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.<span class="built_in">startSystems</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;engine start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>TypeMetaRegister</code> 类就是用来注册函数的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> Pilot</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Reflection</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TypeMetaRegister</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Register</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Unregister</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="comment">// namespace Reflection</span></span><br><span class="line">&#125; <span class="comment">// namespace Pilot</span></span><br></pre></td></tr></table></figure><p><code>Register()</code> 函数就是调用了各个类的注册函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TypeMetaRegister::Register</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Transform</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Quaternion</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Vector3</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于对象序列化和反射的使用示例，Pilot 也提供了一个样例代码，在 <code>meta/meta_example.cpp</code> 中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要了解 Piccolo 游戏引擎的代码框架、对象序列化的实现以及反射机制的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Piccolo引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Piccolo%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时光线追踪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-06-09T08:03:44.000Z</published>
    <updated>2022-07-09T07:41:59.734Z</updated>
    
    <content type="html"><![CDATA[<p>随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。</p><p><em><span id="more"></span></em></p><h3 id="1-实时光线追踪基本思路"><a href="#1-实时光线追踪基本思路" class="headerlink" title="1 实时光线追踪基本思路"></a>1 实时光线追踪基本思路</h3><p>NVIDIA 在 2018 年推出了 RTX 系列显卡，采用 Turing 架构，引入了专门处理光线追踪的 RT Core，使得光线追踪这种计算开销极大的算法能够实时运行。</p><p>实时光线追踪和离线光线追踪使用的算法完全一致，都是采样光线，计算交点，然后循环迭代，RTX 20 系列支持每秒 100 亿根光线的处理，这个数字看似很多，但实际上还要除以屏幕的分辨率，通常就是几千万个像素，还要除以帧率，因此最终实际上目前真正的实时光线追踪只能达到每帧每个像素采样一根光线。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609142644271.png" alt="image-20220609142644271"></p><p>可想而知这样得出的结果是噪声非常严重的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609142722281.png" alt="image-20220609142722281"></p><p>因此实时光线追踪的重点实际上不是光线追踪，而是如何对 1 SPP 的 RTRT 结果进行降噪，使其达到和离线光线追踪一样的效果。下图展示了现在的实时光线追踪降噪技术所能达到的效果，非常不可思议：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609142901751.png" alt="image-20220609142901751"></p><p>简单来说，实时光线追踪会首先生成一张 1 SPP 的 noisy 结果，然后对单帧进行图像空间降噪（Spatial Denoising），之后再联合前一帧图像（任何时候都假设前一帧已经没有噪声）进行时域降噪（Temporal Denoising），最终得到一帧没有噪声的结果。</p><h3 id="2-Spatial-Denoising"><a href="#2-Spatial-Denoising" class="headerlink" title="2 Spatial Denoising"></a>2 Spatial Denoising</h3><h4 id="2-1-联合双边滤波"><a href="#2-1-联合双边滤波" class="headerlink" title="2.1 联合双边滤波"></a>2.1 联合双边滤波</h4><p>单帧图像空间降噪简单的自然是使用低通滤波，比如高斯模糊，这样可以去掉高频的噪声，但同时也会丢掉图像中高频的信息，也就是一些细节，因此为了保留图像细节一般使用双边滤波（Bilateral Filtering）进行降噪。</p><p>双边滤波只是对高斯滤波的改进，高斯滤波只考虑了像素之间的距离作为权值的衰减因素，而为了保留高频信息，双边滤波还考虑了颜色，当两个像素的颜色差异过大时，权值也进一步变小，这样就可以保留原图中的边缘等高频信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609143945517.png" alt="image-20220609143945517"></p><p>上式中后一项是对颜色的距离进行了一个计算，这样相当于两个高斯分布的乘积作为一个像素周围其他像素的权值。</p><p>更进一步，既然可以考虑颜色，那么自然也可以考虑更多的因素，<strong>联合双边滤波（Joint Bilateral Filtering）</strong>就是将许多不同因素作为影响权值衰减的因素，除了像素之间的距离、颜色之外，还可以利用 G-Buffer 中存储的每个像素的深度、法线、反射率等等，因此联合双边滤波非常适合用来做 RTRT 的图像降噪，因为 G-Buffer 中的信息在渲染时就可以顺便得到，几乎不需要任何额外开销。</p><p>需要说明的是，上面是以高斯滤波为例的，实际上双边滤波或者联合双边滤波中的衰减系数不一定要是高斯分布的，可以是指数分布、余弦分布等等，只要能够描述衰减关系就可以。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609144749719.png" alt="image-20220609144749719"></p><p>下面以一个例子来说明联合双边滤波的作用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609144824808.png" alt="image-20220609144824808"></p><p>这是一张噪声很大的渲染结果，我们使用联合双边滤波考虑深度、法线、颜色的影响，于是在对点 B 进行滤波时，可能会将点 A 和点 C 的贡献加入到点 B，但是因为点 A 和点 B 的深度差异比较大，因此点 A 的贡献就会变小，而点 C 和点 B 的法线差异比较大，因此点 C 的贡献也会变小。而点 D 和点 E 的深度和法线相差不大，但颜色相差很大，因此权值也会变小，这样就可以得到比较好的滤波效果。</p><h4 id="2-2-大范围滤波优化"><a href="#2-2-大范围滤波优化" class="headerlink" title="2.2 大范围滤波优化"></a>2.2 大范围滤波优化</h4><p>这里还有一个问题需要讨论，因为使用联合双边滤波，我们的滤波核范围通常很大，不是通常的 5 <em> 5 或者 7 </em> 7，如果滤波核是 128 * 128，那么对每个像素进行滤波都要访问它周围一万多个像素，会非常耗时，因此需要对大滤波核的滤波进行优化，通常使用以下两种方法：</p><ul><li>Separate Passes：也就是将 128 <em> 128 的一次滤波分为 1 </em> 128 和 128 * 1 两次滤波，这样就可以大幅降低复杂度，只需要访问 256 次就可以完成之前访问一万多次的工作：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609145638690.png" alt="image-20220609145638690"></p><p>这么做可行的原因在于二维高斯分布本身就是两个一维高斯分布的乘积，因此也自然可以将一次二维滤波拆成两次一维滤波。但是对于双边滤波和联合双边滤波，不再是简单的二维高斯分布，因此不满足这样的特性，理论上不能使用这个方法，不过工业界依然使用这样的方法，在滤波核不是特别大的时候不会看出什么问题。</p><ul><li>Progressively Growing Sizes：这种方法将一个大的滤波拆分成多次小的滤波，但是每次小的滤波所取得周围像素的间隔会逐渐增大，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609150034090.png" alt="image-20220609150034090"></p><p>将一个 64 <em> 64 的滤波拆分成了 5 次 5 </em> 5 的滤波，第一次在像素周围 5 <em> 5 的区域进行，第二次取的像素之间都会间隔 2 个像素，第三次间隔 4 个像素，直到第 5 次，间隔 16 个像素，整个区域刚好就是 64 </em> 64，这样将 64 <em> 64 变成了 5 </em> 5 * 5，同样大幅降低了复杂度。</p><h4 id="2-3-异常像素移除"><a href="#2-3-异常像素移除" class="headerlink" title="2.3 异常像素移除"></a>2.3 异常像素移除</h4><p>异常像素移除（Outlier Removal）是在进行滤波之前做的一项工作，所谓异常像素（outlier）是指在噪声图像中会有一些非常亮的像素，如果不去除，那在滤波的时候这些非常亮的像素就会扩散到周围一定的区域造成异常：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609150605655.png" alt="image-20220609150605655"></p><p>去除他们的方法非常简单，对每一个像素，取它周围一定区域，通常是 7 * 7，然后求出这个区域内颜色的均值和方差，根据均值和方差可以确定一个范围：</p><script type="math/tex; mode=display">[\mu-k\sigma,\mu+k\sigma]</script><p>将不在这个范围内的像素颜色截断在这个范围内即可。</p><h3 id="3-Temporal-Denoising"><a href="#3-Temporal-Denoising" class="headerlink" title="3 Temporal Denoising"></a>3 Temporal Denoising</h3><h4 id="3-1-Motion-Vector"><a href="#3-1-Motion-Vector" class="headerlink" title="3.1 Motion Vector"></a>3.1 Motion Vector</h4><p>时域滤波是实时光线追踪能够实现的重要原因之一，基本思想就是假设前一帧总是没有噪声的，于是可以将这一帧的像素所显示的位置对应到前一帧的那个像素找到，将它的颜色和这一帧像素的颜色线性融合起来，实现非常好的降噪效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609151126653.png" alt="image-20220609151126653"></p><p>对于第 i 帧的一个像素，我们可以从 G-Buffer 中得到该像素对应的世界空间位置，如果没有 G-Buffer，还可以通过屏幕坐标逆变换得到世界空间坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609151336724.png" alt="image-20220609151336724"></p><p>然后我们在渲染的过程中一定知道这两帧之间物体是怎样移动的，因为我们掌控整个渲染过程，也就知道整个场景的变化过程，于是将当前帧的位置进行场景变换的逆变换，得到前一帧中该点的位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609151431056.png" alt="image-20220609151431056"></p><p>再利用前一帧的各种矩阵将该点投影到屏幕上，就得到了前一帧中对应的像素坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609151532403.png" alt="image-20220609151532403"></p><p>将该像素的颜色和当前帧的颜色进行融合：</p><script type="math/tex; mode=display">color_i = \alpha color_i + (1-\alpha)color_{i-1}</script><p>因为前一帧是没有噪声的图片，所以会让前一帧的颜色的权值更大，一般来说 $\alpha$ 取 0.1 到 0.2，也就是说当前帧的颜色有 80% 到 90% 取决于前一帧。</p><p>于是整个实时光线追踪去噪的过程可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609151859574.png" alt="image-20220609151859574"></p><p>其中带有 - 的表示滤波后的图片，带有 ~ 的表示没有滤波的图片，什么都没有的表示没有噪声的图片。上面的公式表示先对当前帧进行单帧的 Spatial Denoising，再联合前一帧进行 Temporal Denoising。</p><p>下图是 1 SPP 的 RTRT 结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152103914.png" alt="image-20220609152103914"></p><p>使用了上述去噪方法后得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152123879.png" alt="image-20220609152123879"></p><p>这里的图片相比于有噪声的结果看起来变亮了很多，但实际上并没有，只是因为 RTRT 得出的有噪声的结果中像素的颜色很大，经过色调映射显示出来就会显得很暗，去噪的过程一定是能量守恒的。</p><p>下面是离线光线追踪的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152151531.png" alt="image-20220609152151531"></p><p>可以看到除了一些物体接触的地方的阴影没有渲染出来之外，实时光线追踪的结果和离线结果非常接近。</p><h4 id="3-2-Temporal-的问题"><a href="#3-2-Temporal-的问题" class="headerlink" title="3.2 Temporal 的问题"></a>3.2 Temporal 的问题</h4><p>时域去噪方法效果很好，但存在很多问题：</p><ul><li>切换场景的时候，时域去噪会失效，因为前后两帧几乎没有任何对应关系：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152409311.png" alt="image-20220609152409311"></p><ul><li>当我们在一个场景中的倒退的时候也会有问题，因为倒退的时候会有更多场景中的景象进入视野，于是就会出现当前帧的某个地方在上一帧中还没出现：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152546782.png" alt="image-20220609152546782"></p><ul><li>还有当物体移动的时候，会对其他物体造成遮挡，前后两帧中遮挡关系不一样，导致同一个位置会对应到不同的物体上，造成拖影现象：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609152716311.png" alt="image-20220609152716311"></p><ul><li>以及由于光源移动造成的阴影拖影现象，虽然物体没有动，但是因为光照关系变了导致这一点的着色结果变了，从而使得后一帧融合了前一帧的颜色会显示出前一帧的拖影：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609153019170.png" alt="image-20220609153019170"></p><h4 id="3-3-Clamping"><a href="#3-3-Clamping" class="headerlink" title="3.3 Clamping"></a>3.3 Clamping</h4><p>解决上述问题的一个最简单的方法是将前一帧对应的像素的颜色截断到当前帧像素周边一定范围内颜色的均值附近，利用上面的异常像素移除的方法就可以实现，然后再融合到当前像素上，这样可以一定程度解决前后帧颜色不对应的情况，但对于切换场景等情况也无能为力。此外由于将没有噪声的颜色截断到了有噪声的颜色范围内，一定会引入新的噪声。</p><h4 id="3-4-其他解决方案"><a href="#3-4-其他解决方案" class="headerlink" title="3.4 其他解决方案"></a>3.4 其他解决方案</h4><p>Clamping 自然是一个简单的解决方案，但会引入新的问题，对于遮挡、阴影、Glossy 等情况如何寻找上一帧可用的像素信息是一个相对复杂的问题，一些更好的解决方案可以参考<a href="https://zhuanlan.zhihu.com/p/376502501#:~:text=Motion">实时渲染｜Filtering and Denoising：Temporal Reliable Motion Vector</a>中提到的方法。</p><h3 id="4-SVGF"><a href="#4-SVGF" class="headerlink" title="4 SVGF"></a>4 SVGF</h3><p>Spatiotemporal Variance-Guided Filtering 是一个实时光线追踪的具体解决方案，流程和我们上面说到的一致，只是在滤波核的设计上加入了一些更周全的考虑，因此可以得到非常好的效果。</p><p>SVGF 同样考虑了三个因素来影响滤波权值衰减：深度、法线和颜色。</p><p>对于深度，如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609153703827.png" alt="image-20220609153703827"></p><p>由于箱子是侧对我们的，点 A 和点 B 的深度会有差异而使得滤波时的权值变小，但实际上他们属于同一面，不应该因为深度差异是他们的融合权值变小，因此引入了深度的梯度来修正这个影响，其中 $\epsilon$ 是为了防止两个点距离过近导致分母为 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609153851851.png" alt="image-20220609153851851"></p><p>对于法线，使用了两点法线的点乘来作为衰减因素，同时加了一个指数来控制衰减的速度，这个指数和布林冯模型中高光的指数作用完全一致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609154028387.png" alt="image-20220609154028387"></p><p>对于颜色，SVGF 使用的是光照度，也就是像素的灰度值，首先计算了像素周围 7 <em> 7 范围内的灰度方差，然后还将这个方差进行了时域上的平均，最后在当前帧又取了周围 3 </em> 3 区域的方差来进行滤波衰减：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220609154224920.png" alt="image-20220609154224920"></p><p>SVGF 速度快效果好，但是拖影问题依然存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时PBR材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/</id>
    <published>2022-06-08T10:06:47.000Z</published>
    <updated>2022-06-13T03:32:47.691Z</updated>
    
    <content type="html"><![CDATA[<p>在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈微表面"><a href="#1-再谈微表面" class="headerlink" title="1 再谈微表面"></a>1 再谈微表面</h3><p>通过之前的学习可以发现，实时渲染的各种方法实际上都是在离线渲染的基础上，做各种假设和近似来快速得到一个近似地效果，材质也不例外，基于物理的材质最常用的就是微表面模型，实时渲染中同样使用微表面模型，因此我们首先来回顾微表面模型的内容。</p><p>微表面 BRDF 由菲涅尔项 F，几何项 G 和法线分布函数 D 组成，描述了从某个入射方向来的光会向某个出射方向反射出多少能量：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608160027871.png" alt="image-20220608160027871"></p><h4 id="1-1-菲涅尔项"><a href="#1-1-菲涅尔项" class="headerlink" title="1.1 菲涅尔项"></a>1.1 菲涅尔项</h4><p>菲涅尔项描述了随着入射方向和法线夹角增大，反射会变得越来越强的现象：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608160157916.png" alt="image-20220608160157916"></p><p>对于非导体，入射方向与法线夹角和反射率的关系为：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608160244963.png" alt="image-20220608160244963"></p><p>即当我们沿着法线方向观察的时候几乎不会看到反射，而当我们垂直于法线方向观察的时候会看到物体几乎全部被反射。</p><p>对于导体（金属），菲涅尔曲线为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608160343753.png" alt="image-20220608160343753"></p><p>即导体本身就会发生强烈的反射，随着视角变化，观察到的反射不会有太大的变化，因此可以说金属本身就会有比较固定的颜色（反射率），比如金、银、铜都有自己的颜色。</p><p>菲涅尔项表达式非常复杂，与介质和材质的折射率有关，一般在渲染中使用 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608160608070.png" alt="image-20220608160608070"></p><p>总的来说，菲涅尔项描述了对于给定的入射方向和出射方向（半程向量），会有多少光从入射方向反射到出射方向上，一般来说渲染的时候出射方向固定，就是观察方向，那么不同入射方向的光反射到观察方向上的比例就不同，这是菲涅尔项的意义。</p><h4 id="1-2-法线分布函数"><a href="#1-2-法线分布函数" class="headerlink" title="1.2 法线分布函数"></a>1.2 法线分布函数</h4><p>法线分布函数描述了物体表面有多少微表面的法线和给定的半程向量方向一致，那么这些微表面才会被看到（只考虑镜面反射）。这是一个宏观的理解，实际上 NDF 描述的就是微表面的法线的概率分布：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608161221287.png" alt="image-20220608161221287"></p><p>有不同的模型来描述法线分布，比如之前提到过的 Beckmann 法线分布函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608161340128.png" alt="image-20220608161340128"></p><p>该函数由表面粗糙程度 $\alpha$ 和微表面法线与宏观法线（一般是 [0, 0, 1]）的夹角 $\theta_h$ 来定义，从公式可以看出，Beckmann 法线分布实际上和高斯分布非常像，其中表面粗糙程度 $\alpha$ 就类似于正态分布的标准差，粗糙程度越大，法线分布就越分散，而这个正态分布是对于 $tan\theta_h$ 的正态分布， $tan\theta_h$ 的几何意义如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608161702625.png" alt="image-20220608161702625"></p><p>如果直接定义为夹角 $\theta_h$ 的正态分布，那么法线可能取到下半球，夹角就大于 90 度，而对于法线来说只有上半球有意义，因此定义为 $tan\theta_h$ 的正态分布的好处在于可以把上半球的所有法线方向对应到一个平面上的区间，这个区间是无穷大的，刚好是正态分布的积分区间，这样定义自然当法线在下半球的时候没有意义，是一个很巧妙的处理。</p><p>另一个更好的法线分布函数是 GGX 模型，也叫做 Trowbridge-Reitz（TR）模型，相较于 Beckmann 模型，GGX 是长尾（long tail）分布的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608162529565.png" alt="image-20220608162529565"></p><p>也就是过度更加平滑，在值较小的部分衰减速度也更小，这样的好处是高光区域和非高光区域的过渡会更加平滑，呈现出一种 Glossy 的效果，更加真实：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608162719493.png" alt="image-20220608162719493"></p><p>在 TR 模型的基础上还有一个更加通用的 GTR 法线分布，引入了一个可调的参数来控制长尾分布的程度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608162902522.png" alt="image-20220608162902522"></p><p>总之，法线分布函数描述的是微表面的法线方向分布，对于给定的入射和出射方向，可以得到半程向量，法线分布函数可以给出这个材质的表面上有多少微表面的法线是在这个半程向量方向上的，那么这些微表面才可以被看到。更准确的说，NDF 描述的是法线方向的概率分布，渲染时，对于每一个着色点都有不同的半程向量，这个半程向量对应的可以被看到的概率可以通过 NDF 得出，可以被看到也就是表面法线和半程向量方向一致，因此 NDF 给出的概率实际上是当前着色点的法线刚好和当前半程向量重合的概率，而一个点的着色结果是许多不同的半程向量的结果的加权平均，权值就是这个概率，这样就能得到这个着色点正确期望的着色结果。</p><h4 id="1-3-几何项"><a href="#1-3-几何项" class="headerlink" title="1.3 几何项"></a>1.3 几何项</h4><p>几何项描述的是微表面之间的自遮挡现象，自遮挡现象有两种情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608163456607.png" alt="image-20220608163456607"></p><p>一种是入射光被其他微表面遮挡入射不进来，一种是反射光被其他微表面遮挡反射不出去，前者称为 shadowing，后者称为 masking，因此几何项也被称为 Shadowing-Masking Term。</p><p>从上面的定义可以看出，当我们垂直于表面观察时，几乎不会发生自遮挡，当我们观察方向越接近法线的垂直方向，自遮挡就会越严重，因此对应于上面的法线分布得出的几何项分布大概长这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608163757728.png" alt="image-20220608163757728"></p><p>几何项的意义在于，当我们垂直于表面观察的时候，几何项就是 1，对最终结果不会有任何影响，但是当我们接近垂直于法线的方向观察时，比如一个球体的边缘：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608163914474.png" alt="image-20220608163914474"></p><p>如果不考虑几何项，那么按照微表面 BRDF 的定义：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608163942337.png" alt="image-20220608163942337"></p><p>其他两项可以计算出正常结果，但是分母中有观察方向和法线的点乘，由于我们是接近垂直于法线的方向观察的，那么这个点乘结果就会接近于 0，于是整个BRDF 结果就会非常大，如果没有几何项来修正这个结果，那么最终的渲染图像上球体边缘就会是一圈白色。根据上面的几何项曲线可以看出，几何项在夹角接近 90 度的时候迅速变为 0，从而修正了这个非常大的结果。</p><h3 id="2-Kulla-Conty-Approximation"><a href="#2-Kulla-Conty-Approximation" class="headerlink" title="2 Kulla-Conty Approximation"></a>2 Kulla-Conty Approximation</h3><p>上面回顾了微表面模型，并进一步深入理解了各个项的作用，通过上面的分析我们可以很容易得出一个结论：微表面模型只考虑了光线在微表面之间的一次反射。被挡住的光线就认为看不到，这样做的结果就是微表面模型是能量不守恒的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608164659865.png" alt="image-20220608164659865"></p><p>随着粗糙程度增大，最终的渲染结果会越来越暗，因为粗糙程度越大意味着法线分布越分散，从而微表面之间的遮挡也会越严重，在微表面模型中被遮挡掉的能量就被丢掉不考虑了，所以自然会越来越暗。</p><p>实际上被遮挡的光线还会在微表面之间弹射从而被看到，因此为了解决这个问题，提出了 Kulla-Conty 估计，用来近似估计光线在微表面之间的多次弹射。</p><p>Kulla-Conty 估计基于一个关键思想：微表面 BRDF 只考虑了没有被遮挡的能量，那么如果能再设计一个 BRDF 来专门描述被遮挡的能量就可以修正微表面的结果了。</p><p>于是首先要知道没有被遮挡的能量是多少，我们假设入射光强度恒为 1，然后对微表面 BRDF 的渲染方程在整个半球面上积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608165256048.png" alt="image-20220608165256048"></p><p>注意上面的式子中用了一个简单的积分换元，把 $d\theta$ 换成了 $dsin\theta$，这样一来原本渲染方程中的 cos 项也就没有了，光照项为常数 1，因此上面的积分结果就代表了微表面模型中在出射方向 $\mu_o$ 上全部被看到的能量总和，因为光照项为 1，所以该结果是一个系数，表示出射方向 $\mu_o$ 上被看到的能量占全部能量的比例。</p><p>于是因为遮挡而没被看到的能量总和自然就是 $1-E(\mu_o)$，因此，我们要设计一个 BRDF 来专门描述被遮挡的能量，那么这个 BRDF 在半球面上的积分结果就必须是 $1-E(\mu_o)$。</p><p>考虑到 BRDF 具有双向可逆性，因此 Kulla-Conty 估计设计了这样一个 BRDF：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608165644101.png" alt="image-20220608165644101"></p><p>这个 BRDF 的形式并不是唯一的，只要能保证函数在半球的积分结果是 $1-E(\mu_o)$ 就可以，只是 Kulla-Conty 这样设计既把积分结果本身放到了函数中，还考虑了双向可逆的性质，非常巧妙。</p><p>于是通过积分结果为 $1-E(\mu_o)$ 可以求出常数 c：</p><script type="math/tex; mode=display">c = \frac{1}{\pi(1-E_{avg})}</script><p>其中：</p><script type="math/tex; mode=display">E_{avg} = \frac{\int_0^1E(\mu)\mu d\mu}{\int_0^1\mu d\mu} = 2\int_0^1E(\mu)\mu d\mu</script><p>相当于对上面的 $E(\mu_o)$ 做了一个加权平均，权值就是各个方向的夹角正弦 $\mu$，于是整个 Kulla-Conty 估计就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608170245422.png" alt="image-20220608170245422"></p><p>容易验证该函数在半球面上积分结果为 $1-E(\mu_o)$：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608170313862.png" alt="image-20220608170313862"></p><p>因此这个函数可以作为描述被遮挡的能量的 BRDF，现在的问题是 $E_{avg}$ 是对一个积分 $E(\mu)$ 再进行积分，实时计算起来比较复杂，所以需要进行预计算。</p><p>对于 $E(\mu)$ 这个积分，是对全部入射方向 $\mu_i$ 的积分，因此积分结果只与观察方向和法线的夹角正弦 $\mu_o$ 和粗糙程度 $\alpha$ 有关，于是预计算的积分结果可以用一张二维纹理来存储：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608171651408.png" alt="image-20220608171651408"></p><p>而对于 $E_{avg}$ 这个积分，是对 $\mu_o$ 的积分，所以积分结果只与粗糙程度 $\alpha$ 有关，只需要一个一维纹理就可以存储。</p><p>将 Kulla-Conty 的结果加到微表面 BRDF 的结果上就可以近似模拟光线在微表面之间多次弹射的结果，达到能量守恒：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608172124188.png" alt="image-20220608172124188"></p><p>接下来还有最后一个问题，上面的所有推导都是假设物体表面没有颜色，也就是反射率恒为 1，如果物体表面有颜色，那么能量在每次弹射后都会损失，如何计算这种损失来得到正确的结果呢？</p><p>Kulla-Conty 又计算了菲涅尔项的加权平均：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608172427624.png" alt="image-20220608172427624"></p><p>这表示每次弹射，表面上有多少能量被反射。这类似于上面的 $E<em>{avg}$， $E</em>{avg}$ 表示表面上有多少能量没被遮挡能够被看到，于是我们可以直接看到的能量就可以表示为：</p><script type="math/tex; mode=display">F_{avg}E_{avg}</script><p>没被看到的能量就是：</p><script type="math/tex; mode=display">F_{avg}(1-E_{avg})</script><p>这部分能量会在微表面之间继续弹射，于是经过一次弹射后被我们看到的能量就是：</p><script type="math/tex; mode=display">F_{avg}(1-E_{avg})·F_{avg}E_{avg}</script><p>以此类推，可以写出经过无数次弹射后的能量，将这些能量加起来，就可以得到当物体有颜色的时候，光线在微表面之间多次弹射后反射出的能量，这是一个级数求和问题，最终的结果是：</p><script type="math/tex; mode=display">\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}</script><p>将这个系数乘到 Kulla-Conty 的 BRDF 上就可以得到有颜色的情况下被遮挡的能量的 BRDF 了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608173223545.png" alt="image-20220608173223545"></p><h3 id="3-Linearly-Transformed-Cosines（LTC）"><a href="#3-Linearly-Transformed-Cosines（LTC）" class="headerlink" title="3 Linearly Transformed Cosines（LTC）"></a>3 Linearly Transformed Cosines（LTC）</h3><p>有了微表面 BRDF，另一个需要解决的问题是如何使用微表面模型进行渲染。线性变换余弦（LTC）方法是用来解决多边形面光源下，使用微表面 BRDF，主要是 GGX 法线模型的渲染而提出的方法（不考虑阴影）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608173712743.png" alt="image-20220608173712743"></p><p>当然 LTC 不仅适用于上述情况，对于类似 GGX 法线分布的其他微表面模型也都有很好的效果。</p><p>在离线渲染中处理这样的渲染自然是对面光源进行采样计算，但实时渲染需要快速得到渲染结果，而不同的 BRDF 我们不知道它的分布是什么样的，所以也不容易快速求出这个 BRDF 积分的渲染方程的解析解，因此 LTC 将 BRDF 变换成一个 cos 函数，然后对所有的方向、以及面光源（积分区域）都做同样的变换：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608174038845.png" alt="image-20220608174038845"></p><p>这样就将原积分转化为了一个对余弦函数的积分，保证可以快速求出解析解。具体来说，就是将原本的函数 $F(w_i)$ 变换为 $cos(w_i)$，为了便于理解，我们假设 BRDF 是各向同性的，于是 $F(w_i)$ 实际上和方位角无关，在出射方向固定的情况下就是一个只与俯仰角有关的一维函数，所以可以变换到一维的 cos 函数上，事实上 LTC 也可以处理各向异性的情况，这里就不展开讨论了。</p><p>然后将积分变量 $dw<em>i$ 同样变换为 $dw’</em>{i}$，实际上就是对原积分进行了换元：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608174727016.png" alt="image-20220608174727016"></p><p>这样就可以快速求出解析解了。LTC 方法虽然思路很简单，但是效果却非常优秀，因此目前被广泛使用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608174837806.png" alt="image-20220608174837806"></p><h3 id="4-Disney’s-Principled-BRDF"><a href="#4-Disney’s-Principled-BRDF" class="headerlink" title="4 Disney’s Principled BRDF"></a>4 Disney’s Principled BRDF</h3><p>Disney’s Principled BRDF 是目前工业界非常知名的，非常强大的开源 BRDF。微表面 BRDF 的问题之一在于不能够表达复合材质，现实世界中许多材质不是单一的，是多种材质的组合，比如蒙上一层塑料布的木头桌子，那么它的表面就有多层材质，光照表现自然和普通桌子不同，而 Disney’s Principled BRDF 具有强大的表达能力，可以表达各种复合材质。</p><p>并且 Disney’s Principled BRDF 摒弃了传统基于物理的材质的各种物理参数，只使用一些非常符合人直觉的参数就可以进行调节，对于艺术家非常友好，这也是迪士尼设计这个 BRDF 的原则之一，这些原则有：</p><ul><li>使用符合人直觉的参数而不是各种难懂的物理量</li><li>越少的参数越好</li><li>所有参数都是从 0 到 1 调节的</li><li>在一些合理的情况下允许参数不在 0 到 1 范围内</li><li>所有参数的任意组合都必须得出合理的结果，而不是某些非常奇怪的结果</li></ul><p>能够满足上述原则的 BRDF 可以说是完美的，虽然严格来说迪士尼的 BRDF 不是基于物理的，而是进行了各种非常复杂的拟合，但是也常被归为基于物理的 BRDF。</p><p>下图是一些可以调节的参数和得出的材质效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220608175902209.png" alt="image-20220608175902209"></p><p>从上到下依次是：</p><ul><li>次表面散射 subsurface：值越大次表面散射越严重，物体看起来更像一个平面</li><li>金属度 metallic：值越大物体越像金属</li><li>高光度 specular：值越大物体高光反射越强</li><li>高光颜色 specularTint：可以调节高光反射的颜色</li><li>粗糙程度 roughness：值越大物体表面越粗糙</li><li>各向异性程度 anisotropic：值越大物体表面越呈现各向异性</li><li>绒毛 sheen：绒毛相当于物体表面每个点都有一根朝向法线方向的绒毛，表现出来就是物体边缘会有模糊感，值越大绒毛越明显</li><li>绒毛颜色 sheenTint：控制绒毛颜色</li><li>表面通透 clearcoat：类似于给物体表面蒙上一层透明的漆，值越大这个效果越明显</li><li>表面通透颜色 clearcoatGloss：表面通透高光的锐利度，值越大高光越锐利</li></ul><p>上面的所有参数可以随意组合，表达各种复合材质，所以迪士尼 BRDF 的表达能力非常强。</p><h3 id="5-Specular-Glossiness-模型"><a href="#5-Specular-Glossiness-模型" class="headerlink" title="5 Specular Glossiness 模型"></a>5 Specular Glossiness 模型</h3><p>Specular Glossiness（SG）模型是在 Disney’s Principled BRDF 的启发下提出的便于实时渲染的 PBR 材质模型，SG 将所有描述材质需要用到的值都存在各种纹理中，渲染时只需要通过简单的纹理采样就可以计算出基于物理的光照结果，不需要调整任何参数，非常方便。</p><p>SG 模型使用三张纹理来存储信息，分别是：Diffuse、Specular 和 Glossiness。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220613104930087.png" alt="image-20220613104930087"></p><p>Diffuse 存储物体的基础颜色，使用 RGB 三个通道；Specular 存储菲涅尔项的基础反射率，也就是菲涅尔近似公式中的 F0，同样对应 RGB 三个通道；Glossiness 是一个标量，用于控制表面光滑程度。</p><p>通过这三张纹理，就可以得到物体表面任何一个点对应的 F、D 和 G 项，从而根据微表面模型计算光照结果，下面是使用 SG 模型计算着色的代码，可以非常直观的感受到 SG 模型有多方便：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220613105637113.png" alt="image-20220613105637113"></p><p>首先根据漫反射颜色计算出了漫反射项，然后根据微表面模型计算高光反射项，其中粗糙程度根据 Glossiness 采样结果得到，基础反射率 F0 根据 Specular 采样结果得到，再结合各种简单的点乘就可以得到 D、F 和 G 项，最后根据公式计算微表面 specular 结果，加上漫反射结果就是整个 BRDF 结果。有了 BRDF 就可以根据渲染方程得到着色结果了。</p><h3 id="6-Metallic-Roughness-模型"><a href="#6-Metallic-Roughness-模型" class="headerlink" title="6 Metallic Roughness 模型"></a>6 Metallic Roughness 模型</h3><p>Metallic Roughness（MR）是对 SG 模型的又一层封装，SG 模型可以自由地调节漫反射颜色和基础反射率，但有时这对于艺术家来说还是不够直观，因此 MR 使用了另外三个贴图来描述材质：Base Color、Roughness 和 Metallic。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220613110249250.png" alt="image-20220613110249250"></p><p>其中 Base Color 是物体的基础颜色，RGB 三通道；Roughness 和 Metallic 都是标量，分别代表表面粗糙程度和金属度。使用的时候游戏引擎内部会将这些值转化为 SG 模型中的值，下面是转化代码：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220613110606512.png" alt="image-20220613110606512"></p><p>可以看到金属度 Metallic 是一个插值系数，用来从 base color 中取出一定的颜色到介质基本的颜色上，从而构成 SG 模型中的 F0，回顾前文中菲涅尔项的曲线图，金属的基础反射率是非常高的，所以金属度高的时候 base color 中很大一部分颜色就被取出到 F0 中，使得基础反射率变高，而 base color  剩下的颜色就作为 SG 中的 diffuse，于是金属度高就会使 diffuse 很小，也就是金属几乎不会发生漫反射，这和菲涅尔项描述的是完全一致的，所以 MR 模型中的基础颜色就是 diffuse 和 specular 的结合，金属度 Metallic 可以将他们拆分开来，但 base color 的概念对于艺术家来说要比 diffuse 和 specular 更好理解。粗糙程度 Roughness 和 SG 中的光滑程度 Glossiness 相反，二者之间可以互相转化，本质上是一样的。</p><p>MR 和 SG 相比，更便于人们理解，但没有 SG 灵活，因为 MR 不能够自己调节 F0，而是全部包含在了 base color 中，但也因此避免了艺术家如果使用 SG，但给出了错误的 F0 而导致的菲涅尔项错误的情况，各有利弊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时全局光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</id>
    <published>2022-06-05T05:44:59.000Z</published>
    <updated>2022-06-13T03:32:30.197Z</updated>
    
    <content type="html"><![CDATA[<p>全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。</p><p><em><span id="more"></span></em></p><h2 id="1-三维空间全局光照"><a href="#1-三维空间全局光照" class="headerlink" title="1 三维空间全局光照"></a>1 三维空间全局光照</h2><h3 id="1-1-Reﬂective-Shadow-Maps（RSM）"><a href="#1-1-Reﬂective-Shadow-Maps（RSM）" class="headerlink" title="1.1 Reﬂective Shadow Maps（RSM）"></a>1.1 Reﬂective Shadow Maps（RSM）</h3><p>RSM 算法基于一个很简单的但却是实时全局光照中的核心观察：<strong>所有被光源直接照亮的物体表面都可以作为次级光源照亮其他物体。</strong>于是当我们在渲染时得到这个想法的时候，就可以用各种方法实现全局光照了，问题只是在于如何处理这些次级光源。</p><p>那么怎么得到场景中被光源直接照亮的表面信息呢？Shadow Map 所做的正是这个工作，Shadow Map 的每一个 texel 都可以代表场景中的一块区域，这一块区域就一定是被光源直接照亮的区域，就可以作为次级光源照亮其他物体，因此 Shadow Map 实际上可以看作存储了场景中所有的次级光源，因此我们在渲染每个着色点的时候，考虑这些次级光源的贡献即可。</p><p>现在的问题是，每一个次级光源对着色点的贡献相当于从着色点 p 看向这个光源表面所得到的光照结果（其实和光线追踪原理一样），那么如果这个表面是 Glossy 的，情况会非常复杂，因此 RSM 假设所有次级光源表面都是 diffuse 的，这样次级光源对着色点 p 的光照就与他们的相对方向无关了，这样一来次级光源就被抽象为一个向各个方向均匀发光的面光源了。</p><p>那么对于面光源，我们在路径追踪中有推导过如何将渲染方程中对方向立体角的积分转化为对面光源的积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603103514616.png" alt="image-20220603103514616"></p><p>于是渲染方程可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603103524667.png" alt="image-20220603103524667"></p><p>其中 $patch$ 就是代表每一个小的次级光源。现在来看渲染方程中的每一项：</p><p>首先是 BRDF 项，没有什么问题。</p><p>然后是 visibility 项，visibility 要考虑次级光源和着色点的遮挡关系，这是很难得到的，想要得到就要对每一个次级光源生成一个 Shadow Map，而假设我们的直接光照的 Shadow Map 分辨率是 512 <em> 512，那就代表我们有 512 </em> 512 个次级光源，每个次级光源都生成一次 Shadow Map，这是不可能的，因此 RSM 选择不计算 visibility 项，毕竟间接光照是低频的，而且这么多次级光源分别的贡献实际上都很小，所以不计算 visibility 影响也不大。</p><p>最麻烦的是次级光源到着色点的光照 $L_i(q\rightarrow p)$，这要根据该表面的直接光照得到，因为假设了表面是 diffuse 的，所以 BRDF 是一个常数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603104607816.png" alt="image-20220603104607816"></p><p>需要注意这里的 BRDF 是指计算次级光源表面被实际光源直接照射时的渲染方程中的 BRDF，而上面的渲染方程是计算着色点被次级光源照射时的方程。于是 $L_i(q\rightarrow p)$ 就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603104650506.png" alt="image-20220603104650506"></p><p>因为 BRDF 是出射的 Radiance 和入射的 Irradiance 的比值，因此乘上该表面入射的 Irradiance，得到的就是出射的 Radiance，也就是我们想要的次级光源发出的光线。而该表面入射的 Irradiance 可以根据定义表示为直接光源的光通量，也就是功率除以单位面积（因为 Irradiance 表示单位面积上的光的能量），所以就有上面的公式了。上面公式的好处在于带入渲染方程中，我们会发现单位面积 dA 被约掉了，说明之后的计算与次级光源的面积无关。</p><p>接下来考虑的问题是，假设我们的直接光照的 Shadow Map 分辨率是 512 <em> 512，那就代表我们有 512 </em> 512 个次级光源，如果每个次级光源都进行上面的计算，开销也是很大的，而实际上很多次级光源可能对着色点是没有贡献的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603105635240.png" alt="image-20220603105635240"></p><p>着色点为 x，而 Shadow Map 中存储的桌子上的点就显然是对 x 没有贡献的，不需要进行计算，因此我们可以根据法线方向去掉一些不需要计算的次级光源；此外，距离着色点太远的次级光源也不需要计算，因此我们只需要计算着色点一定距离范围内的有贡献的次级光源就可以了，经过这些筛选最后剩下的次级光源数量是可以接受的，也是完全可以做到实时计算的。</p><p>综上，要计算渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603103524667.png" alt="image-20220603103524667"></p><p>我们需要知道的信息有：次级光源到着色点的距离，直接光源对次级光源的光通量以及次级光源表面的法线，因此 Reﬂective Shadow Maps 中存储的就是这些信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603105452496.png" alt="image-20220603105452496"></p><p>RSM 只需要在 SM 的基础上额外存储一些信息就可以实现全局光照，是很容易实现的。但也存在很多缺点，比如因为是基于 Shadow Map，那么对于场景中的所有直接光源都要生成一张 RSM，复杂度会随着光源数量增加；而且整个算法做了很多舍弃和假设，比如舍弃了 visibility 项的计算，假设所有次级光源都是 diffuse 的，这会对最终效果产生一定影响。</p><h3 id="1-2-Light-Propagation-Volumes（LPV）"><a href="#1-2-Light-Propagation-Volumes（LPV）" class="headerlink" title="1.2 Light Propagation Volumes（LPV）"></a>1.2 Light Propagation Volumes（LPV）</h3><p>LPV 的核心思想是，我们要计算着色点的间接光照就需要知道着色点上从各个方向来的 Radiance 是多少，也就是 RSM 中计算的所有次级光源的 Radiance，那如果我们在渲染着色点的时候能直接查询到各个方向来的 Radiance，就不需要额外的计算了。</p><p>于是 LPV 将空间分为一个个网格，然后将所有次级光源表面发出的 Radiance 注入到表面所在的网格中，然后这些 Radiance 根据各自的方向向周围的网格传播，这样一来在渲染的时候只需要查询着色点所在的网格中的 Radiance 就可以快速计算渲染方程了。具体步骤如下：</p><ul><li>第一步：找到能被光源直接照亮的表面，这直接使用 RSM 即可</li><li>第二步：计算这些表面的 Radiance，并注入到所在的网格中，网格中将这些 Radiance 加起来，会得到一个二维函数，表示不同方向上的 Radiance，因为是只与方向有关的二维函数，那么自然可以近似表示为 SH，一般只需要使用前两阶 SH 表示即可，因为 LPV 同样假设次级光源是 diffuse 的，那么次级光源的光照就是低频的，所以不需要太高阶的 SH：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603111036435.png" alt="image-20220603111036435"></p><ul><li>第三步：每个格子中的 Radiance 沿着格子进行传传播，每个格子的 Radiance 会传播到它相邻的六个格子中，传播过去的 Radiance 被加入到那个格子的 Radiance 中，如此迭代，一般 4 到 5 次迭代就可以让整个网格基本达到稳定，这时所有格子里的 Radiance 就可以代表这里的各个方向传播来的 Radiance 了，渲染时可以直接使用：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603111410505.png" alt="image-20220603111410505"></p><ul><li>第四步：渲染时直接将着色点所在的网格中的 Radiance 作为着色点的 Radiance 进行渲染即可。</li></ul><p>通过上面的步骤可以看出 LPV 有一个很严重的问题，就是如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603111539524.png" alt="image-20220603111539524"></p><p>点 p 是一个次级光源，正常来说它发出的 Radiance 不应该照亮墙的背面，但是由于它发出的 Radiance 会被认为是整个网格的 Radiance  ，于是这些 Radiance 就可以照亮墙的背面，也就会发生漏光现象：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603111714792.png" alt="image-20220603111714792"></p><p>不过这不影响 LPV 是一个优秀的实时全局光照解决方案。</p><h3 id="1-3-Voxel-Global-Illumination（VXGI）"><a href="#1-3-Voxel-Global-Illumination（VXGI）" class="headerlink" title="1.3 Voxel Global Illumination（VXGI）"></a>1.3 Voxel Global Illumination（VXGI）</h3><p>VXGI 同样是基于体素（Voxel）的，不同于 LPV，VXGI 将场景体素化，并创建层次结构（LPV 没有层次结构）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220603111846023.png" alt="image-20220603111846023"></p><p>这样一来 RSM 中每个 texel 对应的一片区域就变成对应一些体素，这样就可以计算体素中物体表面的光照作为间接光照，因此 VXGI 可以计算次级光源的 Glossy 光照，不需要假设所有次级光源都是 Glossy 的，所以效果更好，但效率自然更低。VXGI 的实现非常复杂，这里不再赘述。</p><h2 id="2-屏幕空间全局光照"><a href="#2-屏幕空间全局光照" class="headerlink" title="2 屏幕空间全局光照"></a>2 屏幕空间全局光照</h2><h3 id="2-1-Screen-Space-Ambient-Occlusion（SSAO）"><a href="#2-1-Screen-Space-Ambient-Occlusion（SSAO）" class="headerlink" title="2.1 Screen Space Ambient Occlusion（SSAO）"></a>2.1 Screen Space Ambient Occlusion（SSAO）</h3><p>我们之前学习过，环境光遮蔽（AO）是一种对全局光照的近似方法，实现简单，但是可以大幅增强画面的层次感，所以被广泛使用。环境光遮蔽的想法非常简单，Blinn Phong 模型把所有间接光照抽象成了一个常数，叠加到所有着色点上进行一个统一的亮度增强来模拟全局光照，这样的问题在于所有着色点的亮度增强程度是一样的，所以无法增强明暗遮蔽关系，如果我们能对每一个着色点，根据它所处位置的遮蔽关系给这个统一的环境光常数乘上一个系数再累加到着色结果上，就可以体现出物体之间的遮蔽关系了。而这个系数正是渲染方程中的 visibility 项。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605105404933.png" alt="image-20220605105404933"></p><p>上面的过程可以通过渲染方程来更深入的理解。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605105617924.png" alt="image-20220605105617924"></p><p>我们使用之前常用的近似积分拆解公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605105818137.png" alt="image-20220605105818137"></p><p>把 visibility 项拿出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605105715490.png" alt="image-20220605105715490"></p><p>这里我们把 $cos\theta_idw_i$ 看成了一个整体，当作公式中的 $dx$，这实际上是有意义的，我们知道 $dw_i$ 是微分立体角，是单位球面上的一小块面积，乘上了一个和法线的夹角余弦相当于把这一小块面积投影到了单位圆上，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605110006953.png" alt="image-20220605110006953"></p><p>所以 $cos\theta_idw_i$ 这个整体也叫做微分投影立体角，是单位圆中的一小块面积，因此对 $cos\theta_idw_i$ 的积分实际上就是单位圆的面积 $\pi$，这也从另一个角度解释了半球面上对 $cos\theta$ 的积分为什么是  $\pi$。</p><p>现在回到渲染方程，把 visibility 项拿出来之后，渲染方程分为了两部分：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605105715490.png" alt="image-20220605105715490"></p><p>其中，蓝色框中实际上就是对着色点 p 周围<strong>遮挡关系结果的加权平均</strong>（加权和除以权值和就是加权平均），权值是 $cos\theta$，即离法线近的权值大，离法线远的权值小。而分母就是对投影立体角的积分，结果是 $\pi$，于是蓝框中的部分就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605110447249.png" alt="image-20220605110447249"></p><p>一般就写成一个系数 $k_A$  来表示环境光遮蔽系数。</p><p>而黄色框中的部分是一个渲染方程，通过之前的算法我们知道，实时渲染中一般在计算全局光照的时候都会假设所有物体表面都是 diffuse 的，这样每一个次级光源就被抽象成了一个均匀发光的面光源，而在这里， SSAO 还假设所有物体的间接光照都一样，这和 Blinn Phong 模型的假设一致，于是间接光照 $L_i^{indir}$ 就是一个常数，diffuse 的 BRDF 也是常数，因此黄色框部分可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605110615757.png" alt="image-20220605110615757"></p><p>自然就是一个常数，这就相当于 Blinn Phong 中的环境光常数，我们可以直接给定。于是整个渲染方程就是环境光常数乘上了每个片段的遮蔽系数，也就是我们一开始说的那个过程。因为上面的推导中使用了积分拆解近似式，而该公式近似的准确的条件是 $g(x)$ 要么连续，要么在积分区间上波动很小，而在这里 $g(x)$ 就是一个常数，自然满足这两个条件，因此使用这样的方法来近似是完全准确的。</p><p>屏幕空间环境光遮蔽自然是在屏幕空间完成上述过程，那么关键就在于如何只通过屏幕上的信息得到每一个像素对应的场景中的位置的遮蔽关系，从而得到 visibility 系数。</p><p>SSAO 的做法是在屏幕上每一个像素对应的场景中的点周围一个球体范围内随机采样一些点，根据这些点到相机的深度来判断这些点是不是能被看到，用这些结果来近似点 p 会被周围多少物体遮挡，从而得到一个 visibility 系数，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605111352019.png" alt="image-20220605111352019"></p><p>这样做的问题在于我们实际去判断一个点的遮挡关系的时候只应该考虑该点法线方向半球上的遮挡关系，而这里用了整个球体内采样，是不准确的，于是一种解决方法是当采样点中被遮挡的点的数量大于一半时才开始考虑这一点的 AO，这样相当于粗略的截取了一个半球：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605111534174.png" alt="image-20220605111534174"></p><p>当然现代渲染中，我们在屏幕空间也可以得到每一个像素对应的法线，因此可以直接准确的在法线方向半球内采样，并且知道了法线还可以考虑上面公式中的 $cos\theta$ 的加权平均，结果会更加准确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605111716185.png" alt="image-20220605111716185"></p><p>这种方法叫做 HBAO，得到的结果也会比 SSAO 更加真实。</p><h3 id="2-2-Screen-Space-Directional-Occlusion（SSDO）"><a href="#2-2-Screen-Space-Directional-Occlusion（SSDO）" class="headerlink" title="2.2 Screen Space Directional Occlusion（SSDO）"></a>2.2 Screen Space Directional Occlusion（SSDO）</h3><p>SSDO 是 SSAO 的改进，SSAO 中假设一个点接收到的所有来自于其他物体反射光源的间接光照都是一样的（常数），但实际上我们利用 RSM 的思想，我们是知道哪些物体表面是被直接照亮的，因此我们不需要这样简单粗暴的假设，我们可以去准确的计算这些次级光源发出的间接光照是什么。</p><p>SSDO 像是在屏幕空间进行光线追踪一样，在每一个着色点向四面八方打出光光线，如果没有碰到周围的表面说明是直接光照，如果碰到了其他表面就计算该表面的间接光照作为该着色点间接光照的一部分贡献，这里计算其他表面的间接光照还是假设该表面是 diffuse 的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605112300423.png" alt="image-20220605112300423"></p><p>于是就只有两种情况，可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605112324715.png" alt="image-20220605112324715"></p><p>当然，SSDO 既然是屏幕空间的算法，自然不是从 RSM 中获哪那些表面是被直接照亮的，只需要通过深度图就可以近似得到，更准确地说我们认为相机看到的就是被直接照亮的，相机看到的每个点的直接光照结果就作为该点的间接光照去照亮其他点，在实际实现中也不是真的从着色点向周围发出许多光线，而是类似于 HBAO，在着色点法线所在半球随机取点，然后判断这些点的深度是否被遮挡，如果深度大于深度缓冲中的深度，就认为被遮挡，进而认为点 p 到这一点的光线打到了遮挡该点的那个表面，就将那个表面的间接光照作为点 p 的间接光照的贡献之一，整个过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605112905103.png" alt="image-20220605112905103"></p><p>当然这样的做法毕竟不是真正的追踪光线，因此必然会出现一些问题，比如上图中最右边的情况，当点 A 和相机之间有一个遮挡物，点 A 会认为被遮挡，进而认为光线 PA 会打到 z1 所对应的那个点，这显然是不对的，同理点 B 被认为没有被遮挡，但实际上光线 PB 被旁边的表面遮挡到了，不过这些瑕疵在实时渲染中不会对结果有太大影响，因此可以忽略，只要整体结果是好的，那么这个是算法就是好的。</p><p>SSDO 存在的问题不止上面说到的，由于是屏幕空间的算法，所以我们所拥有的全部信息就是屏幕中的信息，相当于是整个场景能被看到的一层外壳，看不到的部分对我们来说是完全不知道的，因此就会丢失掉一些遮蔽信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605113407580.png" alt="image-20220605113407580"></p><p>此外，由于是在法线所在半球内随机取点，这个半球一定对应一个范围，这个范围不能太大，如果无限大那就是光线追踪了，因此对于比较远的间接反射 SSDO 是做不出来的，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605113455806.png" alt="image-20220605113455806"></p><p>上图中立方体反射出了右边的绿色墙面，这是光线追踪的结果，SSDO 是不能做到的，因为它追踪不了那么远，但是近处的颜色是可以得到的，比如左边的红色墙面，这也是 SSDO 最大的优势，就是可以实现 color blending 的效果，能够将物体之间的反射颜色融合起来，这也是因为它把我们看到的颜色作为次级光源来计算着色点的间接光照，而不是像 SSAO 一样全局的设定一个间接光照，下图中最右边可以看出蓝色物体表面映射出了一点黄色：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605113729167.png" alt="image-20220605113729167"></p><h3 id="2-3-Screen-Space-Reﬂection（SSR）"><a href="#2-3-Screen-Space-Reﬂection（SSR）" class="headerlink" title="2.3 Screen Space Reﬂection（SSR）"></a>2.3 Screen Space Reﬂection（SSR）</h3><p>屏幕空间反射 SSR 真正做到了屏幕空间的光线追踪，所以 SSR 更准确地应该被叫做屏幕空间光线追踪（Screen Space Ray-tracing），因此效果很好，也是目前在实时渲染中最广泛使用的方法。</p><p>既然是光线追踪，那么一定分为两步，一是光线和场景求交点，在屏幕空间没有三维场景的信息，实际上计算的是光线和我们看到的场景的一个外壳求交点；二是计算着色，根据采样光线求解渲染方程，这一步和正常的光线追踪完全一样。</p><p>SSR 有效的一个重要原因在于，屏幕中我们能看到的场景中的反射的部分，一定有绝大部分是已经存在于当前的屏幕中的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605114441736.png" alt="image-20220605114441736"></p><p>街道上反射的就是屏幕的上半部分，因此屏幕空间光线追踪是完全可行的，仅利用屏幕中的信息是足够的。</p><p>对于每一个像素，如果只考虑最简单的镜面反射情况，那么我们直接从该点追踪镜面反射方向，就可以找到镜面反射光线和场景外壳上的一个交点，这个交点的颜色我们是直接可以知道的，就把这个颜色作为间接光照颜色（间接光照渲染方程的结果）加到该像素上就可以了，对于更复杂的 Glossy 和漫反射就像光线追踪一样采样更多光线即可，但是也不需要像光线追踪那样采样那么多，因为间接光照最后是要叠加到直接光照结果上的，所以我们只要采样少一些光线，得到一个有噪声的间接光照结果，简单去一下噪（加个模糊之类的）再叠加到直接光照上就能得到不错的结果了。</p><p>下图是镜面反射的结果：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605115220889.png" alt="image-20220605115220889"></p><p>以及 Glossy 的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605115237982.png" alt="image-20220605115237982"></p><p>SSR 还可以实现表面不平整的反射，无非就是不平整的表面法线影响了光线的反射方向而已：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605115334563.png" alt="image-20220605115334563"></p><p>于是现在最主要的问题就是如何在屏幕空间追踪光线，也就是如何求得光线和我们看到的这一层外壳的交点。</p><p>最原始的做法是从着色点出发，沿着要追踪的光线方向，一次移动一定的距离，每次移动后判断对应的深度，如果深度小于深度缓冲中的深度则继续移动，直到深度大于深度缓冲中的深度，则认为找到了交点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605125808577.png" alt="image-20220605125808577"></p><p>这种方法找到的交点是不准确的，交点的精度取决于每次移动的步长，步长过大会找到不准确的交点，步长过小又会影响速度，因此要进行加速优化，这里又要用到图形学中常用的加速手段，类似于三维空间中的 BVH，我们为深度图生成 Mipmap，但这里的 Mipmap 不能取多个深度的均值，要取多个深度的最小值，也就是离我们最近的深度作为下一 level 的深度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130111638.png" alt="image-20220605130111638"></p><p>这样一来，我们就构建了层次深度结构，每次沿着光线移动时可以试探性地增大步长，也就是在更高一层移动，如果找到交点就降低 level 去找具体和哪个像素相交了，举例来说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130239538.png" alt="image-20220605130239538"></p><p>对于上图的情况，我们第一次从着色点出发，先在 level 0 移动，这时每一步会移动一个像素：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130325578.png" alt="image-20220605130325578"></p><p>此时深度小于深度缓冲中的深度，说明没有遮挡，继续移动，这次我们增加一个 level，在 level 1上移动，level 1 中每一个像素代表了 level 0 中的 4 个（我们这里是二维，所以是 2 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130448099.png" alt="image-20220605130448099"></p><p>移动之后还是没有交点，于是再增加一个 level，在 level 2上移动，level 2 中每一个像素代表了 level 0 中的 16 个（我们这里是二维，所以是 4 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130610015.png" alt="image-20220605130610015"></p><p>这时发现有交点了，于是减小一个 level，继续判断：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130649452.png" alt="image-20220605130649452"></p><p>继续减小 level 到 level 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130728981.png" alt="image-20220605130728981"></p><p>这时发现在 level 1有交点的像素细化到 level 0 之后没有交点，于是继续传播，因为没有交点，所以 level 加一，在 level 1 上移动：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130912940.png" alt="image-20220605130912940"></p><p>找到了交点，再次减小一个 level：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605130937759.png" alt="image-20220605130937759"></p><p>最终找到了交点所在的像素，将这个像素对应的颜色作为间接光照累加到当前着色点上即可。上述过程的伪代码如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605131027338.png" alt="image-20220605131027338"></p><p>屏幕空间光线追踪可以很好的实现全局光照，但也一定存在问题，因为我们只有屏幕中的场景信息，这些信息只是整个场景的一个外壳，内部的信息我们是完全不知道的，因此也就会导致我们看不到的部分就不会产生反射，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605131201515.png" alt="image-20220605131201515"></p><p>此外，SSR 也只能反射屏幕中存在的物体，因此一部分在屏幕外的物体的反射就会被“切断”，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605131343414.png" alt="image-20220605131343414"></p><p>不过这可以通过增加一个随距离增大的模糊衰减来解决，使结果看起来更真实：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220605131427066.png" alt="image-20220605131427066"></p><p>当然这只是 SSR 最基本的思想，实际实现中有非常多的细节和优化问题，比如重要性采样、样本在时间和空间上的复用等等，这里就不再展开了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时环境光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/</id>
    <published>2022-06-02T07:34:32.000Z</published>
    <updated>2022-06-13T03:32:11.647Z</updated>
    
    <content type="html"><![CDATA[<p>环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。</p><p><em><span id="more"></span></em></p><h3 id="1-回顾环境贴图"><a href="#1-回顾环境贴图" class="headerlink" title="1 回顾环境贴图"></a>1 回顾环境贴图</h3><p>环境贴图我们在之前的 Shader 部分中学习过也使用过，就是将整个场景存在一个立方体或者球体贴图中，渲染时根据光线反射方向去采样环境贴图得到环境光照。这样的环境光照渲染被称为基于图像的光照，Image-Based Lighting（IBL）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602111629808-16541623890081.png" alt="image-20220602111629808"></p><p>环境光照既然是光照，那自然也是解渲染方程的过程，解渲染方程最简单的方法就是使用数值方法，比如蒙特卡洛方法，但这需要根据光线反射方向采样大量的样本去计算，比如对于漫反射材质，需要在着色点为中心的半球面上均匀采样，而对于金属物体，需要向镜面反射方向一定范围内（Glossy 扰动）随机采样许多光线，这么多采样的计算是非常慢的，因此在实时渲染中需要使用一些方法来代替采样得到正确的环境光照结果。</p><h3 id="2-Split-Sum"><a href="#2-Split-Sum" class="headerlink" title="2 Split Sum"></a>2 Split Sum</h3><p>Split Sum 是解决实时环境光照的一个著名算法，也被使用在虚幻引擎中。上面说过，计算环境光照也是解渲染方程的过程，首先再次回顾渲染方程，并且我们现在计算环境光照的时候先不考虑环境光的阴影项：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602112507731-16541623890092.png" alt="image-20220602112507731"></p><p>于是渲方程就只由两项组成，环境光照项 $L_i$ 和 BRDF 项（一般来说实时渲染中把 BRDF 和 cos 项合称为 BRDF 项），而 Split Sum 基于一个重要的观察：</p><ul><li>如果是 Glossy 的 BRDF，那么我们的积分区间是很小的，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602112750875-16541623890103.png" alt="image-20220602112750875"></p><ul><li>如果是漫反射的 BRDF，虽然积分区间很大，是整个半球面，但是函数值在整个积分区间上的变化是平滑的：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602112855298-16541623890104.png" alt="image-20220602112855298"></p><p>回顾之前我们说到的，实时渲染中非常重要的约等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602113010978-16541623890105.png" alt="image-20220602113010978"></p><p>这个估计要准确，函数 $g(x)$ 必须满足两个条件之一：</p><ul><li>$g(x)$ 在积分区间上波动尽可能小，也就是积分区间尽可能小</li><li>$g(x)$ 在积分区间上平滑</li></ul><p>渲染方程中的 BRDF 刚好符合这两个条件！于是我们可以把渲染方程写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><p>需要注意，在上一节中我们用同样的方法把阴影项拆分了出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602123014213-16541623890107.png" alt="image-20220602123014213"></p><p>这是对于正常的光源渲染的，和我们这里讨论的是两个问题，我们这里的渲染方程是计算环境光照的，不过这两个对渲染方程的改写，用到的思路和方法都是一样的，都是基于上面的重要约等式。</p><p>渲染方程改写成这个形式意味着我们把环境光照项和 BRDF 项分开了，而光照项是环境光的积分除以积分区间的面积，这不就相当于把积分区间范围内，也就是 Glossy 的扰动范围或者漫反射的半球范围内的所有环境光取了一个平均值吗，那么我们如果能够提前计算好这个平均值，在渲染时就不需要大量采样了，只需要直接取到这个平均值就当作对应的环境光项的积分结果的近似值就可以了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602124125503-16541623890108.png" alt="image-20220602124125503"></p><p>于是计算环境光照项的时候，我们可以把环境贴图按照一定的滤波核大小平均一下，生成多张平均后的环境贴图，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602123621399-16541623890109.png" alt="image-20220602123621399"></p><p>当我们计算环境光的时候，根据 Glossy 的扰动大小，决定到多大滤波核平均后的环境贴图中去获取环境光，也可以在不同 level 之间进行插值，和 Mipmap 非常相似。这一步就是 split sum 的第一阶段，解决了环境光项的计算，接下来该解决后面的 BRDF 的积分了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602124242578-165416238901010.png" alt="image-20220602124242578"></p><p>BRDF 的积分如何避免采样呢？BRDF 是一个比较复杂的函数，涉及到很多变量，如果我们要避免采样，就只能进行预计算。首先来回顾一下最常用的微表面 BRDF 模型：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602124444075-165416238901011.png" alt="image-20220602124444075"></p><p>我们来逐个分析一下每项都是关于什么变量的函数。</p><p>首先是菲涅尔项，菲涅尔项非常复杂，但是渲染中常用的是 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602124925813-165416238901113.png" alt="image-20220602124925813"></p><p>这个近似只需要一个基础反射率 $R_0$ 和一个角度 $\theta$，这个角度实际上应该是观察方向和法线的夹角，但是也可以是光线和法线的夹角，也可以是观察方向和切线的夹角，还可以是半程向量和法线的夹角，这是无所谓的，因为这些角度可以很方便的进行转换，总之就是一个角度，于是菲涅尔项需要两个参数 $R_0$ 和 $\theta$。</p><p>然后是法线分布函数 NDF，NDF 描述了微表面的法线分布，一个常用的 Beckmann 分布的公式如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602125413871-165416238901012.png" alt="image-20220602125413871"></p><p>可以看到 NDF 同样是关于两个变量的函数，一个是粗糙程度 $\alpha$，另一个同样是角度 $\theta$。</p><p>最后是遮挡项 G，与入射方向和出射方向有关，而我们的观察方向是固定的，于是遮挡项 G 也只与入射角 $\theta$ 有关。</p><p>综上， BRDF 与基础反射率 $R_0$ ，表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们如果要预计算，那么至少要计算这三个维度，虽然表面上是三个维度，实际上基础反射率 $R_0$ 还有 RGB 三个通道，如果预先计算出这三个变量所有可能的组合情况的 BRDF 积分结果，这无论是计算量还是存储量都是极大的，因此我们要让预计算的变量尽可能少，每少一个变量，就可以少一个维度的存储和计算，那对于预计算效率来说将会是质的提升。</p><p>我们将菲涅尔项的 Schlick’s 近似带入到上面渲染方程中的 BRDF 积分中并做简单的变形可以得到：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><p>这看起来让式子变得更复杂了，但实际上我们把最麻烦的基础反射率 $R_0$ 提取出来了，而剩下的两个积分只与表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们只需要预计算表面粗糙程度 $\alpha$，和入射角 $\theta$ 的所有组合情况就可以了，而这两个值 $\alpha$ 和 $cos\theta$ 都是 0 到 1 的标量，因此预计算的结果就可以存在一张二维纹理中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602130931415-165416238901115.png" alt="image-20220602130931415"></p><p>在渲染时直接查找纹理中的积分结果就可以了。这就是对渲染方程 BRDF 项的计算优化。</p><p>至此我们可以总结一下 split sum 算法是如何计算环境光的：</p><ul><li>首先使用约等式将渲染方程中对光照项和 BRDF 项的乘积的积分转化为了积分的乘积：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><ul><li>然后对于第一项环境光，使用 pre-filtering 生成不同平均程度的环境贴图，使用类似 Mipmap 的方法直接取环境光的平均值近似作为积分结果</li><li>对于第二项 BRDF，预先计算与粗糙程度 $\alpha$ 和入射角 $cos\theta$ 有关的积分的结果，存在一张二维纹理中，计算时只需要查找纹理再乘以基础颜色 $R_0$ 按照以下公式就可以得到 BRDF 积分的近似结果了</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><ul><li>最后将两个积分结果相乘再除以归一化系数（积分区间的面积）就是最终的渲染方程结果</li></ul><p>这样一来整个渲染方程的计算过程就避免了采样，虽然使用了各种近似，但最终的效果却非常好：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602131814205-165416238901116.png" alt="image-20220602131814205"></p><p>在工程中，公式一般不会写成积分形式，而是写成离散的求和形式，但本质是一样的：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602131855491-165416238901117.png" alt="image-20220602131855491"></p><p>而 split sum 方法就是将求和拆分开来进行预计算，这也是 split sum 名称的由来。</p><h3 id="3-环境光照的阴影"><a href="#3-环境光照的阴影" class="headerlink" title="3 环境光照的阴影"></a>3 环境光照的阴影</h3><p>上面的讨论中，我们完全忽略掉了阴影，也就是 Visibility 项，实际上在实时渲染中做环境光照的阴影是几乎不可能的，因为环境贴图相当于把复杂的环境光照存在了一张贴图上，整个环境中实际上有非常多的光源，如果要做阴影，就要对每个光源生成一张 Shadow Map，这是不可能的，因此现在工业上的解决方案就是只生成最主要光源的阴影，这种方法虽然简单粗暴，但在大多数情况下也就足够了。</p><p>当然，有方法能够完全准确的计算出环境光的阴影，比如实时光线追踪，我们将在以后讨论，这里我们将讨论另一种非常强大的方法—— Precomputed radiance transfer（PRT），PRT 不仅可以计算环境光阴影，还可以用于实时全局光照。</p><h3 id="4-球面谐波函数"><a href="#4-球面谐波函数" class="headerlink" title="4 球面谐波函数"></a>4 球面谐波函数</h3><h4 id="4-1-球谐函数的定义和性质"><a href="#4-1-球谐函数的定义和性质" class="headerlink" title="4.1 球谐函数的定义和性质"></a>4.1 球谐函数的定义和性质</h4><p>球面谐波函数（Spherical Harmonics，SH）是一组二维基函数，类似于一维中的傅里叶基函数。空间中的任何球面函数（比如我们的环境贴图、BRDF 等都是球面函数）都可以表示为 SH 的线性组合。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602135006568-165416238901118.png" alt="image-20220602135006568"></p><p>上图表示了前四阶 SH 的可视化结果，不难看出，n 阶 SH 有 2n + 1 个基函数，前 n 阶 SH 有 n * n 个基函数。图中蓝色代表正值，黄色代表负值，颜色深浅代表了值的大小，可以看到同一阶的基函数实际上就是函数值在不同维度的变化，阶数越高函数值变化的频率越高，因此他们的线性组合就可以表示函数中越高频的信息，使用不同阶的球谐函数的组合就可以将一个函数中的不同频率的信息表示出来，再将它们组合在一起就可以基本还原出原本函数的样子，使用的球谐函数越多，自然对原函数的还原也就越好：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602141239497-165416238901119.png" alt="image-20220602141239497"></p><p>这和一维中的傅里叶变换是完全一样的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602135645988-165416238901120.png" alt="image-20220602135645988"></p><p>此外，一个函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分叫做<strong>投影</strong>，投影结果就是这个函数被表示为基函数的线性组合时，对应的基函数的线性组合系数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602135934958-165416238901121.png" alt="image-20220602135934958"></p><p>这可以类比于基向量，任意一个向量 $v$ 可以表示为一组基向量的线性组合，而每个基向量的系数就是向量 $v$ 和该基向量的点乘，而我们知道，向量点乘实际上就是投影，所以函数投影的概念和向量投影是完全一样的，上面的函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分实际上就是对应的函数值相乘再累加起来，这和点乘的计算方式完全一样。</p><p>因此基函数自然也有和基向量完全一样的性质：</p><ul><li>基函数投影到自身结果为 1，相当于基向量是单位向量：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602140619749-165416238901122.png" alt="image-20220602140619749"></p><ul><li>基函数互相正交，即投影结果为 0，相当于基向量互相正交：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602140700382-165416238901123.png" alt="image-20220602140700382"></p><h4 id="4-2-用球谐函数表示环境光"><a href="#4-2-用球谐函数表示环境光" class="headerlink" title="4.2 用球谐函数表示环境光"></a>4.2 用球谐函数表示环境光</h4><p>首先我们回顾上面 split sum 中用到的 pre-filtering 方法，也就是对环境贴图提前进行了一个均值滤波，然后在渲染时只进行一次查询得到平均值作为多次采样的积分近似值，因此可以说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602142643059-165416238901124.png" alt="image-20220602142643059"></p><p>而我们知道均值滤波是低通滤波，只保留了低频信号，如上图，虽然滤波后不能完全还原出原本的环境光照，但是光源之间的明暗关系是完全保留了下来的，对于漫反射或者 Glossy 来说，这是完全够用的，这也是 split sum 可以 work 的原因。</p><p>在这个理解的基础上，又可以得出一个新的理解，那就是<strong>漫反射的 BRDF 对光照的作用，其实就相当于一个低通滤波器的作用</strong>。这其实很好理解，不管环境光照如何复杂，变化如何剧烈，漫反射物体显示出来的都是模糊的变化，不会显示出原本的环境光照那样高频的变化。而这样的特性是由 BRDF 决定的，因此漫反射的 BRDF 相当于对光照做了一个低通滤波。</p><p>于是有人就把 BRDF 投影到了球谐基函数上，并且发现投影只在前三阶有值，之后的投影结果几乎都为 0，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602143333455-165416238901125.png" alt="image-20220602143333455"></p><p>这说明漫反射的 BRDF 中就只包含前三阶 SH 对应的频率的信息，根本就不包含更高频的信息。于是我们也完全可以把环境光照表示为球谐函数，而且只用前三阶就可以近似得到漫反射物体的环境光照结果，事实也确实如此：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602143819188-165416238901126.png" alt="image-20220602143819188"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602143830579-165416238901227.png" alt="image-20220602143830579"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602143841772-165416238901228.png" alt="image-20220602143841772"></p><h3 id="5-Precomputed-radiance-transfer（PRT）"><a href="#5-Precomputed-radiance-transfer（PRT）" class="headerlink" title="5 Precomputed radiance transfer（PRT）"></a>5 Precomputed radiance transfer（PRT）</h3><h4 id="5-1-PRT-原理"><a href="#5-1-PRT-原理" class="headerlink" title="5.1 PRT 原理"></a>5.1 PRT 原理</h4><p>对于一个场景中的一个着色点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602144122954-165416238901229.png" alt="image-20220602144122954"></p><p>它的渲染方程可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602144003377-165416238901230.png" alt="image-20220602144003377"></p><p>环境贴图自然表示整个空间的环境光，visibility 是从这一点看向整个场景得到的遮挡关系，下半部分全黑是因为只在着色点上半球有值，最后是 BRDF 可视化，同样只在上半球有值。渲染方程相当于这些值的乘积的和，如果环境贴图每一面分辨率是 64 <em> 64，那么计算这一个着色点就要进行 6 </em> 64 * 64 次三个数的乘法运算再求和，当分辨率变大的时候这个数字是指数增长的，因此 PRT 将渲染方程分为两部分处理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602145517079-165416238901231.png" alt="image-20220602145517079"></p><p>一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算：<br><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602150253420-165416238901232.png" alt="image-20220602150253420"></p><h4 id="5-2-漫反射情况"><a href="#5-2-漫反射情况" class="headerlink" title="5.2 漫反射情况"></a>5.2 漫反射情况</h4><p>我们接下来先从简单的漫反射情况来详细理解上述过程。对于漫反射， BRDF 是一个常数，我们之前推导过，这里不再赘述，于是渲染方程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/img2022-06-02150537-165416238901233.png" alt="2022-06-02 150537"></p><p>其中光照项表示为球谐函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602150658443-165416238901234.png" alt="image-20220602150658443"></p><p>这样一来对于一个环境光（二维函数），我们只需要记录一个 SH 系数的向量（一维向量）就可以表示了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602152232311.png" alt="image-20220602152232311"></p><p>将 SH 表示的环境光带入渲染方程中可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/img2022-06-02150745-165416238901235.png" alt="2022-06-02 150745"></p><p>其中的积分相当于把 light transport 项投影到基函数上，实际上这个投影方程也可以看作是一个渲染方程，因此投影结果可以认为是在某一个基函数的光照条件下的渲染结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602151932922-165416238901236.png" alt="image-20220602151932922"></p><p>这也是为什么 PRT 能够得到环境光阴影，因为在计算投影结果的时候，计算的是 light transport 的投影结果，而 light transport 就包含了 visibility 项，因此 PRT 能够得到准确的环境光阴影。这个投影结果是可以通过预计算得到的，因此渲染方程最终就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>这样在渲染时只需要计算一次点乘就可以得到环境光照了，为什么是点乘呢？我们接下来从另一个角度来理解上面的过程。</p><p>上面的推导中我们只把光照项表示为了 SH，然后将光照传播项投影到了这些 SH 上去预计算投影结果。我们当然也可以把光照项和光照传播项完全分开计算，分别把他们表示成 SH：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602162810390.png" alt="image-20220602162810390"></p><p>于是渲染方程就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602162847615.png" alt="image-20220602162847615"></p><p>渲染方程变成了一个二次的求和公式，这看起来和之前推导的结果不一样，因为这里二次求和显然是一个 $O(n^2)$ 的复杂度，要遍历 p 和 q 的结果全部累加起来，但是我们知道 SH 是基函数，基函数有正交性，也就是说只有两个基函数相同的时候，上面的积分值才为 1，其他情况下都是 0，因此上面的求和式实际上只是把光照项和光照传播项表示为 SH 后，相同的基函数对应的系数乘积累加了起来，之前说过，用 SH 表示一个二维函数相当于把二维函数压缩成了一个一维的系数向量，所以上面的求和式表示的就是光照项和光照传播项的系数向量的点乘。这和之前推导的公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>表示的意义是完全一样的，这里面 $l_i$ 是光照项的每一个 SH 基函数的系数，$T_i$ 是光照传播项投影到每一个基函数的结果，也就是光照传播项的 SH 系数，二者相乘再求和不正是向量点乘吗。 </p><h4 id="5-3-Glossy-情况"><a href="#5-3-Glossy-情况" class="headerlink" title="5.3 Glossy 情况"></a>5.3 Glossy 情况</h4><p>在此基础上，我们就可以理解 Glossy 情况下 PRT 的计算了。漫反射时， BRDF 是一个常数，无论观察方向如何变化，观察到的光照结果都是一样的，因此光照传播项就是一个二维函数（因为 visibility 是二维的，只与 $w_i$ 有关），表示为 SH 可以得到一个系数向量，再点乘光照项的系数向量就得到了渲染方程的结果。</p><p>但是 Glossy 的 BRDF 不再是一个常数了，而是一个真正的四维函数，当我们在任意一个观察方向 $w_o$ 的时候，BRDF 都是一个与 $w_i$ 有关的二维函数，可以表示为 SH 得到一个系数向量，对于不同的观察方向 $w_o$，自然会得到不同的 SH 表示，也就会得到不同的系数向量。也就是说将 Glossy 的 BRDF 投影到 SH 之后，我们得到的不再是一个系数向量了，而是一个系数矩阵，每一行是一个观察方向 $w_o$ 对应的系数向量，每一列是每一个入射方向 $w_i$ 对应的系数向量，因此上面的公式就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022-06-0265720.png" alt="2022-06-0265720"></p><p>于是我们在计算时就不再是向量点乘了，而是向量和矩阵相乘了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602165910171.png" alt="image-20220602165910171"></p><p>也就是用光照项的系数向量乘以光照传播项的系数矩阵，最终得到的还是一个系数向量，表示的是不同观察方向所看到的光照结果，是一个关于观察方向 $w_o$ 的二维函数，因为对于 Glossy 材质，不同观察方向看到的光照结果是不同的，而漫反射与观察方向无关，所以向量点乘得到的是一个值。</p><h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>总结一下，PRT 将渲染方程分为两部分，一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，漫反射需要预计算一个向量，Glossy 反射需要预计算一个矩阵，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算。</p><p>PRT 效果好速度快，而且可以准确计算环境光阴影，并且如果预计算的时候考虑了光线的多次弹射还可以实现全局光照，而且得益于 SH 的快速旋转性质，PRT 可以在环境光旋转的时候迅速得到渲染结果，无需重新计算，因为当环境光旋转的时候相当于表示它的所有基函数进行了旋转，而旋转后的基函数可以表示为其他同阶基函数的线性组合，因此可以快速得到旋转后的环境光的 SH 表示。</p><p>但 PRT 也存在很多问题，比如只适用于静态场景，因为预计算了光照传播项，而光照传播项又包含了 visibility 和 BRDF，因此预计算完成后，场景的遮挡关系和物体的材质就不能改变了，否则就要重新计算；并且使用 SH 作为基函数只适用于低频环境光照，因为 SH 在表示高频信号的时候会非常吃力，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602152155042-165416238901838.png" alt="image-20220602152155042"></p><p>这是因为 SH 是从低到高的频段表示，我们使用前 n 阶的 SH，就只能表示信号中对应的这么多频段的信息，更高频的信息就会丢失掉，对于一些高频环境光照的场景，可以使用其他基函数，比如二维小波函数（Wavelet），任意一个二维函数都可以表示为所有小波基函数的线性组合，而我们可以只保留线性组合系数最高的那些项来表示原函数，因此小波表示是全频率的，比 SH 更适合表示高频环境光，但小波函数不具有快速旋转性质，当环境光变化时处理非常不灵活，下图是 SH 和 小波函数的渲染结果对比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220602172803653.png" alt="image-20220602172803653"></p><p>显然小波保留了更多的高频信息，得到了更好的阴影和反射效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时阴影</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/</id>
    <published>2022-05-30T12:49:23.000Z</published>
    <updated>2022-07-09T02:58:40.965Z</updated>
    
    <content type="html"><![CDATA[<p>阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈-Shadow-Map"><a href="#1-再谈-Shadow-Map" class="headerlink" title="1 再谈 Shadow Map"></a>1 再谈 Shadow Map</h3><h4 id="1-1-Shadow-Map-背后的数学原理"><a href="#1-1-Shadow-Map-背后的数学原理" class="headerlink" title="1.1 Shadow Map 背后的数学原理"></a>1.1 Shadow Map 背后的数学原理</h4><p>关于 Shadow Map，我们在之前已经了解过，原理非常简单，首先从光源的视角看向整个场景生成一张深度图，然后再从真正的相机视角渲染场景，并对每一个着色点计算其到光源的距离，和深度图中的距离作比较，就可以判断该着色点和光源中间是否有遮挡物，从而产生阴影。整个过程可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-阴影/">【计算机图形学】（十）阴影</a>。</p><p>那么 Shadow Map 为什么可以这么做，可以利用数学知识简单的进行解释，同时了解实时渲染中的优化方向。</p><p>首先是在实时渲染领域非常重要的一个思想，那就是只要看起来是对的，那么它就是对的。也就是说我们不需要精确地计算出结果，只要能够得到结果的正确近似，使最终的渲染效果看起来正确就足够了。因此在实时渲染中会用到各种近似的方法，后面就可以看到，这里先熟悉一个实时渲染中经常用到的近似等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530152415189.png" alt="image-20220530152415189"></p><p>也就是把两个函数乘积的积分近似转化为两个函数积分的乘积，其中分母是一个缩放因子，为了将积分的乘积缩小到和原积分同样的大小，可以通过一个例子来理解：比如 $f(x)$ 是一个常量函数，函数值恒为 2，积分区间是一个长度为 3 的一维区间，那么原积分相当于两倍的 $g(x)$ 在该区间上的积分，转化后的分子，也就是对 $f(x)$ 的积分结果为 3 * 2 =  6，如果不除以缩放因子那么结果就是 6 倍的 $g(x)$ 在该区间上的积分，而除以分母的缩放因子，也就是积分区间长度 3，结果刚好就是 2 倍的 $g(x)$ 在该区间上的积分。</p><p>这个式子在实时渲染中非常有用，比如我们的渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530152854014.png" alt="image-20220530152854014"></p><p>在实时渲染中经常会改写为下面的形式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530153029862.png" alt="image-20220530153029862"></p><p>其中 V 代表可见项，表示了该点的可见程度，可以理解为阴影项，于是上面的渲染方程根据之前的近似等式就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530153303843.png" alt="image-20220530153303843"></p><p>我们在之前的 Shader 中就是在光照计算结果上乘了一个阴影项，这就是可以这么做的道理所在。当然使用这样的近似结果要想估计的准确需要一定的条件：</p><ul><li>$g(x)$ 在积分区间上的波动要尽可能小，或者说积分区间要足够小，体现到渲染中就是光源最好是点光源或者平行光</li><li>$g(x)$ 要是光滑函数，体现到渲染中就是如果不是点光源那么最好是均匀发光的面光源</li></ul><h4 id="1-2-Shadow-Map-的问题"><a href="#1-2-Shadow-Map-的问题" class="headerlink" title="1.2 Shadow Map 的问题"></a>1.2 Shadow Map 的问题</h4><p>Shadow Map 是最基础的阴影算法，优点在于它是一个屏幕空间的算法，不需要知道场景的几何信息，只要知道光源位置和每一个片段的位置就可以完成（世界空间或者裁剪空间都可以），但是正因为其简单，所以有不少缺点，这也是后面的阴影算法的改进方向，总的来说 Shadow Map 有三个最大的问题：</p><p>首先是<strong>自遮挡问题。</strong> Shadow Map 是一个需要两个 Pass 完成的算法，在第一个 Pass 中先从光源位置渲染一遍场景，并将每个像素的深度信息存下来，第二个 Pass 中利用这些深度信息产生阴影。问题在于 Shadow Map 分辨率有限，Shadow Map 中每个像素对应到场景中的一块区域，当第二次进行深度对比的时候，就可能会产生错误，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530145535937.png" alt="image-20220530145535937"></p><p>由于 Shadow Map 分辨率有限，因此每个 texel 对应于场景中一个区域，如图中的区域 1。点 p1 和 p2 对应于屏幕上的不同像素点，由于我们判断一个像素是否位于阴影中，是通过比较该点在以光源为视点的空间中的深度和对应 texel 中储存的深度值。在这种情况下 d(p1) &gt; s，而 d(p2) &lt; s，因此 p1 将会被认为是在阴影中，但其实 p1 和 p2 应该都不在阴影中。于是渲染出来的图就会产生下面的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530145805637.png" alt="image-20220530145805637"></p><p>存在很多阴影纹路，解决这个问题最简单的方法就是在深度比较的时候加上一个容忍度，也就是当着色点的深度比 Shadow Map 中的深度大且它们的差在一定范围内我们就不认为该点被遮挡了。但是如果我们手动设定一个固定的容忍度，也就相当于为 Shadow Map 中的深度进行了一个统一的偏移，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530150153504.png" alt="image-20220530150153504"></p><p>这样虽然解决了自遮挡的问题，但会产生新的问题，也就是一部分本该在阴影中的点就不在阴影中了，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530150232576.png" alt="image-20220530150232576"></p><p>脚的部分阴影就会断掉，原因如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530150705056.png" alt="image-20220530150705056"></p><p>当三角形平面相对于光源的斜率比较大的时候，Shadow Map 中的深度偏移了一段距离，原本被遮挡的点就会变成没有被遮挡从而不产生阴影，如果使用相同的偏移量就会在斜率大的地方有更多的点不被遮挡，从而造成阴影断裂，也就是上图中鞋的部分显然相对于光源的斜率更大，因此会产生阴影断裂现象。因此我们希望可以根据三角形相对于光源的斜率来自适应的调整容忍度，现代显卡已经支持了这种操作。</p><p>Shadow Map 的第二个问题是会<strong>产生走样</strong>，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530151628306.png" alt="image-20220530151628306"></p><p>这同样是由于 Shadow Map 的分辨率有限造成的，可以通过 PCF 来解决，下面会详细介绍。</p><p>Shadow Map 的第三个问题是<strong>只能产生硬阴影</strong>。于是产生了各种软阴影算法，同样在之后详细介绍。</p><h3 id="2-Percentage-Closer-Filtering（PCF）"><a href="#2-Percentage-Closer-Filtering（PCF）" class="headerlink" title="2 Percentage Closer Filtering（PCF）"></a>2 Percentage Closer Filtering（PCF）</h3><p>PCF 是解决 Shadow Map 的走样问题而被提出的。其思想是获取着色点周围的一系列点的深度值，与 P 点深度比较再对比较结果计算一个平均值，也就是说，在比较着色点和 Shadow Map 中的深度的时候，不仅和一个 texel 作比较，而是和多个 texel 作比较，然后将比较的结果进行一个平均作为该点的最终比较结果，这样就得到了一个平滑的，不是非 0 即 1 的阴影项。下面通过一个例子来说明：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530154335327.png" alt="image-20220530154335327"></p><p>对于点 P，我们将其周围 3 * 3 的深度值和当前像素作比较，得到一个比较结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530154413210.png" alt="image-20220530154413210"></p><p>然后将这些结果（加权）平均起来，作为最终该像素的阴影项，这个例子中阴影项最终结果是 0.667，当然一般来说不会取 3 * 3 这么小的邻域。现在的硬件也支持 PCF，但只会取离纹理坐标最近的四个 texel 做平均，效果有限，因此大多数情况下还是在软件 Shader 中做 PCF。</p><p>需要注意的是，PCF 既不是对 Shadow Map 中的深度进行平均，也不是对生成的阴影图像进行滤波，而是对深度比较的结果进行平均。</p><p>下图是 PCF 的效果，可以一定程度上改善阴影的走样问题：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530155053026.png" alt="image-20220530155053026"></p><h3 id="3-Percentage-Closer-Soft-Shadows（PCSS）"><a href="#3-Percentage-Closer-Soft-Shadows（PCSS）" class="headerlink" title="3 Percentage Closer Soft Shadows（PCSS）"></a>3 Percentage Closer Soft Shadows（PCSS）</h3><p>PCSS 是利用 PCF 产生软阴影的算法，为了解决 Shadow Map 无法产生软阴影的问题，实际上所有阴影反走样算法都可以用来产生软阴影。</p><p>从 PCF 的原理可以看出，当我们使用的邻域面积越大，也就是卷积核越大，得到的阴影就会越软，因此我们完全可以使用大卷积核的 PCF 来产生软阴影，但是卷积核选择多大合适呢？如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530155441750.png" alt="image-20220530155441750"></p><p>笔尖附近的阴影非常锐利，而笔杆部分的阴影就变得比较软，这是因为在笔尖处，阴影投射物（Shadow Caster）和阴影接收物（Shadow Reciever）之间的距离很近，而在笔杆部分 Shadow Caster 和 Shadow Reciever 之间的距离较远。因此我们希望 Shadow Caster 和 Shadow Reciever 之间的距离越远，使用的卷积核越大，也就使得阴影越软。</p><p>这可以通过几何关系来描述：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530160458278.png" alt="image-20220530160458278"></p><p>绿色虚线是遮挡物（Blocker）到光源平面的距离，蓝色虚线是阴影接收平面到光源平面的距离，当 Blocker 离光源平面越远，也就是离阴影接收平面越近，光源平面经过 Blocker 上一点映射到阴影接收平面上的面积就越小，我们根据这个映射后的面积决定使用多大的卷积核，这样一来，Blocker 离阴影接收平面越近，使用的卷积核就越小，当 Blocker 离光源平面越近，也就是离阴影接收平面越远，使用的卷积核就越大，这样就可以产生比较真实的软阴影效果。从图中也很容易根据相似三角形原理得出映射后的光源面积：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530160930593.png" alt="image-20220530160930593"></p><p>现在的问题是，Blocker 的深度 $d_{Blocker}$ 如何得到？我们在渲染时只知道阴影接收平面上的一点，并不知道遮挡物距离光源的深度是多少，这时可以再次利用 PCF 的思想，将这一点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 Blocker 的深度。</p><p>于是 PCSS 算法的整个流程就是：</p><ul><li>对于每个像素，首先利用上述方法计算其 $d_{Blocker}$ </li><li>然后根据 $d<em>{Blocker}$ 计算得到卷积核大小 $w</em>{Penumbra}$</li><li>使用对应大小的卷积核进行 PCF</li></ul><p>那么又产生了一个问题，计算 $d<em>{Blocker}$ 时，又该选用多大的邻域范围呢？当然可以是一个固定的大小，比如 5 * 5，但是更好的方法是根据光源面积大小和着色点到光源的距离远近来选择不同的卷积核大小，一种方法是从着色点到光源平面构建一个锥体，然后看该点在  Shadow Map 上对应了多大的区域，将该区域内的深度和该点的深度进行比较，把所有小于该点深度的值平均起来作为 $d</em>{Blocker}$，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530162415880.png" alt="image-20220530162415880"></p><p>另外需要说明的是对于面光源，生成 Shadow Map 时也要像点光源一样，取光源平面中心一点，作为渲染深度图的视点，从该视点出发构建视锥体进行渲染，而 Shadow Map 也就是视锥体的近平面，所以使用上面的方法就可以从空间中一点覆盖到 Shadow Map 上的一块区域。</p><h3 id="4-Variance-Soft-Shadow-Mapping（VSM）"><a href="#4-Variance-Soft-Shadow-Mapping（VSM）" class="headerlink" title="4 Variance Soft Shadow Mapping（VSM）"></a>4 Variance Soft Shadow Mapping（VSM）</h3><h4 id="4-1-PCSS-的问题"><a href="#4-1-PCSS-的问题" class="headerlink" title="4.1 PCSS 的问题"></a>4.1 PCSS 的问题</h4><p>PCSS 利用 PCF 产生软阴影，但是速度并不快，因为 PCSS 在第一步计算 $d_{Blocker}$ 和最后一步进行 PCF 都需要对 Shadow Map 进行采样，而且当卷积核比较大的时候，需要采样很多纹理值，造成性能下降。一种解决方法是不对卷积核内的所有纹理进行采样，而是选取其中一些样本进行计算，但是这样得到的结果中一定存在噪声，不过可以利用后期的去噪方法来优化结果。</p><p>进一步思考这个问题，PCF 的精髓在于 “Percentage Closer”，也就是有多少百分比的 texel 是能够遮挡到当前位置的，换一种说法就是在当前点的一定邻域范围内有多少深度是小于当前点深度的。这就将原问题转化为了一个统计问题，因此使用少量样本也一定程度上能够得到近似正确的结果，但有没有更好的方法来得到相对准确的近似呢？</p><p>从概率与统计的角度来解决上述问题，我们只要能够知道这个邻域范围内的深度是如何分布的，就可以快速地得到一个近似的百分比。最容易想到的就是将深度的分布近似的看作是正态分布，而得到一个正态分布只需要两个量：均值和方差。</p><p><strong>因此 VSM 的核心思想就是</strong>，利用区域查询方法快速地得到 Shadow Map 中一个区域内深度的均值和方差，从而得到深度的近似分布，根据深度分布得到这个区域内有多少深度是小于当前点深度的，然后就可以改进 PCSS 的第一步和第三步中 PCF 的多次纹理采样，从而获得效率提升。</p><h4 id="4-2-区域查询方法"><a href="#4-2-区域查询方法" class="headerlink" title="4.2 区域查询方法"></a>4.2 区域查询方法</h4><p>对于一个区域内的均值，可以利用 MipMap 来快速查询，但是 MipMap 得到的均值是近似值，因为需要三线性插值，即在同一层级的不同平均值之间插值，然后还得在不同层级之间再插值一次得到结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530174618341.png" alt="image-20220530174618341"></p><p>更准确的查询区域均值的方法是利用 Summed Area Tables (SAT)。SAT 实际上就是二维前缀和，具体细节就不赘述了，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530170245397.png" alt="image-20220530170245397"></p><p>因此使用 SAT 获取区域均值是绝对准确的，非近似的，而且还支持矩形区域查询，MipMap 只支持正方形区域。</p><p>至于 SAT 的构建，需要随着 Shadow Map 的更新而重新计算，而 Shadow Map 也要在场景中的物体运动或者光源运动的情况下不断更新，所以还是存在一定的开销的，但 SAT 一旦构建完成就可以使用 VSM 算法快速得到的 PCF 的结果，而不需要再对 Shadow Map 进行多次采样再平均，所以降低了 PCSS 的开销。</p><h4 id="4-3-VSM-的实现"><a href="#4-3-VSM-的实现" class="headerlink" title="4.3 VSM 的实现"></a>4.3 VSM 的实现</h4><p>利用区域查询方法可以快速得到深度的均值，那么如何得到区域内深度的方差呢？利用一个经典概率论公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530170818733.png" alt="image-20220530170818733"></p><p>我们只需要在构建 Shadow Map 的时候，将深度的平方也存在一张纹理中，就可以计算出区域内深度的方差了。在实际实现中，深度和深度的平方可以存在一张纹理的两个不同通道，甚至不需要两张纹理，也不需要 MRT 支持，非常方便。</p><p>于是根据均值和方差就可以构建出该区域内深度的近似分布了，下一步就是得到有多少深度比当前点深度小，也就是算出 $P(x &lt; x<em>{cur})$，已知概率密度函数（PDF）求概率就是对 PDF 进行积分，而如果能够提前算出所有的概率，对于给定的 $x</em>{cur}$，只需要查询就可以了，这正是分段概率函数（CDF），如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530171327752.png" alt="image-20220530171327752"></p><p>但是对于一个连续的概率分布，求其 CDF 是非常困难的，于是 VSM 又利用了一个巧妙的方法来近似 CDF —— 利用切比雪夫不等式。</p><p>切比雪夫不等式（Chebychev’s inequality）在单峰概率分布时如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530171632090.png" alt="image-20220530171632090"></p><p>这个不等式甚至不需要知道具体的概率分布，只要给定均值和方差，就可以得到上面的关系，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530171726482.png" alt="image-20220530171726482"></p><p>切比雪夫不等式描述的是 $x&gt;t$ 的概率不大于右边通过均值和方差计算出来的值。而在图形学中一个常规操作就是把不等式看作约等式，因此可以直接把切比雪夫不等式的右边的值作为 $P(x&gt;t)$ 的估计值，这样自然也就得到了我们需要的 $P(x &lt; t)$ 的估计值。</p><p>但是切比雪夫不等式要求 t 必须大于均值才有效，不过对于图形学来说，这样的近似估计已经足够好了，因为它足够简单快速。</p><p>现在我们可以总结一下 VSM 算法对 PCF 的改进流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>然后在渲染时，只需要查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，这一系列操作只需要 O(1) 时间，不需要任何循环和多次纹理采样</li></ul><p>于是就解决了 PCSS 中的第三步 PCF，那么第一步获取 $d_{Blocker}$ 又该如何优化呢？</p><p>回顾获取 $d<em>{Blocker}$ 的方法：将当前点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 $d</em>{Blocker}$。</p><p>对于一个区域，区域内所有深度可以分为两类：</p><ul><li>一类是小于当前点深度的，也就是会遮挡到当前点的深度，这些点的深度均值为 $z_{occ}$</li><li>另一类是小于当前点深度的，也就是不会遮挡到当前点的深度，这些点的深度均值为 $z_{unocc}$</li></ul><p>于是区域内所有深度的均值 $z_{avg}$ 可以表示成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530173458126.png" alt="image-20220530173458126"></p><p>其中 N 是区域内 texel 总数量， N1 和 N2 分别是不会遮挡和会遮挡当前点的 texel 数量。</p><p>我们希望得到的是会遮挡到当前点的深度的均值 $z<em>{occ}$。而 N1/N 就是我们上面切比雪夫不等式计算的 $P(x &gt; x</em>{cur})$，那么自然 N2/N 就是 $1-P(x &gt; x<em>{cur})$，于是现在我们只要知道 $z</em>{unocc}$ 就可以得到 $z<em>{occ}$ 了，VSM 直接假设 $z</em>{unocc}=x<em>{cur}$ ，也就是假设不会遮挡到当前点的深度的均值就是当前点的深度，根据这些值，就可以得到一个 $z</em>{occ}$ 的近似值了，这个值就作为 $d_{Blocker}$ 去计算 PCF 卷积核大小。</p><p>于是 PCSS 中第一步的多次采样问题也解决了，最后总结一下 VSM 的算法流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>渲染时，对于每个像素，根据之前说的方法得到计算 $d<em>{Blocker}$ 时的卷积核大小，查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计，利用上述方法计算 $z</em>{occ}$ 作为 $d_{Blocker}$ </li><li>然后根据 $d<em>{Blocker}$ 计算得到卷积核大小 $w</em>{Penumbra}$</li><li>使用对应大小的卷积核查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，将切比雪夫估计值作为该像素的阴影项</li></ul><h4 id="4-4-VSM-的优缺点"><a href="#4-4-VSM-的优缺点" class="headerlink" title="4.4 VSM 的优缺点"></a>4.4 VSM 的优缺点</h4><p>VSM 实际上就是 PCSS 的改进方法，加速了 PCF 的计算过程，效率更高，且阴影不会产生噪声，但也存在一些问题。最严重的问题就是会产生漏光（Light Leaking）现象。</p><p>所谓漏光是指当两个 shadow caster 的阴影出现重叠时，在阴影的交界处会出现漏光，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530175426796.png" alt="image-20220530175426796"></p><p>汽车底盘下方有些亮的地方，但是汽车底盘不应该是透光的，这是因为这些地方处于多个 shadow caster 的交界处，车顶有镂空的架子。</p><p>漏光的原因在于 VSM 中使用了单峰概率分布的切比雪夫不等式作为 PCF 的估计值，也就是默认当前点周围的深度分布是一个单峰的概率分布。对于一些复杂的情况，比如树枝，确实一个点周围的深度分布很复杂，可以近似为正态分布，所以阴影也不会有问题，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530175756313.png" alt="image-20220530175756313"></p><p>但是有些情况下，深度分布很简单，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530175829567.png" alt="image-20220530175829567"></p><p>这时如果一个着色点刚好在多个镂空区域的下方，那么该点周围的深度分布可能就是多个峰值或者像上图那样的极端情况，只有几个离散的深度，这时还是用单峰切比雪夫不等式就会使得估计出来的 $P(x &gt; x_{cur})$ 偏大或者偏小，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530180032457.png" alt="image-20220530180032457"></p><p>也就会导致阴影项偏小或者偏大，体现在图像上就是该像素更暗或者更亮，对于阴影来说，更暗我们一般看不出来，但是更亮就会很敏感地被捕捉到，也就是漏光现象。</p><h3 id="5-Moment-Shadow-Mapping（MSM）"><a href="#5-Moment-Shadow-Mapping（MSM）" class="headerlink" title="5 Moment Shadow Mapping（MSM）"></a>5 Moment Shadow Mapping（MSM）</h3><p>MSM 就是为了解决 VSM 的漏光现象而提出的。VSM 漏光的本质原因在于对深度分布的估计不准确，因为 VSM 只使用了均值和方差来估计分布，也就是只使用了深度的一阶矩和二阶矩，MEM 使用更高阶的矩来估计深度分布，得到的分布估计自然更加准确，MEM 经过实验指出，一般情况下使用前四阶矩就可以很好的拟合 PCF 的深度分布了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220530180617122.png" alt="image-20220530180617122"></p><p>最后值得一提的是，现在更多的实时阴影还是使用在区域内采样深度的 PCSS，得益于时间和空间上的去噪和模糊算法可以在很短时间内达到很好的效果，因此我们可以在很小的开销下得到一张有噪声的结果，然后使用去噪或者模糊算法来优化这个结果得到好的渲染图片。</p><h3 id="6-Distance-Field-Soft-Shadows"><a href="#6-Distance-Field-Soft-Shadows" class="headerlink" title="6 Distance Field Soft Shadows"></a>6 Distance Field Soft Shadows</h3><p>基于距离场的软阴影是另一种软阴影的近似算法，与以上基于 Shadow Map 的软阴影算法完全不同。相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，因此目前基于距离场的软阴影算法也逐渐被广泛使用。</p><p>首先回顾一下距离场，距离场是由空间中所有点的距离函数组成的场，而距离函数是指一个点到离它最近的物体表面的距离。下图是一个字母 A 的距离场可视化的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220601142044408.png" alt="image-20220601142044408"></p><p>距离场的优势在于可以使用插值得到物体表面的中间状态，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220601142307684.png" alt="image-20220601142307684"></p><p>上面一行是直接对图像进行插值的结果，黑色部分代表物体，从状态 A 到状态 B 表示一个物体从左向右运动，黑白的边界就表示物体的表面。如果直接对两幅图像的每个像素进行插值是无法得到这两个状态的中间状态的，而如果转化为距离场，对距离场插值之后再逆变换回图像，就可以得到两个状态的中间状态。</p><h4 id="6-1-距离场的用途"><a href="#6-1-距离场的用途" class="headerlink" title="6.1 距离场的用途"></a>6.1 距离场的用途</h4><p>距离场的一个用途就是用来做 Ray marching，也叫做 sphere tracing，也就是可以通过距离场来求光线和表面的交点，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220601142714292.png" alt="image-20220601142714292"></p><p>因为距离场表示的是空间中一点到离它最近的物体表面的距离，因此在任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，也就是不会碰到物体的距离，所以在该点处 SDF(p) 范围内，光线不会与任何物体有交点，于是光线就可以前进 SDF(p) 距离到达边界，到达边界后又会得到一点，然后再去查找该点的 SDF(p) 并继续前进，直到光线足够接近物体或者追踪了足够多次，因此这种方法也叫做 sphere tracing。</p><h4 id="6-2-基于距离场的软阴影"><a href="#6-2-基于距离场的软阴影" class="headerlink" title="6.2 基于距离场的软阴影"></a>6.2 基于距离场的软阴影</h4><p>在 Ray marching 中就可以顺便完成阴影项的计算，得到一个软阴影，上面说到，任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，那么也就表示了这一点的安全角度，所谓安全角度是指该点不会被遮挡到的角度，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220601143236308.png" alt="image-20220601143236308"></p><p>而这个安全角度是很容易算出的，我们知道着色点到该点的距离，也知道该点到离他最近的物体表面的距离，那么安全角度就是：</p><script type="math/tex; mode=display">arcsin(\frac{SDF(p)}{|p - o|})</script><p>该值就可以直接作为阴影项，安全角度越小，被遮挡的概率就越大，因此该着色点的阴影也就越暗。</p><p>但是在着色过程中，反三角函数的计算还是太过复杂，为了简化计算，我们直接使用该点的距离函数值和着色点到该点的距离的比值乘上一个系数来近似 arcsin 值，并且将其限制在 [0, 1] 范围内：</p><script type="math/tex; mode=display">min(k·\frac{SDF(p)}{|p - o|},1.0)</script><p>这样近似不仅降低了计算开销，还能使软阴影更加灵活，因为 k 值越大，相当于在一个很小的安全角度阴影项就达到了 1.0，因此从0 到 1 的过渡就越陡峭，阴影和非阴影的边界就越明显，阴影也就越硬，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022-06-01144018.png" alt="2022-06-01 144018"></p><h4 id="6-3-距离场的优缺点"><a href="#6-3-距离场的优缺点" class="headerlink" title="6.3 距离场的优缺点"></a>6.3 距离场的优缺点</h4><p>相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，但是距离场是定义在三维空间中的，三维空间中的每个点的 SDF 都要存下来，需要非常大的存储开销，虽然有一些距离场的压缩算法，但相比于一张 Shadow Map 二维纹理，依然是极大的开销。</p><p>此外，使用距离场自然需要预先对一个场景计算其距离场，对于一些有形变的物体每次还要重新计算，也是一个很大开销，一个场景中有多个物体还要先计算点到不同物体表面的距离，再取所有距离的最小值作为该点的 SDF，当然也可以使用场景管理的 BVH 等数据结构来优化距离场的计算过程，下图是一个复杂场景的距离场可视化结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220601144718966.png" alt="image-20220601144718966"></p><p>除了上面的缺点外，距离场实际上也存在一些 artifact，这里不赘述，有必要可以之后再做深入了解。</p><h3 id="7-Cascaded-Shadow-Maps（CSM）"><a href="#7-Cascaded-Shadow-Maps（CSM）" class="headerlink" title="7 Cascaded Shadow Maps（CSM）"></a>7 Cascaded Shadow Maps（CSM）</h3><p>CSM 也称为级联阴影，通常用于大型场景的实时阴影中，当场景很大的时候，在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率，否则就会造成阴影的严重锯齿。CSM 的思想是使用多张不同分辨率的阴影贴图，对于<strong>近处</strong>的场景使用<strong>较高分辨率</strong>的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。因为远处的对象只占画面的很少一部分像素，而近处的对象占据了画面的很大一部分，进行这样的处理显然非常合理。</p><p>CSM 根据场景的远近来划分 camera frustum，靠近 camera 的区域划分的较密，远离 camera 的区域划分的比较稀疏，这就使得靠近 camera 的区域能够使用一个相对较大分辨率的 shandow map，减少失真现象。CSM的具体流程如下：</p><ul><li>划分 camera frustum 成多个 subfrustum ;</li><li>计算每个小的 subfrustum 的包围盒；</li><li>对每个 subfrustum 生成投影矩阵；</li><li>对每个 subfrustum 生成一张 shadow map；</li><li>对每一个像素根据深度选择合适的 shadow map 生成阴影。</li></ul><p>CSM 几乎是现代游戏引擎中的标配算法，可以配合上面的软阴影生成算法在大型场景中达到很好的效果，并且保证时效性。</p><p>关于级联阴影的具体实现可以查看<a href="https://blog.csdn.net/qq_39300235/article/details/107765941">联级阴影贴图CSM(Cascaded shadow map)原理与实现</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（二）游戏引擎中的渲染系统</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-26T08:23:09.000Z</published>
    <updated>2022-05-26T08:27:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。</p><p><em><span id="more"></span></em></p><h3 id="1-GPU-架构"><a href="#1-GPU-架构" class="headerlink" title="1 GPU 架构"></a>1 GPU 架构</h3><p>GPU 是渲染系统使用的核心工具，要想使游戏引擎充分利用资源，就要对 GPU 的架构有所了解。关于现代 GPU 架构，这篇文章写的比较细致：<a href="https://zhuanlan.zhihu.com/p/406096300">现代渲染引擎开发-GPU架构</a>，这里只总结重点：</p><ul><li>SIMD是单指令多数据，一条指令处理多个数据，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526155458175.png" alt="image-20220526155458175"></p><ul><li>SIMT是单指令多线程，N 卡使用这种方式，即单条指令在多个核上分多个线程执行</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526155551595.png" alt="image-20220526155551595"></p><ul><li>GPU 中最重要的计算单元是 CU，N 卡中为 CUDA Core，还有专门支持光追的 RT Core 和支持 AI 运算的 Tensor Core 等，多个 CU 组成一个 GPC，也叫做 Shader Engine</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526160001900.png" alt="image-20220526160001900"></p><ul><li>GPU 对性能的瓶颈包括：内存瓶颈、ALU（整形运算单元）瓶颈、TMU（纹理映射单元）瓶颈、BW（带宽）瓶颈等</li></ul><h3 id="2-渲染资源管理"><a href="#2-渲染资源管理" class="headerlink" title="2 渲染资源管理"></a>2 渲染资源管理</h3><p>游戏中的所有对象被称为 GameObject（GO），每一个 GO 包含很多组件，比如模型、语音、动画等等，GO 之间还可以通过事件系统进行交流，并根据其他 GO 发来的消息做出响应。其中，与渲染相关的组件就称为 Renderable，Renderable 包含渲染这个 GO 所需的所有数据，包括顶点、法线、纹理坐标、材质、贴图等等。游戏引擎需要将这些数据高效地组织起来。</p><p>顶点数据的组织我们在 OpenGL 中已经了解，分为顶点数据和顶点索引，顶点索引就描述了所有图元由哪些顶点组成，因为很多图元之间会共享顶点，这样就不需要为每个图元单独存储顶点，从而避免资源浪费。</p><p>一个 GO 最重要的就是要有一个模型，模型由网格 Mesh 组成，因为模型的不同部位可能需要不同的材质，所以一个模型又分为了多个子 Mesh，称为 SubMesh，每个 SubMesh 有它对应的材质（Material），材质包含纹理（Texture）和 Shader 等，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526161157448.png" alt="image-20220526161157448"></p><p>在实际的游戏中，许多游戏对象的 Renderable 可能是重复的，比如许多步兵 NPC，渲染它们需要的数据是完全一样的，如果为每个 GO 都存储一遍这些数据那将会是极大的浪费，因此游戏引擎将所有这些资源放入了资源池中，不同的 GO 只需要存储资源池中资源的索引即可，比如一个模型的 Mesh 对应 Mesh 池中的哪些图元，使用 Shader 池中的哪些 Shader 去渲染，这样就将资源紧凑的管理起来了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526161435933.png" alt="image-20220526161435933"></p><p>这种管理方式也是游戏引擎中很常见的一种管理方式，用来应对资源复用的问题，不只是在渲染系统中，其他系统中也广泛使用了这种管理方式。因此每一个 GO 只是这些资源的组合，是实例化的资源。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526161628614.png" alt="image-20220526161628614"></p><p>此外，因为不同的 GO 会有不同的材质，即使是一个 GO 也会在不同部位使用不同的材质，如果不做任何优化的进行渲染，会有大量的材质更新操作，即卸载掉这个材质的纹理和 Shader，并加载 另一个材质的纹理和 Shader，这样也会造成性能的下降，因此一般的做法是将 SubMesh 按照材质排序，将所有材质相同的 SubMesh 放在一起，这样只需要加载一次材质就可以渲染所有使用该材质的 SubMesh：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220526162146227.png" alt="image-20220526162146227"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>关于透视插值校正</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/</id>
    <published>2022-05-25T08:51:00.000Z</published>
    <updated>2022-05-25T09:16:54.596Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。</p><p><em><span id="more"></span></em></p><h3 id="1-为什么需要透视插值校正"><a href="#1-为什么需要透视插值校正" class="headerlink" title="1 为什么需要透视插值校正"></a>1 为什么需要透视插值校正</h3><p>透视投影我们已经非常熟悉了，透视投影是为了模拟人眼所看到的近大远小的效果，比如一个正方形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220525160340619.png" alt="image-20220525160340619"></p><p>如果是正交投影，那么点 Q 就在 BC 连线中点处，而如果是透视投影，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022-05-25160428.png" alt="屏幕截图 2022-05-25 160428"></p><p>点 Q 就不再处于 BC 连线的中间处了，在我们的渲染器中纹理出现变形的原因就是我们在对顶点的纹理坐标进行插值的时候没有考虑透视的影响。如下图，红色坐标为纹理坐标，黑色为顶点位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/v2-d6f128e3e3150d0ab3941dfdc452e111_r.jpg" alt="v2-d6f128e3e3150d0ab3941dfdc452e111_r"></p><p>当摄像机视线垂直于平面时，将贴图按照 uv 坐标插值，贴到正方形上会如右图所示，不会出现任何问题，但如果相机不垂直于平面：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/v2-67871f21f22f9573e64d3bd30788c033_b.jpg" alt="v2-67871f21f22f9573e64d3bd30788c033_b"></p><p>本来按照正确的透视，正方形的中心点应该在 AC 和 BD 的交点 Q，我们应该把纹理坐标为 (0.5, 0.5) 的颜色值赋给 Q，但是图中却赋给了 P 点，这是因为我们在光栅化插值的时候，使用的是屏幕坐标进行的线性插值，屏幕坐标是投影后的坐标，是没有考虑近大远小的。</p><p>也就是说通，过屏幕坐标插值，可以得到 AC 的中点为点 P，AB 的中点为点 N，AD 的中点为点 M，这些都是投影后屏幕上线段的中点，而不是实际这个正方形在空间中线段的中点，因此就会出现纹理映射错误的情况。所以这时候我们就需要进行透视插值校正。</p><h3 id="2-如何进行透视插值校正"><a href="#2-如何进行透视插值校正" class="headerlink" title="2 如何进行透视插值校正"></a>2 如何进行透视插值校正</h3><p>我们在二维空间中进行推导会简单许多。下图为二维空间中的投影，因为是二维，所以我们把 x 坐标全部置 0，各种几何关系如图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/v2-9ef76bf017541df6b268f0fc5d50f400_b.jpg" alt="v2-9ef76bf017541df6b268f0fc5d50f400_b"></p><p>二维空间中的线段 AB 被投影到 Z = C 平面上，显示为线段 A’B’，利用投影平面的坐标进行插值可以得到：</p><script type="math/tex; mode=display">P' = (1-m)A' + mB'</script><p>于是现在的问题是，如何通过屏幕上的点 P‘ 得到空间中原本的点 P，并求出一个插值关系：</p><script type="math/tex; mode=display">P = (1-n)A + nB</script><p>最简单的方法自然是对点 P’ 应用透视投影变换的逆变换，但矩阵变换太麻烦，我们完全可以通过几何关系解决这个问题。</p><p>在图中添加两条辅助线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/v2-1766a667c7a314f19092ecc00ea03b6b_b.jpg" alt="v2-1766a667c7a314f19092ecc00ea03b6b_b"></p><p>根据三角形相似可以得到：</p><script type="math/tex; mode=display">\frac{n}{1-n} = \frac{|AG|}{|BK|} = \frac{|A'P'|\frac{Z_1}{c}}{|B'P'|\frac{Z_2}{c}} = \frac{mZ_1}{(1-m)Z_2}</script><p>等式两边取倒数可得：</p><script type="math/tex; mode=display">\frac{1}{n} - 1 = \frac{(1-m)Z_2}{mZ_1}</script><p>由此可以解得：</p><script type="math/tex; mode=display">n = \frac{mZ_1}{mZ_1 + (1-m)Z_2}</script><p>这样我们就得到了已知屏幕空间的插值系数 m，求观察空间的插值系数 n 的方法。使用插值系数 n 就可以对顶点的任意属性进行插值了。比如点 P 的 Z 坐标：</p><script type="math/tex; mode=display">Z_n = (1-n)Z_1 + nZ_2 = \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}Z_1 + \frac{mZ_1}{mZ_1 + (1-m)Z_2}Z_2</script><p>化简后得到：</p><script type="math/tex; mode=display">Z_n = \frac{Z_1Z_2}{mZ_1 + (1-m)Z_2} = \frac{1}{\frac{1-m}{Z_1} + \frac{m}{Z_2}}</script><p>这样计算其他属性的插值就可以直接将 $Z_n$ 带入，为什么要将 $Z_n$ 带入呢？因为我们的观察方向都是沿着 -Z 轴方向，所以透视的缩放关系只和深度 Z 有关。比如求点 P 的纹理坐标：</p><script type="math/tex; mode=display">UV_P = \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}UV_A + \frac{mZ_1}{mZ_1 + (1-m)Z_2}UV_B</script><p>将 $Z_n$ 带入得：</p><script type="math/tex; mode=display">UV_P = Z_n(\frac{1-m}{Z_1}UV_A + \frac{m}{Z_2}UV_B)</script><p>上式就是我们在代码中实现的，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的线性插值之后再乘以插值点的深度值，就完成了线性插值的透视校正。</p><p>现在推广到三维空间，可以得到：</p><script type="math/tex; mode=display">Z_n = \frac{1}{\frac{1-u-v}{Z_1} + \frac{u}{Z_2} + \frac{v}{Z_3}}</script><p>其中 u 和 v 是重心插值系数：</p><script type="math/tex; mode=display">P = (1-u-v)A + uB + vC</script><p>于是在三维空间中，点 P 的纹理坐标为：</p><script type="math/tex; mode=display">UV_P = Z_n(\frac{1-u-v}{Z_1}UV_A + \frac{u}{Z_2}UV_B + \frac{v}{Z_3}UV_C)</script><p>于是同样的，在透视除法中，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的重心插值之后再乘以插值点的深度值，就完成了重心插值的透视校正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="3D数学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（九）改进光栅化</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2022-05-25T07:34:39.000Z</published>
    <updated>2022-05-25T09:05:15.976Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。</p><p><em><span id="more"></span></em></p><h3 id="1-边界函数算法"><a href="#1-边界函数算法" class="headerlink" title="1 边界函数算法"></a>1 边界函数算法</h3><p>关于边界函数算法，原理同样非常简单，就是用点和三角形三个顶点连线的向量叉乘来判断点是否在三角形内部，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-光栅化/">【计算机图形学】（三）光栅化</a>，其中还包含了 C++ 代码实现。我们先照搬过来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓边界函数实际上就是上述代码中的 <code>(signOfAB * signofTrig &gt; 0)</code> 等这三个判断条件，因为这个条件判断了点和三角形的一条边界的位置关系，因此被称为边界函数。根据边界函数经过推导可以看出每次移动一个像素得到的边界函数和之前的边界函数的差值是固定的，具体推导过程可以查看<a href="https://zhuanlan.zhihu.com/p/140926917">图形学底层探秘 - 更现代的三角形光栅化与插值算法的实现与优化</a>，因此我们不需要每次都计算叉乘，只需要在前一次的结果上加上差值即可。</p><p>另一个问题是，我们对每个三角形的 Bounding Box 内的像素进行遍历来判断其是否在三角形内部，那么至少会有一半的像素不在三角形内而造成计算浪费，因此出现了分块优化算法，即将 Bounding Box 进行分块，然后只判断每块四个角上的像素是否在三角形内，如果每块的四个像素都在三角形内部或者外部，其他像素就不需要再进行判断了，如果四个像素部分在内部部分在外部就执行正常的算法在块内逐像素判断。这个方法对于占屏幕面积较大的三角形优化效果明显，但如果是小三角形或是斜长的细三角形，反而不如不分块来得快。而且，太大的分块会进一步降低小三角形的绘制效率，而太小的分块又变回了逐像素算法，因此分块的大小需要仔细的权衡。</p><h3 id="2-重心插值"><a href="#2-重心插值" class="headerlink" title="2 重心插值"></a>2 重心插值</h3><p>扫描线算法中使用线性插值就可以确定片元的各种属性值，而在边界函数算法中需要使用重心插值，关于重心坐标我们之前的笔记中也有具体的推导：<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-着色/">【计算机图形学】（六）着色</a>中的第4部分。</p><p>在实现中我们如何计算重心坐标呢？首先整个三角形的面积可以通过：</p><script type="math/tex; mode=display">S_{\Delta} = \frac{1} {2}a·b·sin\theta</script><p>来计算，也就是三角形两条边叉乘得到的向量模的一半，以 AB 和 BC 边为例，三角形的面积为：</p><script type="math/tex; mode=display">S_{\Delta} = \frac{1} {2}(A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx)</script><p>而我们的三个边界函数相加：</p><script type="math/tex; mode=display">F_{AB}(P) + F_{BC}(P) + F_{CA}(P) = A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx</script><p>刚好是三角形面积的二倍，即：</p><script type="math/tex; mode=display">\frac{F_{AB}(P) + F_{BC}(P) + F_{CA}(P)} {2S_{\Delta} } = 1</script><p>而重心坐标就是小三角形面积和整个三角形面积的比值，因此我们可以直接通过边界函数得到点 P 的重心坐标：</p><script type="math/tex; mode=display">\alpha = \frac{F_{AB}(P)} { {2S_{\Delta} } },\beta = \frac{F_{BC}(P)} { {2S_{\Delta} } },\gamma = \frac{F_{CA}(P)} { {2S_{\Delta} } }</script><p>这样整个光栅化算法就完成了。需要注意的是重心插值和之前的线性插值一样，都需要进行透视插值校正，即在透视除法中将所有属性都除以 w 值，最后在片元着色器之前再乘以 w 值恢复。关于透视插值校正我们将在下一节详细讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（八）光源</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/</id>
    <published>2022-05-25T03:24:21.000Z</published>
    <updated>2022-05-25T03:25:42.269Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。</p><p><em><span id="more"></span></em></p><h3 id="1-光源概述"><a href="#1-光源概述" class="headerlink" title="1 光源概述"></a>1 光源概述</h3><p>在 RTR 一书中，作者将光源分为三种，分别是：平行光（direction）、点光源（point）和聚光灯（spot）。我们分别来实现这三种光源。</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h3><p>在实现光源之前我们需要一些函数和变量，首先是在 <code>Global.h</code> 中定义的环境光项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>还有计算反射方向的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射的计算 2n * cos(n,l) - l = r</span></span><br><span class="line"><span class="comment">// lightDir是光指向片元的方向</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> glm::vec3&amp; lightDir, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightDir - <span class="number">2</span> * glm::<span class="built_in">dot</span>(normal, lightDir) * normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-平行光"><a href="#3-平行光" class="headerlink" title="3 平行光"></a>3 平行光</h3><p>在实现各类光源之前我们先实现一个光源基类，这样其他光源都派生自该基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光源基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Color;</span><br><span class="line">    glm::vec3 Specular;</span><br><span class="line">    glm::vec3 Direction;</span><br><span class="line">    <span class="type">float</span> Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Light</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Light</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) :</span><br><span class="line">        <span class="built_in">Position</span>(pos),</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Direction</span>(dir),</span><br><span class="line">        <span class="built_in">Intensity</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是平行光，平行光不需要位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光，不需要位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DirectionLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) : </span><br><span class="line">        <span class="built_in">Light</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), color, specular, dir, i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们新建一个 <code>BlinnPhongShader</code> 类继承于基本的 Shader 类，在其中实现平行光的计算，并修改片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Light.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlinnPhongShader</span> : <span class="keyword">public</span> Shader &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量都要是单位向量</span></span><br><span class="line">    <span class="comment">// ViewDir是片元指向摄像机的方向</span></span><br><span class="line">    <span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcDirLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> DirectionLight&amp; dirLight,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -dirLight.Direction), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - dirLight.Direction);</span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">        glm::vec3 diffuse = dirLight.Color * diff * albedo;</span><br><span class="line">        glm::vec3 specular = dirLight.Specular * spec;</span><br><span class="line">        <span class="keyword">return</span> (diffuse + specular) * dirLight.Intensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">        glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">        glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">        glm::vec3 result = Ambient * albedo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">            result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个平行光：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光源</span></span><br><span class="line"><span class="function">DirectionLight <span class="title">dir</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">1.0</span>)</span></span>;</span><br><span class="line">dirLights = &amp;dir;</span><br><span class="line">dirLtNums = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用光照Shader</span></span><br><span class="line">BlinnPhongShader shader;</span><br><span class="line"><span class="comment">// 加载模型</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220525112039177.png" alt="image-20220525112039177"></p><h3 id="4-点光源"><a href="#4-点光源" class="headerlink" title="4 点光源"></a>4 点光源</h3><p>点光源无所谓方向，它向四周均匀发光，光照强度和距离成反比，我们使用常数项、一次项和二次项来控制光照衰减，首先是点光源类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点光源，不需要方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> Constant;        <span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> Linear;        <span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> Quadratic;    <span class="comment">// 二次项</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PointLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span></span><br><span class="line">    ) : <span class="built_in">Light</span>(pos, color, specular, glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), i), <span class="built_in">Constant</span>(c), <span class="built_in">Linear</span>(l), <span class="built_in">Quadratic</span>(q)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是计算点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算点光源</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcPtLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PointLight&amp; ptLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到光源的距离</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, ptLight.Position);</span><br><span class="line">    <span class="comment">// 强度衰减因子</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (ptLight.Constant + ptLight.Linear * distance +</span><br><span class="line">                               ptLight.Quadratic * (distance * distance));</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - ptLight.Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = ptLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = ptLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * ptLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入点光源贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PointLight <span class="title">pt</span><span class="params">(glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">ptLights = &amp;pt;</span><br><span class="line">ptLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220525112022188.png" alt="image-20220525112022188"></p><h3 id="5-聚光灯"><a href="#5-聚光灯" class="headerlink" title="5 聚光灯"></a>5 聚光灯</h3><p>聚光灯可以理解为手电筒，只有在与手电筒正方向夹角在一定范围内的像素才会被照亮。像素到光源位置的方向与光源正向夹角被称为切光角，切光角在设定范围内的像素，按照点光源的方式计算光照。切光角之外的像素不会被照亮。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220525110724976.png" alt="image-20220525110724976"></p><p>为了避免边缘突变，可以设立一个外切光角，在内外切光角之间使用插值乘以计算结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span> : <span class="keyword">public</span> PointLight &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> innerCutOff;        <span class="comment">// 内切光角范围</span></span><br><span class="line">    <span class="type">float</span> outterCutOff;        <span class="comment">// 外切光角范围</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpotLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; icut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; ocut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5</span>))</span><br><span class="line">    ) : <span class="built_in">PointLight</span>(pos, color, specular, i, c, l, q), <span class="built_in">innerCutOff</span>(icut), <span class="built_in">outterCutOff</span>(ocut)</span><br><span class="line">    &#123;</span><br><span class="line">        Direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计算聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算聚光灯，切光角以内按点光源计算</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcSpLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SpotLight&amp; spLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - spLight.Position);</span><br><span class="line">    <span class="comment">// 切光角</span></span><br><span class="line">    <span class="type">float</span> theta = glm::<span class="built_in">dot</span>(lightDir, glm::<span class="built_in">normalize</span>(spLight.Direction));</span><br><span class="line">    <span class="comment">// 内外切光角插值系数</span></span><br><span class="line">    <span class="type">float</span> weight = <span class="built_in">saturate</span>((theta - spLight.outterCutOff) / (spLight.innerCutOff - spLight.outterCutOff));</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">Lerp</span>(<span class="number">0</span>, <span class="number">1</span>, weight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按点光源计算</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, spLight.Position);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (spLight.Constant + spLight.Linear * distance +</span><br><span class="line">                               spLight.Quadratic * (distance * distance));</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = spLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = spLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= (attenuation * intensity);</span><br><span class="line">    specular *= (attenuation * intensity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * spLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入聚光灯贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; spLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcSpLight</span>(*(spLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中加入聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="function">SpotLight <span class="title">sp</span><span class="params">(camera-&gt;Position, camera-&gt;Front)</span></span>;</span><br><span class="line">spLights = &amp;sp;</span><br><span class="line">spLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220525111959282.png" alt="image-20220525111959282"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（七）加载模型</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-05-24T11:51:24.000Z</published>
    <updated>2022-05-24T11:52:25.830Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。</p><p><em><span id="more"></span></em></p><h3 id="1-模型、对象、网格的关系"><a href="#1-模型、对象、网格的关系" class="headerlink" title="1 模型、对象、网格的关系"></a>1 模型、对象、网格的关系</h3><p>在实现加载模型的功能之前，我们首先要了解模型由什么组成。一个模型（Model）包含多个对象（Object），每个对象拥有网格（Mesh）和材质（Material），网格存储了多边形的绘制信息，包括顶点位置、顶点法向、顶点纹理坐标，顶点索引；材质存储了光照和贴图信息，比如漫反射光颜色、镜面反射光颜色、镜面反射光泽度、纹理贴图信息等。所有这些数据都提供给 Shader 来使用，因此一个 Shader 需要绑定一个材质才能发挥作用。</p><h3 id="2-材质与对象类"><a href="#2-材质与对象类" class="headerlink" title="2 材质与对象类"></a>2 材质与对象类</h3><p>了解了这些关系后，我们开始实现相应的类。首先是材质类，最简单的材质包括漫反射颜色、镜面反射颜色、Glossy 扰动和一张主纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 材质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准光照材质包括</span></span><br><span class="line"><span class="comment">//漫反射颜色 镜面反射颜色 镜面反射强度</span></span><br><span class="line"><span class="comment">//纹理一张</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec4 Specular;</span><br><span class="line">    <span class="type">int</span> Gloss;</span><br><span class="line">    Texture* MainTex;</span><br><span class="line">    Shader* shader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Material</span>() :</span><br><span class="line">        <span class="built_in">Color</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Specular</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Gloss</span>(<span class="number">32</span>),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Material</span>(<span class="type">const</span> glm::vec4&amp; color, <span class="type">const</span> glm::vec4&amp; specular, <span class="type">const</span> <span class="type">int</span>&amp; gloss) :</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Gloss</span>(gloss),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Material</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetShader</span><span class="params">(Shader* s)</span> </span>&#123;</span><br><span class="line">        shader = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTexture</span><span class="params">(Texture* t)</span> </span>&#123;</span><br><span class="line">        MainTex = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后是 Object 类，一个 Object 包含一个 Mesh 和一个 Material：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Object类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    Material material;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Mesh&amp; m, <span class="type">const</span> Material&amp; mat) &#123;</span><br><span class="line">        mesh = m;</span><br><span class="line">        material = mat;</span><br><span class="line">    &#125;</span><br><span class="line">    Object&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3 模型类"></a>3 模型类</h3><p>最后是模型类，模型类需要能够加载 obj 模型并解析，之前在图形学中我们了解过 obj 文件的格式，这里再复习一遍。</p><p>一个典型的 obj 文件使用记事本打开可以看到如下格式，这里使用我们项目中用到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 3ds Max Wavefront OBJ Exporter v0.97b - (c)2007 guruware</span><br><span class="line"># File Created: 04.08.2011 15:18:00</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object01</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">v  -7.0063 72.8042 6.8872</span><br><span class="line">v  -6.9854 72.8711 8.2541</span><br><span class="line">v  -7.8984 74.1601 6.7762</span><br><span class="line">......</span><br><span class="line"># 65 vertices</span><br><span class="line"></span><br><span class="line">vn -0.8222 -0.5678 0.0404</span><br><span class="line">vn -0.7979 -0.5926 0.1101</span><br><span class="line">vn -0.8362 -0.5469 0.0396</span><br><span class="line">......</span><br><span class="line"># 70 vertex normals</span><br><span class="line"></span><br><span class="line">vt 0.4465 -0.7212 0.0000</span><br><span class="line">vt 0.4014 -0.7905 0.0000</span><br><span class="line">vt 0.4932 -0.8096 0.0000</span><br><span class="line">......</span><br><span class="line"># 36 texture coords</span><br><span class="line"></span><br><span class="line">g Object01</span><br><span class="line">s 1</span><br><span class="line">f 1/1/1 2/2/2 3/3/3 </span><br><span class="line">s 2</span><br><span class="line">f 3/3/4 2/2/2 4/4/5 </span><br><span class="line">s 3</span><br><span class="line">f 5/5/6 2/2/2 1/1/1 </span><br><span class="line">......</span><br><span class="line"># 0 polygons - 104 triangles</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object02</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>每一个 Object 下面都有 v、vn、vt 和 g、s、f 开头的数据，它们分别代表：</p><ul><li>v（vertex） ：后面记录了一个顶点坐标</li><li>vn（vertex normal）：后面记录了一个法线</li><li>vt（vertex texcood）：后面记录了一个纹理坐标</li><li>g（geometry）：代表下面将开始几何信息</li><li>s：后面跟图元编号</li><li>f（face）：后面后面记录了一个面的三个顶点所使用的顶点坐标、法线和纹理坐标（也可以是四个或者多个组成多边形）</li><li>5/5/6：表示该顶点使用第 5 个 v，第 5 个 vn，第 6 个 vt，这个索引是全局的</li></ul><p>于是我们可以实现模型 Model 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Model类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Object&gt; objects;</span><br><span class="line">    <span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> std::string&amp; path) &#123;</span><br><span class="line">        <span class="built_in">LoadObj</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Model&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;model == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMaterial</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; id, <span class="type">const</span> Material&amp; m)</span> </span>&#123;</span><br><span class="line">        objects[id].material = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadObj</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Open Obj File Error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;glm::vec3&gt; vertexs;</span><br><span class="line">        std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line">        std::vector&lt;glm::vec2&gt; texcoords;</span><br><span class="line"></span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> currentObjectNums = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">            <span class="comment">// 顶点数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    currentObjectNums++;</span><br><span class="line">                    Object o;</span><br><span class="line">                    objects.<span class="built_in">push_back</span>(o);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 v;</span><br><span class="line">                iss &gt;&gt; v.x;</span><br><span class="line">                iss &gt;&gt; v.y;</span><br><span class="line">                iss &gt;&gt; v.z;</span><br><span class="line">                vertexs.<span class="built_in">push_back</span>(v);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 法线数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vn &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vn;</span><br><span class="line">                iss &gt;&gt; vn.x;</span><br><span class="line">                iss &gt;&gt; vn.y;</span><br><span class="line">                iss &gt;&gt; vn.z;</span><br><span class="line">                normals.<span class="built_in">push_back</span>(vn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纹理坐标</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vt;</span><br><span class="line">                iss &gt;&gt; vt.x;</span><br><span class="line">                iss &gt;&gt; vt.y;</span><br><span class="line">                vt.y = <span class="number">1</span> - vt.y;</span><br><span class="line">                <span class="comment">// 纹理坐标z为0</span></span><br><span class="line">                iss &gt;&gt; vt.z;</span><br><span class="line">                texcoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>(vt.x, vt.y));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 图元数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                <span class="type">char</span> bar;</span><br><span class="line">                <span class="type">int</span> vIndex, vtIndex, vnIndex;</span><br><span class="line">                <span class="comment">//解析每个顶点数据 eg：1/1/1</span></span><br><span class="line">                <span class="type">int</span> offset = objects[currentObjectNums].mesh.VBO.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    iss &gt;&gt; vIndex &gt;&gt; bar &gt;&gt; vtIndex &gt;&gt; bar &gt;&gt; vnIndex;</span><br><span class="line">                    <span class="function">Vertex <span class="title">vertex</span><span class="params">(vertexs[vIndex - <span class="number">1</span>], glm::vec4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), texcoords[vtIndex - <span class="number">1</span>], normals[vnIndex - <span class="number">1</span>])</span></span>;</span><br><span class="line">                    objects[currentObjectNums].mesh.VBO.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">                    objects[currentObjectNums].mesh.EBO.<span class="built_in">push_back</span>(offset + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-绘制模型"><a href="#4-绘制模型" class="headerlink" title="4 绘制模型"></a>4 绘制模型</h3><p>接下来在我们原来的 <code>DarwMesh</code> 函数基础上，稍作修改实现绘制对象和绘制模型的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制一个模型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawModel</span><span class="params">(Model&amp; model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.objects.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">DrawObject</span>(model.objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawObject</span><span class="params">(Object&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentMat = &amp;obj.material;</span><br><span class="line">    currentMat-&gt;shader-&gt;texture = currentMat-&gt;MainTex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj.mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = obj.mesh.VBO[obj.mesh.EBO[i]];</span><br><span class="line">        p2 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>修改主函数，加载模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;Model.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用标准Shader</span></span><br><span class="line">    Shader shader;</span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    Material bodyMat;</span><br><span class="line">    bodyMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">bodyTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_body02.jpg&quot;</span>)</span></span>;</span><br><span class="line">    bodyMat.<span class="built_in">SetTexture</span>(&amp;bodyTexture);</span><br><span class="line"></span><br><span class="line">    Material faceMat;</span><br><span class="line">    faceMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">faceTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex002f_body01.jpg&quot;</span>)</span></span>;</span><br><span class="line">    faceMat.<span class="built_in">SetTexture</span>(&amp;faceTexture);</span><br><span class="line"></span><br><span class="line">    Material mouseMat;</span><br><span class="line">    mouseMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">mouseTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_mouse.jpg&quot;</span>)</span></span>;</span><br><span class="line">    mouseMat.<span class="built_in">SetTexture</span>(&amp;mouseTexture);</span><br><span class="line"></span><br><span class="line">    Material eyeMat;</span><br><span class="line">    eyeMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">eyeTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex001f_eye.jpg&quot;</span>)</span></span>;</span><br><span class="line">    eyeMat.<span class="built_in">SetTexture</span>(&amp;eyeTexture);</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">model</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\neptune.obj&quot;</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">0</span>, mouseMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">1</span>, faceMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">2</span>, bodyMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">3</span>, eyeMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建箱子</span></span><br><span class="line">    Mesh box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    Material mat;</span><br><span class="line">    mat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">boxt</span><span class="params">(TEXTURE_PATH)</span></span>;</span><br><span class="line">    mat.<span class="built_in">SetTexture</span>(&amp;boxt);</span><br><span class="line">    <span class="function">Object <span class="title">obj</span><span class="params">(box, mat)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line">    <span class="comment">// 改变渲染模式，默认为纹理填充，改变后为只绘制边框</span></span><br><span class="line">    <span class="comment">//dw-&gt;ChangeRenderMode();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    ViewMatrix = camera-&gt;<span class="built_in">ViewMatrix</span>();</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    ProjectMatrix = camera-&gt;<span class="built_in">PerspectiveMatrix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将箱子左移两单位</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 让箱子在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">0.0</span>;</span><br><span class="line">    ModelMatrix *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="comment">// 旋转后要更新法线</span></span><br><span class="line">    <span class="built_in">UpdateNormalMatrix</span>();</span><br><span class="line">    <span class="comment">// 绘制箱子</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawObject</span>(obj);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 因为模型太大，需要缩小100倍</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/Model1.png" alt="Model1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（六）剔除与裁剪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2022-05-24T03:16:46.000Z</published>
    <updated>2022-05-24T03:30:36.765Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。</p><p><em><span id="more"></span></em></p><h3 id="1-剔除和裁剪概览"><a href="#1-剔除和裁剪概览" class="headerlink" title="1 剔除和裁剪概览"></a>1 剔除和裁剪概览</h3><p>在整个渲染管线中，需要进行多次剔除与裁剪，分别是：视锥剔除、正面/背面剔除、齐次裁剪。</p><ul><li>视锥剔除一般发生在 CPU 阶段，通过 AABB、OBB 等将物体包围起来，然后与视锥体做碰撞检测，可以直接剔除掉完全不可见的物体，运算量较低但精度也较低。</li><li>正面/背面剔除在顶点着色器之后，齐次裁剪之前进行，将不需要渲染的图元直接剔除掉；一般来说这一步也可以在齐次裁剪之后进行，因为操作比较简单，所以可以在世界空间运算也可以在 NDC 中运算，取决于管线的设计。</li><li>齐次裁剪自然是在裁剪空间中进行，即顶点着色器之后，透视除法之前。在透视除法之前是因为如果有物体在摄像机的位置，会出现 w = 0 ，做透视除法的时候会出现除零错误。这一阶段是将在视口外的图元丢弃，一部分在视口内的图元，会进行裁剪，生成新的多边形。当然做裁剪的性能消耗也不小，很多情况下裁剪之后并不比直接把原来的多边形画出来丢弃一部分更快，尤其是 GPU 并不适合做这种判断条件比较多的工作。现代 GPU 通常是用一个比视口大很多（10倍以上？）的虚拟视口来裁剪，那种超出一点点的，就直接画了吧，GPU 性能没那么捉襟见肘。</li></ul><h3 id="2-视锥剔除"><a href="#2-视锥剔除" class="headerlink" title="2 视锥剔除"></a>2 视锥剔除</h3><p>视锥剔除首先要计算物体的包围盒，一般来说如果场景管理使用 BVH 的话，层次包围盒已经计算好了，直接遍历整个 BVH 树即可。然后获得视锥体的六个面的方程，用包围盒和六个面进行碰撞检测，具体实现可以有很多种方法，这里我们实现世界空间下的视锥剔除，流程如下：</p><ul><li>计算包围要绘制物体的 AABB（世界空间），实际我们逐图元计算，剔除掉完全在视锥体外的图元，这样一来就和后面的齐次裁剪中的剔除所做的工作几乎一样了，但这里只是为了学习原理，实际的渲染管线中是利用 BVH 等来剔除掉完全不在视锥体内的物体，而图元是在齐次裁剪的时候剔除的</li><li>获得视锥体六个面的平面方程（世界空间）</li><li>判断 AABB 的顶点在六个面的内侧还是外侧，也可以判断最小点和最大点，实现方法不唯一</li><li>剔除掉所有顶点完全在某一面外侧的物体，我们这里是图元</li></ul><h4 id="2-1-获取视锥平面方程"><a href="#2-1-获取视锥平面方程" class="headerlink" title="2.1 获取视锥平面方程"></a>2.1 获取视锥平面方程</h4><p>那么如何获取视锥体六个平面的方程呢？通过 MVP 变换矩阵就可以直接得出，并且使用 MVP 三个矩阵的不同组合可以得出不同空间下的视锥体平面方程。具体推导的原文可以查看：<a href="http://www8.cs.umu.se/kurser/5DV180/VT18/lab/plane_extraction.pdf">Fast Extraction of Viewing Frustum Planes from the WorldView-Projection Matrix</a></p><p>我们首先定义一个顶点 $v = (x, y, z, w=1)$，以及一个 4 * 4 的矩阵 <script type="math/tex">M = m_{ij}</script>，这个矩阵可以是投影矩阵 P，也可以是 VP，还可以是 MVP，总之经过矩阵 $M$ 后，顶点 $v$ 就被转换到了一个规范立方体中变为 $v’ = (x’, y’, z’, w’)$，这个过程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220523110857514.png" alt="image-20220523110857514"></p><p>规范立方体的范围是 [-w’, w’]，因此如果这个顶点在立方体内，那么必须满足：</p><ul><li>-w’ &lt; x’ &lt; w’</li><li>-w’ &lt; y’ &lt; w’</li><li>-w’ &lt; z’ &lt; w’</li></ul><p>这实际上描述了顶点和视锥体六个平面的关系，原文中以下表列出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220523111017102.png" alt="image-20220523111017102"></p><p>现在以顶点和左侧平面的关系为例，只需要判断 -w’ &lt; x’ 就可以了，根据矩阵乘法，可以得出：</p><script type="math/tex; mode=display">-w' < x' \Rightarrow -(row4 · v) < (row1 · v)</script><p>于是可以进一步得到：</p><script type="math/tex; mode=display">(row1 + row4) · v > 0</script><p>将矩阵元素带入展开可以写成：</p><script type="math/tex; mode=display">(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44})*w > 0</script><p>由于 $w = 1$，因此可以写为：</p><script type="math/tex; mode=display">(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44}) > 0</script><p>这实际上已经得到了视锥体左平面的方程，因为空间中一个平面可以表示为 <script type="math/tex">Ax + By + Cz + D = 0</script>，所以视锥体左平面的方程中：</p><script type="math/tex; mode=display">A = m_{11}+m_{41},\ B = m_{12}+m_{42},\ C = m_{13}+m_{43},\ D = m_{14}+m_{44}</script><p>类似的可以得出其他几个面的方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220523111837599.png" alt="image-20220523111837599"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220523111857255.png" alt="image-20220523111857255"></p><p>上面说过， 4 * 4 的矩阵 <script type="math/tex">M</script> 可以是投影矩阵 P，也可以是 VP，还可以是 MVP，不同的组合得到的视锥体平面方程是不同空间下的：</p><ul><li>当矩阵是 P 时，得到的是观察空间下的平面</li><li>当矩阵是 VP 时，得到的是世界空间下的平面</li><li>当矩阵是 MVP 时，得到的是模型空间下的平面</li></ul><h4 id="2-2-判断顶点与平面的关系"><a href="#2-2-判断顶点与平面的关系" class="headerlink" title="2.2 判断顶点与平面的关系"></a>2.2 判断顶点与平面的关系</h4><p>顶点与平面的关系判断非常简单，类似于二维中点和直线的关系，将顶点坐标 $(x, y, z)$ 带入平面方程计算得到点到平面的距离 <script type="math/tex">d = Ax + By + Cz + D</script>：</p><ul><li>d &gt; 0 时，点在平面法向所指的区域</li><li>d &lt; 0 时，点在平面法向反方向所指的区域</li><li>d = 0 时，点在平面上</li></ul><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>我们使用世界空间下的视锥体剔除，首先在 <code>math.h</code> 中加入视锥体六个平面的方程以及点和平面的关系判断函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视锥体的六个平面方程（世界空间下，传入的是 VP 矩阵），用于视锥剔除</span></span><br><span class="line"><span class="comment">// 所得的平面法向都是指向视锥体内部的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewingFrustumPlanes</span><span class="params">(std::vector&lt;glm::vec4&gt;&amp; result, <span class="type">const</span> glm::mat4&amp; vp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左侧  </span></span><br><span class="line">    result[<span class="number">0</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//右侧</span></span><br><span class="line">    result[<span class="number">1</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//上侧</span></span><br><span class="line">    result[<span class="number">2</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//下侧</span></span><br><span class="line">    result[<span class="number">3</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Near</span></span><br><span class="line">    result[<span class="number">4</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//Far</span></span><br><span class="line">    result[<span class="number">5</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点到平面距离 d =  Ax + By + Cz + D;</span></span><br><span class="line"><span class="comment">// d &lt; 0 点在平面法向反方向所指的区域</span></span><br><span class="line"><span class="comment">// d &gt; 0 点在平面法向所指的区域</span></span><br><span class="line"><span class="comment">// d = 0 在平面上</span></span><br><span class="line"><span class="comment">// d &lt; 0 返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point2Plane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    <span class="keyword">return</span> sb &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于管理，我们新建一个 <code>Cull.h</code> 来管理各类剔除函数，目前只有视锥体剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界空间的视锥剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFrustumCull</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::vec4&gt; ViewPlanes, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果三个顶点都在某一个平面外侧，则剔除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">3</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">4</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 远平面只保留完全在内的图元，部分在内的直接丢掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">5</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入视锥体剔除，一般来说应该在 CPU 阶段进行，但是我们为了方便将视锥体剔除放在顶点着色器之后，因为顶点着色器之后才知道世界空间下的坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line">    <span class="comment">// 视锥体剔除用到的视锥体平面</span></span><br><span class="line">    std::vector&lt;glm::vec4&gt; ViewPlanes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除开关</span></span><br><span class="line">    <span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Draw</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        shader = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取视锥体六个平面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateViewPlanes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ViewingFrustumPlanes</span>(ViewPlanes, ProjectMatrix * ViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            Vertex p1, p2, p3;</span><br><span class="line">            p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">            p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">            p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">            <span class="comment">//顶点着色器变换到裁剪空间</span></span><br><span class="line">            V2F v1, v2, v3;</span><br><span class="line">            v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">            v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">            v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视锥体剔除</span></span><br><span class="line">            <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">            <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">            v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">            v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-正面-背面剔除"><a href="#3-正面-背面剔除" class="headerlink" title="3 正面/背面剔除"></a>3 正面/背面剔除</h3><p>经过视锥体剔除将所有完全不在视锥体内的图元剔除掉之后，剩下的图元要么完全在视锥体内，要么部分在视锥体内，对于部分在视锥体内的图元需要进行裁剪，但因为裁剪是计算量较大的操作，为了进一步减少无用的运算，在此之前还要根据需要将背面（有时也需要将正面的剔除）的图元剔除掉，这一步操作比较简单，我们在世界空间计算。根据观察方向和图元的法线方向的夹角来判断图元是正对我们还是背对我们，原理在之前的 RTR 总结中有介绍，这里不再赘述。</p><p>也可以先做齐次裁剪，透视除法之后在 NDC 中进行正面/背面剔除，但要注意 NDC 是左手系，观察方向恒定为 (0, 0, 1)。无论在哪里计算，原理都是一样的。</p><p>在 <code>Cull.h</code> 中加入正面/背面剔除函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正面/背面</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Face</span> &#123;</span><br><span class="line">    Back,</span><br><span class="line">    Front</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界空间的面剔除，剔除正向面或者逆向面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFaceCull</span><span class="params">(Face face, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叉乘得到法向量</span></span><br><span class="line">    glm::vec3 tmp1 = glm::<span class="built_in">vec3</span>(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);</span><br><span class="line">    glm::vec3 tmp2 = glm::<span class="built_in">vec3</span>(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);</span><br><span class="line">    glm::vec3 normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(tmp1, tmp2));</span><br><span class="line">    <span class="comment">// 世界空间下的观察方向</span></span><br><span class="line">    glm::vec3 view = camera-&gt;Front;</span><br><span class="line">    <span class="comment">// 也可以在NDC中剔除，这时观察方向恒定为(0, 0, 1)，但上面的叉乘顺序顺序要颠倒一下，因为NDC是左手系</span></span><br><span class="line">    <span class="comment">//glm::vec3 view = glm::vec3(0, 0, 1);</span></span><br><span class="line">    <span class="keyword">if</span> (face == Back)</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入正面/背面剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 剔除开关</span></span><br><span class="line"><span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="type">bool</span> FaceCull;</span><br><span class="line">Face CullMode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisableFaceCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableFaceCull</span><span class="params">(Face f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">true</span>;</span><br><span class="line">    CullMode = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldSpaceCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 光栅化</span></span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-齐次裁剪"><a href="#4-齐次裁剪" class="headerlink" title="4 齐次裁剪"></a>4 齐次裁剪</h3><p>最后是比较麻烦的齐次裁剪，之前说过，渲染管线中进行齐次裁剪的位置是<strong>投影之后，透视除法之前</strong>，我们知道，在世界空间和观察空间中，一个点的坐标是 (X, Y, Z, 1)，经过透视投影之后变为 (X’, Y’, Z’, -Z)，再除以 W 坐标变化到 NDC 中 (X’/-Z, Y’/-Z, Z’/-Z, 1)。这其中，如果一个点在观察者的身后，其观察坐标 Z 会大于 0（观察空间是右手系），那么透视投影之后 W 会小于 0，进行透视除法会导致顶点的 X, Y 坐标上下左右翻转。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220523175755959.png" alt="image-20220523175755959"></p><p>并且如果一个物体在相机平面上，会在透视除法时导致除零错误。</p><p>透视投影之后，透视除法之前的坐标空间被称为裁剪空间，也叫齐次（裁剪）空间，它实质上是一个四维空间，变换到齐次空间的顶点之间仍然是线性相关的（可以直接使用线性插值而不是透视插值）。这是因为透视除法将所有坐标除以 w 才会真正破坏顶点之间的线性关系，所以也有这种说法：<strong>真正的投影是通过透视除法完成的</strong>。</p><p>这时，在视锥体中的点一定满足如下条件：</p><ul><li>$-w &lt; x,y,z &lt; w$</li><li>$near&lt;w&lt;far$</li></ul><p>如果不满足这个条件的点，就需要被剔除，因此我们可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 裁剪空间剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClipSpaceCull</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三个点的w都在near或far之外则需要剔除</span></span><br><span class="line">    <span class="keyword">if</span> (v1.w &lt;= camera-&gt;Near &amp;&amp; v2.w &lt;= camera-&gt;Near &amp;&amp; v3.w &lt;= camera-&gt;Near)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.w &gt;= camera-&gt;Far &amp;&amp; v2.w &lt;= camera-&gt;Far &amp;&amp; v3.w &lt;= camera-&gt;Far)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 任意一个点在规范立方体内则不需要剔除，等待进行下一步裁剪</span></span><br><span class="line">    <span class="keyword">if</span> (v1.x &lt;= v1.w || v1.y &lt;= v1.w || v1.z &lt;= v1.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2.x &lt;= v2.w || v2.y &lt;= v2.w || v2.z &lt;= v2.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v3.x &lt;= v3.w || v3.y &lt;= v3.w || v3.z &lt;= v3.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对没有被剔除的片元进行裁剪，使用 <strong>Sutherland-Hodgeman 裁剪算法</strong>，也叫做逐边裁剪算法，它的原理很简单，在二维中就是每次使用裁剪框的一条边去裁剪多边形的每一条边，生成新的顶点并作为下一条裁剪边的输入，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/image-20220524094004535.png" alt="image-20220524094004535"></p><p>这个算法在齐次空间也同样适用（而且可以推广到任意维），与二维的区别是，裁剪平面变为了 6 个，而不是四条线了。</p><p>使用点到平面的距离来判断点在平面的内外，和之前的计算方法类似，之前的计算方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool Point2Plane(const glm::vec3&amp; v, const glm::vec4&amp; p) &#123;</span><br><span class="line"></span><br><span class="line">    float sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    return sb &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只适用于世界空间或者观察空间等 w 为 1 的空间中，而我们现在是在裁剪空间，顶点的 w 值不为 1， 因此不能省略顶点的 w，所以需要重新写一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在裁剪平面法线所指方向，即内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inside</span><span class="params">(<span class="type">const</span> glm::vec4&amp; line, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line.x * p.x + line.y * p.y + line.z * p.z + line.w * p.w &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还需要一个函数直接判断三个顶点是否都在视口内，这样就无需裁剪了，也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有顶点都在内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AllVertexsInside</span><span class="params">(<span class="type">const</span> std::vector&lt;V2F&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.x) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.y) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.z) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是计算两个点连线与平面的交点，这可以通过插值实现，分别在一个平面两侧的两个点 A 和 B，它们连线与平面的交点 C 可以通过权重 da / (da - db) 从 A 到 B 插值得到。其中 da 和 db 分别是点 A 和 B 到裁剪平面的距离，可以通过上面函数的方法计算得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交点，通过端点插值得到</span></span><br><span class="line"><span class="function">V2F <span class="title">Intersect</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> glm::vec4&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> da = v1.windowPos.x * line.x + v1.windowPos.y * line.y + v1.windowPos.z * line.z + v1.windowPos.w * line.w;</span><br><span class="line">    <span class="type">float</span> db = v2.windowPos.x * line.x + v2.windowPos.y * line.y + v2.windowPos.z * line.z + v2.windowPos.w * line.w;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> weight = da / (da - db);</span><br><span class="line">    <span class="keyword">return</span> V2F::<span class="built_in">lerp</span>(v1, v2, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 Sutherland-Hodgeman 裁剪算法，代码很好理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SutherlandHodgeman裁剪算法</span></span><br><span class="line"><span class="comment">// 输入三个顶点，输出裁剪后的顶点组</span></span><br><span class="line"><span class="function">std::vector&lt;V2F&gt; <span class="title">SutherlandHodgeman</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;V2F&gt; output = &#123; v1,v2,v3 &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AllVertexsInside</span>(output)) &#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ViewLines.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;V2F&gt; <span class="title">input</span><span class="params">(output)</span></span>;</span><br><span class="line">        output.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            V2F current = input[j];</span><br><span class="line">            V2F last = input[(j + input.<span class="built_in">size</span>() - <span class="number">1</span>) % input.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], current.windowPos)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                    V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                    output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">                &#125;</span><br><span class="line">                output.<span class="built_in">push_back</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在渲染流程中加入裁剪，因为裁剪后生成了新的顶点，所以要做比较多的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了能更方便看出裁剪效果，我们加入了渲染模式选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RenderMode</span> &#123;</span><br><span class="line">    Line,    <span class="comment">// 仅绘制边框</span></span><br><span class="line">    Fill    <span class="comment">// 绘制图形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变渲染模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChangeRenderMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (renderMode == Fill)</span><br><span class="line">        renderMode = Line;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        renderMode = Fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新增一个画线算法，使用 BresenhamLine 画线算法，原理比较简单，具体可以查看<a href="https://blog.csdn.net/yzh1994414/article/details/82860187">Bresenham 算法原理</a>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ****************** BresenhamLine画线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">const</span> V2F&amp; from, <span class="type">const</span> V2F&amp; to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = to.windowPos.x - from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> dy = to.windowPos.y - from.windowPos.y;</span><br><span class="line">    <span class="type">int</span> Xstep = <span class="number">1</span>, Ystep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Xstep = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Ystep = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> currentX = from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> currentY = from.windowPos.y;</span><br><span class="line">    V2F tmp;</span><br><span class="line">    <span class="comment">//斜率小于1</span></span><br><span class="line">    <span class="keyword">if</span> (dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dy - dx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dx));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentX += Xstep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentY += Ystep;</span><br><span class="line">                P += <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//斜率大于1，利用对称性画</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dx - dy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dy; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dy));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentY += Ystep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dx;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentX += Xstep;</span><br><span class="line">                P -= <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>现在来测试一下上面实现的裁剪吧，因为可以只渲染边框，可以清楚的看到每个面的渲染情况。</p><p>我们首先关闭背面剔除，得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/NonCull.png" alt="NonCull"></p><p>然后开启背面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/BackCull.png" alt="BackCull"></p><p>试试开启正面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/FrontCull.png" alt="FrontCull"></p><p>接下来将正方体移动到屏幕边缘，测试裁剪效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/Clip.png" alt="Clip"></p><p>可以看到裁剪产生的新的图元。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
</feed>
