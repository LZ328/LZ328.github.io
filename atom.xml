<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-06-29T03:25:57.434Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【知识汇总】数学相关</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/28/20220628-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-3D%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/28/20220628-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-3D%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/</id>
    <published>2022-06-28T04:51:19.000Z</published>
    <updated>2022-06-29T03:25:57.434Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结图形学中常用的数学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p><p><em><span id="more"></span></em></p><h4 id="给定点集如何求凸包"><a href="#给定点集如何求凸包" class="headerlink" title="给定点集如何求凸包"></a>给定点集如何求凸包</h4><p>求凸包算法可以查看<a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552"> 凸包（Convex Hull）问题算法详解</a>，其中比较重要的是分治法、步进法和扫描法：</p><ul><li>分治法首先找到一定在凸包上的两个点，然后连线将凸包分为上包和下包，在上包和下包中分别找到距离直线最远的点，连线继续划分，直到找到全部凸包上的点</li><li>步进法从一个凸包上的点出发，逆时针寻找其他凸包上的点，每次找到一个点，再从该点出发继续寻找，寻找时是通过连线夹角判断是否为凸包上的点的</li><li>Graham 扫描法先找到一个凸包上的点，然后以该点为原点对其他点做平移，然后根据各点相对于原点的辐角和距离排序，然后扫描该序列中的点，利用类似单调栈的思路维护凸包点，直到扫描完全部点</li></ul><h4 id="向量点乘和叉乘的几何意义"><a href="#向量点乘和叉乘的几何意义" class="headerlink" title="向量点乘和叉乘的几何意义"></a>向量点乘和叉乘的几何意义</h4><p>点乘代表一个向量在另一个向量方向上的投影，同时也可以快速求得两向量的夹角，进而判断向量是否同向等等；</p><p>叉乘得到的自然是平面法向量，此外叉乘向量的模是两向量构成的平行四边形的面积。</p><h4 id="判断点在三角形内的方法"><a href="#判断点在三角形内的方法" class="headerlink" title="判断点在三角形内的方法"></a>判断点在三角形内的方法</h4><p>向量叉乘，判断 z 坐标是否同向</p><p>代数几何判断点和直线的位置，本质上和向量叉乘一样</p><p>重心坐标，其实就是求面积，三个小三角形面积和为大三角形面积说明点在内部，其实就是重心坐标非负</p><h4 id="判断点在矩形内部的方法"><a href="#判断点在矩形内部的方法" class="headerlink" title="判断点在矩形内部的方法"></a>判断点在矩形内部的方法</h4><p>同样是叉乘，判断点在四条边的内部即可</p><p>面积法也可以，可以看作是重心坐标的推广</p><h4 id="如何判断凸多边形"><a href="#如何判断凸多边形" class="headerlink" title="如何判断凸多边形"></a>如何判断凸多边形</h4><p>逆时针遍历每三个点，判断点在前两个点连线的哪一侧，都在左侧就是凸多边形，都在右侧就是凹多边形</p><p>向量叉乘，每三个点组成两个向量，依次叉乘，结果都为正方向为凸多边形</p><p>也可以对多边形求凸包，凸包点数和多边形顶点数一样就是凸多边形，少于多边形点数就是凹多边形，但是这种方法没必要</p><h4 id="叉乘求多边形面积"><a href="#叉乘求多边形面积" class="headerlink" title="叉乘求多边形面积"></a>叉乘求多边形面积</h4><p>叉乘求的是有向面积，只要逆时针每三个点求叉乘再累加起来就是多边形面积的二倍。</p><h4 id="空间两直线的距离"><a href="#空间两直线的距离" class="headerlink" title="空间两直线的距离"></a>空间两直线的距离</h4><p>可以查看<a href="https://blog.csdn.net/zhyh1435589631/article/details/52960121">求空间两条直线之间的距离</a>，主要分为两种情况：</p><ul><li>平行直线间的距离，相当于求点到直线的距离</li><li>异面不平行直线距离，求两条直线上任意两点间连线在两直线方向向量叉乘方向上的投影长度</li></ul><h4 id="点到三角形的最近距离"><a href="#点到三角形的最近距离" class="headerlink" title="点到三角形的最近距离"></a>点到三角形的最近距离</h4><p>求点和三角形任意一点连线在三角形平面法向上的投影长度即可，平面法向通过三角形三点叉乘可以得到</p><h4 id="给定法线和入射光线求反射光线"><a href="#给定法线和入射光线求反射光线" class="headerlink" title="给定法线和入射光线求反射光线"></a>给定法线和入射光线求反射光线</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/">【RayTracer】（五）金属材质</a>中的 3.1 部分</p><h4 id="行列式为-0-有什么意义"><a href="#行列式为-0-有什么意义" class="headerlink" title="行列式为 0 有什么意义"></a>行列式为 0 有什么意义</h4><p>行列式的几何意义和叉乘一样，都代表面积（二维）或者体积（三维），为 0 意味着二维中中两向量重合或者三位重量平面重合，具体的行列式几何意义可以查看<a href="https://www.cnblogs.com/AndyJee/p/3491487.html">【线性代数的几何意义】行列式的几何意义</a></p><h4 id="齐次坐标的意义"><a href="#齐次坐标的意义" class="headerlink" title="齐次坐标的意义"></a>齐次坐标的意义</h4><p>为了让所有变换都表示成矩阵向量乘法的形式，引入了齐次坐标。</p><p>关于齐次坐标可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>的 1.3 部分</p><h4 id="光线和球体求交点及优化"><a href="#光线和球体求交点及优化" class="headerlink" title="光线和球体求交点及优化"></a>光线和球体求交点及优化</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/">【RayTracer】（二）实现物体类</a></p><h4 id="光线和三角形求交点"><a href="#光线和三角形求交点" class="headerlink" title="光线和三角形求交点"></a>光线和三角形求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>的 3.3 部分</p><h4 id="光线和-AABB-求交点"><a href="#光线和-AABB-求交点" class="headerlink" title="光线和 AABB 求交点"></a>光线和 AABB 求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>第 4 部分</p><h4 id="法线矩阵是什么"><a href="#法线矩阵是什么" class="headerlink" title="法线矩阵是什么"></a>法线矩阵是什么</h4><p>法线变换矩阵是原变换矩阵的逆转置，具体可以查看<a href="https://blog.csdn.net/Qinhaifu/article/details/102476692">法线矩阵</a>以及笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a></p><h4 id="为什么矩阵-4-维但向量只用-3-维就可以"><a href="#为什么矩阵-4-维但向量只用-3-维就可以" class="headerlink" title="为什么矩阵 4 维但向量只用 3 维就可以"></a>为什么矩阵 4 维但向量只用 3 维就可以</h4><p>向量的齐次坐标第 4 维为 0，矩阵 4 维是为了可以同时对向量和点进行变换，对于向量不存在平移变化，所以三维就够了</p><h4 id="特征值和特征向量的意义"><a href="#特征值和特征向量的意义" class="headerlink" title="特征值和特征向量的意义"></a>特征值和特征向量的意义</h4><p>查看<a href="https://blog.csdn.net/qq_32742009/article/details/82217051">矩阵的特征向量、特征值及其含义</a></p><h4 id="正交矩阵的特征"><a href="#正交矩阵的特征" class="headerlink" title="正交矩阵的特征"></a>正交矩阵的特征</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/120170892">正交矩阵学习小结</a></p><h4 id="旋转矩阵的特征值"><a href="#旋转矩阵的特征值" class="headerlink" title="旋转矩阵的特征值"></a>旋转矩阵的特征值</h4><p>三维旋转矩阵的特征值为 1 和与旋转角有关的一对共轭复数，具体可以查看<a href="https://blog.csdn.net/lewif/article/details/105110720">坐标变换(7)—旋转矩阵和特征向量</a></p><h4 id="欧拉角和万向锁"><a href="#欧拉角和万向锁" class="headerlink" title="欧拉角和万向锁"></a>欧拉角和万向锁</h4><p>欧拉角优势在于简单，但旋转顺序影响结果并且存在万向锁问题，四元数可以解决万向锁问题</p><h4 id="四元数的概念、作用和插值方法"><a href="#四元数的概念、作用和插值方法" class="headerlink" title="四元数的概念、作用和插值方法"></a>四元数的概念、作用和插值方法</h4><p>四元数的概念和理解查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/">【计算机图形学】（二）旋转与四元数</a></p><p>四元数的球面线性插值查看<a href="https://blog.csdn.net/weixin_42595073/article/details/100704061">四元数的插值方法</a></p><h4 id="最小二乘法的几何意义"><a href="#最小二乘法的几何意义" class="headerlink" title="最小二乘法的几何意义"></a>最小二乘法的几何意义</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqaure method）</a></p><h4 id="矩阵特征值分解和奇异值分解"><a href="#矩阵特征值分解和奇异值分解" class="headerlink" title="矩阵特征值分解和奇异值分解"></a>矩阵特征值分解和奇异值分解</h4><p>特征值分解只适用于方阵，奇异值分解适用于任意矩阵</p><p>查看<a href="https://zhuanlan.zhihu.com/p/480389473">【彻底搞懂】矩阵奇异值分解（SVD）</a>和<a href="https://zhuanlan.zhihu.com/p/122259109">强大的矩阵奇异值分解(SVD)</a></p><h4 id="多元函数全微分"><a href="#多元函数全微分" class="headerlink" title="多元函数全微分"></a>多元函数全微分</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/485956707">通俗理解多元函数的全微分</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结图形学中常用的数学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="3D数学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【知识汇总】C++相关</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/</id>
    <published>2022-06-25T09:01:46.000Z</published>
    <updated>2022-06-25T09:21:37.637Z</updated>
    
    <content type="html"><![CDATA[<p>本篇总结 C++ 相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p><p><em><span id="more"></span></em></p><h2 id="1-多态"><a href="#1-多态" class="headerlink" title="1 多态"></a>1 多态</h2><h4 id="多态的定义、种类、如何实现"><a href="#多态的定义、种类、如何实现" class="headerlink" title="多态的定义、种类、如何实现"></a>多态的定义、种类、如何实现</h4><p>多态简单概括就是“一种接口，多种方法”，是面向对象编程的核心，主要指不同的对象收到相同的消息做出不同的动作。C++ 通过指针或引用实现多态，具体查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/">【C++ 对象模型】（一）关于对象</a>。</p><h4 id="虚函数如何实现多态"><a href="#虚函数如何实现多态" class="headerlink" title="虚函数如何实现多态"></a>虚函数如何实现多态</h4><p>基类指针指向派生类对象，可以调用不同派生类的方法，这是通过虚函数来实现的。每一个类都有一张虚函数表，类的对象中包含指向虚函数表的指针，派生类对象中包含基类子对象并且在内存布局的最前面，而虚函数表指针又位于实例对象内存的最前面，因此使用基类指针可以指向任何派生类对象并且正确寻址到虚函数表，这样通过一个基类指针就可以在运行时找到不同派生类的虚函数表从而调用对应的函数，实现多态。</p><h4 id="虚表指针什么时候产生"><a href="#虚表指针什么时候产生" class="headerlink" title="虚表指针什么时候产生"></a>虚表指针什么时候产生</h4><p>首先每一个类的虚函数表在编译期间确定，虚函数表指针在虚函数表确定后，对象被构造出来的时候就可以确定了，实际上编译器会在构造函数时中加入对虚函数表指针的赋值操作，并且这些操作会在用于自己定义的初始化操作之前执行。同样的，虚基类指针也在编译期确定。</p><h4 id="关于纯虚函数"><a href="#关于纯虚函数" class="headerlink" title="关于纯虚函数"></a>关于纯虚函数</h4><p>纯虚函数没有定义，必须在派生类中实现，在虚函数表中会存在一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序。</p><h4 id="重载、重写与覆盖"><a href="#重载、重写与覆盖" class="headerlink" title="重载、重写与覆盖"></a>重载、重写与覆盖</h4><p>重载允许有多个同名的函数，而这些函数可以参数列表不同，返回类型不同，参数个数不同，参数类型不同等等。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。在派生类中重写了基类中的函数会覆盖基类中定义的函数，重写虚函数会覆盖虚函数表对应位置的函数指针。</p><h4 id="多继承的实现及可能出现的问题"><a href="#多继承的实现及可能出现的问题" class="headerlink" title="多继承的实现及可能出现的问题"></a>多继承的实现及可能出现的问题</h4><p>多继承会将基类子对象按照继承顺序放在派生类对象中。菱形继承中可能出现重复继承同一个基类的情况。解决办法是使用虚继承。</p><h4 id="菱形继承类大小的计算"><a href="#菱形继承类大小的计算" class="headerlink" title="菱形继承类大小的计算"></a>菱形继承类大小的计算</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第2部分</p><h4 id="类对象的内存存储形式"><a href="#类对象的内存存储形式" class="headerlink" title="类对象的内存存储形式"></a>类对象的内存存储形式</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第3部分</p><h4 id="override-和-final"><a href="#override-和-final" class="headerlink" title="override 和 final"></a>override 和 final</h4><p>override 关键字告诉编译器这个函数是重写基类的函数，如果该函数和基类函数的标识不是完全一样就会报错，比如基类函数中有 const 修饰，派生类重写的时候忘记了 const，如果没有 override，就会导致我们以为重写了基类的函数，但实际上因为没有加 const ，这是两个完全不同的函数而产生错误。同时因为 override 可以说明这是一个重写的基类虚函数，因此派生类中函数的 virtual 关键字就可以去掉了。</p><p>final 关键字用于类声明可以禁止继承该类，用于方法可以禁止该方法在派生类中被重写。</p><h4 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h4><p>因为虚函数会在放在虚函数表中，构造对象时给对象的 vptr 赋值，如果构造函数是虚函数，那调用构造函数的时候就要用 vptr 去找构造函数，但此时 vptr 还没有被赋值。</p><h4 id="为什么析构函数可以是虚函数"><a href="#为什么析构函数可以是虚函数" class="headerlink" title="为什么析构函数可以是虚函数"></a>为什么析构函数可以是虚函数</h4><p>与构造函数不同，vptr 已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。</p><p>当我们使用基类指针可以指向派生类的对象时，如果删除该指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。而如果析构函数不定义为虚函数，编译器会实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，从而存在内存泄露的风险。</p><p>更多关于析构函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/">【C++ 对象模型】（五）对象复制和析构</a></p><h4 id="关于构造函数和析构函数的细节"><a href="#关于构造函数和析构函数的细节" class="headerlink" title="关于构造函数和析构函数的细节"></a>关于构造函数和析构函数的细节</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 1 部分</p><h4 id="关于拷贝构造函数"><a href="#关于拷贝构造函数" class="headerlink" title="关于拷贝构造函数"></a>关于拷贝构造函数</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分</p><h4 id="new、placement-new-和-malloc"><a href="#new、placement-new-和-malloc" class="headerlink" title="new、placement new 和 malloc"></a>new、placement new 和 malloc</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/">【C++ 对象模型】（六）关于执行期</a></p><h2 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h2><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>指针指向内存后在使用完毕不释放内存导致这块内存既没有用处也无法再被分配出去。智能指针会在对象生命周期结束后自动释放内存。</p><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象。shared_ptr 对资源做引用计数，当引用计数为 0 的时候，自动释放资源。</p><p>shared_ptr 需要维护的信息有两部分：</p><ol><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li></ol><p>所以，一个 shared_ptr 对象有两个指针。一个是指向共享资源的指针，一个是指向控制信息的指针。shared_ptr 的自定义 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/image-20220625132147566.png" alt="image-20220625132147566"></p><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</p><p>总结一下，std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p><ol><li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li></ol><h4 id="为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？"><a href="#为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？" class="headerlink" title="为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？"></a>为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？</h4><p>不能。 因为在存在继承的情况下，shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</p><p>比如基类指针指向派生类对象，基类指针指向的是派生类中的基类子对象，但控制信息中该基类指针也会为派生类对象的引用计数加 1，并且控制信息中指向的共享资源不是基类子对象，而是派生类对象本身。</p><h4 id="关于循环引用"><a href="#关于循环引用" class="headerlink" title="关于循环引用"></a>关于循环引用</h4><p>引用计数的一个问题就是不能处理循环引用的情况，当两个对象互相引用的时候，引用计数永远为 1，导致二者都无法释放从而造成内存泄露。这时将其中一个 shared_ptr 改为 weak_ptr，在需要获取操作权的时候使用 <code>weak_ptr.lock()</code>函数将 weak_ptr 提升为 shared_ptr 即可，这样既解决了循环引用问题也达到了原本的目的。</p><p>关于循环引用的例子可以查看<a href="https://blog.csdn.net/u012442719/article/details/55045583">c++ weak ptr解除指针循环引用</a>加深理解。</p><h4 id="shared-ptr-的实现"><a href="#shared-ptr-的实现" class="headerlink" title="shared_ptr 的实现"></a>shared_ptr 的实现</h4><p>查看<a href="https://blog.csdn.net/xiaodu655/article/details/85780240">智能指针（shared_ptr的实现）</a>。</p><h4 id="关于野指针"><a href="#关于野指针" class="headerlink" title="关于野指针"></a>关于野指针</h4><p>初始化指针时没有给初始值或者释放内存后没有将指针置空就会产生野指针，具体可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/">【C++ 对象模型】（六）关于执行期</a>中 2.2 部分。</p><p>避免野指针的方法是：</p><ul><li>初始化指针的时候将其置为 nullptr，之后再对其操作</li><li>释放指针的时候将其置为 nullptr</li></ul><h2 id="3-STL"><a href="#3-STL" class="headerlink" title="3 STL"></a>3 STL</h2><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/">【STL】迭代器</a></p><h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/">【STL】序列式容器</a></p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/">【STL】关联式容器</a></p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><h4 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h4><ol><li><strong>预编译</strong>（.cpp -&gt; .i），预编译主要进行代码文本替换工作。编译器执行预编译指令（以 # 开头，例如 #include），这个过程会得到不包含 # 指令的 .i 文件。这个过程会拷贝 #include 包含的文件代码，进行 #define 宏定义的替换 ， 处理条件编译指令（#ifndef、#ifdef、#endif）等等。</li><li><strong>编译优化</strong>（.i -&gt; .s），通过预编译输出的 .i 文件中，只包含常量、字符串、变量的定义，以及关键字：main、if、else、for、while等。编译优化阶段则是通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</li><li><strong>汇编</strong>（.s -&gt; .o 或 .obj），汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件。目标文件中存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成，通常至少有两个段：<ul><li>代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行</li></ul></li><li><strong>链接</strong>（.o -&gt; .exe &#x2F; .a &#x2F; .so &#x2F; .lib &#x2F; .dll 等），由汇编程序生成的目标文件并不能立即就执行，还要通过链接过程。这是因为某个源文件调用了另一个源文件中的函数或常量或在程序中调用了某个库文件中的函数，链接的主要工作就是将有关的目标文件连接起来，形成最终的可执行文件。</li></ol><h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>堆是由程序员控制的内存区域，通过 new 和 delete 来申请堆上的内存和释放堆上的内存。</p><p>栈是由编译器管理的内存，在需要时自动分配，不需要时自动清除。栈通常存放局部变量、函数参数等。</p><p>除了堆和栈之外，还有存储全局变量和静态变量的存储区以及存放常量的存储区。</p><p>堆和栈的对比：</p><table><thead><tr><th></th><th>堆（Heap）</th><th>栈（Stack）</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>堆中资源由程序员控制（需要注意内存泄漏）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td><strong>内存管理机制</strong></td><td>系统维护一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序，系统还会将多余的部分重新放入空闲链表中，释放内存时将内存重新加入空闲内存链表中。</td><td>栈是一块连续的内存空间，只要栈的剩余空间大于所申请空间，系统就为程序提供栈内存，否则报错 stack overflow。</td></tr><tr><td><strong>空间大小</strong></td><td>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</td><td>在Windows下，栈是向低地址扩展的数据结构，栈是一块连续的内存区域，大小是操作系统预定好的，在编译时确定，可设置。</td></tr><tr><td><strong>碎片问题</strong></td><td>对于堆，频繁的 new &#x2F; delete 会造成大量内存碎片，使程序效率降低。</td><td>对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。</td></tr><tr><td><strong>分配方式</strong></td><td>堆都是动态分配，没有静态分配的堆</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由 alloca() 函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td><strong>效率</strong></td><td>堆由 C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是极其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table><h4 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第 1 部分。</p><h4 id="内联函数与宏的区别"><a href="#内联函数与宏的区别" class="headerlink" title="内联函数与宏的区别"></a>内联函数与宏的区别</h4><p>宏在预编译时在调用处执行字符串的原样替换（宏展开）。而内联函数在编译时在调用处展开，同时进行<strong>参数类型检查，宏定义不会进行参数类型检查。</strong></p><p>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</p><p>一般来说内联函数可以完全替代宏，更多关于内联函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/">【C++ 对象模型】（四）关于函数成员</a>第 3 部分。</p><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝就是在拷贝时直接进行简单的对应赋值操作，类似于参数的引用传递，源对象与拷贝对象共用一份实体，对其中任何一个对象的改动都会影响另外一个对象。</p><p>深拷贝则类似于参数的值传递，源对象与拷贝对象互相独立 ，其中任何一个对象的改动都不会对另外一个对象造成影响。</p><h4 id="什么时候需要深拷贝"><a href="#什么时候需要深拷贝" class="headerlink" title="什么时候需要深拷贝"></a>什么时候需要深拷贝</h4><p>当一个类中有对其他类对象成员时需要深拷贝，也就是不能直接将一个类对象的某个对象成员赋值给另一个类对象，而是要单独开辟一块内存，重新构造一个相同的对象成员，否则当类对象析构时，拷贝的类对象的该对象成员也被析构掉了就会产生错误。</p><p>关于拷贝构造函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分。</p><h4 id="C-的强制类型转换"><a href="#C-的强制类型转换" class="headerlink" title="C++ 的强制类型转换"></a>C++ 的强制类型转换</h4><p>C++ 提供四种强制类型转换关键字：static_cast、const_cast、reinterpret_cast 和 dynamic_cast。</p><ul><li><strong>static_cast</strong> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。主要用于内置类型之间的转换或者将空指针转化为对应类型的指针。static_cast 也可以用于类层次结构中基类和派生类之间指针或引用的转换，但<strong>需要注意</strong>：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的，但进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</li><li><strong>const_cast</strong> 用于强制去掉 const 修饰的常量特性，但需要特别注意的是 const_cast 不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。具体的例子可以查看<a href="https://blog.csdn.net/q610098308/article/details/115915802">C++强制类型转换</a>第 2 部分，总之非必要情况下尽量不要使用 const_cast。</li><li><strong>reinterpret_cast</strong> 主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。reinterpret_cast 可以将指针或引用转换为一个足够长度的整形，这里的足够长度具体是多少则取决于操作系统，如果是 32 位的操作系统，就需要 4 个字节及以上的整型，如果是 64 位的操作系统则需要 8 个字节及以上的整型。 </li><li><strong>dynamic_cast</strong> 是 C++ 支持多态的方式之一，其他三种类型转换都是在编译时进行，而 dynamic_cast 则是在运行时处理。 在 C++ 中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。dynamic_cast 操作符则可以在运行期对可能产生问题的类型转换进行判定。dynamic_cast 具有以下特性：<ul><li>不能用于内置的基本数据类型的强制转换。</li><li>dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr。</li><li>使用 dynamic_cast 进行转换时，基类中一定要有虚函数，否则编译不通过。这是因为类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</li><li>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是完全一样的。在进行下行转换时，由于 dynamic_cast 具有运行时类型检查的功能，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败，因此要比 static_cast 更安全。运行时类型检查需要运行时类型信息，这个信息存储在虚函数表中，关于这部分可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/">【C++ 对象模型】（一）关于对象</a>第 2 部分和<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/">【C++ 对象模型】（七）模板和 RTTI</a>第 2 部分。</li></ul></li></ul><h4 id="关于模板的声明和实现"><a href="#关于模板的声明和实现" class="headerlink" title="关于模板的声明和实现"></a>关于模板的声明和实现</h4><p>C++ 在写模版函数时（<code>template&lt;class T&gt;</code>之类的），头文件不能与 cpp 文件分离。这就意味者，你头文件定义的含模版的地方必须在头文件中实现，没用模版定义的地方可以放在 cpp 中实现。为什么会这样呢？</p><p>C++ 中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。</p><p>既然是在编译的时候，根据套用的不同类型进行编译，那么，套用不同类型的模板类实际上就是完全不同的类型，也就是说 <code>stack&lt;int&gt;</code> 和 <code>stack&lt;char&gt;</code> 是两个不同的数据类型，他们共同的成员函数也不是同一个函数，只不过具有相似的功能罢了。因此这两个模板类的成员函数也会被编译出完全不同的代码。</p><p>所以模板类的实现，脱离具体的使用，是无法单独的编译的；把声明和实现分开的做法也是不可取的，必须把实现全部写在头文件里面。为了清晰，实现可以不写在 class 后面的花括号里面，可以写在 class 的外面。</p><p>但也可以实现模板声明和实现分离，比如有下面的模板类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTemplate</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">TestTemplate</span>(Node node):</span><br><span class="line">  <span class="built_in">data</span>(node) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  Node data;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> node&gt;</span><br><span class="line"><span class="type">void</span> TestTemplate&lt;node&gt;::<span class="built_in">print</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TestTemplate &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把它们分别放在 .h 和 .cpp 文件中，链接器会报错，提示找不到实现。但在 .h 文件中模板类的声明下加这一句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestTemplate.tpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后把实现放在名为 TestTemplate.tpp 文件中，即可实现模板声明和实现的文件分离。</p><h4 id="类的静态成员变量何时初始化"><a href="#类的静态成员变量何时初始化" class="headerlink" title="类的静态成员变量何时初始化"></a>类的静态成员变量何时初始化</h4><p>在 main 函数运行前，程序加载时进行初始化，分为静态初始化和动态初始化。</p><p>静态初始化是用常量堆静态成员初始化，静态初始化在程序加载的过程中完成。</p><p>动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a &#x3D; foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。</p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p><p>左值是可寻址的变量，有持久性；右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</p><p>左值和右值主要的区别之一是左值可以被修改，而右值不能。</p><h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。</p><p>能指向左值，不能指向右值的就是左值引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure><p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，const 左值引用是可以指向右值的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><p>const 左值引用不会修改指向值，因此可以指向右值，这也是为什么通常要使用 <code>const &amp;</code> 作为函数参数的原因之一，如 <code>std::vector </code>的 <code>push_back</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>如果没有 <code>const</code>，<code>vec.push_back(5)</code> 这样的代码就无法编译通过了。</p><p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"> </span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure><h4 id="move-和-forward-的作用"><a href="#move-和-forward-的作用" class="headerlink" title="move 和 forward 的作用"></a>move 和 forward 的作用</h4><p><code>std::move</code> 可以将左值强制转化为右值，从而让右值引用可以指向左值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = std::<span class="built_in">move</span>(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure><p>那么 move 到底有什么用处呢？首先来总结一下左右值引用：</p><ol><li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li><li>右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值，但 const 左值引用也能指向右值。</li><li>作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li></ol><p>上面已经给出了 move 的作用之一，就是比左值引用更加灵活，但其本身只是一个类型转换工具，不会对性能有任何提升，但使用 move 可以实现移动语义从而提升性能。</p><p>在没有右值引用之前，当一个类中有其他对象成员的时候，拷贝构造或者赋值运算都需要深拷贝，相当于复制了一份对象成员，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然拷贝构造函数的参数是左值引用的，左值引用就是为了防止拷贝，但函数内还是进行了深拷贝，如果被拷贝者之后就不需要了，那这样的拷贝函数会显得非常呆，于是有人提出是不是可以写一个移动构造函数，进行浅拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用 const 左值引用实现移动构造函数有两个问题：</p><ul><li>不优雅，表示移动语义还需要一个额外的参数(或者其他方式)</li><li>实际根本无法实现，<code>temp_array</code>是个 const 左值引用，无法被修改，所以 <code>temp_array.data_ = nullptr;</code> 这行根本无法编译通过。当然函数参数可以改成非 const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，但这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li></ul><p>可以看出左值引用使用起来非常不方便，而使用右值引用作为参数可以完美的解决这个问题，实现成员数据的移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止 temp_array 析构时 delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时使用 move 转化为右值传入函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做一些操作</span></span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上在 STL 的很多容器中都使用了以右值引用为参数的移动构造函数和移动赋值重载函数，或者其他函数，最常见的如 std::vector 的 <code>push_back</code> 和 <code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;aacasxs&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;axcsddcas&quot;</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非设计不允许移动，STL 中的类大都支持移动语义函数。另外，编译器会默认在用户自定义的类和结构体中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数。因此，<strong>可移动对象在需要拷贝且被拷贝者之后不再被需要的场景中，建议使用 <code>std::move</code> 触发移动语义，提升性能。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line"><span class="comment">// 改为： </span></span><br><span class="line">moveable_objecta = std::<span class="built_in">move</span>(moveable_objectb);</span><br></pre></td></tr></table></figure><p>还有些 STL 类是 <code>move-only</code> 的，比如智能指针中的 <code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动（转移内部对象所有权，或者叫浅拷贝），不能拷贝（深拷贝）。</p><p>与 move 相比，forward 更强大，move 只能将左值转化为右值，forward 都可以。</p><p><code>std::forward&lt;T&gt;(u)</code> 有两个参数 T 与 u。当 T 为左值引用类型时，u 将被转换为 T 类型的左值；否则 u 将被转换为 T 类型右值。</p><h4 id="什么是引用折叠"><a href="#什么是引用折叠" class="headerlink" title="什么是引用折叠"></a>什么是引用折叠</h4><p>右值引用比左值引用更加灵活，但如果右值引用绑定的对象类型是未知的话，就既可能是左值，又可能是右值。比如模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">// 10是右值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// x是左值</span></span><br></pre></td></tr></table></figure><p>由于存在 <code>T&amp;&amp;</code> 这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这时相比普通的右值引用(&amp;&amp;)会发生类型的变化，这种变化就称为引用折叠。</p><p>引用折叠规则如下：</p><p>1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;）</p><p>2.所有的其他引用类型之间的折叠都将变成左值引用。 （A&amp; &amp; 变成 A&amp;; A&amp; &amp;&amp; 变成 A&amp;; A&amp;&amp; &amp; 变成 A&amp;）</p><h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>C++ 中 static 修饰不同的内容会有不同的效果：</p><ul><li>static 修饰变量的时候，被修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。</li><li>static 修饰类中的成员变量的时候，可以直接通过类名访问改变量，该变量值初始化一次，被所有对象共享</li><li>static 修饰类中的函数的时候，该函数可以直接通过类名调用，且静态成员函数只能访问类中的静态成员变量</li></ul><h4 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h4><ul><li>定义常量</li><li>防止内容被修改（const char* p 是指针指向的内容不可变，而 char* const p 是指针本身不可变）</li><li>左值引用指向右值</li></ul><h4 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h4><p>extern 可以引用不在同一个文件中的变量或者函数</p><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>指针是一个地址，是一个单独的变量，指针本身和其指向的内容都可以被改变；而引用是对象的别名，依附于某一个对象，可以通过引用改变对象的内容，但引用本身不能改变，即引用在其生命周期内只能依附于固定的对象。</p><p>因此可以有空指针，但不能有空的引用。</p><h4 id="auto-和-decltype"><a href="#auto-和-decltype" class="headerlink" title="auto 和 decltype"></a>auto 和 decltype</h4><ul><li><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></li><li><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></li><li><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.2&utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></li></ul><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><ul><li><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C++ Lambda表达式原理及应用</a></li><li><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></li><li><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></li></ul><h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><ul><li><a href="https://blog.csdn.net/JMW1407/article/details/107130600">仿函数(functors)</a></li><li><a href="https://blog.csdn.net/toby54king/article/details/105103111">C++中的仿函数有点难，这篇文章却讲的通俗易懂</a></li><li><a href="https://zhuanlan.zhihu.com/p/362323211">C++ 仿函数为何而生</a></li></ul><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/64985296">C++17 新特性之 std::optional（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/251306766">C++干货系列——C++17新特性之std::optional</a></li></ul><h4 id="游戏引擎常用的设计模式"><a href="#游戏引擎常用的设计模式" class="headerlink" title="游戏引擎常用的设计模式"></a>游戏引擎常用的设计模式</h4><p>关于设计模式具体的可以查看<a href="https://zhuanlan.zhihu.com/p/431714886">C++各类设计模式及实现详解</a>，这里简单总结游戏引擎中可能用到的几种：</p><ul><li>单例模式（SingletonDesign Pattern）：只允许创建一个类的一个实例。在游戏中，就像在电影里，应该只有一个导演。导演是一个类，这个类在游戏中指挥发生的事情。它控制对象的呈现。它控制位置更新。它将玩家的输入指向正确的游戏角色。引擎应该阻止创建一个以上的导演类的实例，通过单例设计模式来实现。此设计模式确保为给定类实例化有且只有一个对象。</li><li>策略模式（StrategyDesign Pattern）：通过解耦类行为从而提供灵活性。在游戏中，你应该将输入控制器和游戏逻辑之间的交互进行解耦。游戏的逻辑应该接收相同类型的输入，而不管输入控制器是什么（按钮，手势，操纵杆）。尽管对用户每个输入控制器的行为表现不同，但它们必须向游戏的逻辑提供相同的数据。此外，添加或删除输入控制器不应导致游戏崩溃。这种解耦行为和灵活性是可能的，这归功于策略设计模式。这种设计模式允许通过动态方式来改变行为，而不需要修改游戏的任何逻辑，为你的游戏提供了很高的灵活性。</li><li>观察者模式（Observer Design Pattern）：允许类在不知道任何事情的情况下相互交互。在游戏中，你的所有类耦合度应该设计的很低。这意味着你的类应该能够彼此交互且彼此之间应该知道对方尽量少的内容。使得你的类具有低耦合度，使得你的游戏可以模块化和灵活性的添加新的功能，且不会有意外的错误。</li><li>组合模式（CompositeDesign Pattern）：为所有类提供了统一的接入点。游戏通常包含许多视图。主视图中显示角色。有一个子视图，显示玩家的积分。有一个子视图，显示游戏中剩下的时间。如果你在移动设备上玩游戏，那么每个按钮都是一个视图。可维护性应该是游戏开发过程中的主要关注点。每个视图不应具有不同的函数名称或不同的访问点。相反，你想要为每个视图提供一个统一的访问点，即相同的函数调用应该既能够访问主视图也能够访问子视图。这种统一的接入点可以使用复合设计模式。此模式将每个视图放置在树状结构中，从而为每个视图提供统一的访问点。取代了需要用不同的函数来访问不同的子视图，组合模式可以用相同的函数访问任何视图。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇总结 C++ 相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="知识汇总" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【Pilot代码解读】渲染系统（一）渲染流程</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/18/20220618-Pilot-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/18/20220618-Pilot-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-06-18T02:56:25.000Z</published>
    <updated>2022-06-23T09:23:52.195Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们了解了引擎的整体运行流程以及反射机制的实现，这一节开始探究 Pilot 的渲染系统是如何实现的，首先来了解渲染系统的整个流程。</p><p><em><span id="more"></span></em></p><p>回顾上一节中，引擎运行时最核心的函数 <code>tickOneFrame()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到引擎每一帧的流程就是先进行 <code>logicalTick</code>，然后通过 <code>swapLogicRenderData</code> 进行渲染系统的数据更新，最后进行渲染 <code>rendererTick</code>，之后还有一些窗口的事件响应。接下来我们从 <code>logicalTick</code> 开始看看整个系统是如何运行的。</p><h3 id="1-logicalTick"><a href="#1-logicalTick" class="headerlink" title="1 logicalTick"></a>1 logicalTick</h3><p><code>logicalTick</code>  的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::logicalTick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_world_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    g_runtime_global_context.m_input_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>logicalTick</code>  内部调用了世界管理系统的 tick 和输入管理系统的 tick。</p><h4 id="1-1-世界管理系统"><a href="#1-1-世界管理系统" class="headerlink" title="1.1 世界管理系统"></a>1.1 世界管理系统</h4><p>世界管理系统 <code>m_world_manager</code> 属于 <code>WorldManager</code> 类，该类用于管理整个游戏世界，包括编辑世界和运行世界，世界中包含各种关卡（Level），于是  <code>WorldManager</code> 的 tick 实际上就是调用关卡的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorldManager::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_world_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">loadWorld</span>(m_current_world_url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tick the active level</span></span><br><span class="line">    std::shared_ptr&lt;Level&gt; active_level = m_current_active_level.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (active_level)</span><br><span class="line">    &#123;</span><br><span class="line">        active_level-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而关卡类 Level 就是用于管理游戏对象（GO）的类，包含多个 Game Objects，于是 Level 的 tick 函数自然就是调用每个 GO 的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Level::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; id_object_pair : m_gobjects)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(id_object_pair.second);</span><br><span class="line">        <span class="keyword">if</span> (id_object_pair.second)</span><br><span class="line">        &#123;</span><br><span class="line">            id_object_pair.second-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_current_active_character &amp;&amp; g_is_editor_mode == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_current_active_character-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了调用每个 GO 的 tick ，最后还判断了是否有当前激活的角色和是否在编辑模式，如果不在编辑模式且存在激活的角色（也就是可被控制的角色），就调用该角色的 tick。角色 Character 类可以通过游戏对象 GObject 类来创建，因此它们都属于游戏对象，而 GObject 类的成员如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GObjectID   m_id &#123;k_invalid_gobject_id&#125;;</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::string m_definition_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to use the ReflectionPtr due to that the components need to be reflected </span></span><br><span class="line">    <span class="comment">// in editor, and it&#x27;s polymorphism</span></span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br></pre></td></tr></table></figure><p>每一个 GO 包含唯一的 GID 标识，名字，读取的链接以及各种组件，这些组件需要使用反射，因为组件有许多不同的类型，比如动画组件、mesh 组件、运动组件、相机组件等等，并且这些组件还要显示在组件面板，所以需要用到反射机制。于是每一个 GO 的 tick 就是调用它所有组件的 tick：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GObject::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : m_components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldComponentTick</span>(component.<span class="built_in">getTypeName</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            component-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不同组件的 tick 自然就是对应于动画、物理、相机运动、物体形变等各个逻辑系统的运算。</p><h4 id="1-2-输入管理系统"><a href="#1-2-输入管理系统" class="headerlink" title="1.2 输入管理系统"></a>1.2 输入管理系统</h4><p>输入管理系统 <code>InputSystem</code> 类自然是用来管理鼠标、键盘的各种输入并作出响应，这里不多赘述。</p><h3 id="2-swapLogicRenderData"><a href="#2-swapLogicRenderData" class="headerlink" title="2 swapLogicRenderData"></a>2 swapLogicRenderData</h3><p>逻辑系统运算完毕后，这一帧的世界就构建完成了，但是逻辑运算是在当前世界上进行的，如果世界的资源发生了改变，那么逻辑系统告诉渲染系统更新了哪些资源，渲染系统要获取这些资源加入到渲染资源中，这是通过渲染系统中的 <code>swapLogicRenderData</code> 函数完成的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::swapLogicRenderData</span><span class="params">()</span> </span>&#123; m_swap_context.<span class="built_in">swapLogicRenderData</span>(); &#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数调用了渲染系统的成员 <code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数， <code>m_swap_context</code> 属于 <code>RenderSwapContext</code> 类，其中包含要交换的数据 <code>RenderSwapData</code>，<code>RenderSwapData</code> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderSwapData</span></span><br><span class="line">&#123;</span><br><span class="line">    std::optional&lt;LevelResourceDesc&gt;      level_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_to_delete;</span><br><span class="line">    std::optional&lt;CameraSwapData&gt;         camera_swap_data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDirtyGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDeleteGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中包含关卡资源、游戏对象、相机数据，这些都是在逻辑系统计算的。这里使用了 C++ 17 的新特性 <code>optional</code>，为了之后可以通过 <code>has_value</code> 函数快速判断是否需要在渲染系统中更新这些资源的数据。</p><p><code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swapLogicRenderData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isReadyToSwap</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RenderSwapContext::isReadyToSwap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(m_swap_data[m_render_swap_data_index].level_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_to_delete.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].camera_swap_data.<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resetLevelRsourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectResourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectToDelete</span>();</span><br><span class="line">    <span class="built_in">resetCameraSwapData</span>();</span><br><span class="line">    std::<span class="built_in">swap</span>(m_logic_swap_data_index, m_render_swap_data_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其功能就是当需要在渲染系统中更新这些资源的数据时就进行数据交换操作。</p><h3 id="3-rendererTick"><a href="#3-rendererTick" class="headerlink" title="3 rendererTick"></a>3 rendererTick</h3><p>接下来就是最重要的 rendererTick 了，rendererTick 调用了渲染系统的 tick 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::rendererTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染系统的 tick 函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process swap data between logic and render contexts</span></span><br><span class="line">    <span class="built_in">processSwapData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare render command context</span></span><br><span class="line">    m_rhi-&gt;<span class="built_in">prepareContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame buffer</span></span><br><span class="line">    m_render_resource-&gt;<span class="built_in">updatePerFrameBuffer</span>(m_render_scene, m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame visible objects</span></span><br><span class="line">    m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                         m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare pipeline&#x27;s render passes data</span></span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">preparePassData</span>(m_render_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render one frame</span></span><br><span class="line">    <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是处理从逻辑系统交换来的数据，也就是根据场景或者 GO 是否有变化从硬盘加载对应的资源或者卸载部分资源，然后准备渲染的各种数据。这些数据包括：</p><ul><li>变换矩阵、场景的光源数据，这通过 <code>updatePerFrameBuffer</code> 函数来设定，该函数根据场景和相机来获取矩阵和场景的光照信息，而整个渲染场景的光源在系统初始化的时候会进行构建，之后不会改变，相机会在逻辑 tick 中改变；</li><li>可见的物体数据，这通过 <code>updateVisibleObjects</code> 函数进行，实际上就是在进入渲染之前，把完全不可见的物体剔除掉。</li></ul><p>数据准备完毕后准备渲染的 Pass，最后根据指定的渲染模式进行前向渲染或者延迟渲染。</p><p>下一节开始我们将学习这些流程的具体实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们了解了引擎的整体运行流程以及反射机制的实现，这一节开始探究 Pilot 的渲染系统是如何实现的，首先来了解渲染系统的整个流程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Pilot引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Pilot%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【Pilot代码解读】整体框架与反射机制</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/</id>
    <published>2022-06-17T02:24:42.000Z</published>
    <updated>2022-06-19T06:20:36.832Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要了解 Pilot 游戏引擎的代码框架、对象序列化的实现以及反射机制的实现。</p><p><em><span id="more"></span></em></p><h3 id="1-引擎运行结果"><a href="#1-引擎运行结果" class="headerlink" title="1 引擎运行结果"></a>1 引擎运行结果</h3><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220619142030660.png" alt="image-20220619142030660"></p><h3 id="2-代码整体框架"><a href="#2-代码整体框架" class="headerlink" title="2 代码整体框架"></a>2 代码整体框架</h3><p>Pilot 引擎除了第三方库之外，主要包含四部分，分别是编辑器、预编译、引擎运行时核心和 Shader 编译，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220617091342823.png" alt="image-20220617091342823"></p><p>其中预编译部分负责预先生成一些文件，比如用来实现反射的文件，会在后文中提到，Shader 编译部分在之后的渲染系统代码中也会说到。编辑器负责整个引擎的界面、工具等的实现，需要引擎核心部分作为成员，是引擎核心功能对使用者的接口；引擎核心部分按照<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/">【游戏引擎】（一）游戏引擎架构</a>中的分层结构实现，分别是核心层、功能层、平台层、资源层：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220617092113728.png" alt="image-20220617092113728"></p><p>而 engine.cpp 负责将这些系统整合起来构成完整的运行时引擎。</p><p>整个引擎的主函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;runtime/engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;editor/include/editor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_XSTR(s) PILOT_STR(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_STR(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::filesystem::path pilot_root_folder = std::filesystem::<span class="built_in">path</span>(<span class="built_in">PILOT_XSTR</span>(PILOT_ROOT_DIR));</span><br><span class="line"></span><br><span class="line">    Pilot::EngineInitParams params;</span><br><span class="line">    params.m_root_folder      = pilot_root_folder;</span><br><span class="line">    params.m_config_file_path = pilot_root_folder / <span class="string">&quot;PilotEditor.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEngine* engine = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEngine</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">startEngine</span>(params);</span><br><span class="line">    engine-&gt;<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEditor* editor = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEditor</span>();</span><br><span class="line">    editor-&gt;<span class="built_in">initialize</span>(engine);</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    engine-&gt;<span class="built_in">shutdownEngine</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从主函数出发可以大概了解引擎运行时的整体架构。主函数中首先初始化了运行时引擎，然后启动和初始化引擎，之后用运行时引擎初始化编辑器，再让编辑器运行，编辑器运行结束后先清理编辑器内容再清理引擎内容。</p><p>其中关键的函数就是 <code>editor-&gt;run()</code> 了，函数内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEditor::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m_engine_runtime);</span><br><span class="line">    <span class="built_in">assert</span>(m_editor_ui);</span><br><span class="line">    <span class="type">float</span> delta_time;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delta_time = m_engine_runtime-&gt;<span class="built_in">calculateDeltaTime</span>();</span><br><span class="line">        g_editor_global_context.m_scene_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        g_editor_global_context.m_input_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        <span class="keyword">if</span> (!m_engine_runtime-&gt;<span class="built_in">tickOneFrame</span>(delta_time))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断了运行时引擎和引擎 UI 是否初始化成功，然后就是运行时主循环了，循环内就是各种 <code>tick()</code> 函数，其中最重要的是运行时引擎的 <code>tickOneFrame</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其中包含 <code>logicalTick()</code> 和 <code>rendererTick()</code> 两部分，和我们之前笔记中描述的流程完全一致，当窗口关闭时函数返回 false，于是引擎主循环就会退出。</p><h3 id="3-代码反射"><a href="#3-代码反射" class="headerlink" title="3 代码反射"></a>3 代码反射</h3><p>代码反射是指允许在运行时检查已知数据类型。 反射允许枚举给定程序集中的数据类型，并且可以发现给定类或值类型的成员。 无论类型在编译时是已知的还是引用的，都是如此。 这使得反射成为开发和代码管理工具的有用功能。</p><p>定义很抽象，通过一个实际场景来理解，比如引擎中对于不同对象要显示出它的组件，但是不同对象的属性不同，我们不可能为每个类都编写一个组件面板，这时通过反射，就可以快速方便的知道一个类中有哪些成员变量，他们都是什么类型。</p><p>反射的另一个作用是在对象序列化时使用，所谓序列化就是存储到磁盘上，将对象变成一定格式的二进制文件或者自定义格式的文件（如json），然后要用的时候再将保存在磁盘上的文件转化成一个内存中的对象，这个过程中总是需要有一个指示来告诉编译器要生成什么样的对象，最简单的方式当然就是类名了，例如：将一个 ClassXXX 对象存储到磁盘上，再从磁盘读取的时候让编译器根据 “ClassXXX” 名称来 new 一个对象。但问题是，C++ 语言本身不支持反射，也就是说不能通过类的名称字符串来生成一个对象，像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassXXX object = <span class="keyword">new</span> “ClassXXX”;</span><br></pre></td></tr></table></figure><p>于是就需要反射机制来实现这个功能。</p><p>反射的实现方法是，提前处理需要反射的类型，生成一个类似配置文件的东西，在 Pilot 引擎中也是一个 C++ 文件，在预编译阶段生成，文件中包含一个类有哪些属性变量、父类。这些属性变量的 get 、set、getFieldName 获取变量的名字、getFieldTypeName 获取变量的类型、isArray_id 是不是数组等方法，都被封装成一个结构体，与类型的名字（字符串类型）做一个映射（map）。<br>在运行的时候加载这些配置表，这样我们其实通过一个类型的名字就可以知道他有什么变量，以及这些变量的具体属性和方法，然后就可以把这个类型当做一个方法集，与类型的实例挂钩就可以方便的处理这个实例的各个属性。</p><p>接下来我们以常用的 Vector3 类为例，来看看 Pilot 中的反射实现。首先是类的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">REFLECTION_TYPE</span>(Vector3)</span><br><span class="line"><span class="built_in">CLASS</span>(Vector3, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(Vector3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> y &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> z &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了三个宏定义，他们都在 <code>reflection.h</code> 中定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS(class_name, ...) class class_name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_BODY(class_name) \</span></span><br><span class="line"><span class="meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">    friend class PSerializer;</span></span><br><span class="line">    <span class="comment">// public: virtual std::string getTypeName() override &#123;return #class_name;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_TYPE(class_name) \</span></span><br><span class="line"><span class="meta">    namespace Reflection \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        namespace TypeFieldReflectionOparator \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            class Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br></pre></td></tr></table></figure><p>可以看到首先声明了与类名称有关的 <code>Type##class_name##Operator</code> 类，<code>##</code> 是连接符，将两个字符串连接起来，这里生成的类则Iran就是 <code>TypeVector3Operator</code>，然后将该类和序列化类 <code>PSerializer</code> 作为了 Vector3 类的友元。</p><p><code>TypeVector3Operator</code> 类在 <code>vector3.reflection.gen.h</code> 文件中定义，这个文件是预编译阶段生成的，其中定义的就是对该类的各种回调函数，包括返回类名称，序列化类对象，通过序列化的 json 文件构建该类的对象，获取该类的基类，以及上面说到的对成员变量的各种方法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;D:/TechStack/GamesEngine/PilotEngine/Pilot-main/engine/source/runtime/core/math/vector3.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Pilot&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector3</span>;</span><br><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line"><span class="keyword">namespace</span> TypeFieldReflectionOparator&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">TypeVector3Operator</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getClassName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Vector3&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">constructorWithJson</span><span class="params">(<span class="type">const</span> PJson&amp; json_context)</span></span>&#123;</span><br><span class="line">          Vector3* ret_instance= <span class="keyword">new</span> Vector3;</span><br><span class="line">          PSerializer::<span class="built_in">read</span>(json_context, *ret_instance);</span><br><span class="line">          <span class="keyword">return</span> ret_instance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> PJson <span class="title">writeByName</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> PSerializer::<span class="built_in">write</span>(*(Vector3*)instance);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// base class</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getVector3BaseClassReflectionInstanceList</span><span class="params">(ReflectionInstance* &amp;out_list, <span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// fields</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;y&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_y</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_y</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;z&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_z</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_z</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="comment">//namespace TypeFieldReflectionOparator</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">TypeWrapperRegister_Vector3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_x=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_x);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_x);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_y=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_y);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_y);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_z=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_z);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_z);</span><br><span class="line">       ClassFunctionTuple* f_class_function_tuple_Vector3=<span class="keyword">new</span> <span class="built_in">ClassFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getVector3BaseClassReflectionInstanceList,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::constructorWithJson,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::writeByName);</span><br><span class="line">       <span class="built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_class_function_tuple_Vector3);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">namespace</span> TypeWrappersRegister&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Vector3</span><span class="params">()</span></span>&#123; <span class="built_in">TypeWrapperRegister_Vector3</span>();&#125;</span><br><span class="line">&#125;<span class="comment">//namespace TypeWrappersRegister</span></span><br><span class="line">&#125;<span class="comment">//namespace Reflection</span></span><br><span class="line">&#125;<span class="comment">//namespace Pilot</span></span><br></pre></td></tr></table></figure><p>上面的代码中还有注册这些回调函数的函数 <code>TypeWrapperRegister_Vector3</code>，函数中就是对所有成员的方法进行了注册，所谓注册就是将这些函数和类型名称对应起来，放到哈希表中，实现方法是用变量的各种方法初始化一个 <code>FieldFunctionTuple</code> 元组，这个元组的声明同样在 <code>reflection.h</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*, <span class="type">void</span>*)&gt;      SetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">void</span>*)&gt;            GetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">const</span> <span class="type">char</span>*()&gt;           GetNameFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span>*)&gt; SetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">int</span>, <span class="type">void</span>*)&gt;       GetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">void</span>*)&gt;              GetSizeFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">bool</span>()&gt;                  GetBoolFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">const</span> PJson&amp;)&gt;                          ConstructorWithPJson;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;PJson(<span class="type">void</span>*)&gt;                                 WritePJsonByName;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt;</span><br><span class="line">    FieldFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetBaseClassReflectionInstanceListFunc, ConstructorWithPJson, WritePJsonByName&gt;</span><br><span class="line">    ClassFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetArrayFunc, GetArrayFunc, GetSizeFunc, GetNameFuncion, GetNameFuncion&gt; ArrayFunctionTuple;</span><br></pre></td></tr></table></figure><p>元组中存放的就是各类函数的指针，然后通过一个宏定义 <code>REGISTER_FIELD_TO_MAP</code> 注册这些函数，该宏定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_FIELD_TO_MAP(name, value) TypeMetaRegisterinterface::registerToFieldMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_BASE_CLASS_TO_MAP(name, value) TypeMetaRegisterinterface::registerToClassMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_ARRAY_TO_MAP(name, value) TypeMetaRegisterinterface::registerToArrayMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNREGISTER_ALL TypeMetaRegisterinterface::unregisterAll();</span></span><br></pre></td></tr></table></figure><p>实际上宏定义就是调用了 <code>TypeMetaRegisterinterface</code> 类中的方法，该类是用来注册各种回调函数的接口，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeMetaRegisterinterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unregisterAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类中的各种方法就是用来将给定的函数指针元组和类名称关联起来，存放到全局定义的哈希表中，以类名为键，这样之后使用时通过类名就可以找到类中各种成员变量的名称、类型、方法了，这部分在 <code>reflection.cpp</code> 中实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown_type = <span class="string">&quot;UnknownType&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown      = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;      m_class_map;</span><br><span class="line">    <span class="type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt; m_field_map;</span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;      m_array_map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_field_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_array_map.<span class="built_in">find</span>(name) == m_array_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_array_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_class_map.<span class="built_in">find</span>(name) == m_class_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_class_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::unregisterAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_field_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_field_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_class_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_class_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_array_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_array_map.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有需要反射的类都会在运行时引擎启动时进行注册，也就是之前主函数中的 <code>engine-&gt;startEngine()</code> 函数，该函数定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::startEngine</span><span class="params">(<span class="type">const</span> EngineInitParams&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_init_params = param;</span><br><span class="line"></span><br><span class="line">    Reflection::TypeMetaRegister::<span class="built_in">Register</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.<span class="built_in">startSystems</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;engine start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>TypeMetaRegister</code> 类就是用来注册函数的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> Pilot</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Reflection</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TypeMetaRegister</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Register</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Unregister</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="comment">// namespace Reflection</span></span><br><span class="line">&#125; <span class="comment">// namespace Pilot</span></span><br></pre></td></tr></table></figure><p><code>Register()</code> 函数就是调用了各个类的注册函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TypeMetaRegister::Register</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Transform</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Quaternion</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Vector3</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于对象序列化和反射的使用示例，Pilot 也提供了一个样例代码，在 <code>meta/meta_example.cpp</code> 中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节主要了解 Pilot 游戏引擎的代码框架、对象序列化的实现以及反射机制的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Pilot引擎代码解读" scheme="https://lz328.github.io/LycTechStack.github.io/categories/Pilot%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时光线追踪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-06-09T08:03:44.000Z</published>
    <updated>2022-06-13T03:33:04.591Z</updated>
    
    <content type="html"><![CDATA[<p>随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。</p><p><em><span id="more"></span></em></p><h3 id="1-实时光线追踪基本思路"><a href="#1-实时光线追踪基本思路" class="headerlink" title="1 实时光线追踪基本思路"></a>1 实时光线追踪基本思路</h3><p>NVIDIA 在 2018 年推出了 RTX 系列显卡，采用 Turing 架构，引入了专门处理光线追踪的 RT Core，使得光线追踪这种计算开销极大的算法能够实时运行。</p><p>实时光线追踪和离线光线追踪使用的算法完全一致，都是采样光线，计算交点，然后循环迭代，RTX 20 系列支持每秒 100 亿根光线的处理，这个数字看似很多，但实际上还要除以屏幕的分辨率，通常就是几千万个像素，还要除以帧率，因此最终实际上目前真正的实时光线追踪只能达到每帧每个像素采样一根光线。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142644271.png" alt="image-20220609142644271"></p><p>可想而知这样得出的结果是噪声非常严重的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142722281.png" alt="image-20220609142722281"></p><p>因此实时光线追踪的重点实际上不是光线追踪，而是如何对 1 SPP 的 RTRT 结果进行降噪，使其达到和离线光线追踪一样的效果。下图展示了现在的实时光线追踪降噪技术所能达到的效果，非常不可思议：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142901751.png" alt="image-20220609142901751"></p><p>简单来说，实时光线追踪会首先生成一张 1 SPP 的 noisy 结果，然后对单帧进行图像空间降噪（Spatial Denoising），之后再联合前一帧图像（任何时候都假设前一帧已经没有噪声）进行时域降噪（Temporal Denoising），最终得到一帧没有噪声的结果。</p><h3 id="2-Spatial-Denoising"><a href="#2-Spatial-Denoising" class="headerlink" title="2 Spatial Denoising"></a>2 Spatial Denoising</h3><h4 id="2-1-联合双边滤波"><a href="#2-1-联合双边滤波" class="headerlink" title="2.1 联合双边滤波"></a>2.1 联合双边滤波</h4><p>单帧图像空间降噪简单的自然是使用低通滤波，比如高斯模糊，这样可以去掉高频的噪声，但同时也会丢掉图像中高频的信息，也就是一些细节，因此为了保留图像细节一般使用双边滤波（Bilateral Filtering）进行降噪。</p><p>双边滤波只是对高斯滤波的改进，高斯滤波只考虑了像素之间的距离作为权值的衰减因素，而为了保留高频信息，双边滤波还考虑了颜色，当两个像素的颜色差异过大时，权值也进一步变小，这样就可以保留原图中的边缘等高频信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609143945517.png" alt="image-20220609143945517"></p><p>上式中后一项是对颜色的距离进行了一个计算，这样相当于两个高斯分布的乘积作为一个像素周围其他像素的权值。</p><p>更进一步，既然可以考虑颜色，那么自然也可以考虑更多的因素，<strong>联合双边滤波（Joint Bilateral Filtering）</strong>就是将许多不同因素作为影响权值衰减的因素，除了像素之间的距离、颜色之外，还可以利用 G-Buffer 中存储的每个像素的深度、法线、反射率等等，因此联合双边滤波非常适合用来做 RTRT 的图像降噪，因为 G-Buffer 中的信息在渲染时就可以顺便得到，几乎不需要任何额外开销。</p><p>需要说明的是，上面是以高斯滤波为例的，实际上双边滤波或者联合双边滤波中的衰减系数不一定要是高斯分布的，可以是指数分布、余弦分布等等，只要能够描述衰减关系就可以。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144749719.png" alt="image-20220609144749719"></p><p>下面以一个例子来说明联合双边滤波的作用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144824808.png" alt="image-20220609144824808"></p><p>这是一张噪声很大的渲染结果，我们使用联合双边滤波考虑深度、法线、颜色的影响，于是在对点 B 进行滤波时，可能会将点 A 和点 C 的贡献加入到点 B，但是因为点 A 和点 B 的深度差异比较大，因此点 A 的贡献就会变小，而点 C 和点 B 的法线差异比较大，因此点 C 的贡献也会变小。而点 D 和点 E 的深度和法线相差不大，但颜色相差很大，因此权值也会变小，这样就可以得到比较好的滤波效果。</p><h4 id="2-2-大范围滤波优化"><a href="#2-2-大范围滤波优化" class="headerlink" title="2.2 大范围滤波优化"></a>2.2 大范围滤波优化</h4><p>这里还有一个问题需要讨论，因为使用联合双边滤波，我们的滤波核范围通常很大，不是通常的 5 * 5 或者 7 * 7，如果滤波核是 128 * 128，那么对每个像素进行滤波都要访问它周围一万多个像素，会非常耗时，因此需要对大滤波核的滤波进行优化，通常使用以下两种方法：</p><ul><li>Separate Passes：也就是将 128 * 128 的一次滤波分为 1 * 128 和 128 * 1 两次滤波，这样就可以大幅降低复杂度，只需要访问 256 次就可以完成之前访问一万多次的工作：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609145638690.png" alt="image-20220609145638690"></p><p>这么做可行的原因在于二维高斯分布本身就是两个一维高斯分布的乘积，因此也自然可以将一次二维滤波拆成两次一维滤波。但是对于双边滤波和联合双边滤波，不再是简单的二维高斯分布，因此不满足这样的特性，理论上不能使用这个方法，不过工业界依然使用这样的方法，在滤波核不是特别大的时候不会看出什么问题。</p><ul><li>Progressively Growing Sizes：这种方法将一个大的滤波拆分成多次小的滤波，但是每次小的滤波所取得周围像素的间隔会逐渐增大，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150034090.png" alt="image-20220609150034090"></p><p>将一个 64 * 64 的滤波拆分成了 5 次 5 * 5 的滤波，第一次在像素周围 5 * 5 的区域进行，第二次取的像素之间都会间隔 2 个像素，第三次间隔 4 个像素，直到第 5 次，间隔 16 个像素，整个区域刚好就是 64 * 64，这样将 64 * 64 变成了 5 * 5 * 5，同样大幅降低了复杂度。</p><h4 id="2-3-异常像素移除"><a href="#2-3-异常像素移除" class="headerlink" title="2.3 异常像素移除"></a>2.3 异常像素移除</h4><p>异常像素移除（Outlier Removal）是在进行滤波之前做的一项工作，所谓异常像素（outlier）是指在噪声图像中会有一些非常亮的像素，如果不去除，那在滤波的时候这些非常亮的像素就会扩散到周围一定的区域造成异常：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150605655.png" alt="image-20220609150605655"></p><p>去除他们的方法非常简单，对每一个像素，取它周围一定区域，通常是 7 * 7，然后求出这个区域内颜色的均值和方差，根据均值和方差可以确定一个范围：<br>$$<br>[\mu-k\sigma,\mu+k\sigma]<br>$$<br>将不在这个范围内的像素颜色截断在这个范围内即可。</p><h3 id="3-Temporal-Denoising"><a href="#3-Temporal-Denoising" class="headerlink" title="3 Temporal Denoising"></a>3 Temporal Denoising</h3><h4 id="3-1-Motion-Vector"><a href="#3-1-Motion-Vector" class="headerlink" title="3.1 Motion Vector"></a>3.1 Motion Vector</h4><p>时域滤波是实时光线追踪能够实现的重要原因之一，基本思想就是假设前一帧总是没有噪声的，于是可以将这一帧的像素所显示的位置对应到前一帧的那个像素找到，将它的颜色和这一帧像素的颜色线性融合起来，实现非常好的降噪效果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151126653.png" alt="image-20220609151126653"></p><p>对于第 i 帧的一个像素，我们可以从 G-Buffer 中得到该像素对应的世界空间位置，如果没有 G-Buffer，还可以通过屏幕坐标逆变换得到世界空间坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151336724.png" alt="image-20220609151336724"></p><p>然后我们在渲染的过程中一定知道这两帧之间物体是怎样移动的，因为我们掌控整个渲染过程，也就知道整个场景的变化过程，于是将当前帧的位置进行场景变换的逆变换，得到前一帧中该点的位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151431056.png" alt="image-20220609151431056"></p><p>再利用前一帧的各种矩阵将该点投影到屏幕上，就得到了前一帧中对应的像素坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151532403.png" alt="image-20220609151532403"></p><p>将该像素的颜色和当前帧的颜色进行融合：<br>$$<br>color_i &#x3D; \alpha color_i + (1-\alpha)color_{i-1}<br>$$<br>因为前一帧是没有噪声的图片，所以会让前一帧的颜色的权值更大，一般来说 $\alpha$ 取 0.1 到 0.2，也就是说当前帧的颜色有 80% 到 90% 取决于前一帧。</p><p>于是整个实时光线追踪去噪的过程可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151859574.png" alt="image-20220609151859574"></p><p>其中带有 - 的表示滤波后的图片，带有 ~ 的表示没有滤波的图片，什么都没有的表示没有噪声的图片。上面的公式表示先对当前帧进行单帧的 Spatial Denoising，再联合前一帧进行 Temporal Denoising。</p><p>下图是 1 SPP 的 RTRT 结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152103914.png" alt="image-20220609152103914"></p><p>使用了上述去噪方法后得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152123879.png" alt="image-20220609152123879"></p><p>这里的图片相比于有噪声的结果看起来变亮了很多，但实际上并没有，只是因为 RTRT 得出的有噪声的结果中像素的颜色很大，经过色调映射显示出来就会显得很暗，去噪的过程一定是能量守恒的。</p><p>下面是离线光线追踪的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152151531.png" alt="image-20220609152151531"></p><p>可以看到除了一些物体接触的地方的阴影没有渲染出来之外，实时光线追踪的结果和离线结果非常接近。</p><h4 id="3-2-Temporal-的问题"><a href="#3-2-Temporal-的问题" class="headerlink" title="3.2 Temporal 的问题"></a>3.2 Temporal 的问题</h4><p>时域去噪方法效果很好，但存在很多问题：</p><ul><li>切换场景的时候，时域去噪会失效，因为前后两帧几乎没有任何对应关系：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152409311.png" alt="image-20220609152409311"></p><ul><li>当我们在一个场景中的倒退的时候也会有问题，因为倒退的时候会有更多场景中的景象进入视野，于是就会出现当前帧的某个地方在上一帧中还没出现：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152546782.png" alt="image-20220609152546782"></p><ul><li>还有当物体移动的时候，会对其他物体造成遮挡，前后两帧中遮挡关系不一样，导致同一个位置会对应到不同的物体上，造成拖影现象：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152716311.png" alt="image-20220609152716311"></p><ul><li>以及由于光源移动造成的阴影拖影现象，虽然物体没有动，但是因为光照关系变了导致这一点的着色结果变了，从而使得后一帧融合了前一帧的颜色会显示出前一帧的拖影：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153019170.png" alt="image-20220609153019170"></p><h4 id="3-3-Clamping"><a href="#3-3-Clamping" class="headerlink" title="3.3 Clamping"></a>3.3 Clamping</h4><p>解决上述问题的一个最简单的方法是将前一帧对应的像素的颜色截断到当前帧像素周边一定范围内颜色的均值附近，利用上面的异常像素移除的方法就可以实现，然后再融合到当前像素上，这样可以一定程度解决前后帧颜色不对应的情况，但对于切换场景等情况也无能为力。此外由于将没有噪声的颜色截断到了有噪声的颜色范围内，一定会引入新的噪声。</p><h3 id="4-SVGF"><a href="#4-SVGF" class="headerlink" title="4 SVGF"></a>4 SVGF</h3><p>Spatiotemporal Variance-Guided Filtering 是一个实时光线追踪的具体解决方案，流程和我们上面说到的一致，只是在滤波核的设计上加入了一些更周全的考虑，因此可以得到非常好的效果。</p><p>SVGF 同样考虑了三个因素来影响滤波权值衰减：深度、法线和颜色。</p><p>对于深度，如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153703827.png" alt="image-20220609153703827"></p><p>由于箱子是侧对我们的，点 A 和点 B 的深度会有差异而使得滤波时的权值变小，但实际上他们属于同一面，不应该因为深度差异是他们的融合权值变小，因此引入了深度的梯度来修正这个影响，其中 $\epsilon$ 是为了防止两个点距离过近导致分母为 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153851851.png" alt="image-20220609153851851"></p><p>对于法线，使用了两点法线的点乘来作为衰减因素，同时加了一个指数来控制衰减的速度，这个指数和布林冯模型中高光的指数作用完全一致：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154028387.png" alt="image-20220609154028387"></p><p>对于颜色，SVGF 使用的是光照度，也就是像素的灰度值，首先计算了像素周围 7 * 7 范围内的灰度方差，然后还将这个方差进行了时域上的平均，最后在当前帧又取了周围 3 * 3 区域的方差来进行滤波衰减：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154224920.png" alt="image-20220609154224920"></p><p>SVGF 速度快效果好，但是拖影问题依然存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时PBR材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/</id>
    <published>2022-06-08T10:06:47.000Z</published>
    <updated>2022-06-13T03:32:47.691Z</updated>
    
    <content type="html"><![CDATA[<p>在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈微表面"><a href="#1-再谈微表面" class="headerlink" title="1 再谈微表面"></a>1 再谈微表面</h3><p>通过之前的学习可以发现，实时渲染的各种方法实际上都是在离线渲染的基础上，做各种假设和近似来快速得到一个近似地效果，材质也不例外，基于物理的材质最常用的就是微表面模型，实时渲染中同样使用微表面模型，因此我们首先来回顾微表面模型的内容。</p><p>微表面 BRDF 由菲涅尔项 F，几何项 G 和法线分布函数 D 组成，描述了从某个入射方向来的光会向某个出射方向反射出多少能量：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160027871.png" alt="image-20220608160027871"></p><h4 id="1-1-菲涅尔项"><a href="#1-1-菲涅尔项" class="headerlink" title="1.1 菲涅尔项"></a>1.1 菲涅尔项</h4><p>菲涅尔项描述了随着入射方向和法线夹角增大，反射会变得越来越强的现象：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160157916.png" alt="image-20220608160157916"></p><p>对于非导体，入射方向与法线夹角和反射率的关系为：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160244963.png" alt="image-20220608160244963"></p><p>即当我们沿着法线方向观察的时候几乎不会看到反射，而当我们垂直于法线方向观察的时候会看到物体几乎全部被反射。</p><p>对于导体（金属），菲涅尔曲线为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160343753.png" alt="image-20220608160343753"></p><p>即导体本身就会发生强烈的反射，随着视角变化，观察到的反射不会有太大的变化，因此可以说金属本身就会有比较固定的颜色（反射率），比如金、银、铜都有自己的颜色。</p><p>菲涅尔项表达式非常复杂，与介质和材质的折射率有关，一般在渲染中使用 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160608070.png" alt="image-20220608160608070"></p><p>总的来说，菲涅尔项描述了对于给定的入射方向和出射方向（半程向量），会有多少光从入射方向反射到出射方向上，一般来说渲染的时候出射方向固定，就是观察方向，那么不同入射方向的光反射到观察方向上的比例就不同，这是菲涅尔项的意义。</p><h4 id="1-2-法线分布函数"><a href="#1-2-法线分布函数" class="headerlink" title="1.2 法线分布函数"></a>1.2 法线分布函数</h4><p>法线分布函数描述了物体表面有多少微表面的法线和给定的半程向量方向一致，那么这些微表面才会被看到（只考虑镜面反射）。这是一个宏观的理解，实际上 NDF 描述的就是微表面的法线的概率分布：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161221287.png" alt="image-20220608161221287"></p><p>有不同的模型来描述法线分布，比如之前提到过的 Beckmann 法线分布函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161340128.png" alt="image-20220608161340128"></p><p>该函数由表面粗糙程度 $\alpha$ 和微表面法线与宏观法线（一般是 [0, 0, 1]）的夹角 $\theta_h$ 来定义，从公式可以看出，Beckmann 法线分布实际上和高斯分布非常像，其中表面粗糙程度 $\alpha$ 就类似于正态分布的标准差，粗糙程度越大，法线分布就越分散，而这个正态分布是对于 $tan\theta_h$ 的正态分布， $tan\theta_h$ 的几何意义如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161702625.png" alt="image-20220608161702625"></p><p>如果直接定义为夹角 $\theta_h$ 的正态分布，那么法线可能取到下半球，夹角就大于 90 度，而对于法线来说只有上半球有意义，因此定义为 $tan\theta_h$ 的正态分布的好处在于可以把上半球的所有法线方向对应到一个平面上的区间，这个区间是无穷大的，刚好是正态分布的积分区间，这样定义自然当法线在下半球的时候没有意义，是一个很巧妙的处理。</p><p>另一个更好的法线分布函数是 GGX 模型，也叫做 Trowbridge-Reitz（TR）模型，相较于 Beckmann 模型，GGX 是长尾（long tail）分布的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162529565.png" alt="image-20220608162529565"></p><p>也就是过度更加平滑，在值较小的部分衰减速度也更小，这样的好处是高光区域和非高光区域的过渡会更加平滑，呈现出一种 Glossy 的效果，更加真实：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162719493.png" alt="image-20220608162719493"></p><p>在 TR 模型的基础上还有一个更加通用的 GTR 法线分布，引入了一个可调的参数来控制长尾分布的程度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162902522.png" alt="image-20220608162902522"></p><p>总之，法线分布函数描述的是微表面的法线方向分布，对于给定的入射和出射方向，可以得到半程向量，法线分布函数可以给出这个材质的表面上有多少微表面的法线是在这个半程向量方向上的，那么这些微表面才可以被看到。更准确的说，NDF 描述的是法线方向的概率分布，渲染时，对于每一个着色点都有不同的半程向量，这个半程向量对应的可以被看到的概率可以通过 NDF 得出，可以被看到也就是表面法线和半程向量方向一致，因此 NDF 给出的概率实际上是当前着色点的法线刚好和当前半程向量重合的概率，而一个点的着色结果是许多不同的半程向量的结果的加权平均，权值就是这个概率，这样就能得到这个着色点正确期望的着色结果。</p><h4 id="1-3-几何项"><a href="#1-3-几何项" class="headerlink" title="1.3 几何项"></a>1.3 几何项</h4><p>几何项描述的是微表面之间的自遮挡现象，自遮挡现象有两种情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163456607.png" alt="image-20220608163456607"></p><p>一种是入射光被其他微表面遮挡入射不进来，一种是反射光被其他微表面遮挡反射不出去，前者称为 shadowing，后者称为 masking，因此几何项也被称为 Shadowing-Masking Term。</p><p>从上面的定义可以看出，当我们垂直于表面观察时，几乎不会发生自遮挡，当我们观察方向越接近法线的垂直方向，自遮挡就会越严重，因此对应于上面的法线分布得出的几何项分布大概长这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163757728.png" alt="image-20220608163757728"></p><p>几何项的意义在于，当我们垂直于表面观察的时候，几何项就是 1，对最终结果不会有任何影响，但是当我们接近垂直于法线的方向观察时，比如一个球体的边缘：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163914474.png" alt="image-20220608163914474"></p><p>如果不考虑几何项，那么按照微表面 BRDF 的定义：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163942337.png" alt="image-20220608163942337"></p><p>其他两项可以计算出正常结果，但是分母中有观察方向和法线的点乘，由于我们是接近垂直于法线的方向观察的，那么这个点乘结果就会接近于 0，于是整个BRDF 结果就会非常大，如果没有几何项来修正这个结果，那么最终的渲染图像上球体边缘就会是一圈白色。根据上面的几何项曲线可以看出，几何项在夹角接近 90 度的时候迅速变为 0，从而修正了这个非常大的结果。</p><h3 id="2-Kulla-Conty-Approximation"><a href="#2-Kulla-Conty-Approximation" class="headerlink" title="2 Kulla-Conty Approximation"></a>2 Kulla-Conty Approximation</h3><p>上面回顾了微表面模型，并进一步深入理解了各个项的作用，通过上面的分析我们可以很容易得出一个结论：微表面模型只考虑了光线在微表面之间的一次反射。被挡住的光线就认为看不到，这样做的结果就是微表面模型是能量不守恒的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608164659865.png" alt="image-20220608164659865"></p><p>随着粗糙程度增大，最终的渲染结果会越来越暗，因为粗糙程度越大意味着法线分布越分散，从而微表面之间的遮挡也会越严重，在微表面模型中被遮挡掉的能量就被丢掉不考虑了，所以自然会越来越暗。</p><p>实际上被遮挡的光线还会在微表面之间弹射从而被看到，因此为了解决这个问题，提出了 Kulla-Conty 估计，用来近似估计光线在微表面之间的多次弹射。</p><p>Kulla-Conty 估计基于一个关键思想：微表面 BRDF 只考虑了没有被遮挡的能量，那么如果能再设计一个 BRDF 来专门描述被遮挡的能量就可以修正微表面的结果了。</p><p>于是首先要知道没有被遮挡的能量是多少，我们假设入射光强度恒为 1，然后对微表面 BRDF 的渲染方程在整个半球面上积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165256048.png" alt="image-20220608165256048"></p><p>注意上面的式子中用了一个简单的积分换元，把 $d\theta$ 换成了 $dsin\theta$，这样一来原本渲染方程中的 cos 项也就没有了，光照项为常数 1，因此上面的积分结果就代表了微表面模型中在出射方向 $\mu_o$ 上全部被看到的能量总和，因为光照项为 1，所以该结果是一个系数，表示出射方向 $\mu_o$ 上被看到的能量占全部能量的比例。</p><p>于是因为遮挡而没被看到的能量总和自然就是 $1-E(\mu_o)$，因此，我们要设计一个 BRDF 来专门描述被遮挡的能量，那么这个 BRDF 在半球面上的积分结果就必须是 $1-E(\mu_o)$。</p><p>考虑到 BRDF 具有双向可逆性，因此 Kulla-Conty 估计设计了这样一个 BRDF：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165644101.png" alt="image-20220608165644101"></p><p>这个 BRDF 的形式并不是唯一的，只要能保证函数在半球的积分结果是 $1-E(\mu_o)$ 就可以，只是 Kulla-Conty 这样设计既把积分结果本身放到了函数中，还考虑了双向可逆的性质，非常巧妙。</p><p>于是通过积分结果为 $1-E(\mu_o)$ 可以求出常数 c：<br>$$<br>c &#x3D; \frac{1}{\pi(1-E_{avg})}<br>$$<br>其中：<br>$$<br>E_{avg} &#x3D; \frac{\int_0^1E(\mu)\mu d\mu}{\int_0^1\mu d\mu} &#x3D; 2\int_0^1E(\mu)\mu d\mu<br>$$<br>相当于对上面的 $E(\mu_o)$ 做了一个加权平均，权值就是各个方向的夹角正弦 $\mu$，于是整个 Kulla-Conty 估计就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170245422.png" alt="image-20220608170245422"></p><p>容易验证该函数在半球面上积分结果为 $1-E(\mu_o)$：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170313862.png" alt="image-20220608170313862"></p><p>因此这个函数可以作为描述被遮挡的能量的 BRDF，现在的问题是 $E_{avg}$ 是对一个积分 $E(\mu)$ 再进行积分，实时计算起来比较复杂，所以需要进行预计算。</p><p>对于 $E(\mu)$ 这个积分，是对全部入射方向 $\mu_i$ 的积分，因此积分结果只与观察方向和法线的夹角正弦 $\mu_o$ 和粗糙程度 $\alpha$ 有关，于是预计算的积分结果可以用一张二维纹理来存储：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608171651408.png" alt="image-20220608171651408"></p><p>而对于 $E_{avg}$ 这个积分，是对 $\mu_o$ 的积分，所以积分结果只与粗糙程度 $\alpha$ 有关，只需要一个一维纹理就可以存储。</p><p>将 Kulla-Conty 的结果加到微表面 BRDF 的结果上就可以近似模拟光线在微表面之间多次弹射的结果，达到能量守恒：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172124188.png" alt="image-20220608172124188"></p><p>接下来还有最后一个问题，上面的所有推导都是假设物体表面没有颜色，也就是反射率恒为 1，如果物体表面有颜色，那么能量在每次弹射后都会损失，如何计算这种损失来得到正确的结果呢？</p><p>Kulla-Conty 又计算了菲涅尔项的加权平均：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172427624.png" alt="image-20220608172427624"></p><p>这表示每次弹射，表面上有多少能量被反射。这类似于上面的 $E_{avg}$， $E_{avg}$ 表示表面上有多少能量没被遮挡能够被看到，于是我们可以直接看到的能量就可以表示为：<br>$$<br>F_{avg}E_{avg}<br>$$<br>没被看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})<br>$$<br>这部分能量会在微表面之间继续弹射，于是经过一次弹射后被我们看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})·F_{avg}E_{avg}<br>$$<br>以此类推，可以写出经过无数次弹射后的能量，将这些能量加起来，就可以得到当物体有颜色的时候，光线在微表面之间多次弹射后反射出的能量，这是一个级数求和问题，最终的结果是：<br>$$<br>\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}<br>$$<br>将这个系数乘到 Kulla-Conty 的 BRDF 上就可以得到有颜色的情况下被遮挡的能量的 BRDF 了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173223545.png" alt="image-20220608173223545"></p><h3 id="3-Linearly-Transformed-Cosines（LTC）"><a href="#3-Linearly-Transformed-Cosines（LTC）" class="headerlink" title="3 Linearly Transformed Cosines（LTC）"></a>3 Linearly Transformed Cosines（LTC）</h3><p>有了微表面 BRDF，另一个需要解决的问题是如何使用微表面模型进行渲染。线性变换余弦（LTC）方法是用来解决多边形面光源下，使用微表面 BRDF，主要是 GGX 法线模型的渲染而提出的方法（不考虑阴影）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173712743.png" alt="image-20220608173712743"></p><p>当然 LTC 不仅适用于上述情况，对于类似 GGX 法线分布的其他微表面模型也都有很好的效果。</p><p>在离线渲染中处理这样的渲染自然是对面光源进行采样计算，但实时渲染需要快速得到渲染结果，而不同的 BRDF 我们不知道它的分布是什么样的，所以也不容易快速求出这个 BRDF 积分的渲染方程的解析解，因此 LTC 将 BRDF 变换成一个 cos 函数，然后对所有的方向、以及面光源（积分区域）都做同样的变换：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174038845.png" alt="image-20220608174038845"></p><p>这样就将原积分转化为了一个对余弦函数的积分，保证可以快速求出解析解。具体来说，就是将原本的函数 $F(w_i)$ 变换为 $cos(w_i)$，为了便于理解，我们假设 BRDF 是各向同性的，于是 $F(w_i)$ 实际上和方位角无关，在出射方向固定的情况下就是一个只与俯仰角有关的一维函数，所以可以变换到一维的 cos 函数上，事实上 LTC 也可以处理各向异性的情况，这里就不展开讨论了。</p><p>然后将积分变量 $dw_i$ 同样变换为 $dw’_{i}$，实际上就是对原积分进行了换元：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174727016.png" alt="image-20220608174727016"></p><p>这样就可以快速求出解析解了。LTC 方法虽然思路很简单，但是效果却非常优秀，因此目前被广泛使用：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174837806.png" alt="image-20220608174837806"></p><h3 id="4-Disney’s-Principled-BRDF"><a href="#4-Disney’s-Principled-BRDF" class="headerlink" title="4 Disney’s Principled BRDF"></a>4 Disney’s Principled BRDF</h3><p>Disney’s Principled BRDF 是目前工业界非常知名的，非常强大的开源 BRDF。微表面 BRDF 的问题之一在于不能够表达复合材质，现实世界中许多材质不是单一的，是多种材质的组合，比如蒙上一层塑料布的木头桌子，那么它的表面就有多层材质，光照表现自然和普通桌子不同，而 Disney’s Principled BRDF 具有强大的表达能力，可以表达各种复合材质。</p><p>并且 Disney’s Principled BRDF 摒弃了传统基于物理的材质的各种物理参数，只使用一些非常符合人直觉的参数就可以进行调节，对于艺术家非常友好，这也是迪士尼设计这个 BRDF 的原则之一，这些原则有：</p><ul><li>使用符合人直觉的参数而不是各种难懂的物理量</li><li>越少的参数越好</li><li>所有参数都是从 0 到 1 调节的</li><li>在一些合理的情况下允许参数不在 0 到 1 范围内</li><li>所有参数的任意组合都必须得出合理的结果，而不是某些非常奇怪的结果</li></ul><p>能够满足上述原则的 BRDF 可以说是完美的，虽然严格来说迪士尼的 BRDF 不是基于物理的，而是进行了各种非常复杂的拟合，但是也常被归为基于物理的 BRDF。</p><p>下图是一些可以调节的参数和得出的材质效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608175902209.png" alt="image-20220608175902209"></p><p>从上到下依次是：</p><ul><li>次表面散射 subsurface：值越大次表面散射越严重，物体看起来更像一个平面</li><li>金属度 metallic：值越大物体越像金属</li><li>高光度 specular：值越大物体高光反射越强</li><li>高光颜色 specularTint：可以调节高光反射的颜色</li><li>粗糙程度 roughness：值越大物体表面越粗糙</li><li>各向异性程度 anisotropic：值越大物体表面越呈现各向异性</li><li>绒毛 sheen：绒毛相当于物体表面每个点都有一根朝向法线方向的绒毛，表现出来就是物体边缘会有模糊感，值越大绒毛越明显</li><li>绒毛颜色 sheenTint：控制绒毛颜色</li><li>表面通透 clearcoat：类似于给物体表面蒙上一层透明的漆，值越大这个效果越明显</li><li>表面通透颜色 clearcoatGloss：表面通透高光的锐利度，值越大高光越锐利</li></ul><p>上面的所有参数可以随意组合，表达各种复合材质，所以迪士尼 BRDF 的表达能力非常强。</p><h3 id="5-Specular-Glossiness-模型"><a href="#5-Specular-Glossiness-模型" class="headerlink" title="5 Specular Glossiness 模型"></a>5 Specular Glossiness 模型</h3><p>Specular Glossiness（SG）模型是在 Disney’s Principled BRDF 的启发下提出的便于实时渲染的 PBR 材质模型，SG 将所有描述材质需要用到的值都存在各种纹理中，渲染时只需要通过简单的纹理采样就可以计算出基于物理的光照结果，不需要调整任何参数，非常方便。</p><p>SG 模型使用三张纹理来存储信息，分别是：Diffuse、Specular 和 Glossiness。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613104930087.png" alt="image-20220613104930087"></p><p>Diffuse 存储物体的基础颜色，使用 RGB 三个通道；Specular 存储菲涅尔项的基础反射率，也就是菲涅尔近似公式中的 F0，同样对应 RGB 三个通道；Glossiness 是一个标量，用于控制表面光滑程度。</p><p>通过这三张纹理，就可以得到物体表面任何一个点对应的 F、D 和 G 项，从而根据微表面模型计算光照结果，下面是使用 SG 模型计算着色的代码，可以非常直观的感受到 SG 模型有多方便：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613105637113.png" alt="image-20220613105637113"></p><p>首先根据漫反射颜色计算出了漫反射项，然后根据微表面模型计算高光反射项，其中粗糙程度根据 Glossiness 采样结果得到，基础反射率 F0 根据 Specular 采样结果得到，再结合各种简单的点乘就可以得到 D、F 和 G 项，最后根据公式计算微表面 specular 结果，加上漫反射结果就是整个 BRDF 结果。有了 BRDF 就可以根据渲染方程得到着色结果了。</p><h3 id="6-Metallic-Roughness-模型"><a href="#6-Metallic-Roughness-模型" class="headerlink" title="6 Metallic Roughness 模型"></a>6 Metallic Roughness 模型</h3><p>Metallic Roughness（MR）是对 SG 模型的又一层封装，SG 模型可以自由地调节漫反射颜色和基础反射率，但有时这对于艺术家来说还是不够直观，因此 MR 使用了另外三个贴图来描述材质：Base Color、Roughness 和 Metallic。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110249250.png" alt="image-20220613110249250"></p><p>其中 Base Color 是物体的基础颜色，RGB 三通道；Roughness 和 Metallic 都是标量，分别代表表面粗糙程度和金属度。使用的时候游戏引擎内部会将这些值转化为 SG 模型中的值，下面是转化代码：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110606512.png" alt="image-20220613110606512"></p><p>可以看到金属度 Metallic 是一个插值系数，用来从 base color 中取出一定的颜色到介质基本的颜色上，从而构成 SG 模型中的 F0，回顾前文中菲涅尔项的曲线图，金属的基础反射率是非常高的，所以金属度高的时候 base color 中很大一部分颜色就被取出到 F0 中，使得基础反射率变高，而 base color  剩下的颜色就作为 SG 中的 diffuse，于是金属度高就会使 diffuse 很小，也就是金属几乎不会发生漫反射，这和菲涅尔项描述的是完全一致的，所以 MR 模型中的基础颜色就是 diffuse 和 specular 的结合，金属度 Metallic 可以将他们拆分开来，但 base color 的概念对于艺术家来说要比 diffuse 和 specular 更好理解。粗糙程度 Roughness 和 SG 中的光滑程度 Glossiness 相反，二者之间可以互相转化，本质上是一样的。</p><p>MR 和 SG 相比，更便于人们理解，但没有 SG 灵活，因为 MR 不能够自己调节 F0，而是全部包含在了 base color 中，但也因此避免了艺术家如果使用 SG，但给出了错误的 F0 而导致的菲涅尔项错误的情况，各有利弊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时全局光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</id>
    <published>2022-06-05T05:44:59.000Z</published>
    <updated>2022-06-13T03:32:30.197Z</updated>
    
    <content type="html"><![CDATA[<p>全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。</p><p><em><span id="more"></span></em></p><h2 id="1-三维空间全局光照"><a href="#1-三维空间全局光照" class="headerlink" title="1 三维空间全局光照"></a>1 三维空间全局光照</h2><h3 id="1-1-Reﬂective-Shadow-Maps（RSM）"><a href="#1-1-Reﬂective-Shadow-Maps（RSM）" class="headerlink" title="1.1 Reﬂective Shadow Maps（RSM）"></a>1.1 Reﬂective Shadow Maps（RSM）</h3><p>RSM 算法基于一个很简单的但却是实时全局光照中的核心观察：<strong>所有被光源直接照亮的物体表面都可以作为次级光源照亮其他物体。</strong>于是当我们在渲染时得到这个想法的时候，就可以用各种方法实现全局光照了，问题只是在于如何处理这些次级光源。</p><p>那么怎么得到场景中被光源直接照亮的表面信息呢？Shadow Map 所做的正是这个工作，Shadow Map 的每一个 texel 都可以代表场景中的一块区域，这一块区域就一定是被光源直接照亮的区域，就可以作为次级光源照亮其他物体，因此 Shadow Map 实际上可以看作存储了场景中所有的次级光源，因此我们在渲染每个着色点的时候，考虑这些次级光源的贡献即可。</p><p>现在的问题是，每一个次级光源对着色点的贡献相当于从着色点 p 看向这个光源表面所得到的光照结果（其实和光线追踪原理一样），那么如果这个表面是 Glossy 的，情况会非常复杂，因此 RSM 假设所有次级光源表面都是 diffuse 的，这样次级光源对着色点 p 的光照就与他们的相对方向无关了，这样一来次级光源就被抽象为一个向各个方向均匀发光的面光源了。</p><p>那么对于面光源，我们在路径追踪中有推导过如何将渲染方程中对方向立体角的积分转化为对面光源的积分：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103514616.png" alt="image-20220603103514616"></p><p>于是渲染方程可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p><p>其中 $patch$ 就是代表每一个小的次级光源。现在来看渲染方程中的每一项：</p><p>首先是 BRDF 项，没有什么问题。</p><p>然后是 visibility 项，visibility 要考虑次级光源和着色点的遮挡关系，这是很难得到的，想要得到就要对每一个次级光源生成一个 Shadow Map，而假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，每个次级光源都生成一次 Shadow Map，这是不可能的，因此 RSM 选择不计算 visibility 项，毕竟间接光照是低频的，而且这么多次级光源分别的贡献实际上都很小，所以不计算 visibility 影响也不大。</p><p>最麻烦的是次级光源到着色点的光照 $L_i(q\rightarrow p)$，这要根据该表面的直接光照得到，因为假设了表面是 diffuse 的，所以 BRDF 是一个常数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104607816.png" alt="image-20220603104607816"></p><p>需要注意这里的 BRDF 是指计算次级光源表面被实际光源直接照射时的渲染方程中的 BRDF，而上面的渲染方程是计算着色点被次级光源照射时的方程。于是 $L_i(q\rightarrow p)$ 就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104650506.png" alt="image-20220603104650506"></p><p>因为 BRDF 是出射的 Radiance 和入射的 Irradiance 的比值，因此乘上该表面入射的 Irradiance，得到的就是出射的 Radiance，也就是我们想要的次级光源发出的光线。而该表面入射的 Irradiance 可以根据定义表示为直接光源的光通量，也就是功率除以单位面积（因为 Irradiance 表示单位面积上的光的能量），所以就有上面的公式了。上面公式的好处在于带入渲染方程中，我们会发现单位面积 dA 被约掉了，说明之后的计算与次级光源的面积无关。</p><p>接下来考虑的问题是，假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，如果每个次级光源都进行上面的计算，开销也是很大的，而实际上很多次级光源可能对着色点是没有贡献的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105635240.png" alt="image-20220603105635240"></p><p>着色点为 x，而 Shadow Map 中存储的桌子上的点就显然是对 x 没有贡献的，不需要进行计算，因此我们可以根据法线方向去掉一些不需要计算的次级光源；此外，距离着色点太远的次级光源也不需要计算，因此我们只需要计算着色点一定距离范围内的有贡献的次级光源就可以了，经过这些筛选最后剩下的次级光源数量是可以接受的，也是完全可以做到实时计算的。</p><p>综上，要计算渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p><p>我们需要知道的信息有：次级光源到着色点的距离，直接光源对次级光源的光通量以及次级光源表面的法线，因此 Reﬂective Shadow Maps 中存储的就是这些信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105452496.png" alt="image-20220603105452496"></p><p>RSM 只需要在 SM 的基础上额外存储一些信息就可以实现全局光照，是很容易实现的。但也存在很多缺点，比如因为是基于 Shadow Map，那么对于场景中的所有直接光源都要生成一张 RSM，复杂度会随着光源数量增加；而且整个算法做了很多舍弃和假设，比如舍弃了 visibility 项的计算，假设所有次级光源都是 diffuse 的，这会对最终效果产生一定影响。</p><h3 id="1-2-Light-Propagation-Volumes（LPV）"><a href="#1-2-Light-Propagation-Volumes（LPV）" class="headerlink" title="1.2 Light Propagation Volumes（LPV）"></a>1.2 Light Propagation Volumes（LPV）</h3><p>LPV 的核心思想是，我们要计算着色点的间接光照就需要知道着色点上从各个方向来的 Radiance 是多少，也就是 RSM 中计算的所有次级光源的 Radiance，那如果我们在渲染着色点的时候能直接查询到各个方向来的 Radiance，就不需要额外的计算了。</p><p>于是 LPV 将空间分为一个个网格，然后将所有次级光源表面发出的 Radiance 注入到表面所在的网格中，然后这些 Radiance 根据各自的方向向周围的网格传播，这样一来在渲染的时候只需要查询着色点所在的网格中的 Radiance 就可以快速计算渲染方程了。具体步骤如下：</p><ul><li>第一步：找到能被光源直接照亮的表面，这直接使用 RSM 即可</li><li>第二步：计算这些表面的 Radiance，并注入到所在的网格中，网格中将这些 Radiance 加起来，会得到一个二维函数，表示不同方向上的 Radiance，因为是只与方向有关的二维函数，那么自然可以近似表示为 SH，一般只需要使用前两阶 SH 表示即可，因为 LPV 同样假设次级光源是 diffuse 的，那么次级光源的光照就是低频的，所以不需要太高阶的 SH：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111036435.png" alt="image-20220603111036435"></p><ul><li>第三步：每个格子中的 Radiance 沿着格子进行传传播，每个格子的 Radiance 会传播到它相邻的六个格子中，传播过去的 Radiance 被加入到那个格子的 Radiance 中，如此迭代，一般 4 到 5 次迭代就可以让整个网格基本达到稳定，这时所有格子里的 Radiance 就可以代表这里的各个方向传播来的 Radiance 了，渲染时可以直接使用：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111410505.png" alt="image-20220603111410505"></p><ul><li>第四步：渲染时直接将着色点所在的网格中的 Radiance 作为着色点的 Radiance 进行渲染即可。</li></ul><p>通过上面的步骤可以看出 LPV 有一个很严重的问题，就是如下图中的情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111539524.png" alt="image-20220603111539524"></p><p>点 p 是一个次级光源，正常来说它发出的 Radiance 不应该照亮墙的背面，但是由于它发出的 Radiance 会被认为是整个网格的 Radiance  ，于是这些 Radiance 就可以照亮墙的背面，也就会发生漏光现象：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111714792.png" alt="image-20220603111714792"></p><p>不过这不影响 LPV 是一个优秀的实时全局光照解决方案。</p><h3 id="1-3-Voxel-Global-Illumination（VXGI）"><a href="#1-3-Voxel-Global-Illumination（VXGI）" class="headerlink" title="1.3 Voxel Global Illumination（VXGI）"></a>1.3 Voxel Global Illumination（VXGI）</h3><p>VXGI 同样是基于体素（Voxel）的，不同于 LPV，VXGI 将场景体素化，并创建层次结构（LPV 没有层次结构）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111846023.png" alt="image-20220603111846023"></p><p>这样一来 RSM 中每个 texel 对应的一片区域就变成对应一些体素，这样就可以计算体素中物体表面的光照作为间接光照，因此 VXGI 可以计算次级光源的 Glossy 光照，不需要假设所有次级光源都是 Glossy 的，所以效果更好，但效率自然更低。VXGI 的实现非常复杂，这里不再赘述。</p><h2 id="2-屏幕空间全局光照"><a href="#2-屏幕空间全局光照" class="headerlink" title="2 屏幕空间全局光照"></a>2 屏幕空间全局光照</h2><h3 id="2-1-Screen-Space-Ambient-Occlusion（SSAO）"><a href="#2-1-Screen-Space-Ambient-Occlusion（SSAO）" class="headerlink" title="2.1 Screen Space Ambient Occlusion（SSAO）"></a>2.1 Screen Space Ambient Occlusion（SSAO）</h3><p>我们之前学习过，环境光遮蔽（AO）是一种对全局光照的近似方法，实现简单，但是可以大幅增强画面的层次感，所以被广泛使用。环境光遮蔽的想法非常简单，Blinn Phong 模型把所有间接光照抽象成了一个常数，叠加到所有着色点上进行一个统一的亮度增强来模拟全局光照，这样的问题在于所有着色点的亮度增强程度是一样的，所以无法增强明暗遮蔽关系，如果我们能对每一个着色点，根据它所处位置的遮蔽关系给这个统一的环境光常数乘上一个系数再累加到着色结果上，就可以体现出物体之间的遮蔽关系了。而这个系数正是渲染方程中的 visibility 项。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105404933.png" alt="image-20220605105404933"></p><p>上面的过程可以通过渲染方程来更深入的理解。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105617924.png" alt="image-20220605105617924"></p><p>我们使用之前常用的近似积分拆解公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105818137.png" alt="image-20220605105818137"></p><p>把 visibility 项拿出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p><p>这里我们把 $cos\theta_idw_i$ 看成了一个整体，当作公式中的 $dx$，这实际上是有意义的，我们知道 $dw_i$ 是微分立体角，是单位球面上的一小块面积，乘上了一个和法线的夹角余弦相当于把这一小块面积投影到了单位圆上，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110006953.png" alt="image-20220605110006953"></p><p>所以 $cos\theta_idw_i$ 这个整体也叫做微分投影立体角，是单位圆中的一小块面积，因此对 $cos\theta_idw_i$ 的积分实际上就是单位圆的面积 $\pi$，这也从另一个角度解释了半球面上对 $cos\theta$ 的积分为什么是  $\pi$。</p><p>现在回到渲染方程，把 visibility 项拿出来之后，渲染方程分为了两部分：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p><p>其中，蓝色框中实际上就是对着色点 p 周围<strong>遮挡关系结果的加权平均</strong>（加权和除以权值和就是加权平均），权值是 $cos\theta$，即离法线近的权值大，离法线远的权值小。而分母就是对投影立体角的积分，结果是 $\pi$，于是蓝框中的部分就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110447249.png" alt="image-20220605110447249"></p><p>一般就写成一个系数 $k_A$  来表示环境光遮蔽系数。</p><p>而黄色框中的部分是一个渲染方程，通过之前的算法我们知道，实时渲染中一般在计算全局光照的时候都会假设所有物体表面都是 diffuse 的，这样每一个次级光源就被抽象成了一个均匀发光的面光源，而在这里， SSAO 还假设所有物体的间接光照都一样，这和 Blinn Phong 模型的假设一致，于是间接光照 $L_i^{indir}$ 就是一个常数，diffuse 的 BRDF 也是常数，因此黄色框部分可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110615757.png" alt="image-20220605110615757"></p><p>自然就是一个常数，这就相当于 Blinn Phong 中的环境光常数，我们可以直接给定。于是整个渲染方程就是环境光常数乘上了每个片段的遮蔽系数，也就是我们一开始说的那个过程。因为上面的推导中使用了积分拆解近似式，而该公式近似的准确的条件是 $g(x)$ 要么连续，要么在积分区间上波动很小，而在这里 $g(x)$ 就是一个常数，自然满足这两个条件，因此使用这样的方法来近似是完全准确的。</p><p>屏幕空间环境光遮蔽自然是在屏幕空间完成上述过程，那么关键就在于如何只通过屏幕上的信息得到每一个像素对应的场景中的位置的遮蔽关系，从而得到 visibility 系数。</p><p>SSAO 的做法是在屏幕上每一个像素对应的场景中的点周围一个球体范围内随机采样一些点，根据这些点到相机的深度来判断这些点是不是能被看到，用这些结果来近似点 p 会被周围多少物体遮挡，从而得到一个 visibility 系数，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111352019.png" alt="image-20220605111352019"></p><p>这样做的问题在于我们实际去判断一个点的遮挡关系的时候只应该考虑该点法线方向半球上的遮挡关系，而这里用了整个球体内采样，是不准确的，于是一种解决方法是当采样点中被遮挡的点的数量大于一半时才开始考虑这一点的 AO，这样相当于粗略的截取了一个半球：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111534174.png" alt="image-20220605111534174"></p><p>当然现代渲染中，我们在屏幕空间也可以得到每一个像素对应的法线，因此可以直接准确的在法线方向半球内采样，并且知道了法线还可以考虑上面公式中的 $cos\theta$ 的加权平均，结果会更加准确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111716185.png" alt="image-20220605111716185"></p><p>这种方法叫做 HBAO，得到的结果也会比 SSAO 更加真实。</p><h3 id="2-2-Screen-Space-Directional-Occlusion（SSDO）"><a href="#2-2-Screen-Space-Directional-Occlusion（SSDO）" class="headerlink" title="2.2 Screen Space Directional Occlusion（SSDO）"></a>2.2 Screen Space Directional Occlusion（SSDO）</h3><p>SSDO 是 SSAO 的改进，SSAO 中假设一个点接收到的所有来自于其他物体反射光源的间接光照都是一样的（常数），但实际上我们利用 RSM 的思想，我们是知道哪些物体表面是被直接照亮的，因此我们不需要这样简单粗暴的假设，我们可以去准确的计算这些次级光源发出的间接光照是什么。</p><p>SSDO 像是在屏幕空间进行光线追踪一样，在每一个着色点向四面八方打出光光线，如果没有碰到周围的表面说明是直接光照，如果碰到了其他表面就计算该表面的间接光照作为该着色点间接光照的一部分贡献，这里计算其他表面的间接光照还是假设该表面是 diffuse 的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112300423.png" alt="image-20220605112300423"></p><p>于是就只有两种情况，可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112324715.png" alt="image-20220605112324715"></p><p>当然，SSDO 既然是屏幕空间的算法，自然不是从 RSM 中获哪那些表面是被直接照亮的，只需要通过深度图就可以近似得到，更准确地说我们认为相机看到的就是被直接照亮的，相机看到的每个点的直接光照结果就作为该点的间接光照去照亮其他点，在实际实现中也不是真的从着色点向周围发出许多光线，而是类似于 HBAO，在着色点法线所在半球随机取点，然后判断这些点的深度是否被遮挡，如果深度大于深度缓冲中的深度，就认为被遮挡，进而认为点 p 到这一点的光线打到了遮挡该点的那个表面，就将那个表面的间接光照作为点 p 的间接光照的贡献之一，整个过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112905103.png" alt="image-20220605112905103"></p><p>当然这样的做法毕竟不是真正的追踪光线，因此必然会出现一些问题，比如上图中最右边的情况，当点 A 和相机之间有一个遮挡物，点 A 会认为被遮挡，进而认为光线 PA 会打到 z1 所对应的那个点，这显然是不对的，同理点 B 被认为没有被遮挡，但实际上光线 PB 被旁边的表面遮挡到了，不过这些瑕疵在实时渲染中不会对结果有太大影响，因此可以忽略，只要整体结果是好的，那么这个是算法就是好的。</p><p>SSDO 存在的问题不止上面说到的，由于是屏幕空间的算法，所以我们所拥有的全部信息就是屏幕中的信息，相当于是整个场景能被看到的一层外壳，看不到的部分对我们来说是完全不知道的，因此就会丢失掉一些遮蔽信息：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113407580.png" alt="image-20220605113407580"></p><p>此外，由于是在法线所在半球内随机取点，这个半球一定对应一个范围，这个范围不能太大，如果无限大那就是光线追踪了，因此对于比较远的间接反射 SSDO 是做不出来的，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113455806.png" alt="image-20220605113455806"></p><p>上图中立方体反射出了右边的绿色墙面，这是光线追踪的结果，SSDO 是不能做到的，因为它追踪不了那么远，但是近处的颜色是可以得到的，比如左边的红色墙面，这也是 SSDO 最大的优势，就是可以实现 color blending 的效果，能够将物体之间的反射颜色融合起来，这也是因为它把我们看到的颜色作为次级光源来计算着色点的间接光照，而不是像 SSAO 一样全局的设定一个间接光照，下图中最右边可以看出蓝色物体表面映射出了一点黄色：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113729167.png" alt="image-20220605113729167"></p><h3 id="2-3-Screen-Space-Reﬂection（SSR）"><a href="#2-3-Screen-Space-Reﬂection（SSR）" class="headerlink" title="2.3 Screen Space Reﬂection（SSR）"></a>2.3 Screen Space Reﬂection（SSR）</h3><p>屏幕空间反射 SSR 真正做到了屏幕空间的光线追踪，所以 SSR 更准确地应该被叫做屏幕空间光线追踪（Screen Space Ray-tracing），因此效果很好，也是目前在实时渲染中最广泛使用的方法。</p><p>既然是光线追踪，那么一定分为两步，一是光线和场景求交点，在屏幕空间没有三维场景的信息，实际上计算的是光线和我们看到的场景的一个外壳求交点；二是计算着色，根据采样光线求解渲染方程，这一步和正常的光线追踪完全一样。</p><p>SSR 有效的一个重要原因在于，屏幕中我们能看到的场景中的反射的部分，一定有绝大部分是已经存在于当前的屏幕中的，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605114441736.png" alt="image-20220605114441736"></p><p>街道上反射的就是屏幕的上半部分，因此屏幕空间光线追踪是完全可行的，仅利用屏幕中的信息是足够的。</p><p>对于每一个像素，如果只考虑最简单的镜面反射情况，那么我们直接从该点追踪镜面反射方向，就可以找到镜面反射光线和场景外壳上的一个交点，这个交点的颜色我们是直接可以知道的，就把这个颜色作为间接光照颜色（间接光照渲染方程的结果）加到该像素上就可以了，对于更复杂的 Glossy 和漫反射就像光线追踪一样采样更多光线即可，但是也不需要像光线追踪那样采样那么多，因为间接光照最后是要叠加到直接光照结果上的，所以我们只要采样少一些光线，得到一个有噪声的间接光照结果，简单去一下噪（加个模糊之类的）再叠加到直接光照上就能得到不错的结果了。</p><p>下图是镜面反射的结果：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115220889.png" alt="image-20220605115220889"></p><p>以及 Glossy 的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115237982.png" alt="image-20220605115237982"></p><p>SSR 还可以实现表面不平整的反射，无非就是不平整的表面法线影响了光线的反射方向而已：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115334563.png" alt="image-20220605115334563"></p><p>于是现在最主要的问题就是如何在屏幕空间追踪光线，也就是如何求得光线和我们看到的这一层外壳的交点。</p><p>最原始的做法是从着色点出发，沿着要追踪的光线方向，一次移动一定的距离，每次移动后判断对应的深度，如果深度小于深度缓冲中的深度则继续移动，直到深度大于深度缓冲中的深度，则认为找到了交点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605125808577.png" alt="image-20220605125808577"></p><p>这种方法找到的交点是不准确的，交点的精度取决于每次移动的步长，步长过大会找到不准确的交点，步长过小又会影响速度，因此要进行加速优化，这里又要用到图形学中常用的加速手段，类似于三维空间中的 BVH，我们为深度图生成 Mipmap，但这里的 Mipmap 不能取多个深度的均值，要取多个深度的最小值，也就是离我们最近的深度作为下一 level 的深度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130111638.png" alt="image-20220605130111638"></p><p>这样一来，我们就构建了层次深度结构，每次沿着光线移动时可以试探性地增大步长，也就是在更高一层移动，如果找到交点就降低 level 去找具体和哪个像素相交了，举例来说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130239538.png" alt="image-20220605130239538"></p><p>对于上图的情况，我们第一次从着色点出发，先在 level 0 移动，这时每一步会移动一个像素：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130325578.png" alt="image-20220605130325578"></p><p>此时深度小于深度缓冲中的深度，说明没有遮挡，继续移动，这次我们增加一个 level，在 level 1上移动，level 1 中每一个像素代表了 level 0 中的 4 个（我们这里是二维，所以是 2 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130448099.png" alt="image-20220605130448099"></p><p>移动之后还是没有交点，于是再增加一个 level，在 level 2上移动，level 2 中每一个像素代表了 level 0 中的 16 个（我们这里是二维，所以是 4 个）像素深度的最小值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130610015.png" alt="image-20220605130610015"></p><p>这时发现有交点了，于是减小一个 level，继续判断：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130649452.png" alt="image-20220605130649452"></p><p>继续减小 level 到 level 0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130728981.png" alt="image-20220605130728981"></p><p>这时发现在 level 1有交点的像素细化到 level 0 之后没有交点，于是继续传播，因为没有交点，所以 level 加一，在 level 1 上移动：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130912940.png" alt="image-20220605130912940"></p><p>找到了交点，再次减小一个 level：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130937759.png" alt="image-20220605130937759"></p><p>最终找到了交点所在的像素，将这个像素对应的颜色作为间接光照累加到当前着色点上即可。上述过程的伪代码如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131027338.png" alt="image-20220605131027338"></p><p>屏幕空间光线追踪可以很好的实现全局光照，但也一定存在问题，因为我们只有屏幕中的场景信息，这些信息只是整个场景的一个外壳，内部的信息我们是完全不知道的，因此也就会导致我们看不到的部分就不会产生反射，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131201515.png" alt="image-20220605131201515"></p><p>此外，SSR 也只能反射屏幕中存在的物体，因此一部分在屏幕外的物体的反射就会被“切断”，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131343414.png" alt="image-20220605131343414"></p><p>不过这可以通过增加一个随距离增大的模糊衰减来解决，使结果看起来更真实：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131427066.png" alt="image-20220605131427066"></p><p>当然这只是 SSR 最基本的思想，实际实现中有非常多的细节和优化问题，比如重要性采样、样本在时间和空间上的复用等等，这里就不再展开了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时环境光照</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/</id>
    <published>2022-06-02T07:34:32.000Z</published>
    <updated>2022-06-13T03:32:11.647Z</updated>
    
    <content type="html"><![CDATA[<p>环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。</p><p><em><span id="more"></span></em></p><h3 id="1-回顾环境贴图"><a href="#1-回顾环境贴图" class="headerlink" title="1 回顾环境贴图"></a>1 回顾环境贴图</h3><p>环境贴图我们在之前的 Shader 部分中学习过也使用过，就是将整个场景存在一个立方体或者球体贴图中，渲染时根据光线反射方向去采样环境贴图得到环境光照。这样的环境光照渲染被称为基于图像的光照，Image-Based Lighting（IBL）。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602111629808-16541623890081.png" alt="image-20220602111629808"></p><p>环境光照既然是光照，那自然也是解渲染方程的过程，解渲染方程最简单的方法就是使用数值方法，比如蒙特卡洛方法，但这需要根据光线反射方向采样大量的样本去计算，比如对于漫反射材质，需要在着色点为中心的半球面上均匀采样，而对于金属物体，需要向镜面反射方向一定范围内（Glossy 扰动）随机采样许多光线，这么多采样的计算是非常慢的，因此在实时渲染中需要使用一些方法来代替采样得到正确的环境光照结果。</p><h3 id="2-Split-Sum"><a href="#2-Split-Sum" class="headerlink" title="2 Split Sum"></a>2 Split Sum</h3><p>Split Sum 是解决实时环境光照的一个著名算法，也被使用在虚幻引擎中。上面说过，计算环境光照也是解渲染方程的过程，首先再次回顾渲染方程，并且我们现在计算环境光照的时候先不考虑环境光的阴影项：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112507731-16541623890092.png" alt="image-20220602112507731"></p><p>于是渲方程就只由两项组成，环境光照项 $L_i$ 和 BRDF 项（一般来说实时渲染中把 BRDF 和 cos 项合称为 BRDF 项），而 Split Sum 基于一个重要的观察：</p><ul><li>如果是 Glossy 的 BRDF，那么我们的积分区间是很小的，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112750875-16541623890103.png" alt="image-20220602112750875"></p><ul><li>如果是漫反射的 BRDF，虽然积分区间很大，是整个半球面，但是函数值在整个积分区间上的变化是平滑的：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112855298-16541623890104.png" alt="image-20220602112855298"></p><p>回顾之前我们说到的，实时渲染中非常重要的约等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602113010978-16541623890105.png" alt="image-20220602113010978"></p><p>这个估计要准确，函数 $g(x)$ 必须满足两个条件之一：</p><ul><li>$g(x)$ 在积分区间上波动尽可能小，也就是积分区间尽可能小</li><li>$g(x)$ 在积分区间上平滑</li></ul><p>渲染方程中的 BRDF 刚好符合这两个条件！于是我们可以把渲染方程写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><p>需要注意，在上一节中我们用同样的方法把阴影项拆分了出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123014213-16541623890107.png" alt="image-20220602123014213"></p><p>这是对于正常的光源渲染的，和我们这里讨论的是两个问题，我们这里的渲染方程是计算环境光照的，不过这两个对渲染方程的改写，用到的思路和方法都是一样的，都是基于上面的重要约等式。</p><p>渲染方程改写成这个形式意味着我们把环境光照项和 BRDF 项分开了，而光照项是环境光的积分除以积分区间的面积，这不就相当于把积分区间范围内，也就是 Glossy 的扰动范围或者漫反射的半球范围内的所有环境光取了一个平均值吗，那么我们如果能够提前计算好这个平均值，在渲染时就不需要大量采样了，只需要直接取到这个平均值就当作对应的环境光项的积分结果的近似值就可以了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124125503-16541623890108.png" alt="image-20220602124125503"></p><p>于是计算环境光照项的时候，我们可以把环境贴图按照一定的滤波核大小平均一下，生成多张平均后的环境贴图，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123621399-16541623890109.png" alt="image-20220602123621399"></p><p>当我们计算环境光的时候，根据 Glossy 的扰动大小，决定到多大滤波核平均后的环境贴图中去获取环境光，也可以在不同 level 之间进行插值，和 Mipmap 非常相似。这一步就是 split sum 的第一阶段，解决了环境光项的计算，接下来该解决后面的 BRDF 的积分了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124242578-165416238901010.png" alt="image-20220602124242578"></p><p>BRDF 的积分如何避免采样呢？BRDF 是一个比较复杂的函数，涉及到很多变量，如果我们要避免采样，就只能进行预计算。首先来回顾一下最常用的微表面 BRDF 模型：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124444075-165416238901011.png" alt="image-20220602124444075"></p><p>我们来逐个分析一下每项都是关于什么变量的函数。</p><p>首先是菲涅尔项，菲涅尔项非常复杂，但是渲染中常用的是 Schlick’s 近似：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124925813-165416238901113.png" alt="image-20220602124925813"></p><p>这个近似只需要一个基础反射率 $R_0$ 和一个角度 $\theta$，这个角度实际上应该是观察方向和法线的夹角，但是也可以是光线和法线的夹角，也可以是观察方向和切线的夹角，还可以是半程向量和法线的夹角，这是无所谓的，因为这些角度可以很方便的进行转换，总之就是一个角度，于是菲涅尔项需要两个参数 $R_0$ 和 $\theta$。</p><p>然后是法线分布函数 NDF，NDF 描述了微表面的法线分布，一个常用的 Beckmann 分布的公式如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602125413871-165416238901012.png" alt="image-20220602125413871"></p><p>可以看到 NDF 同样是关于两个变量的函数，一个是粗糙程度 $\alpha$，另一个同样是角度 $\theta$。</p><p>最后是遮挡项 G，与入射方向和出射方向有关，而我们的观察方向是固定的，于是遮挡项 G 也只与入射角 $\theta$ 有关。</p><p>综上， BRDF 与基础反射率 $R_0$ ，表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们如果要预计算，那么至少要计算这三个维度，虽然表面上是三个维度，实际上基础反射率 $R_0$ 还有 RGB 三个通道，如果预先计算出这三个变量所有可能的组合情况的 BRDF 积分结果，这无论是计算量还是存储量都是极大的，因此我们要让预计算的变量尽可能少，每少一个变量，就可以少一个维度的存储和计算，那对于预计算效率来说将会是质的提升。</p><p>我们将菲涅尔项的 Schlick’s 近似带入到上面渲染方程中的 BRDF 积分中并做简单的变形可以得到：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><p>这看起来让式子变得更复杂了，但实际上我们把最麻烦的基础反射率 $R_0$ 提取出来了，而剩下的两个积分只与表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们只需要预计算表面粗糙程度 $\alpha$，和入射角 $\theta$ 的所有组合情况就可以了，而这两个值 $\alpha$ 和 $cos\theta$ 都是 0 到 1 的标量，因此预计算的结果就可以存在一张二维纹理中：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130931415-165416238901115.png" alt="image-20220602130931415"></p><p>在渲染时直接查找纹理中的积分结果就可以了。这就是对渲染方程 BRDF 项的计算优化。</p><p>至此我们可以总结一下 split sum 算法是如何计算环境光的：</p><ul><li>首先使用约等式将渲染方程中对光照项和 BRDF 项的乘积的积分转化为了积分的乘积：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p><ul><li>然后对于第一项环境光，使用 pre-filtering 生成不同平均程度的环境贴图，使用类似 Mipmap 的方法直接取环境光的平均值近似作为积分结果</li><li>对于第二项 BRDF，预先计算与粗糙程度 $\alpha$ 和入射角 $cos\theta$ 有关的积分的结果，存在一张二维纹理中，计算时只需要查找纹理再乘以基础颜色 $R_0$ 按照以下公式就可以得到 BRDF 积分的近似结果了</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p><ul><li>最后将两个积分结果相乘再除以归一化系数（积分区间的面积）就是最终的渲染方程结果</li></ul><p>这样一来整个渲染方程的计算过程就避免了采样，虽然使用了各种近似，但最终的效果却非常好：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131814205-165416238901116.png" alt="image-20220602131814205"></p><p>在工程中，公式一般不会写成积分形式，而是写成离散的求和形式，但本质是一样的：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131855491-165416238901117.png" alt="image-20220602131855491"></p><p>而 split sum 方法就是将求和拆分开来进行预计算，这也是 split sum 名称的由来。</p><h3 id="3-环境光照的阴影"><a href="#3-环境光照的阴影" class="headerlink" title="3 环境光照的阴影"></a>3 环境光照的阴影</h3><p>上面的讨论中，我们完全忽略掉了阴影，也就是 Visibility 项，实际上在实时渲染中做环境光照的阴影是几乎不可能的，因为环境贴图相当于把复杂的环境光照存在了一张贴图上，整个环境中实际上有非常多的光源，如果要做阴影，就要对每个光源生成一张 Shadow Map，这是不可能的，因此现在工业上的解决方案就是只生成最主要光源的阴影，这种方法虽然简单粗暴，但在大多数情况下也就足够了。</p><p>当然，有方法能够完全准确的计算出环境光的阴影，比如实时光线追踪，我们将在以后讨论，这里我们将讨论另一种非常强大的方法—— Precomputed radiance transfer（PRT），PRT 不仅可以计算环境光阴影，还可以用于实时全局光照。</p><h3 id="4-球面谐波函数"><a href="#4-球面谐波函数" class="headerlink" title="4 球面谐波函数"></a>4 球面谐波函数</h3><h4 id="4-1-球谐函数的定义和性质"><a href="#4-1-球谐函数的定义和性质" class="headerlink" title="4.1 球谐函数的定义和性质"></a>4.1 球谐函数的定义和性质</h4><p>球面谐波函数（Spherical Harmonics，SH）是一组二维基函数，类似于一维中的傅里叶基函数。空间中的任何球面函数（比如我们的环境贴图、BRDF 等都是球面函数）都可以表示为 SH 的线性组合。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135006568-165416238901118.png" alt="image-20220602135006568"></p><p>上图表示了前四阶 SH 的可视化结果，不难看出，n 阶 SH 有 2n + 1 个基函数，前 n 阶 SH 有 n * n 个基函数。图中蓝色代表正值，黄色代表负值，颜色深浅代表了值的大小，可以看到同一阶的基函数实际上就是函数值在不同维度的变化，阶数越高函数值变化的频率越高，因此他们的线性组合就可以表示函数中越高频的信息，使用不同阶的球谐函数的组合就可以将一个函数中的不同频率的信息表示出来，再将它们组合在一起就可以基本还原出原本函数的样子，使用的球谐函数越多，自然对原函数的还原也就越好：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602141239497-165416238901119.png" alt="image-20220602141239497"></p><p>这和一维中的傅里叶变换是完全一样的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135645988-165416238901120.png" alt="image-20220602135645988"></p><p>此外，一个函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分叫做<strong>投影</strong>，投影结果就是这个函数被表示为基函数的线性组合时，对应的基函数的线性组合系数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135934958-165416238901121.png" alt="image-20220602135934958"></p><p>这可以类比于基向量，任意一个向量 $v$ 可以表示为一组基向量的线性组合，而每个基向量的系数就是向量 $v$ 和该基向量的点乘，而我们知道，向量点乘实际上就是投影，所以函数投影的概念和向量投影是完全一样的，上面的函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分实际上就是对应的函数值相乘再累加起来，这和点乘的计算方式完全一样。</p><p>因此基函数自然也有和基向量完全一样的性质：</p><ul><li>基函数投影到自身结果为 1，相当于基向量是单位向量：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140619749-165416238901122.png" alt="image-20220602140619749"></p><ul><li>基函数互相正交，即投影结果为 0，相当于基向量互相正交：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140700382-165416238901123.png" alt="image-20220602140700382"></p><h4 id="4-2-用球谐函数表示环境光"><a href="#4-2-用球谐函数表示环境光" class="headerlink" title="4.2 用球谐函数表示环境光"></a>4.2 用球谐函数表示环境光</h4><p>首先我们回顾上面 split sum 中用到的 pre-filtering 方法，也就是对环境贴图提前进行了一个均值滤波，然后在渲染时只进行一次查询得到平均值作为多次采样的积分近似值，因此可以说：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602142643059-165416238901124.png" alt="image-20220602142643059"></p><p>而我们知道均值滤波是低通滤波，只保留了低频信号，如上图，虽然滤波后不能完全还原出原本的环境光照，但是光源之间的明暗关系是完全保留了下来的，对于漫反射或者 Glossy 来说，这是完全够用的，这也是 split sum 可以 work 的原因。</p><p>在这个理解的基础上，又可以得出一个新的理解，那就是<strong>漫反射的 BRDF 对光照的作用，其实就相当于一个低通滤波器的作用</strong>。这其实很好理解，不管环境光照如何复杂，变化如何剧烈，漫反射物体显示出来的都是模糊的变化，不会显示出原本的环境光照那样高频的变化。而这样的特性是由 BRDF 决定的，因此漫反射的 BRDF 相当于对光照做了一个低通滤波。</p><p>于是有人就把 BRDF 投影到了球谐基函数上，并且发现投影只在前三阶有值，之后的投影结果几乎都为 0，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143333455-165416238901125.png" alt="image-20220602143333455"></p><p>这说明漫反射的 BRDF 中就只包含前三阶 SH 对应的频率的信息，根本就不包含更高频的信息。于是我们也完全可以把环境光照表示为球谐函数，而且只用前三阶就可以近似得到漫反射物体的环境光照结果，事实也确实如此：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143819188-165416238901126.png" alt="image-20220602143819188"></p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143830579-165416238901227.png" alt="image-20220602143830579"></p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143841772-165416238901228.png" alt="image-20220602143841772"></p><h3 id="5-Precomputed-radiance-transfer（PRT）"><a href="#5-Precomputed-radiance-transfer（PRT）" class="headerlink" title="5 Precomputed radiance transfer（PRT）"></a>5 Precomputed radiance transfer（PRT）</h3><h4 id="5-1-PRT-原理"><a href="#5-1-PRT-原理" class="headerlink" title="5.1 PRT 原理"></a>5.1 PRT 原理</h4><p>对于一个场景中的一个着色点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144122954-165416238901229.png" alt="image-20220602144122954"></p><p>它的渲染方程可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144003377-165416238901230.png" alt="image-20220602144003377"></p><p>环境贴图自然表示整个空间的环境光，visibility 是从这一点看向整个场景得到的遮挡关系，下半部分全黑是因为只在着色点上半球有值，最后是 BRDF 可视化，同样只在上半球有值。渲染方程相当于这些值的乘积的和，如果环境贴图每一面分辨率是 64 * 64，那么计算这一个着色点就要进行 6 * 64 * 64 次三个数的乘法运算再求和，当分辨率变大的时候这个数字是指数增长的，因此 PRT 将渲染方程分为两部分处理：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602145517079-165416238901231.png" alt="image-20220602145517079"></p><p>一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算：<br><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150253420-165416238901232.png" alt="image-20220602150253420"></p><h4 id="5-2-漫反射情况"><a href="#5-2-漫反射情况" class="headerlink" title="5.2 漫反射情况"></a>5.2 漫反射情况</h4><p>我们接下来先从简单的漫反射情况来详细理解上述过程。对于漫反射， BRDF 是一个常数，我们之前推导过，这里不再赘述，于是渲染方程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150537-165416238901233.png" alt="2022-06-02 150537"></p><p>其中光照项表示为球谐函数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150658443-165416238901234.png" alt="image-20220602150658443"></p><p>这样一来对于一个环境光（二维函数），我们只需要记录一个 SH 系数的向量（一维向量）就可以表示了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152232311.png" alt="image-20220602152232311"></p><p>将 SH 表示的环境光带入渲染方程中可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150745-165416238901235.png" alt="2022-06-02 150745"></p><p>其中的积分相当于把 light transport 项投影到基函数上，实际上这个投影方程也可以看作是一个渲染方程，因此投影结果可以认为是在某一个基函数的光照条件下的渲染结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602151932922-165416238901236.png" alt="image-20220602151932922"></p><p>这也是为什么 PRT 能够得到环境光阴影，因为在计算投影结果的时候，计算的是 light transport 的投影结果，而 light transport 就包含了 visibility 项，因此 PRT 能够得到准确的环境光阴影。这个投影结果是可以通过预计算得到的，因此渲染方程最终就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>这样在渲染时只需要计算一次点乘就可以得到环境光照了，为什么是点乘呢？我们接下来从另一个角度来理解上面的过程。</p><p>上面的推导中我们只把光照项表示为了 SH，然后将光照传播项投影到了这些 SH 上去预计算投影结果。我们当然也可以把光照项和光照传播项完全分开计算，分别把他们表示成 SH：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162810390.png" alt="image-20220602162810390"></p><p>于是渲染方程就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162847615.png" alt="image-20220602162847615"></p><p>渲染方程变成了一个二次的求和公式，这看起来和之前推导的结果不一样，因为这里二次求和显然是一个 $O(n^2)$ 的复杂度，要遍历 p 和 q 的结果全部累加起来，但是我们知道 SH 是基函数，基函数有正交性，也就是说只有两个基函数相同的时候，上面的积分值才为 1，其他情况下都是 0，因此上面的求和式实际上只是把光照项和光照传播项表示为 SH 后，相同的基函数对应的系数乘积累加了起来，之前说过，用 SH 表示一个二维函数相当于把二维函数压缩成了一个一维的系数向量，所以上面的求和式表示的就是光照项和光照传播项的系数向量的点乘。这和之前推导的公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p><p>表示的意义是完全一样的，这里面 $l_i$ 是光照项的每一个 SH 基函数的系数，$T_i$ 是光照传播项投影到每一个基函数的结果，也就是光照传播项的 SH 系数，二者相乘再求和不正是向量点乘吗。 </p><h4 id="5-3-Glossy-情况"><a href="#5-3-Glossy-情况" class="headerlink" title="5.3 Glossy 情况"></a>5.3 Glossy 情况</h4><p>在此基础上，我们就可以理解 Glossy 情况下 PRT 的计算了。漫反射时， BRDF 是一个常数，无论观察方向如何变化，观察到的光照结果都是一样的，因此光照传播项就是一个二维函数（因为 visibility 是二维的，只与 $w_i$ 有关），表示为 SH 可以得到一个系数向量，再点乘光照项的系数向量就得到了渲染方程的结果。</p><p>但是 Glossy 的 BRDF 不再是一个常数了，而是一个真正的四维函数，当我们在任意一个观察方向 $w_o$ 的时候，BRDF 都是一个与 $w_i$ 有关的二维函数，可以表示为 SH 得到一个系数向量，对于不同的观察方向 $w_o$，自然会得到不同的 SH 表示，也就会得到不同的系数向量。也就是说将 Glossy 的 BRDF 投影到 SH 之后，我们得到的不再是一个系数向量了，而是一个系数矩阵，每一行是一个观察方向 $w_o$ 对应的系数向量，每一列是每一个入射方向 $w_i$ 对应的系数向量，因此上面的公式就变成了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-0265720.png" alt="2022-06-0265720"></p><p>于是我们在计算时就不再是向量点乘了，而是向量和矩阵相乘了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602165910171.png" alt="image-20220602165910171"></p><p>也就是用光照项的系数向量乘以光照传播项的系数矩阵，最终得到的还是一个系数向量，表示的是不同观察方向所看到的光照结果，是一个关于观察方向 $w_o$ 的二维函数，因为对于 Glossy 材质，不同观察方向看到的光照结果是不同的，而漫反射与观察方向无关，所以向量点乘得到的是一个值。</p><h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>总结一下，PRT 将渲染方程分为两部分，一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，漫反射需要预计算一个向量，Glossy 反射需要预计算一个矩阵，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算。</p><p>PRT 效果好速度快，而且可以准确计算环境光阴影，并且如果预计算的时候考虑了光线的多次弹射还可以实现全局光照，而且得益于 SH 的快速旋转性质，PRT 可以在环境光旋转的时候迅速得到渲染结果，无需重新计算，因为当环境光旋转的时候相当于表示它的所有基函数进行了旋转，而旋转后的基函数可以表示为其他同阶基函数的线性组合，因此可以快速得到旋转后的环境光的 SH 表示。</p><p>但 PRT 也存在很多问题，比如只适用于静态场景，因为预计算了光照传播项，而光照传播项又包含了 visibility 和 BRDF，因此预计算完成后，场景的遮挡关系和物体的材质就不能改变了，否则就要重新计算；并且使用 SH 作为基函数只适用于低频环境光照，因为 SH 在表示高频信号的时候会非常吃力，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152155042-165416238901838.png" alt="image-20220602152155042"></p><p>这是因为 SH 是从低到高的频段表示，我们使用前 n 阶的 SH，就只能表示信号中对应的这么多频段的信息，更高频的信息就会丢失掉，对于一些高频环境光照的场景，可以使用其他基函数，比如二维小波函数（Wavelet），任意一个二维函数都可以表示为所有小波基函数的线性组合，而我们可以只保留线性组合系数最高的那些项来表示原函数，因此小波表示是全频率的，比 SH 更适合表示高频环境光，但小波函数不具有快速旋转性质，当环境光变化时处理非常不灵活，下图是 SH 和 小波函数的渲染结果对比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602172803653.png" alt="image-20220602172803653"></p><p>显然小波保留了更多的高频信息，得到了更好的阴影和反射效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【高质量实时渲染】实时阴影</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/</id>
    <published>2022-05-30T12:49:23.000Z</published>
    <updated>2022-06-13T03:31:52.570Z</updated>
    
    <content type="html"><![CDATA[<p>阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈-Shadow-Map"><a href="#1-再谈-Shadow-Map" class="headerlink" title="1 再谈 Shadow Map"></a>1 再谈 Shadow Map</h3><h4 id="1-1-Shadow-Map-背后的数学原理"><a href="#1-1-Shadow-Map-背后的数学原理" class="headerlink" title="1.1 Shadow Map 背后的数学原理"></a>1.1 Shadow Map 背后的数学原理</h4><p>关于 Shadow Map，我们在之前已经了解过，原理非常简单，首先从光源的视角看向整个场景生成一张深度图，然后再从真正的相机视角渲染场景，并对每一个着色点计算其到光源的距离，和深度图中的距离作比较，就可以判断该着色点和光源中间是否有遮挡物，从而产生阴影。整个过程可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/">【计算机图形学】（十）阴影</a>。</p><p>那么 Shadow Map 为什么可以这么做，可以利用数学知识简单的进行解释，同时了解实时渲染中的优化方向。</p><p>首先是在实时渲染领域非常重要的一个思想，那就是只要看起来是对的，那么它就是对的。也就是说我们不需要精确地计算出结果，只要能够得到结果的正确近似，使最终的渲染效果看起来正确就足够了。因此在实时渲染中会用到各种近似的方法，后面就可以看到，这里先熟悉一个实时渲染中经常用到的近似等式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152415189.png" alt="image-20220530152415189"></p><p>也就是把两个函数乘积的积分近似转化为两个函数积分的乘积，其中分母是一个缩放因子，为了将积分的乘积缩小到和原积分同样的大小，可以通过一个例子来理解：比如 $f(x)$ 是一个常量函数，函数值恒为 2，积分区间是一个长度为 3 的一维区间，那么原积分相当于两倍的 $g(x)$ 在该区间上的积分，转化后的分子，也就是对 $f(x)$ 的积分结果为 3 * 2 &#x3D;  6，如果不除以缩放因子那么结果就是 6 倍的 $g(x)$ 在该区间上的积分，而除以分母的缩放因子，也就是积分区间长度 3，结果刚好就是 2 倍的 $g(x)$ 在该区间上的积分。</p><p>这个式子在实时渲染中非常有用，比如我们的渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152854014.png" alt="image-20220530152854014"></p><p>在实时渲染中经常会改写为下面的形式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153029862.png" alt="image-20220530153029862"></p><p>其中 V 代表可见项，表示了该点的可见程度，可以理解为阴影项，于是上面的渲染方程根据之前的近似等式就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153303843.png" alt="image-20220530153303843"></p><p>我们在之前的 Shader 中就是在光照计算结果上乘了一个阴影项，这就是可以这么做的道理所在。当然使用这样的近似结果要想估计的准确需要一定的条件：</p><ul><li>$g(x)$ 在积分区间上的波动要尽可能小，或者说积分区间要足够小，体现到渲染中就是光源最好是点光源或者平行光</li><li>$g(x)$ 要是光滑函数，体现到渲染中就是如果不是点光源那么最好是均匀发光的面光源</li></ul><h4 id="1-2-Shadow-Map-的问题"><a href="#1-2-Shadow-Map-的问题" class="headerlink" title="1.2 Shadow Map 的问题"></a>1.2 Shadow Map 的问题</h4><p>Shadow Map 是最基础的阴影算法，优点在于它是一个屏幕空间的算法，不需要知道场景的几何信息，只要知道光源位置和每一个片段的位置就可以完成（世界空间或者裁剪空间都可以），但是正因为其简单，所以有不少缺点，这也是后面的阴影算法的改进方向，总的来说 Shadow Map 有三个最大的问题：</p><p>首先是<strong>自遮挡问题。</strong> Shadow Map 是一个需要两个 Pass 完成的算法，在第一个 Pass 中先从光源位置渲染一遍场景，并将每个像素的深度信息存下来，第二个 Pass 中利用这些深度信息产生阴影。问题在于 Shadow Map 分辨率有限，Shadow Map 中每个像素对应到场景中的一块区域，当第二次进行深度对比的时候，就可能会产生错误，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145535937.png" alt="image-20220530145535937"></p><p>由于 Shadow Map 分辨率有限，因此每个 texel 对应于场景中一个区域，如图中的区域 1。点 p1 和 p2 对应于屏幕上的不同像素点，由于我们判断一个像素是否位于阴影中，是通过比较该点在以光源为视点的空间中的深度和对应 texel 中储存的深度值。在这种情况下 d(p1) &gt; s，而 d(p2) &lt; s，因此 p1 将会被认为是在阴影中，但其实 p1 和 p2 应该都不在阴影中。于是渲染出来的图就会产生下面的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145805637.png" alt="image-20220530145805637"></p><p>存在很多阴影纹路，解决这个问题最简单的方法就是在深度比较的时候加上一个容忍度，也就是当着色点的深度比 Shadow Map 中的深度大且它们的差在一定范围内我们就不认为该点被遮挡了。但是如果我们手动设定一个固定的容忍度，也就相当于为 Shadow Map 中的深度进行了一个统一的偏移，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150153504.png" alt="image-20220530150153504"></p><p>这样虽然解决了自遮挡的问题，但会产生新的问题，也就是一部分本该在阴影中的点就不在阴影中了，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150232576.png" alt="image-20220530150232576"></p><p>脚的部分阴影就会断掉，原因如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150705056.png" alt="image-20220530150705056"></p><p>当三角形平面相对于光源的斜率比较大的时候，Shadow Map 中的深度偏移了一段距离，原本被遮挡的点就会变成没有被遮挡从而不产生阴影，如果使用相同的偏移量就会在斜率大的地方有更多的点不被遮挡，从而造成阴影断裂，也就是上图中鞋的部分显然相对于光源的斜率更大，因此会产生阴影断裂现象。因此我们希望可以根据三角形相对于光源的斜率来自适应的调整容忍度，现代显卡已经支持了这种操作。</p><p>Shadow Map 的第二个问题是会<strong>产生走样</strong>，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530151628306.png" alt="image-20220530151628306"></p><p>这同样是由于 Shadow Map 的分辨率有限造成的，可以通过 PCF 来解决，下面会详细介绍。</p><p>Shadow Map 的第三个问题是<strong>只能产生硬阴影</strong>。于是产生了各种软阴影算法，同样在之后详细介绍。</p><h3 id="2-Percentage-Closer-Filtering（PCF）"><a href="#2-Percentage-Closer-Filtering（PCF）" class="headerlink" title="2 Percentage Closer Filtering（PCF）"></a>2 Percentage Closer Filtering（PCF）</h3><p>PCF 是解决 Shadow Map 的走样问题而被提出的。其思想是获取着色点周围的一系列点的深度值，与 P 点深度比较再对比较结果计算一个平均值，也就是说，在比较着色点和 Shadow Map 中的深度的时候，不仅和一个 texel 作比较，而是和多个 texel 作比较，然后将比较的结果进行一个平均作为该点的最终比较结果，这样就得到了一个平滑的，不是非 0 即 1 的阴影项。下面通过一个例子来说明：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154335327.png" alt="image-20220530154335327"></p><p>对于点 P，我们将其周围 3 * 3 的深度值和当前像素作比较，得到一个比较结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154413210.png" alt="image-20220530154413210"></p><p>然后将这些结果（加权）平均起来，作为最终该像素的阴影项，这个例子中阴影项最终结果是 0.667，当然一般来说不会取 3 * 3 这么小的邻域。现在的硬件也支持 PCF，但只会取离纹理坐标最近的四个 texel 做平均，效果有限，因此大多数情况下还是在软件 Shader 中做 PCF。</p><p>需要注意的是，PCF 既不是对 Shadow Map 中的深度进行平均，也不是对生成的阴影图像进行滤波，而是对深度比较的结果进行平均。</p><p>下图是 PCF 的效果，可以一定程度上改善阴影的走样问题：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155053026.png" alt="image-20220530155053026"></p><h3 id="3-Percentage-Closer-Soft-Shadows（PCSS）"><a href="#3-Percentage-Closer-Soft-Shadows（PCSS）" class="headerlink" title="3 Percentage Closer Soft Shadows（PCSS）"></a>3 Percentage Closer Soft Shadows（PCSS）</h3><p>PCSS 是利用 PCF 产生软阴影的算法，为了解决 Shadow Map 无法产生软阴影的问题，实际上所有阴影反走样算法都可以用来产生软阴影。</p><p>从 PCF 的原理可以看出，当我们使用的邻域面积越大，也就是卷积核越大，得到的阴影就会越软，因此我们完全可以使用大卷积核的 PCF 来产生软阴影，但是卷积核选择多大合适呢？如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155441750.png" alt="image-20220530155441750"></p><p>笔尖附近的阴影非常锐利，而笔杆部分的阴影就变得比较软，这是因为在笔尖处，阴影投射物（Shadow Caster）和阴影接收物（Shadow Reciever）之间的距离很近，而在笔杆部分 Shadow Caster 和 Shadow Reciever 之间的距离较远。因此我们希望 Shadow Caster 和 Shadow Reciever 之间的距离越远，使用的卷积核越大，也就使得阴影越软。</p><p>这可以通过几何关系来描述：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160458278.png" alt="image-20220530160458278"></p><p>绿色虚线是遮挡物（Blocker）到光源平面的距离，蓝色虚线是阴影接收平面到光源平面的距离，当 Blocker 离光源平面越远，也就是离阴影接收平面越近，光源平面经过 Blocker 上一点映射到阴影接收平面上的面积就越小，我们根据这个映射后的面积决定使用多大的卷积核，这样一来，Blocker 离阴影接收平面越近，使用的卷积核就越小，当 Blocker 离光源平面越近，也就是离阴影接收平面越远，使用的卷积核就越大，这样就可以产生比较真实的软阴影效果。从图中也很容易根据相似三角形原理得出映射后的光源面积：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160930593.png" alt="image-20220530160930593"></p><p>现在的问题是，Blocker 的深度 $d_{Blocker}$ 如何得到？我们在渲染时只知道阴影接收平面上的一点，并不知道遮挡物距离光源的深度是多少，这时可以再次利用 PCF 的思想，将这一点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 Blocker 的深度。</p><p>于是 PCSS 算法的整个流程就是：</p><ul><li>对于每个像素，首先利用上述方法计算其 $d_{Blocker}$ </li><li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li><li>使用对应大小的卷积核进行 PCF</li></ul><p>那么又产生了一个问题，计算 $d_{Blocker}$ 时，又该选用多大的邻域范围呢？当然可以是一个固定的大小，比如 5 * 5，但是更好的方法是根据光源面积大小和着色点到光源的距离远近来选择不同的卷积核大小，一种方法是从着色点到光源平面构建一个锥体，然后看该点在  Shadow Map 上对应了多大的区域，将该区域内的深度和该点的深度进行比较，把所有小于该点深度的值平均起来作为 $d_{Blocker}$，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530162415880.png" alt="image-20220530162415880"></p><p>另外需要说明的是对于面光源，生成 Shadow Map 时也要像点光源一样，取光源平面中心一点，作为渲染深度图的视点，从该视点出发构建视锥体进行渲染，而 Shadow Map 也就是视锥体的近平面，所以使用上面的方法就可以从空间中一点覆盖到 Shadow Map 上的一块区域。</p><h3 id="4-Variance-Soft-Shadow-Mapping（VSM）"><a href="#4-Variance-Soft-Shadow-Mapping（VSM）" class="headerlink" title="4 Variance Soft Shadow Mapping（VSM）"></a>4 Variance Soft Shadow Mapping（VSM）</h3><h4 id="4-1-PCSS-的问题"><a href="#4-1-PCSS-的问题" class="headerlink" title="4.1 PCSS 的问题"></a>4.1 PCSS 的问题</h4><p>PCSS 利用 PCF 产生软阴影，但是速度并不快，因为 PCSS 在第一步计算 $d_{Blocker}$ 和最后一步进行 PCF 都需要对 Shadow Map 进行采样，而且当卷积核比较大的时候，需要采样很多纹理值，造成性能下降。一种解决方法是不对卷积核内的所有纹理进行采样，而是选取其中一些样本进行计算，但是这样得到的结果中一定存在噪声，不过可以利用后期的去噪方法来优化结果。</p><p>进一步思考这个问题，PCF 的精髓在于 “Percentage Closer”，也就是有多少百分比的 texel 是能够遮挡到当前位置的，换一种说法就是在当前点的一定邻域范围内有多少深度是小于当前点深度的。这就将原问题转化为了一个统计问题，因此使用少量样本也一定程度上能够得到近似正确的结果，但有没有更好的方法来得到相对准确的近似呢？</p><p>从概率与统计的角度来解决上述问题，我们只要能够知道这个邻域范围内的深度是如何分布的，就可以快速地得到一个近似的百分比。最容易想到的就是将深度的分布近似的看作是正态分布，而得到一个正态分布只需要两个量：均值和方差。</p><p><strong>因此 VSM 的核心思想就是</strong>，利用区域查询方法快速地得到 Shadow Map 中一个区域内深度的均值和方差，从而得到深度的近似分布，根据深度分布得到这个区域内有多少深度是小于当前点深度的，然后就可以改进 PCSS 的第一步和第三步中 PCF 的多次纹理采样，从而获得效率提升。</p><h4 id="4-2-区域查询方法"><a href="#4-2-区域查询方法" class="headerlink" title="4.2 区域查询方法"></a>4.2 区域查询方法</h4><p>对于一个区域内的均值，可以利用 MipMap 来快速查询，但是 MipMap 得到的均值是近似值，因为需要三线性插值，即在同一层级的不同平均值之间插值，然后还得在不同层级之间再插值一次得到结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530174618341.png" alt="image-20220530174618341"></p><p>更准确的查询区域均值的方法是利用 Summed Area Tables (SAT)。SAT 实际上就是二维前缀和，具体细节就不赘述了，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170245397.png" alt="image-20220530170245397"></p><p>因此使用 SAT 获取区域均值是绝对准确的，非近似的，而且还支持矩形区域查询，MipMap 只支持正方形区域。</p><p>至于 SAT 的构建，需要随着 Shadow Map 的更新而重新计算，而 Shadow Map 也要在场景中的物体运动或者光源运动的情况下不断更新，所以还是存在一定的开销的，但 SAT 一旦构建完成就可以使用 VSM 算法快速得到的 PCF 的结果，而不需要再对 Shadow Map 进行多次采样再平均，所以降低了 PCSS 的开销。</p><h4 id="4-3-VSM-的实现"><a href="#4-3-VSM-的实现" class="headerlink" title="4.3 VSM 的实现"></a>4.3 VSM 的实现</h4><p>利用区域查询方法可以快速得到深度的均值，那么如何得到区域内深度的方差呢？利用一个经典概率论公式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170818733.png" alt="image-20220530170818733"></p><p>我们只需要在构建 Shadow Map 的时候，将深度的平方也存在一张纹理中，就可以计算出区域内深度的方差了。在实际实现中，深度和深度的平方可以存在一张纹理的两个不同通道，甚至不需要两张纹理，也不需要 MRT 支持，非常方便。</p><p>于是根据均值和方差就可以构建出该区域内深度的近似分布了，下一步就是得到有多少深度比当前点深度小，也就是算出 $P(x &lt; x_{cur})$，已知概率密度函数（PDF）求概率就是对 PDF 进行积分，而如果能够提前算出所有的概率，对于给定的 $x_{cur}$，只需要查询就可以了，这正是分段概率函数（CDF），如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171327752.png" alt="image-20220530171327752"></p><p>但是对于一个连续的概率分布，求其 CDF 是非常困难的，于是 VSM 又利用了一个巧妙的方法来近似 CDF —— 利用切比雪夫不等式。</p><p>切比雪夫不等式（Chebychev’s inequality）在单峰概率分布时如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171632090.png" alt="image-20220530171632090"></p><p>这个不等式甚至不需要知道具体的概率分布，只要给定均值和方差，就可以得到上面的关系，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171726482.png" alt="image-20220530171726482"></p><p>切比雪夫不等式描述的是 $x&gt;t$ 的概率不大于右边通过均值和方差计算出来的值。而在图形学中一个常规操作就是把不等式看作约等式，因此可以直接把切比雪夫不等式的右边的值作为 $P(x&gt;t)$ 的估计值，这样自然也就得到了我们需要的 $P(x &lt; t)$ 的估计值。</p><p>但是切比雪夫不等式要求 t 必须大于均值才有效，不过对于图形学来说，这样的近似估计已经足够好了，因为它足够简单快速。</p><p>现在我们可以总结一下 VSM 算法对 PCF 的改进流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>然后在渲染时，只需要查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，这一系列操作只需要 O(1) 时间，不需要任何循环和多次纹理采样</li></ul><p>于是就解决了 PCSS 中的第三步 PCF，那么第一步获取 $d_{Blocker}$ 又该如何优化呢？</p><p>回顾获取 $d_{Blocker}$ 的方法：将当前点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 $d_{Blocker}$。</p><p>对于一个区域，区域内所有深度可以分为两类：</p><ul><li>一类是小于当前点深度的，也就是会遮挡到当前点的深度，这些点的深度均值为 $z_{occ}$</li><li>另一类是小于当前点深度的，也就是不会遮挡到当前点的深度，这些点的深度均值为 $z_{unocc}$</li></ul><p>于是区域内所有深度的均值 $z_{avg}$ 可以表示成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530173458126.png" alt="image-20220530173458126"></p><p>其中 N 是区域内 texel 总数量， N1 和 N2 分别是不会遮挡和会遮挡当前点的 texel 数量。</p><p>我们希望得到的是会遮挡到当前点的深度的均值 $z_{occ}$。而 N1&#x2F;N 就是我们上面切比雪夫不等式计算的 $P(x &gt; x_{cur})$，那么自然 N2&#x2F;N 就是 $1-P(x &gt; x_{cur})$，于是现在我们只要知道 $z_{unocc}$ 就可以得到 $z_{occ}$ 了，VSM 直接假设 $z_{unocc}&#x3D;x_{cur}$ ，也就是假设不会遮挡到当前点的深度的均值就是当前点的深度，根据这些值，就可以得到一个 $z_{occ}$ 的近似值了，这个值就作为 $d_{Blocker}$ 去计算 PCF 卷积核大小。</p><p>于是 PCSS 中第一步的多次采样问题也解决了，最后总结一下 VSM 的算法流程：</p><ul><li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li><li>然后预处理得到 Shadow Map 的 SAT</li><li>渲染时，对于每个像素，根据之前说的方法得到计算 $d_{Blocker}$ 时的卷积核大小，查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计，利用上述方法计算 $z_{occ}$ 作为 $d_{Blocker}$ </li><li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li><li>使用对应大小的卷积核查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，将切比雪夫估计值作为该像素的阴影项</li></ul><h4 id="4-4-VSM-的优缺点"><a href="#4-4-VSM-的优缺点" class="headerlink" title="4.4 VSM 的优缺点"></a>4.4 VSM 的优缺点</h4><p>VSM 实际上就是 PCSS 的改进方法，加速了 PCF 的计算过程，效率更高，且阴影不会产生噪声，但也存在一些问题。最严重的问题就是会产生漏光（Light Leaking）现象。</p><p>所谓漏光是指当两个 shadow caster 的阴影出现重叠时，在阴影的交界处会出现漏光，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175426796.png" alt="image-20220530175426796"></p><p>汽车底盘下方有些亮的地方，但是汽车底盘不应该是透光的，这是因为这些地方处于多个 shadow caster 的交界处，车顶有镂空的架子。</p><p>漏光的原因在于 VSM 中使用了单峰概率分布的切比雪夫不等式作为 PCF 的估计值，也就是默认当前点周围的深度分布是一个单峰的概率分布。对于一些复杂的情况，比如树枝，确实一个点周围的深度分布很复杂，可以近似为正态分布，所以阴影也不会有问题，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175756313.png" alt="image-20220530175756313"></p><p>但是有些情况下，深度分布很简单，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175829567.png" alt="image-20220530175829567"></p><p>这时如果一个着色点刚好在多个镂空区域的下方，那么该点周围的深度分布可能就是多个峰值或者像上图那样的极端情况，只有几个离散的深度，这时还是用单峰切比雪夫不等式就会使得估计出来的 $P(x &gt; x_{cur})$ 偏大或者偏小，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180032457.png" alt="image-20220530180032457"></p><p>也就会导致阴影项偏小或者偏大，体现在图像上就是该像素更暗或者更亮，对于阴影来说，更暗我们一般看不出来，但是更亮就会很敏感地被捕捉到，也就是漏光现象。</p><h3 id="5-Moment-Shadow-Mapping（MSM）"><a href="#5-Moment-Shadow-Mapping（MSM）" class="headerlink" title="5 Moment Shadow Mapping（MSM）"></a>5 Moment Shadow Mapping（MSM）</h3><p>MSM 就是为了解决 VSM 的漏光现象而提出的。VSM 漏光的本质原因在于对深度分布的估计不准确，因为 VSM 只使用了均值和方差来估计分布，也就是只使用了深度的一阶矩和二阶矩，MEM 使用更高阶的矩来估计深度分布，得到的分布估计自然更加准确，MEM 经过实验指出，一般情况下使用前四阶矩就可以很好的拟合 PCF 的深度分布了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180617122.png" alt="image-20220530180617122"></p><p>最后值得一提的是，现在更多的实时阴影还是使用在区域内采样深度的 PCSS，得益于时间和空间上的去噪和模糊算法可以在很短时间内达到很好的效果，因此我们可以在很小的开销下得到一张有噪声的结果，然后使用去噪或者模糊算法来优化这个结果得到好的渲染图片。</p><h3 id="6-Distance-Field-Soft-Shadows"><a href="#6-Distance-Field-Soft-Shadows" class="headerlink" title="6 Distance Field Soft Shadows"></a>6 Distance Field Soft Shadows</h3><p>基于距离场的软阴影是另一种软阴影的近似算法，与以上基于 Shadow Map 的软阴影算法完全不同。相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，因此目前基于距离场的软阴影算法也逐渐被广泛使用。</p><p>首先回顾一下距离场，距离场是由空间中所有点的距离函数组成的场，而距离函数是指一个点到离它最近的物体表面的距离。下图是一个字母 A 的距离场可视化的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142044408.png" alt="image-20220601142044408"></p><p>距离场的优势在于可以使用插值得到物体表面的中间状态，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142307684.png" alt="image-20220601142307684"></p><p>上面一行是直接对图像进行插值的结果，黑色部分代表物体，从状态 A 到状态 B 表示一个物体从左向右运动，黑白的边界就表示物体的表面。如果直接对两幅图像的每个像素进行插值是无法得到这两个状态的中间状态的，而如果转化为距离场，对距离场插值之后再逆变换回图像，就可以得到两个状态的中间状态。</p><h4 id="6-1-距离场的用途"><a href="#6-1-距离场的用途" class="headerlink" title="6.1 距离场的用途"></a>6.1 距离场的用途</h4><p>距离场的一个用途就是用来做 Ray marching，也叫做 sphere tracing，也就是可以通过距离场来求光线和表面的交点，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142714292.png" alt="image-20220601142714292"></p><p>因为距离场表示的是空间中一点到离它最近的物体表面的距离，因此在任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，也就是不会碰到物体的距离，所以在该点处 SDF(p) 范围内，光线不会与任何物体有交点，于是光线就可以前进 SDF(p) 距离到达边界，到达边界后又会得到一点，然后再去查找该点的 SDF(p) 并继续前进，直到光线足够接近物体或者追踪了足够多次，因此这种方法也叫做 sphere tracing。</p><h4 id="6-2-基于距离场的软阴影"><a href="#6-2-基于距离场的软阴影" class="headerlink" title="6.2 基于距离场的软阴影"></a>6.2 基于距离场的软阴影</h4><p>在 Ray marching 中就可以顺便完成阴影项的计算，得到一个软阴影，上面说到，任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，那么也就表示了这一点的安全角度，所谓安全角度是指该点不会被遮挡到的角度，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601143236308.png" alt="image-20220601143236308"></p><p>而这个安全角度是很容易算出的，我们知道着色点到该点的距离，也知道该点到离他最近的物体表面的距离，那么安全角度就是：<br>$$<br>arcsin(\frac{SDF(p)}{|p - o|})<br>$$<br>该值就可以直接作为阴影项，安全角度越小，被遮挡的概率就越大，因此该着色点的阴影也就越暗。</p><p>但是在着色过程中，反三角函数的计算还是太过复杂，为了简化计算，我们直接使用该点的距离函数值和着色点到该点的距离的比值乘上一个系数来近似 arcsin 值，并且将其限制在 [0, 1] 范围内：<br>$$<br>min(k·\frac{SDF(p)}{|p - o|},1.0)<br>$$<br>这样近似不仅降低了计算开销，还能使软阴影更加灵活，因为 k 值越大，相当于在一个很小的安全角度阴影项就达到了 1.0，因此从0 到 1 的过渡就越陡峭，阴影和非阴影的边界就越明显，阴影也就越硬，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/2022-06-01144018.png" alt="2022-06-01 144018"></p><h4 id="6-3-距离场的优缺点"><a href="#6-3-距离场的优缺点" class="headerlink" title="6.3 距离场的优缺点"></a>6.3 距离场的优缺点</h4><p>相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，但是距离场是定义在三维空间中的，三维空间中的每个点的 SDF 都要存下来，需要非常大的存储开销，虽然有一些距离场的压缩算法，但相比于一张 Shadow Map 二维纹理，依然是极大的开销。</p><p>此外，使用距离场自然需要预先对一个场景计算其距离场，对于一些有形变的物体每次还要重新计算，也是一个很大开销，一个场景中有多个物体还要先计算点到不同物体表面的距离，再取所有距离的最小值作为该点的 SDF，当然也可以使用场景管理的 BVH 等数据结构来优化距离场的计算过程，下图是一个复杂场景的距离场可视化结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601144718966.png" alt="image-20220601144718966"></p><p>除了上面的缺点外，距离场实际上也存在一些 artifact，这里不赘述，有必要可以之后再做深入了解。</p><h3 id="7-Cascaded-Shadow-Maps（CSM）"><a href="#7-Cascaded-Shadow-Maps（CSM）" class="headerlink" title="7 Cascaded Shadow Maps（CSM）"></a>7 Cascaded Shadow Maps（CSM）</h3><p>CSM 也称为级联阴影，通常用于大型场景的实时阴影中，当场景很大的时候，在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率，否则就会造成阴影的严重锯齿。CSM 的思想是使用多张不同分辨率的阴影贴图，对于<strong>近处</strong>的场景使用<strong>较高分辨率</strong>的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。因为远处的对象只占画面的很少一部分像素，而近处的对象占据了画面的很大一部分，进行这样的处理显然非常合理。</p><p>CSM 根据场景的远近来划分 camera frustum，靠近 camera 的区域划分的较密，远离 camera 的区域划分的比较稀疏，这就使得靠近 camera 的区域能够使用一个相对较大分辨率的 shandow map，减少失真现象。CSM的具体流程如下：</p><ul><li>划分 camera frustum 成多个 subfrustum ;</li><li>计算每个小的 subfrustum 的包围盒；</li><li>对每个 subfrustum 生成投影矩阵；</li><li>对每个 subfrustum 生成一张 shadow map；</li><li>对每一个像素根据深度选择合适的 shadow map 生成阴影。</li></ul><p>CSM 几乎是现代游戏引擎中的标配算法，可以配合上面的软阴影生成算法在大型场景中达到很好的效果，并且保证时效性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="高质量实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【游戏引擎】（二）游戏引擎中的渲染系统</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-26T08:23:09.000Z</published>
    <updated>2022-05-26T08:27:14.282Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。</p><p><em><span id="more"></span></em></p><h3 id="1-GPU-架构"><a href="#1-GPU-架构" class="headerlink" title="1 GPU 架构"></a>1 GPU 架构</h3><p>GPU 是渲染系统使用的核心工具，要想使游戏引擎充分利用资源，就要对 GPU 的架构有所了解。关于现代 GPU 架构，这篇文章写的比较细致：<a href="https://zhuanlan.zhihu.com/p/406096300">现代渲染引擎开发-GPU架构</a>，这里只总结重点：</p><ul><li>SIMD是单指令多数据，一条指令处理多个数据，如下图：</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155458175.png" alt="image-20220526155458175"></p><ul><li>SIMT是单指令多线程，N 卡使用这种方式，即单条指令在多个核上分多个线程执行</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155551595.png" alt="image-20220526155551595"></p><ul><li>GPU 中最重要的计算单元是 CU，N 卡中为 CUDA Core，还有专门支持光追的 RT Core 和支持 AI 运算的 Tensor Core 等，多个 CU 组成一个 GPC，也叫做 Shader Engine</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526160001900.png" alt="image-20220526160001900"></p><ul><li>GPU 对性能的瓶颈包括：内存瓶颈、ALU（整形运算单元）瓶颈、TMU（纹理映射单元）瓶颈、BW（带宽）瓶颈等</li></ul><h3 id="2-渲染资源管理"><a href="#2-渲染资源管理" class="headerlink" title="2 渲染资源管理"></a>2 渲染资源管理</h3><p>游戏中的所有对象被称为 GameObject（GO），每一个 GO 包含很多组件，比如模型、语音、动画等等，GO 之间还可以通过事件系统进行交流，并根据其他 GO 发来的消息做出响应。其中，与渲染相关的组件就称为 Renderable，Renderable 包含渲染这个 GO 所需的所有数据，包括顶点、法线、纹理坐标、材质、贴图等等。游戏引擎需要将这些数据高效地组织起来。</p><p>顶点数据的组织我们在 OpenGL 中已经了解，分为顶点数据和顶点索引，顶点索引就描述了所有图元由哪些顶点组成，因为很多图元之间会共享顶点，这样就不需要为每个图元单独存储顶点，从而避免资源浪费。</p><p>一个 GO 最重要的就是要有一个模型，模型由网格 Mesh 组成，因为模型的不同部位可能需要不同的材质，所以一个模型又分为了多个子 Mesh，称为 SubMesh，每个 SubMesh 有它对应的材质（Material），材质包含纹理（Texture）和 Shader 等，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161157448.png" alt="image-20220526161157448"></p><p>在实际的游戏中，许多游戏对象的 Renderable 可能是重复的，比如许多步兵 NPC，渲染它们需要的数据是完全一样的，如果为每个 GO 都存储一遍这些数据那将会是极大的浪费，因此游戏引擎将所有这些资源放入了资源池中，不同的 GO 只需要存储资源池中资源的索引即可，比如一个模型的 Mesh 对应 Mesh 池中的哪些图元，使用 Shader 池中的哪些 Shader 去渲染，这样就将资源紧凑的管理起来了：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161435933.png" alt="image-20220526161435933"></p><p>这种管理方式也是游戏引擎中很常见的一种管理方式，用来应对资源复用的问题，不只是在渲染系统中，其他系统中也广泛使用了这种管理方式。因此每一个 GO 只是这些资源的组合，是实例化的资源。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161628614.png" alt="image-20220526161628614"></p><p>此外，因为不同的 GO 会有不同的材质，即使是一个 GO 也会在不同部位使用不同的材质，如果不做任何优化的进行渲染，会有大量的材质更新操作，即卸载掉这个材质的纹理和 Shader，并加载 另一个材质的纹理和 Shader，这样也会造成性能的下降，因此一般的做法是将 SubMesh 按照材质排序，将所有材质相同的 SubMesh 放在一起，这样只需要加载一次材质就可以渲染所有使用该材质的 SubMesh：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526162146227.png" alt="image-20220526162146227"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>关于透视插值校正</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/</id>
    <published>2022-05-25T08:51:00.000Z</published>
    <updated>2022-05-25T09:16:54.596Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。</p><p><em><span id="more"></span></em></p><h3 id="1-为什么需要透视插值校正"><a href="#1-为什么需要透视插值校正" class="headerlink" title="1 为什么需要透视插值校正"></a>1 为什么需要透视插值校正</h3><p>透视投影我们已经非常熟悉了，透视投影是为了模拟人眼所看到的近大远小的效果，比如一个正方形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/image-20220525160340619.png" alt="image-20220525160340619"></p><p>如果是正交投影，那么点 Q 就在 BC 连线中点处，而如果是透视投影，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/2022-05-25160428.png" alt="屏幕截图 2022-05-25 160428"></p><p>点 Q 就不再处于 BC 连线的中间处了，在我们的渲染器中纹理出现变形的原因就是我们在对顶点的纹理坐标进行插值的时候没有考虑透视的影响。如下图，红色坐标为纹理坐标，黑色为顶点位置：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-d6f128e3e3150d0ab3941dfdc452e111_r.jpg" alt="v2-d6f128e3e3150d0ab3941dfdc452e111_r"></p><p>当摄像机视线垂直于平面时，将贴图按照 uv 坐标插值，贴到正方形上会如右图所示，不会出现任何问题，但如果相机不垂直于平面：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-67871f21f22f9573e64d3bd30788c033_b.jpg" alt="v2-67871f21f22f9573e64d3bd30788c033_b"></p><p>本来按照正确的透视，正方形的中心点应该在 AC 和 BD 的交点 Q，我们应该把纹理坐标为 (0.5, 0.5) 的颜色值赋给 Q，但是图中却赋给了 P 点，这是因为我们在光栅化插值的时候，使用的是屏幕坐标进行的线性插值，屏幕坐标是投影后的坐标，是没有考虑近大远小的。</p><p>也就是说通，过屏幕坐标插值，可以得到 AC 的中点为点 P，AB 的中点为点 N，AD 的中点为点 M，这些都是投影后屏幕上线段的中点，而不是实际这个正方形在空间中线段的中点，因此就会出现纹理映射错误的情况。所以这时候我们就需要进行透视插值校正。</p><h3 id="2-如何进行透视插值校正"><a href="#2-如何进行透视插值校正" class="headerlink" title="2 如何进行透视插值校正"></a>2 如何进行透视插值校正</h3><p>我们在二维空间中进行推导会简单许多。下图为二维空间中的投影，因为是二维，所以我们把 x 坐标全部置 0，各种几何关系如图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-9ef76bf017541df6b268f0fc5d50f400_b.jpg" alt="v2-9ef76bf017541df6b268f0fc5d50f400_b"></p><p>二维空间中的线段 AB 被投影到 Z &#x3D; C 平面上，显示为线段 A’B’，利用投影平面的坐标进行插值可以得到：<br>$$<br>P’ &#x3D; (1-m)A’ + mB’<br>$$<br>于是现在的问题是，如何通过屏幕上的点 P‘ 得到空间中原本的点 P，并求出一个插值关系：<br>$$<br>P &#x3D; (1-n)A + nB<br>$$<br>最简单的方法自然是对点 P’ 应用透视投影变换的逆变换，但矩阵变换太麻烦，我们完全可以通过几何关系解决这个问题。</p><p>在图中添加两条辅助线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-1766a667c7a314f19092ecc00ea03b6b_b.jpg" alt="v2-1766a667c7a314f19092ecc00ea03b6b_b"></p><p>根据三角形相似可以得到：<br>$$<br>\frac{n}{1-n} &#x3D; \frac{|AG|}{|BK|} &#x3D; \frac{|A’P’|\frac{Z_1}{c}}{|B’P’|\frac{Z_2}{c}} &#x3D; \frac{mZ_1}{(1-m)Z_2}<br>$$<br>等式两边取倒数可得：<br>$$<br>\frac{1}{n} - 1 &#x3D; \frac{(1-m)Z_2}{mZ_1}<br>$$<br>由此可以解得：<br>$$<br>n &#x3D; \frac{mZ_1}{mZ_1 + (1-m)Z_2}<br>$$<br>这样我们就得到了已知屏幕空间的插值系数 m，求观察空间的插值系数 n 的方法。使用插值系数 n 就可以对顶点的任意属性进行插值了。比如点 P 的 Z 坐标：<br>$$<br>Z_n &#x3D; (1-n)Z_1 + nZ_2 &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}Z_1 + \frac{mZ_1}{mZ_1 + (1-m)Z_2}Z_2<br>$$<br>化简后得到：<br>$$<br>Z_n &#x3D; \frac{Z_1Z_2}{mZ_1 + (1-m)Z_2} &#x3D; \frac{1}{\frac{1-m}{Z_1} + \frac{m}{Z_2}}<br>$$<br>这样计算其他属性的插值就可以直接将 $Z_n$ 带入，为什么要将 $Z_n$ 带入呢？因为我们的观察方向都是沿着 -Z 轴方向，所以透视的缩放关系只和深度 Z 有关。比如求点 P 的纹理坐标：<br>$$<br>UV_P &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}UV_A + \frac{mZ_1}{mZ_1 + (1-m)Z_2}UV_B<br>$$<br>将 $Z_n$ 带入得：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-m}{Z_1}UV_A + \frac{m}{Z_2}UV_B)<br>$$<br>上式就是我们在代码中实现的，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的线性插值之后再乘以插值点的深度值，就完成了线性插值的透视校正。</p><p>现在推广到三维空间，可以得到：<br>$$<br>Z_n &#x3D; \frac{1}{\frac{1-u-v}{Z_1} + \frac{u}{Z_2} + \frac{v}{Z_3}}<br>$$<br>其中 u 和 v 是重心插值系数：<br>$$<br>P &#x3D; (1-u-v)A + uB + vC<br>$$<br>于是在三维空间中，点 P 的纹理坐标为：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-u-v}{Z_1}UV_A + \frac{u}{Z_2}UV_B + \frac{v}{Z_3}UV_C)<br>$$<br>于是同样的，在透视除法中，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的重心插值之后再乘以插值点的深度值，就完成了重心插值的透视校正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="3D数学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（九）改进光栅化</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2022-05-25T07:34:39.000Z</published>
    <updated>2022-05-25T09:05:15.976Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。</p><p><em><span id="more"></span></em></p><h3 id="1-边界函数算法"><a href="#1-边界函数算法" class="headerlink" title="1 边界函数算法"></a>1 边界函数算法</h3><p>关于边界函数算法，原理同样非常简单，就是用点和三角形三个顶点连线的向量叉乘来判断点是否在三角形内部，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/">【计算机图形学】（三）光栅化</a>，其中还包含了 C++ 代码实现。我们先照搬过来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓边界函数实际上就是上述代码中的 <code>(signOfAB * signofTrig &gt; 0)</code> 等这三个判断条件，因为这个条件判断了点和三角形的一条边界的位置关系，因此被称为边界函数。根据边界函数经过推导可以看出每次移动一个像素得到的边界函数和之前的边界函数的差值是固定的，具体推导过程可以查看<a href="https://zhuanlan.zhihu.com/p/140926917">图形学底层探秘 - 更现代的三角形光栅化与插值算法的实现与优化</a>，因此我们不需要每次都计算叉乘，只需要在前一次的结果上加上差值即可。</p><p>另一个问题是，我们对每个三角形的 Bounding Box 内的像素进行遍历来判断其是否在三角形内部，那么至少会有一半的像素不在三角形内而造成计算浪费，因此出现了分块优化算法，即将 Bounding Box 进行分块，然后只判断每块四个角上的像素是否在三角形内，如果每块的四个像素都在三角形内部或者外部，其他像素就不需要再进行判断了，如果四个像素部分在内部部分在外部就执行正常的算法在块内逐像素判断。这个方法对于占屏幕面积较大的三角形优化效果明显，但如果是小三角形或是斜长的细三角形，反而不如不分块来得快。而且，太大的分块会进一步降低小三角形的绘制效率，而太小的分块又变回了逐像素算法，因此分块的大小需要仔细的权衡。</p><h3 id="2-重心插值"><a href="#2-重心插值" class="headerlink" title="2 重心插值"></a>2 重心插值</h3><p>扫描线算法中使用线性插值就可以确定片元的各种属性值，而在边界函数算法中需要使用重心插值，关于重心坐标我们之前的笔记中也有具体的推导：<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a>中的第4部分。</p><p>在实现中我们如何计算重心坐标呢？首先整个三角形的面积可以通过：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}a·b·sin\theta<br>$$<br>来计算，也就是三角形两条边叉乘得到的向量模的一半，以 AB 和 BC 边为例，三角形的面积为：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}(A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx)<br>$$<br>而我们的三个边界函数相加：<br>$$<br>F_{AB}(P) + F_{BC}(P) + F_{CA}(P) &#x3D; A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx<br>$$<br>刚好是三角形面积的二倍，即：<br>$$<br>\frac{F_{AB}(P) + F_{BC}(P) + F_{CA}(P)} {2S_{\Delta} } &#x3D; 1<br>$$<br>而重心坐标就是小三角形面积和整个三角形面积的比值，因此我们可以直接通过边界函数得到点 P 的重心坐标：<br>$$<br>\alpha &#x3D; \frac{F_{AB}(P)} { {2S_{\Delta} } },\beta &#x3D; \frac{F_{BC}(P)} { {2S_{\Delta} } },\gamma &#x3D; \frac{F_{CA}(P)} { {2S_{\Delta} } }<br>$$<br>这样整个光栅化算法就完成了。需要注意的是重心插值和之前的线性插值一样，都需要进行透视插值校正，即在透视除法中将所有属性都除以 w 值，最后在片元着色器之前再乘以 w 值恢复。关于透视插值校正我们将在下一节详细讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（八）光源</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/</id>
    <published>2022-05-25T03:24:21.000Z</published>
    <updated>2022-05-25T03:25:42.269Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。</p><p><em><span id="more"></span></em></p><h3 id="1-光源概述"><a href="#1-光源概述" class="headerlink" title="1 光源概述"></a>1 光源概述</h3><p>在 RTR 一书中，作者将光源分为三种，分别是：平行光（direction）、点光源（point）和聚光灯（spot）。我们分别来实现这三种光源。</p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h3><p>在实现光源之前我们需要一些函数和变量，首先是在 <code>Global.h</code> 中定义的环境光项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>还有计算反射方向的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射的计算 2n * cos(n,l) - l = r</span></span><br><span class="line"><span class="comment">// lightDir是光指向片元的方向</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> glm::vec3&amp; lightDir, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightDir - <span class="number">2</span> * glm::<span class="built_in">dot</span>(normal, lightDir) * normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-平行光"><a href="#3-平行光" class="headerlink" title="3 平行光"></a>3 平行光</h3><p>在实现各类光源之前我们先实现一个光源基类，这样其他光源都派生自该基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光源基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Color;</span><br><span class="line">    glm::vec3 Specular;</span><br><span class="line">    glm::vec3 Direction;</span><br><span class="line">    <span class="type">float</span> Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Light</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Light</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) :</span><br><span class="line">        <span class="built_in">Position</span>(pos),</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Direction</span>(dir),</span><br><span class="line">        <span class="built_in">Intensity</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是平行光，平行光不需要位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光，不需要位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DirectionLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) : </span><br><span class="line">        <span class="built_in">Light</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), color, specular, dir, i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们新建一个 <code>BlinnPhongShader</code> 类继承于基本的 Shader 类，在其中实现平行光的计算，并修改片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Light.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlinnPhongShader</span> : <span class="keyword">public</span> Shader &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量都要是单位向量</span></span><br><span class="line">    <span class="comment">// ViewDir是片元指向摄像机的方向</span></span><br><span class="line">    <span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcDirLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> DirectionLight&amp; dirLight,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -dirLight.Direction), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - dirLight.Direction);</span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">        glm::vec3 diffuse = dirLight.Color * diff * albedo;</span><br><span class="line">        glm::vec3 specular = dirLight.Specular * spec;</span><br><span class="line">        <span class="keyword">return</span> (diffuse + specular) * dirLight.Intensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">        glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">        glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">        glm::vec3 result = Ambient * albedo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">            result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个平行光：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平行光源</span></span><br><span class="line"><span class="function">DirectionLight <span class="title">dir</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">1.0</span>)</span></span>;</span><br><span class="line">dirLights = &amp;dir;</span><br><span class="line">dirLtNums = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用光照Shader</span></span><br><span class="line">BlinnPhongShader shader;</span><br><span class="line"><span class="comment">// 加载模型</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112039177.png" alt="image-20220525112039177"></p><h3 id="4-点光源"><a href="#4-点光源" class="headerlink" title="4 点光源"></a>4 点光源</h3><p>点光源无所谓方向，它向四周均匀发光，光照强度和距离成反比，我们使用常数项、一次项和二次项来控制光照衰减，首先是点光源类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点光源，不需要方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> Constant;        <span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> Linear;        <span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> Quadratic;    <span class="comment">// 二次项</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PointLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span></span><br><span class="line">    ) : <span class="built_in">Light</span>(pos, color, specular, glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), i), <span class="built_in">Constant</span>(c), <span class="built_in">Linear</span>(l), <span class="built_in">Quadratic</span>(q)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是计算点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算点光源</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcPtLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PointLight&amp; ptLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到光源的距离</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, ptLight.Position);</span><br><span class="line">    <span class="comment">// 强度衰减因子</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (ptLight.Constant + ptLight.Linear * distance +</span><br><span class="line">                               ptLight.Quadratic * (distance * distance));</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - ptLight.Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = ptLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = ptLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * ptLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入点光源贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数中加入一个点光源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PointLight <span class="title">pt</span><span class="params">(glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">ptLights = &amp;pt;</span><br><span class="line">ptLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查看效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112022188.png" alt="image-20220525112022188"></p><h3 id="5-聚光灯"><a href="#5-聚光灯" class="headerlink" title="5 聚光灯"></a>5 聚光灯</h3><p>聚光灯可以理解为手电筒，只有在与手电筒正方向夹角在一定范围内的像素才会被照亮。像素到光源位置的方向与光源正向夹角被称为切光角，切光角在设定范围内的像素，按照点光源的方式计算光照。切光角之外的像素不会被照亮。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525110724976.png" alt="image-20220525110724976"></p><p>为了避免边缘突变，可以设立一个外切光角，在内外切光角之间使用插值乘以计算结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span> : <span class="keyword">public</span> PointLight &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> innerCutOff;        <span class="comment">// 内切光角范围</span></span><br><span class="line">    <span class="type">float</span> outterCutOff;        <span class="comment">// 外切光角范围</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpotLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; icut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; ocut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5</span>))</span><br><span class="line">    ) : <span class="built_in">PointLight</span>(pos, color, specular, i, c, l, q), <span class="built_in">innerCutOff</span>(icut), <span class="built_in">outterCutOff</span>(ocut)</span><br><span class="line">    &#123;</span><br><span class="line">        Direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计算聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算聚光灯，切光角以内按点光源计算</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcSpLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SpotLight&amp; spLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - spLight.Position);</span><br><span class="line">    <span class="comment">// 切光角</span></span><br><span class="line">    <span class="type">float</span> theta = glm::<span class="built_in">dot</span>(lightDir, glm::<span class="built_in">normalize</span>(spLight.Direction));</span><br><span class="line">    <span class="comment">// 内外切光角插值系数</span></span><br><span class="line">    <span class="type">float</span> weight = <span class="built_in">saturate</span>((theta - spLight.outterCutOff) / (spLight.innerCutOff - spLight.outterCutOff));</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">Lerp</span>(<span class="number">0</span>, <span class="number">1</span>, weight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按点光源计算</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, spLight.Position);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (spLight.Constant + spLight.Linear * distance +</span><br><span class="line">                               spLight.Quadratic * (distance * distance));</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = spLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = spLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= (attenuation * intensity);</span><br><span class="line">    specular *= (attenuation * intensity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * spLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中加入聚光灯贡献：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; spLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcSpLight</span>(*(spLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中加入聚光灯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="function">SpotLight <span class="title">sp</span><span class="params">(camera-&gt;Position, camera-&gt;Front)</span></span>;</span><br><span class="line">spLights = &amp;sp;</span><br><span class="line">spLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525111959282.png" alt="image-20220525111959282"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（七）加载模型</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-05-24T11:51:24.000Z</published>
    <updated>2022-05-24T11:52:25.830Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。</p><p><em><span id="more"></span></em></p><h3 id="1-模型、对象、网格的关系"><a href="#1-模型、对象、网格的关系" class="headerlink" title="1 模型、对象、网格的关系"></a>1 模型、对象、网格的关系</h3><p>在实现加载模型的功能之前，我们首先要了解模型由什么组成。一个模型（Model）包含多个对象（Object），每个对象拥有网格（Mesh）和材质（Material），网格存储了多边形的绘制信息，包括顶点位置、顶点法向、顶点纹理坐标，顶点索引；材质存储了光照和贴图信息，比如漫反射光颜色、镜面反射光颜色、镜面反射光泽度、纹理贴图信息等。所有这些数据都提供给 Shader 来使用，因此一个 Shader 需要绑定一个材质才能发挥作用。</p><h3 id="2-材质与对象类"><a href="#2-材质与对象类" class="headerlink" title="2 材质与对象类"></a>2 材质与对象类</h3><p>了解了这些关系后，我们开始实现相应的类。首先是材质类，最简单的材质包括漫反射颜色、镜面反射颜色、Glossy 扰动和一张主纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 材质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准光照材质包括</span></span><br><span class="line"><span class="comment">//漫反射颜色 镜面反射颜色 镜面反射强度</span></span><br><span class="line"><span class="comment">//纹理一张</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec4 Specular;</span><br><span class="line">    <span class="type">int</span> Gloss;</span><br><span class="line">    Texture* MainTex;</span><br><span class="line">    Shader* shader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Material</span>() :</span><br><span class="line">        <span class="built_in">Color</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Specular</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Gloss</span>(<span class="number">32</span>),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Material</span>(<span class="type">const</span> glm::vec4&amp; color, <span class="type">const</span> glm::vec4&amp; specular, <span class="type">const</span> <span class="type">int</span>&amp; gloss) :</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Gloss</span>(gloss),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Material</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetShader</span><span class="params">(Shader* s)</span> </span>&#123;</span><br><span class="line">        shader = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTexture</span><span class="params">(Texture* t)</span> </span>&#123;</span><br><span class="line">        MainTex = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后是 Object 类，一个 Object 包含一个 Mesh 和一个 Material：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Object类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    Material material;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Mesh&amp; m, <span class="type">const</span> Material&amp; mat) &#123;</span><br><span class="line">        mesh = m;</span><br><span class="line">        material = mat;</span><br><span class="line">    &#125;</span><br><span class="line">    Object&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3 模型类"></a>3 模型类</h3><p>最后是模型类，模型类需要能够加载 obj 模型并解析，之前在图形学中我们了解过 obj 文件的格式，这里再复习一遍。</p><p>一个典型的 obj 文件使用记事本打开可以看到如下格式，这里使用我们项目中用到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 3ds Max Wavefront OBJ Exporter v0.97b - (c)2007 guruware</span><br><span class="line"># File Created: 04.08.2011 15:18:00</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object01</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">v  -7.0063 72.8042 6.8872</span><br><span class="line">v  -6.9854 72.8711 8.2541</span><br><span class="line">v  -7.8984 74.1601 6.7762</span><br><span class="line">......</span><br><span class="line"># 65 vertices</span><br><span class="line"></span><br><span class="line">vn -0.8222 -0.5678 0.0404</span><br><span class="line">vn -0.7979 -0.5926 0.1101</span><br><span class="line">vn -0.8362 -0.5469 0.0396</span><br><span class="line">......</span><br><span class="line"># 70 vertex normals</span><br><span class="line"></span><br><span class="line">vt 0.4465 -0.7212 0.0000</span><br><span class="line">vt 0.4014 -0.7905 0.0000</span><br><span class="line">vt 0.4932 -0.8096 0.0000</span><br><span class="line">......</span><br><span class="line"># 36 texture coords</span><br><span class="line"></span><br><span class="line">g Object01</span><br><span class="line">s 1</span><br><span class="line">f 1/1/1 2/2/2 3/3/3 </span><br><span class="line">s 2</span><br><span class="line">f 3/3/4 2/2/2 4/4/5 </span><br><span class="line">s 3</span><br><span class="line">f 5/5/6 2/2/2 1/1/1 </span><br><span class="line">......</span><br><span class="line"># 0 polygons - 104 triangles</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object02</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>每一个 Object 下面都有 v、vn、vt 和 g、s、f 开头的数据，它们分别代表：</p><ul><li>v（vertex） ：后面记录了一个顶点坐标</li><li>vn（vertex normal）：后面记录了一个法线</li><li>vt（vertex texcood）：后面记录了一个纹理坐标</li><li>g（geometry）：代表下面将开始几何信息</li><li>s：后面跟图元编号</li><li>f（face）：后面后面记录了一个面的三个顶点所使用的顶点坐标、法线和纹理坐标（也可以是四个或者多个组成多边形）</li><li>5&#x2F;5&#x2F;6：表示该顶点使用第 5 个 v，第 5 个 vn，第 6 个 vt，这个索引是全局的</li></ul><p>于是我们可以实现模型 Model 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Model类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Object&gt; objects;</span><br><span class="line">    <span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> std::string&amp; path) &#123;</span><br><span class="line">        <span class="built_in">LoadObj</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Model&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;model == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMaterial</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; id, <span class="type">const</span> Material&amp; m)</span> </span>&#123;</span><br><span class="line">        objects[id].material = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadObj</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Open Obj File Error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;glm::vec3&gt; vertexs;</span><br><span class="line">        std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line">        std::vector&lt;glm::vec2&gt; texcoords;</span><br><span class="line"></span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> currentObjectNums = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">            <span class="comment">// 顶点数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    currentObjectNums++;</span><br><span class="line">                    Object o;</span><br><span class="line">                    objects.<span class="built_in">push_back</span>(o);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 v;</span><br><span class="line">                iss &gt;&gt; v.x;</span><br><span class="line">                iss &gt;&gt; v.y;</span><br><span class="line">                iss &gt;&gt; v.z;</span><br><span class="line">                vertexs.<span class="built_in">push_back</span>(v);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 法线数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vn &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vn;</span><br><span class="line">                iss &gt;&gt; vn.x;</span><br><span class="line">                iss &gt;&gt; vn.y;</span><br><span class="line">                iss &gt;&gt; vn.z;</span><br><span class="line">                normals.<span class="built_in">push_back</span>(vn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纹理坐标</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vt;</span><br><span class="line">                iss &gt;&gt; vt.x;</span><br><span class="line">                iss &gt;&gt; vt.y;</span><br><span class="line">                vt.y = <span class="number">1</span> - vt.y;</span><br><span class="line">                <span class="comment">// 纹理坐标z为0</span></span><br><span class="line">                iss &gt;&gt; vt.z;</span><br><span class="line">                texcoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>(vt.x, vt.y));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 图元数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                <span class="type">char</span> bar;</span><br><span class="line">                <span class="type">int</span> vIndex, vtIndex, vnIndex;</span><br><span class="line">                <span class="comment">//解析每个顶点数据 eg：1/1/1</span></span><br><span class="line">                <span class="type">int</span> offset = objects[currentObjectNums].mesh.VBO.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    iss &gt;&gt; vIndex &gt;&gt; bar &gt;&gt; vtIndex &gt;&gt; bar &gt;&gt; vnIndex;</span><br><span class="line">                    <span class="function">Vertex <span class="title">vertex</span><span class="params">(vertexs[vIndex - <span class="number">1</span>], glm::vec4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), texcoords[vtIndex - <span class="number">1</span>], normals[vnIndex - <span class="number">1</span>])</span></span>;</span><br><span class="line">                    objects[currentObjectNums].mesh.VBO.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">                    objects[currentObjectNums].mesh.EBO.<span class="built_in">push_back</span>(offset + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-绘制模型"><a href="#4-绘制模型" class="headerlink" title="4 绘制模型"></a>4 绘制模型</h3><p>接下来在我们原来的 <code>DarwMesh</code> 函数基础上，稍作修改实现绘制对象和绘制模型的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制一个模型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawModel</span><span class="params">(Model&amp; model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.objects.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">DrawObject</span>(model.objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawObject</span><span class="params">(Object&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentMat = &amp;obj.material;</span><br><span class="line">    currentMat-&gt;shader-&gt;texture = currentMat-&gt;MainTex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj.mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = obj.mesh.VBO[obj.mesh.EBO[i]];</span><br><span class="line">        p2 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>修改主函数，加载模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;Model.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用标准Shader</span></span><br><span class="line">    Shader shader;</span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    Material bodyMat;</span><br><span class="line">    bodyMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">bodyTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_body02.jpg&quot;</span>)</span></span>;</span><br><span class="line">    bodyMat.<span class="built_in">SetTexture</span>(&amp;bodyTexture);</span><br><span class="line"></span><br><span class="line">    Material faceMat;</span><br><span class="line">    faceMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">faceTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex002f_body01.jpg&quot;</span>)</span></span>;</span><br><span class="line">    faceMat.<span class="built_in">SetTexture</span>(&amp;faceTexture);</span><br><span class="line"></span><br><span class="line">    Material mouseMat;</span><br><span class="line">    mouseMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">mouseTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_mouse.jpg&quot;</span>)</span></span>;</span><br><span class="line">    mouseMat.<span class="built_in">SetTexture</span>(&amp;mouseTexture);</span><br><span class="line"></span><br><span class="line">    Material eyeMat;</span><br><span class="line">    eyeMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">eyeTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex001f_eye.jpg&quot;</span>)</span></span>;</span><br><span class="line">    eyeMat.<span class="built_in">SetTexture</span>(&amp;eyeTexture);</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">model</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\neptune.obj&quot;</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">0</span>, mouseMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">1</span>, faceMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">2</span>, bodyMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">3</span>, eyeMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建箱子</span></span><br><span class="line">    Mesh box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    Material mat;</span><br><span class="line">    mat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">boxt</span><span class="params">(TEXTURE_PATH)</span></span>;</span><br><span class="line">    mat.<span class="built_in">SetTexture</span>(&amp;boxt);</span><br><span class="line">    <span class="function">Object <span class="title">obj</span><span class="params">(box, mat)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line">    <span class="comment">// 改变渲染模式，默认为纹理填充，改变后为只绘制边框</span></span><br><span class="line">    <span class="comment">//dw-&gt;ChangeRenderMode();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    ViewMatrix = camera-&gt;<span class="built_in">ViewMatrix</span>();</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    ProjectMatrix = camera-&gt;<span class="built_in">PerspectiveMatrix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将箱子左移两单位</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 让箱子在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">0.0</span>;</span><br><span class="line">    ModelMatrix *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="comment">// 旋转后要更新法线</span></span><br><span class="line">    <span class="built_in">UpdateNormalMatrix</span>();</span><br><span class="line">    <span class="comment">// 绘制箱子</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawObject</span>(obj);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 因为模型太大，需要缩小100倍</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/Model1.png" alt="Model1"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（六）剔除与裁剪</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/</id>
    <published>2022-05-24T03:16:46.000Z</published>
    <updated>2022-05-24T03:30:36.765Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。</p><p><em><span id="more"></span></em></p><h3 id="1-剔除和裁剪概览"><a href="#1-剔除和裁剪概览" class="headerlink" title="1 剔除和裁剪概览"></a>1 剔除和裁剪概览</h3><p>在整个渲染管线中，需要进行多次剔除与裁剪，分别是：视锥剔除、正面&#x2F;背面剔除、齐次裁剪。</p><ul><li>视锥剔除一般发生在 CPU 阶段，通过 AABB、OBB 等将物体包围起来，然后与视锥体做碰撞检测，可以直接剔除掉完全不可见的物体，运算量较低但精度也较低。</li><li>正面&#x2F;背面剔除在顶点着色器之后，齐次裁剪之前进行，将不需要渲染的图元直接剔除掉；一般来说这一步也可以在齐次裁剪之后进行，因为操作比较简单，所以可以在世界空间运算也可以在 NDC 中运算，取决于管线的设计。</li><li>齐次裁剪自然是在裁剪空间中进行，即顶点着色器之后，透视除法之前。在透视除法之前是因为如果有物体在摄像机的位置，会出现 w &#x3D; 0 ，做透视除法的时候会出现除零错误。这一阶段是将在视口外的图元丢弃，一部分在视口内的图元，会进行裁剪，生成新的多边形。当然做裁剪的性能消耗也不小，很多情况下裁剪之后并不比直接把原来的多边形画出来丢弃一部分更快，尤其是 GPU 并不适合做这种判断条件比较多的工作。现代 GPU 通常是用一个比视口大很多（10倍以上？）的虚拟视口来裁剪，那种超出一点点的，就直接画了吧，GPU 性能没那么捉襟见肘。</li></ul><h3 id="2-视锥剔除"><a href="#2-视锥剔除" class="headerlink" title="2 视锥剔除"></a>2 视锥剔除</h3><p>视锥剔除首先要计算物体的包围盒，一般来说如果场景管理使用 BVH 的话，层次包围盒已经计算好了，直接遍历整个 BVH 树即可。然后获得视锥体的六个面的方程，用包围盒和六个面进行碰撞检测，具体实现可以有很多种方法，这里我们实现世界空间下的视锥剔除，流程如下：</p><ul><li>计算包围要绘制物体的 AABB（世界空间），实际我们逐图元计算，剔除掉完全在视锥体外的图元，这样一来就和后面的齐次裁剪中的剔除所做的工作几乎一样了，但这里只是为了学习原理，实际的渲染管线中是利用 BVH 等来剔除掉完全不在视锥体内的物体，而图元是在齐次裁剪的时候剔除的</li><li>获得视锥体六个面的平面方程（世界空间）</li><li>判断 AABB 的顶点在六个面的内侧还是外侧，也可以判断最小点和最大点，实现方法不唯一</li><li>剔除掉所有顶点完全在某一面外侧的物体，我们这里是图元</li></ul><h4 id="2-1-获取视锥平面方程"><a href="#2-1-获取视锥平面方程" class="headerlink" title="2.1 获取视锥平面方程"></a>2.1 获取视锥平面方程</h4><p>那么如何获取视锥体六个平面的方程呢？通过 MVP 变换矩阵就可以直接得出，并且使用 MVP 三个矩阵的不同组合可以得出不同空间下的视锥体平面方程。具体推导的原文可以查看：<a href="http://www8.cs.umu.se/kurser/5DV180/VT18/lab/plane_extraction.pdf">Fast Extraction of Viewing Frustum Planes from the WorldView-Projection Matrix</a></p><p>我们首先定义一个顶点 $v &#x3D; (x, y, z, w&#x3D;1)$，以及一个 4 * 4 的矩阵 $$M &#x3D; m_{ij}$$，这个矩阵可以是投影矩阵 P，也可以是 VP，还可以是 MVP，总之经过矩阵 $M$ 后，顶点 $v$ 就被转换到了一个规范立方体中变为 $v’ &#x3D; (x’, y’, z’, w’)$，这个过程可以写为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523110857514.png" alt="image-20220523110857514"></p><p>规范立方体的范围是 [-w’, w’]，因此如果这个顶点在立方体内，那么必须满足：</p><ul><li>-w’ &lt; x’ &lt; w’</li><li>-w’ &lt; y’ &lt; w’</li><li>-w’ &lt; z’ &lt; w’</li></ul><p>这实际上描述了顶点和视锥体六个平面的关系，原文中以下表列出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111017102.png" alt="image-20220523111017102"></p><p>现在以顶点和左侧平面的关系为例，只需要判断 -w’ &lt; x’ 就可以了，根据矩阵乘法，可以得出：<br>$$<br>-w’ &lt; x’ \Rightarrow -(row4 · v) &lt; (row1 · v)<br>$$<br>于是可以进一步得到：<br>$$<br>(row1 + row4) · v &gt; 0<br>$$<br>将矩阵元素带入展开可以写成：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44})*w &gt; 0<br>$$<br>由于 $w &#x3D; 1$，因此可以写为：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44}) &gt; 0<br>$$<br>这实际上已经得到了视锥体左平面的方程，因为空间中一个平面可以表示为 $$Ax + By + Cz + D &#x3D; 0$$，所以视锥体左平面的方程中：<br>$$<br>A &#x3D; m_{11}+m_{41},\ B &#x3D; m_{12}+m_{42},\ C &#x3D; m_{13}+m_{43},\ D &#x3D; m_{14}+m_{44}<br>$$<br>类似的可以得出其他几个面的方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111837599.png" alt="image-20220523111837599"></p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111857255.png" alt="image-20220523111857255"></p><p>上面说过， 4 * 4 的矩阵 $$M$$ 可以是投影矩阵 P，也可以是 VP，还可以是 MVP，不同的组合得到的视锥体平面方程是不同空间下的：</p><ul><li>当矩阵是 P 时，得到的是观察空间下的平面</li><li>当矩阵是 VP 时，得到的是世界空间下的平面</li><li>当矩阵是 MVP 时，得到的是模型空间下的平面</li></ul><h4 id="2-2-判断顶点与平面的关系"><a href="#2-2-判断顶点与平面的关系" class="headerlink" title="2.2 判断顶点与平面的关系"></a>2.2 判断顶点与平面的关系</h4><p>顶点与平面的关系判断非常简单，类似于二维中点和直线的关系，将顶点坐标 $(x, y, z)$ 带入平面方程计算得到点到平面的距离 $$d &#x3D; Ax + By + Cz + D$$：</p><ul><li>d &gt; 0 时，点在平面法向所指的区域</li><li>d &lt; 0 时，点在平面法向反方向所指的区域</li><li>d &#x3D; 0 时，点在平面上</li></ul><h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>我们使用世界空间下的视锥体剔除，首先在 <code>math.h</code> 中加入视锥体六个平面的方程以及点和平面的关系判断函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视锥体的六个平面方程（世界空间下，传入的是 VP 矩阵），用于视锥剔除</span></span><br><span class="line"><span class="comment">// 所得的平面法向都是指向视锥体内部的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewingFrustumPlanes</span><span class="params">(std::vector&lt;glm::vec4&gt;&amp; result, <span class="type">const</span> glm::mat4&amp; vp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左侧  </span></span><br><span class="line">    result[<span class="number">0</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//右侧</span></span><br><span class="line">    result[<span class="number">1</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//上侧</span></span><br><span class="line">    result[<span class="number">2</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//下侧</span></span><br><span class="line">    result[<span class="number">3</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Near</span></span><br><span class="line">    result[<span class="number">4</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//Far</span></span><br><span class="line">    result[<span class="number">5</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点到平面距离 d =  Ax + By + Cz + D;</span></span><br><span class="line"><span class="comment">// d &lt; 0 点在平面法向反方向所指的区域</span></span><br><span class="line"><span class="comment">// d &gt; 0 点在平面法向所指的区域</span></span><br><span class="line"><span class="comment">// d = 0 在平面上</span></span><br><span class="line"><span class="comment">// d &lt; 0 返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point2Plane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    <span class="keyword">return</span> sb &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于管理，我们新建一个 <code>Cull.h</code> 来管理各类剔除函数，目前只有视锥体剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//世界空间的视锥剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFrustumCull</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::vec4&gt; ViewPlanes, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果三个顶点都在某一个平面外侧，则剔除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">3</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">4</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 远平面只保留完全在内的图元，部分在内的直接丢掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">5</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入视锥体剔除，一般来说应该在 CPU 阶段进行，但是我们为了方便将视锥体剔除放在顶点着色器之后，因为顶点着色器之后才知道世界空间下的坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line">    <span class="comment">// 视锥体剔除用到的视锥体平面</span></span><br><span class="line">    std::vector&lt;glm::vec4&gt; ViewPlanes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除开关</span></span><br><span class="line">    <span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Draw</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        shader = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取视锥体六个平面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateViewPlanes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ViewingFrustumPlanes</span>(ViewPlanes, ProjectMatrix * ViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            Vertex p1, p2, p3;</span><br><span class="line">            p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">            p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">            p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">            <span class="comment">//顶点着色器变换到裁剪空间</span></span><br><span class="line">            V2F v1, v2, v3;</span><br><span class="line">            v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">            v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">            v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视锥体剔除</span></span><br><span class="line">            <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">            <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">            v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">            v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-正面-x2F-背面剔除"><a href="#3-正面-x2F-背面剔除" class="headerlink" title="3 正面&#x2F;背面剔除"></a>3 正面&#x2F;背面剔除</h3><p>经过视锥体剔除将所有完全不在视锥体内的图元剔除掉之后，剩下的图元要么完全在视锥体内，要么部分在视锥体内，对于部分在视锥体内的图元需要进行裁剪，但因为裁剪是计算量较大的操作，为了进一步减少无用的运算，在此之前还要根据需要将背面（有时也需要将正面的剔除）的图元剔除掉，这一步操作比较简单，我们在世界空间计算。根据观察方向和图元的法线方向的夹角来判断图元是正对我们还是背对我们，原理在之前的 RTR 总结中有介绍，这里不再赘述。</p><p>也可以先做齐次裁剪，透视除法之后在 NDC 中进行正面&#x2F;背面剔除，但要注意 NDC 是左手系，观察方向恒定为 (0, 0, 1)。无论在哪里计算，原理都是一样的。</p><p>在 <code>Cull.h</code> 中加入正面&#x2F;背面剔除函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正面/背面</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Face</span> &#123;</span><br><span class="line">    Back,</span><br><span class="line">    Front</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界空间的面剔除，剔除正向面或者逆向面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFaceCull</span><span class="params">(Face face, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叉乘得到法向量</span></span><br><span class="line">    glm::vec3 tmp1 = glm::<span class="built_in">vec3</span>(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);</span><br><span class="line">    glm::vec3 tmp2 = glm::<span class="built_in">vec3</span>(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);</span><br><span class="line">    glm::vec3 normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(tmp1, tmp2));</span><br><span class="line">    <span class="comment">// 世界空间下的观察方向</span></span><br><span class="line">    glm::vec3 view = camera-&gt;Front;</span><br><span class="line">    <span class="comment">// 也可以在NDC中剔除，这时观察方向恒定为(0, 0, 1)，但上面的叉乘顺序顺序要颠倒一下，因为NDC是左手系</span></span><br><span class="line">    <span class="comment">//glm::vec3 view = glm::vec3(0, 0, 1);</span></span><br><span class="line">    <span class="keyword">if</span> (face == Back)</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在渲染流程中加入正面&#x2F;背面剔除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 剔除开关</span></span><br><span class="line"><span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="type">bool</span> FaceCull;</span><br><span class="line">Face CullMode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisableFaceCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableFaceCull</span><span class="params">(Face f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">true</span>;</span><br><span class="line">    CullMode = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldSpaceCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 光栅化</span></span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-齐次裁剪"><a href="#4-齐次裁剪" class="headerlink" title="4 齐次裁剪"></a>4 齐次裁剪</h3><p>最后是比较麻烦的齐次裁剪，之前说过，渲染管线中进行齐次裁剪的位置是<strong>投影之后，透视除法之前</strong>，我们知道，在世界空间和观察空间中，一个点的坐标是 (X, Y, Z, 1)，经过透视投影之后变为 (X’, Y’, Z’, -Z)，再除以 W 坐标变化到 NDC 中 (X’&#x2F;-Z, Y’&#x2F;-Z, Z’&#x2F;-Z, 1)。这其中，如果一个点在观察者的身后，其观察坐标 Z 会大于 0（观察空间是右手系），那么透视投影之后 W 会小于 0，进行透视除法会导致顶点的 X, Y 坐标上下左右翻转。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523175755959.png" alt="image-20220523175755959"></p><p>并且如果一个物体在相机平面上，会在透视除法时导致除零错误。</p><p>透视投影之后，透视除法之前的坐标空间被称为裁剪空间，也叫齐次（裁剪）空间，它实质上是一个四维空间，变换到齐次空间的顶点之间仍然是线性相关的（可以直接使用线性插值而不是透视插值）。这是因为透视除法将所有坐标除以 w 才会真正破坏顶点之间的线性关系，所以也有这种说法：<strong>真正的投影是通过透视除法完成的</strong>。</p><p>这时，在视锥体中的点一定满足如下条件：</p><ul><li>$-w &lt; x,y,z &lt; w$</li><li>$near&lt;w&lt;far$</li></ul><p>如果不满足这个条件的点，就需要被剔除，因此我们可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 裁剪空间剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClipSpaceCull</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三个点的w都在near或far之外则需要剔除</span></span><br><span class="line">    <span class="keyword">if</span> (v1.w &lt;= camera-&gt;Near &amp;&amp; v2.w &lt;= camera-&gt;Near &amp;&amp; v3.w &lt;= camera-&gt;Near)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.w &gt;= camera-&gt;Far &amp;&amp; v2.w &lt;= camera-&gt;Far &amp;&amp; v3.w &lt;= camera-&gt;Far)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 任意一个点在规范立方体内则不需要剔除，等待进行下一步裁剪</span></span><br><span class="line">    <span class="keyword">if</span> (v1.x &lt;= v1.w || v1.y &lt;= v1.w || v1.z &lt;= v1.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2.x &lt;= v2.w || v2.y &lt;= v2.w || v2.z &lt;= v2.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v3.x &lt;= v3.w || v3.y &lt;= v3.w || v3.z &lt;= v3.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对没有被剔除的片元进行裁剪，使用 <strong>Sutherland-Hodgeman 裁剪算法</strong>，也叫做逐边裁剪算法，它的原理很简单，在二维中就是每次使用裁剪框的一条边去裁剪多边形的每一条边，生成新的顶点并作为下一条裁剪边的输入，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220524094004535.png" alt="image-20220524094004535"></p><p>这个算法在齐次空间也同样适用（而且可以推广到任意维），与二维的区别是，裁剪平面变为了 6 个，而不是四条线了。</p><p>使用点到平面的距离来判断点在平面的内外，和之前的计算方法类似，之前的计算方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool Point2Plane(const glm::vec3&amp; v, const glm::vec4&amp; p) &#123;</span><br><span class="line"></span><br><span class="line">    float sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    return sb &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只适用于世界空间或者观察空间等 w 为 1 的空间中，而我们现在是在裁剪空间，顶点的 w 值不为 1， 因此不能省略顶点的 w，所以需要重新写一个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在裁剪平面法线所指方向，即内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inside</span><span class="params">(<span class="type">const</span> glm::vec4&amp; line, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line.x * p.x + line.y * p.y + line.z * p.z + line.w * p.w &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还需要一个函数直接判断三个顶点是否都在视口内，这样就无需裁剪了，也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有顶点都在内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AllVertexsInside</span><span class="params">(<span class="type">const</span> std::vector&lt;V2F&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.x) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.y) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.z) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是计算两个点连线与平面的交点，这可以通过插值实现，分别在一个平面两侧的两个点 A 和 B，它们连线与平面的交点 C 可以通过权重 da &#x2F; (da - db) 从 A 到 B 插值得到。其中 da 和 db 分别是点 A 和 B 到裁剪平面的距离，可以通过上面函数的方法计算得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交点，通过端点插值得到</span></span><br><span class="line"><span class="function">V2F <span class="title">Intersect</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> glm::vec4&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> da = v1.windowPos.x * line.x + v1.windowPos.y * line.y + v1.windowPos.z * line.z + v1.windowPos.w * line.w;</span><br><span class="line">    <span class="type">float</span> db = v2.windowPos.x * line.x + v2.windowPos.y * line.y + v2.windowPos.z * line.z + v2.windowPos.w * line.w;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> weight = da / (da - db);</span><br><span class="line">    <span class="keyword">return</span> V2F::<span class="built_in">lerp</span>(v1, v2, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 Sutherland-Hodgeman 裁剪算法，代码很好理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SutherlandHodgeman裁剪算法</span></span><br><span class="line"><span class="comment">// 输入三个顶点，输出裁剪后的顶点组</span></span><br><span class="line"><span class="function">std::vector&lt;V2F&gt; <span class="title">SutherlandHodgeman</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;V2F&gt; output = &#123; v1,v2,v3 &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AllVertexsInside</span>(output)) &#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ViewLines.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;V2F&gt; <span class="title">input</span><span class="params">(output)</span></span>;</span><br><span class="line">        output.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            V2F current = input[j];</span><br><span class="line">            V2F last = input[(j + input.<span class="built_in">size</span>() - <span class="number">1</span>) % input.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], current.windowPos)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                    V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                    output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">                &#125;</span><br><span class="line">                output.<span class="built_in">push_back</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在渲染流程中加入裁剪，因为裁剪后生成了新的顶点，所以要做比较多的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了能更方便看出裁剪效果，我们加入了渲染模式选项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RenderMode</span> &#123;</span><br><span class="line">    Line,    <span class="comment">// 仅绘制边框</span></span><br><span class="line">    Fill    <span class="comment">// 绘制图形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变渲染模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChangeRenderMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (renderMode == Fill)</span><br><span class="line">        renderMode = Line;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        renderMode = Fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新增一个画线算法，使用 BresenhamLine 画线算法，原理比较简单，具体可以查看<a href="https://blog.csdn.net/yzh1994414/article/details/82860187">Bresenham 算法原理</a>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ****************** BresenhamLine画线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">const</span> V2F&amp; from, <span class="type">const</span> V2F&amp; to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = to.windowPos.x - from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> dy = to.windowPos.y - from.windowPos.y;</span><br><span class="line">    <span class="type">int</span> Xstep = <span class="number">1</span>, Ystep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Xstep = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Ystep = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> currentX = from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> currentY = from.windowPos.y;</span><br><span class="line">    V2F tmp;</span><br><span class="line">    <span class="comment">//斜率小于1</span></span><br><span class="line">    <span class="keyword">if</span> (dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dy - dx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dx));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentX += Xstep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentY += Ystep;</span><br><span class="line">                P += <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//斜率大于1，利用对称性画</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dx - dy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dy; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dy));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentY += Ystep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dx;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentX += Xstep;</span><br><span class="line">                P -= <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>现在来测试一下上面实现的裁剪吧，因为可以只渲染边框，可以清楚的看到每个面的渲染情况。</p><p>我们首先关闭背面剔除，得到的结果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/NonCull.png" alt="NonCull"></p><p>然后开启背面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/BackCull.png" alt="BackCull"></p><p>试试开启正面剔除：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/FrontCull.png" alt="FrontCull"></p><p>接下来将正方体移动到屏幕边缘，测试裁剪效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/Clip.png" alt="Clip"></p><p>可以看到裁剪产生的新的图元。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（五）相机</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-05-23T08:19:01.000Z</published>
    <updated>2022-05-23T08:20:35.725Z</updated>
    
    <content type="html"><![CDATA[<p>上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。</p><p><em><span id="more"></span></em></p><p>MVP 矩阵中， M 矩阵负责改变模型在世界空间的位置和姿态，V 矩阵需要相机位置和相机的三个向量（up、right、front）来确定，P 矩阵跟视场大小、宽高比和远近平面位置有关。因此相机类主要负责管理确定 V 和 P 矩阵的参数。</p><p>这里相机类的实现可以参考之前光线追踪器中的相机类，只需要给定相机的位置、lookat 位置和在世界空间的 up 方向就可以确定相机的三个向量 up、right 和 front；对于相机旋转，我们使用欧拉角，由于大部分第一人称游戏也不支持滚转角旋转，因此我们也只实现俯仰角和偏航角，具体计算方法也很简单，以（0, 0, -1）为默认观察方向：</p><ul><li>对于每一个 front 向量，将其投影到 XOZ  平面（即把 y 置 0 再单位化）</li><li>front 向量和投影向量的夹角即为俯仰角，需要注意俯仰角不能超过 90 度否则整个视野会倒过来</li><li>投影向量与（0, 0, -1）的夹角为偏航角</li></ul><p>由此我们可以写出相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line">    <span class="comment">// 视场和宽高比</span></span><br><span class="line">    <span class="type">float</span> Fov;</span><br><span class="line">    <span class="type">float</span> Aspect;</span><br><span class="line">    <span class="comment">// 远近平面距离</span></span><br><span class="line">    <span class="type">float</span> Near;</span><br><span class="line">    <span class="type">float</span> Far;</span><br><span class="line">    <span class="comment">// 俯仰和偏航角</span></span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(</span><br><span class="line">        glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">        glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3 lookat = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        <span class="type">float</span> fov = <span class="number">60.0f</span>,</span><br><span class="line">        <span class="type">int</span> w = <span class="number">800</span>,</span><br><span class="line">        <span class="type">int</span> h = <span class="number">600</span>,</span><br><span class="line">        <span class="type">float</span> n = <span class="number">0.3f</span>,</span><br><span class="line">        <span class="type">float</span> f = <span class="number">100</span></span><br><span class="line">    ) :</span><br><span class="line">        <span class="built_in">Position</span>(position), <span class="built_in">WorldUp</span>(up), <span class="built_in">Fov</span>(glm::<span class="built_in">radians</span>(fov)), <span class="built_in">Aspect</span>((<span class="type">float</span>)w / h), <span class="built_in">Pitch</span>(<span class="number">0</span>), <span class="built_in">Yaw</span>(<span class="number">0</span>), <span class="built_in">Near</span>(n), <span class="built_in">Far</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(lookat - Position);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Front 向量计算欧拉角</span></span><br><span class="line">        <span class="function">glm::vec3 <span class="title">WorldFront</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        glm::vec3 FrontXZ = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(Front.x, <span class="number">0</span>, Front.z));</span><br><span class="line">        <span class="type">float</span> yd = glm::<span class="built_in">dot</span>(WorldFront, FrontXZ);</span><br><span class="line">        <span class="type">float</span> pd = glm::<span class="built_in">dot</span>(Front, FrontXZ);</span><br><span class="line">        <span class="keyword">if</span> (yd &gt; <span class="number">1.0</span>)</span><br><span class="line">            yd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (yd &lt; <span class="number">-1</span>)</span><br><span class="line">            yd = <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &gt; <span class="number">1.0</span>)</span><br><span class="line">            pd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &lt; <span class="number">-1</span>)</span><br><span class="line">            pd = <span class="number">-1.0</span>;</span><br><span class="line">        Yaw = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(yd));</span><br><span class="line">        Pitch = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(pd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">ViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetViewMatrix</span>(Position, Front, Right, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">PerspectiveMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPerspectiveMatrix</span>(Fov, Aspect, Near, Far);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateFov</span><span class="params">(<span class="type">float</span> fov = <span class="number">60.0f</span>)</span> </span>&#123;</span><br><span class="line">        Fov = glm::<span class="built_in">radians</span>(fov);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateAspect</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        Aspect = (<span class="type">float</span>)w / h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改俯仰角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotatePitch</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Pitch += angle;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0</span>)</span><br><span class="line">            Pitch = <span class="number">89.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0</span>)</span><br><span class="line">            Pitch = <span class="number">-89.0</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更改偏航角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateYaw</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Yaw += angle;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &gt; <span class="number">360</span>)</span><br><span class="line">            Yaw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &lt; <span class="number">0</span>)</span><br><span class="line">            Yaw = <span class="number">360</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 更新相机三个向量，根据俯仰角和偏航角计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = -<span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = -<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>相机应该作为全局变量，以便于之后的裁剪等算法获取相机相关的参数，因此我们在 <code>Global.h</code> 中加入全局变量的定义，将渲染管线以及之后要实现的材质等也设置为全局对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">Camera* camera;</span><br><span class="line">Draw* dw;</span><br><span class="line">Material* currentMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;camera.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setViewMatrix</span>(camera-&gt;<span class="built_in">ViewMatrix</span>());</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setProjectMatrix</span>(camera-&gt;<span class="built_in">PerspectiveMatrix</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw-&gt;<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制，渲染管线流程</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到和之前一样的结果说明正确：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/camera.png" alt="camera"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（四）纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/</id>
    <published>2022-05-22T10:21:49.000Z</published>
    <updated>2022-05-23T08:20:42.365Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。</p><p><em><span id="more"></span></em></p><h3 id="1-OpenGL-中的纹理"><a href="#1-OpenGL-中的纹理" class="headerlink" title="1 OpenGL 中的纹理"></a>1 OpenGL 中的纹理</h3><p>首先来看 OpenGL 中如何使用纹理有关的操作，可以参考官方教程：[纹理 - LearnOpenGL CN](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;06 Textures&#x2F;)</p><h3 id="2-实现纹理类"><a href="#2-实现纹理类" class="headerlink" title="2 实现纹理类"></a>2 实现纹理类</h3><p>然后我们自己手动实现一个简单的纹理类，纹理环绕方式使用 GL_REPEAT 的方式，即超过 1.0 的纹理坐标就直接重复，纹理过滤的方式采用最近邻方式，加载图片还是使用简单强大的 stbi 库，纹理类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 图片纹理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> channels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>() : <span class="built_in">width</span>(<span class="number">-1</span>), <span class="built_in">height</span>(<span class="number">-1</span>), <span class="built_in">channels</span>(<span class="number">-1</span>), <span class="built_in">data</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; Path) &#123;</span><br><span class="line">        <span class="built_in">LoadTexture</span>(Path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; Path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">        data = <span class="built_in">stbi_load</span>(Path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理采样，使用重复寻址方式,等同于OpenGL的GL_REPEAT</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">Sample2D</span><span class="params">(<span class="type">const</span> glm::vec2&amp; texcoord)</span> </span>&#123;</span><br><span class="line"><span class="type">float</span> x = texcoord.x - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.x);</span><br><span class="line"><span class="type">float</span> y = texcoord.y - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.y);</span><br><span class="line">x = x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetColor</span>(x * (width - <span class="number">1</span>), y * (height - <span class="number">1</span>)) / <span class="number">255.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取颜色，对不同通道纹理图片分别处理，以便于加载法线、高度纹理等</span></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width || y &lt; <span class="number">0</span> || y &gt;= height)</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">switch</span> (channels) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor1</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor2</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor3</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor4</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = y * width + x;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">2</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">3</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">4</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), *(data + xy + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改 Shader 类，加入纹理成员，并修改片元着色器，将颜色改为纹理采样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        texture = <span class="keyword">new</span> <span class="built_in">Texture</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 ModelMatrix;</span><br><span class="line">    glm::mat4 ViewMatrix;</span><br><span class="line">    glm::mat4 ProjectMatrix;</span><br><span class="line">    Texture* texture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">        V2F o;</span><br><span class="line">        <span class="comment">// 变换到世界空间</span></span><br><span class="line">        o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line">        <span class="comment">// 变换到裁剪空间</span></span><br><span class="line">        o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line">        <span class="comment">// 法线变换</span></span><br><span class="line">        o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">        o.texcoord = a2v.texcoord;</span><br><span class="line">        o.color = a2v.color;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (texture-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec4 color = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord);</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">        ModelMatrix = model;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">        ViewMatrix = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">        ProjectMatrix = project;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTexture</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        texture-&gt;<span class="built_in">LoadTexture</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后在 Draw 类中加入纹理图片路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">        FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">        shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">        shader-&gt;<span class="built_in">setTexture</span>(TexturePath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;texture_box2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(0,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box.png" alt="texture_box"></p><h3 id="3-透视纹理映射"><a href="#3-透视纹理映射" class="headerlink" title="3 透视纹理映射"></a>3 透视纹理映射</h3><p>可以看出当立方体的面不正对我们的时候，纹理出现了变形。这是因为我们对顶点插值时使用的插值参数是通过顶点间的 x, y 坐标求出的，但是透视投影之后纹理坐标并不跟投影点 x , y 坐标线性相关。这种直接插值纹理坐标的方式被称为<strong>仿射映射</strong>，解决办法是做<strong>透视映射</strong>，具体可以查看<a href="https://blog.csdn.net/popy007/article/details/5570803">深入探索透视纹理映射</a>这篇文章。</p><p>总之实际的做法就是在透视除法时，将除了屏幕坐标之外的所有值都除以 w 值，然后再进行插值，这样就可以得到正确的纹理映射关系，最后在扫描线函数中，调用片元着色器之前再乘以 w 恢复即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录下原本的 w</span></span><br><span class="line">    v.w = v.windowPos.w;</span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他属性也要除以 w，以便于正确插值，之后在片元着色器之前再乘以原本的 w 恢复</span></span><br><span class="line">    v.worldPos /= v.w;</span><br><span class="line">    v.normal /= v.w;</span><br><span class="line">    v.texcoord /= v.w;</span><br><span class="line">    v.color /= v.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            v.worldPos *= v.w;</span><br><span class="line">            v.normal *= v.w;</span><br><span class="line">            v.texcoord *= v.w;</span><br><span class="line">            v.color *= v.w;</span><br><span class="line"></span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box2.png" alt="texture_box2"></p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box3.png" alt="texture_box3"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（三）变换与深度测试</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-21T10:28:14.000Z</published>
    <updated>2022-05-23T08:21:00.151Z</updated>
    
    <content type="html"><![CDATA[<p>上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。</p><p><em><span id="more"></span></em></p><h3 id="1-Mesh-类"><a href="#1-Mesh-类" class="headerlink" title="1 Mesh 类"></a>1 Mesh 类</h3><p>网格（Mesh）是用于保存三维模型的数据结构，通常来说一个网格包含一系列顶点数据和索引，用它们就能绘制出一系列多边形。同时网格还包含该模型所使用的材质信息（贴图、光照等）。上一章中我们是直接用顶点来画图形的，相当于手动创建了一个 Mesh，但是当模型比较复杂的时候，就需要一个类来管理模型的 Mesh，于是我们创建一个 Mesh 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 网格类，基础单位是三角形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; VBO;        <span class="comment">// 存放顶点数据</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; EBO;    <span class="comment">// 存放顶点索引顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> <span class="type">int</span>&amp; vNum, <span class="type">const</span> <span class="type">int</span>&amp; iNum) &#123;</span><br><span class="line">        VBO.<span class="built_in">resize</span>(vNum);</span><br><span class="line">        EBO.<span class="built_in">resize</span>(iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">        :<span class="built_in">VBO</span>(mesh.VBO), <span class="built_in">EBO</span>(mesh.EBO) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        VBO = mesh.VBO;</span><br><span class="line">        EBO = mesh.EBO;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddMesh</span>(mesh);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向网格中加入其它网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> offset = VBO.<span class="built_in">size</span>();</span><br><span class="line">        VBO.<span class="built_in">insert</span>(VBO.<span class="built_in">end</span>(), mesh.VBO.<span class="built_in">begin</span>(), mesh.VBO.<span class="built_in">end</span>());</span><br><span class="line">        EBO.<span class="built_in">reserve</span>(EBO.<span class="built_in">size</span>() + mesh.EBO.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            EBO.<span class="built_in">push_back</span>(mesh.EBO[i] + offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向网格中添加一一个三角形片面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v1);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v2);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v3);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后我们就可以在 Draw 类中将之前画三角形的函数 <code>DrawTriangle</code> 改为更一般的画网格的函数 <code>DrawMesh</code> 了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">// 顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><p>接下来是重头戏，三维变换。虽然对三维坐标变换已经有过深入的理论学习，但是在实践之前还是有必要再复习一次，把理论和实际结合起来。之前的笔记参考<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>。</p><p>首先梳理一下整个从三维模型到屏幕上的图像变换过程：</p><ul><li>模型定点定义在模型空间，需要将所有模型的顶点转换到世界空间</li><li>世界空间中有各种模型和观察整个场景的相机，因此要将世界空间变换到相机空间，也称观察空间</li><li>观察空间中的顶点位置还是三维坐标，因此要进行投影变换将所有物体顶点变换到裁剪空间，得到二维位置以及深度</li><li>裁剪空间经过透视除法变换到标准设备坐标系</li><li>标准设备坐标系最后经过视口变换到屏幕空间中</li></ul><p>于是首先是世界空间到观察空间的变换，也就是将世界空间原点移动到相机位置，然后将世界空间的三个坐标轴和相机的 right、up、front 三个方向对齐。平移矩阵很好写出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165556253.png" alt="image-20220521165556253"></p><p>坐标轴对齐也很简单，要将 A 空间的坐标轴和 B 空间的坐标轴对齐，只需要将 A 空间下 B 空间的坐标轴按行排列即可，因此只要将世界坐标系下的相机的三个方向按行排列，就是从世界空间到相机空间的变换矩阵：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165545686.png" alt="image-20220521165545686"></p><p>于是整个视角变换矩阵即为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165714434.png" alt="image-20220521165714434"></p><p>我们在 <code>math.h</code> 中加入视角变换矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视角变换矩阵，也称观察矩阵</span></span><br><span class="line"><span class="comment">// V = R*T</span></span><br><span class="line"><span class="comment">// T = [  1 , 0 , 0 , -eyex          R = [  Right , 0 </span></span><br><span class="line"><span class="comment">//        0 , 1 , 0 , -eyey                   UP  , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 1 , -eyez               - Front , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 0 ,   1   ]                 0   , 1 ]</span></span><br><span class="line"><span class="comment">//V =  [  Right  ,  - Right·eye</span></span><br><span class="line"><span class="comment">//          UP   ,  - UP·eye</span></span><br><span class="line"><span class="comment">//       -Front  ,   Front·eye</span></span><br><span class="line"><span class="comment">//         0     ,       1        ]</span></span><br><span class="line"><span class="comment">// OpenGL中观察空间是右手系，+z 轴指向屏幕外，为了让朝向保持不变，对Front向量取反</span></span><br><span class="line"></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">(glm::vec3 pos, glm::vec3 front, glm::vec3 right, glm::vec3 up)</span> </span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = right.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">0</span>] = right.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">0</span>] = right.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">0</span>] = -glm::<span class="built_in">dot</span>(right, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">1</span>] = up.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = up.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">1</span>] = up.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">1</span>] = -glm::<span class="built_in">dot</span>(up, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">2</span>] = -front.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">2</span>] = -front.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -front.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = glm::<span class="built_in">dot</span>(front, pos);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是透视投影矩阵，之前的笔记有详细推导，这里就不再赘述了，顺便再附上两篇透视投影的详细推导和理解的文章：</p><ul><li><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">OpenGL投影矩阵(Projection Matrix)构造方法</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影</a></li></ul><p>这里我们使用的透视投影矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172401734.png" alt="image-20220521172401734"></p><p>其中 r &#x3D; -l, t &#x3D; -b，因此投影矩阵最终为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172445502.png" alt="image-20220521172445502"></p><p>其中，r 是屏幕半宽，t 是屏幕半高，f 是远平面距离，n 是近平面距离。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视投影 参数 fov(弧度) aspect near far</span></span><br><span class="line"><span class="comment">//M = [   1/aspect*tan(fov/2),       0      ,         0      ,       0</span></span><br><span class="line"><span class="comment">//               0  ,         1/tan(fov/2)  ,         0      ,       0 </span></span><br><span class="line"><span class="comment">//               0  ,                0      ,  - (f+n)/(f-n) ,  -2fn/(f-n)</span></span><br><span class="line"><span class="comment">//               0  ,                0      ,         -1     ,       0     ]</span></span><br><span class="line"><span class="comment">// 投影之后从右手系变成了左手系，+Z指向屏幕内</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; fovy, <span class="type">const</span> <span class="type">float</span>&amp; aspect, <span class="type">const</span> <span class="type">float</span>&amp; n, <span class="type">const</span> <span class="type">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> tanHalfFov = <span class="built_in">tan</span>(fovy * <span class="number">0.5f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span> / (aspect * tanHalfFov);</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span> / (tanHalfFov);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -(f + n) / (f - n);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-1.0f</span>;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = (<span class="number">-2.0f</span> * n * f) / (f - n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过透视投影后，所有坐标都在 [-w, w] 之间，还需要经过透视除法将其变换到 NDC：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 透视除法在顶点着色器变换到裁剪空间之后，视口变换之前进行，因此修改画网格的函数，加入透视除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">//顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3 构建模型"></a>3 构建模型</h3><p>到此为止我们已经可以渲染一个三维物体了，我们使用 Mesh 构建一个立方体。一个立方体由 6 个面组成，每个面又可以分为两个三角形，于是我们写出三个函数：分别是构建三角形，构建平面和构建立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个三角形</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateTriangle</span><span class="params">(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//逆时针的三角形</span></span><br><span class="line">    <span class="comment">//顶点顺序 0 1 2</span></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(p1, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(p2, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(p3, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建一个平面，顶点顺序为左上 左下 右下 右上</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreatePlane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; leftTop, <span class="type">const</span> glm::vec3&amp; leftBottom, <span class="type">const</span> glm::vec3&amp; rightBottom, <span class="type">const</span> glm::vec3&amp; rightTop, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(leftTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(rightTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(rightBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">3</span>].position = glm::<span class="built_in">vec4</span>(leftBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">3</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个逆时针三角形</span></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    result.EBO[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建立方体</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateBox</span><span class="params">(<span class="type">const</span> glm::vec3&amp; center, <span class="type">float</span> radius)</span> </span>&#123;</span><br><span class="line">    Mesh result;</span><br><span class="line"></span><br><span class="line">    Mesh front = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(front);</span><br><span class="line"></span><br><span class="line">    Mesh left = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(left);</span><br><span class="line"></span><br><span class="line">    Mesh right = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(right);</span><br><span class="line"></span><br><span class="line">    Mesh back = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(back);</span><br><span class="line"></span><br><span class="line">    Mesh up = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(up);</span><br><span class="line"></span><br><span class="line">    Mesh down = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(down);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的颜色更加标准了，所有分量范围都在 [0 ,1]，因此需要修改对应的 <code>FrameBuffer</code> 中的写颜色函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>saturate</code> 函数在 math.h 中定义，作用是将输入值截断在 [0, 1] 范围内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">saturate</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数绘制立方体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;box.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">30.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box.png" alt="box"></p><p>可以看出透视关系不正确，这是因为没有做深度测试的原因，因此我们需要实现深度测试。</p><h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4 深度测试"></a>4 深度测试</h3><p>我们首先需要在 FrameBuffer 类中加入深度缓冲：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Width, Height;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; depthBuffer;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        <span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重设缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">            *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时重置深度缓冲</span></span><br><span class="line">        depthBuffer.<span class="built_in">assign</span>(Width * Height, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将颜色写入对应位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入深度，Z-Buffer 中深度范围是 [0,1]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">float</span>* p = depthBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + y * Width + x) = depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取深度</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> *(depthBuffer.<span class="built_in">data</span>() + y * Width + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正常深度测试应该在片元着色器之后，但是为了避免不必要的计算，可以在扫描线算法中加入深度测试，也相当于实现了 Early-Z 算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box-16531280264721.png" alt="box"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（二）框架搭建</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2022-05-20T03:33:30.000Z</published>
    <updated>2022-05-23T08:21:17.571Z</updated>
    
    <content type="html"><![CDATA[<p>上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。</p><p><em><span id="more"></span></em></p><h3 id="1-统一管理全局变量"><a href="#1-统一管理全局变量" class="headerlink" title="1 统一管理全局变量"></a>1 统一管理全局变量</h3><p>首先我们使用一个头文件 <code>Global.h</code> 来统一管理我们用到的所有头文件、全局变量和类声明，为了之后使用方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-FrameBuffer-类"><a href="#2-FrameBuffer-类" class="headerlink" title="2 FrameBuffer 类"></a>2 FrameBuffer 类</h3><p>和光线追踪器中一样，我们使用一个 unsigned char 数组来存放像素，但这次我们使用 RGBA 四个通道。为了保证整个代码结构清晰，我们封装一个 <code>FrameBuffer</code> 类来管理颜色缓冲，后续还可以加入深度缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> Width, Height;</span><br><span class="line">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line"><span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重设缓冲区大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">*(p + i) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + i + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + i + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + i + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> xy = (y * Width + x);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">*(p + xy * <span class="number">4</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">*(p + xy * <span class="number">4</span> + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-管理顶点数据"><a href="#3-管理顶点数据" class="headerlink" title="3 管理顶点数据"></a>3 管理顶点数据</h3><p>顶点是我们光栅化渲染器的输入数据，所以理所应当用一个类来管理。一个顶点包含的数据有：模型坐标、顶点颜色、顶点法线、纹理坐标。注意位置坐标使用的是四维齐次坐标，在模型空间和世界空间的坐标都是 x, y, z 加上恒为 1 的 w，所以要用四维向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 顶点Vertex类和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VERTEX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 position;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _pos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex = glm::<span class="built_in">vec2</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">position</span>(_pos, <span class="number">1.0f</span>), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; v) :<span class="built_in">position</span>(v.position), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-渲染管线思路"><a href="#4-渲染管线思路" class="headerlink" title="4 渲染管线思路"></a>4 渲染管线思路</h3><p>输入输出都定义完了，接下来开始一步一步实现渲染管线。通常的 OpenGL 渲染管线流程如下：</p><ol><li>输入顶点数据和图元类型（点、直线、三角形等基本图元）</li><li>顶点着色器对顶点进行处理，将坐标变换到世界坐标，计算纹理坐标和顶点颜色等，输出到中间结构体（v2f）</li><li>对 v2f 进行图元装配过程，也就是为每个三角形指定顶点数据与索引</li><li>将顶点变换到摄像机的观察空间</li><li>进行投影，将顶点变换到裁剪空间</li><li>进行裁剪和面剔除工作，将看不见的图元进行裁剪，剔除背向面，减少后续计算量</li><li>执行齐次除法，将顶点变换到 NDC（标准设备坐标）</li><li>执行视口变换，最终将顶点转换到屏幕坐标（从三维变成二维）</li><li>光栅化，计算图形在屏幕上最终覆盖的像素点</li><li>用顶点数据插值，在像素点位置生成新的 v2f</li><li>逐像素运行片元着色器，进行纹理采样、光照计算等，输出该点最终颜色值（RGBA）</li><li>执行透明度测试-&gt;模板测试-&gt;深度测试，丢弃掉一些片元</li><li>执行混合操作</li></ol><h3 id="5-V2F-类"><a href="#5-V2F-类" class="headerlink" title="5 V2F 类"></a>5 V2F 类</h3><p>上述过程中，一个重要的结构体是 v2f，因此首先我们需要定义一个 v2f 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> V2F_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2F_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V2F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">glm::vec4 worldPos;</span><br><span class="line">glm::vec4 windowPos;</span><br><span class="line">glm::vec4 color;</span><br><span class="line">glm::vec2 texcoord;</span><br><span class="line">glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">glm::mat3 TBN;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">V2F</span>(</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _wPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _pPos,</span><br><span class="line"><span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line"><span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line"><span class="type">const</span> glm::vec3&amp; _normal,</span><br><span class="line"><span class="type">const</span> glm::mat3&amp; _tbn</span><br><span class="line">) :</span><br><span class="line"><span class="built_in">worldPos</span>(_wPos), <span class="built_in">windowPos</span>(_pPos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal), <span class="built_in">TBN</span>(_tbn) &#123;&#125;</span><br><span class="line"><span class="built_in">V2F</span>(<span class="type">const</span> V2F&amp; v) :</span><br><span class="line"><span class="built_in">worldPos</span>(v.worldPos), <span class="built_in">windowPos</span>(v.windowPos), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal), <span class="built_in">TBN</span>(v.TBN), <span class="built_in">Z</span>(v.Z) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个顶点之间的插值</span></span><br><span class="line"><span class="function"><span class="type">static</span> V2F <span class="title">lerp</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> <span class="type">float</span>&amp; factor)</span> </span>&#123;</span><br><span class="line">V2F result;</span><br><span class="line">result.windowPos = <span class="built_in">Lerp</span>(v1.windowPos, v2.windowPos, factor);</span><br><span class="line">result.worldPos = <span class="built_in">Lerp</span>(v1.worldPos, v2.worldPos, factor);</span><br><span class="line">result.color = <span class="built_in">Lerp</span>(v1.color, v2.color, factor);</span><br><span class="line">result.normal = <span class="built_in">Lerp</span>(v1.normal, v2.normal, factor);</span><br><span class="line">result.texcoord = <span class="built_in">Lerp</span>(v1.texcoord, v2.texcoord, factor);</span><br><span class="line"></span><br><span class="line">result.TBN = v1.TBN;</span><br><span class="line"></span><br><span class="line">result.Z = <span class="built_in">Lerp</span>(v1.Z, v2.Z, factor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>V2F 中一个重要的操作就是插值，为此我们新建一个 <code>math.h</code> 文件来存放需要用到的数学操作，首先是线性插值函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v1, <span class="type">const</span> glm::vec3&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec2&amp; v1, <span class="type">const</span> glm::vec2&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; f1, <span class="type">const</span> <span class="type">float</span>&amp; f2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * f1 + factor * f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-Shader-类"><a href="#6-Shader-类" class="headerlink" title="6 Shader 类"></a>6 Shader 类</h3><p>有了上面这些准备，现在我们可以用顶点着色器来对顶点进行处理了。先从简单的情况开始，我们首先渲染一个二维图形，因为画二维图形不需要三维到二维的变换，所以三个变换矩阵都置为单位矩阵，实际上等于没做变换直接输出。片元着色器也是直接将调用点的颜色进行输出即可。我们同样封装一个 <code>Shader</code> 类来管理顶点和片元着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">V2F o;</span><br><span class="line"><span class="comment">// 变换到世界空间</span></span><br><span class="line">o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line"><span class="comment">// 变换到裁剪空间</span></span><br><span class="line">o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line"><span class="comment">// 法线变换</span></span><br><span class="line">o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">o.texcoord = a2v.texcoord;</span><br><span class="line">o.color = a2v.color;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 片元着色器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v.color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">ModelMatrix = model;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">ViewMatrix = view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">ProjectMatrix = project;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="7-视口变换"><a href="#7-视口变换" class="headerlink" title="7 视口变换"></a>7 视口变换</h3><p>现在我们可以在主函数中定义是三个顶点，由于 OpenGL 的 NDC 的坐标范围是[-1,1)，而我们目前并没有做任何的坐标变换，因此我们直接定义 NDC 下的顶点坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br></pre></td></tr></table></figure><p>现在我们得到了处理后的顶点，但还在 NDC 当中，需要进一步转化为屏幕空间中的坐标，即需要进行视口变换。视口变换做的操作是将 X, Y 坐标从 [-1,1) 映射到屏幕坐标 [0,w) 和 [0,h) 上，同时将原点从屏幕中间移到左下角。注意，在 OpenGL 中，左下角是原点，右上角是 (w,h) ，而 DirectX 中左上角是原点。在我们的 <code>math.h</code> 中定义视口变换矩阵，该矩阵是一个缩放+平移的矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glm 的矩阵是行矩阵，而我们一般使用的是列矩阵，所以存放的时候要转置</span></span><br><span class="line"><span class="comment">// 行矩阵做变换是右乘 v * M  ，列矩阵是左乘 M * v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视口变换矩阵  ox oy是左下角的坐标  从[-1,1]的 NDC 变换到屏幕坐标 [0,0],[w,h]</span></span><br><span class="line"><span class="comment">// Vp = [  w/2 ,   0  ,  0  , ox+w/2 ,</span></span><br><span class="line"><span class="comment">//0  ,  h/2 ,  0  , oy+h/2 ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  1  ,   0    ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  0  ,   1   ]</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewPortMatrix</span><span class="params">(<span class="type">int</span> ox, <span class="type">int</span> oy, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">result[<span class="number">0</span>][<span class="number">0</span>] = width / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">0</span>] = ox + (width / <span class="number">2.0f</span>);</span><br><span class="line">result[<span class="number">1</span>][<span class="number">1</span>] = height / <span class="number">2.0f</span>;</span><br><span class="line">result[<span class="number">3</span>][<span class="number">1</span>] = oy + (height / <span class="number">2.0f</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br></pre></td></tr></table></figure><h3 id="8-光栅化"><a href="#8-光栅化" class="headerlink" title="8 光栅化"></a>8 光栅化</h3><p>接下来需要计算我们的三角形覆盖了哪些屏幕像素，这里使用经典的扫描线算法。其思想很简单，从三角形最上面的点开始往下逐步画横线，两个交点之间的区域就是覆盖的区域。</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162253946.png" alt="image-20220519162253946"></p><p>朝向下侧的三角形原理也是一样的，只不过是对称过来了。有了这两种三角形，不难发现任意三角形都能最多分为一个平顶和一个平底三角形，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162338364.png" alt="image-20220519162338364"></p><p>于是我们得到一般三角形的光栅化方法：</p><ol><li>根据三个顶点的 y 坐标判定是否有两个相等，有则判断是平底还是平顶三角形，直接画</li><li>找到 y 值在中间的点，划分出上下两个三角形，画两个</li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扫描线算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader.<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改上一节的主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line">FrameBuffer FrontBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">FrontBuffer.<span class="built_in">Resize</span>(SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染并写出图片</span></span><br><span class="line">FrontBuffer.<span class="built_in">ClearColorBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line"></span><br><span class="line">std::string filepath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\test.png&quot;</span>;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), SCR_WIDTH, SCR_HEIGHT, <span class="number">4</span>, FrontBuffer.colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test.png" alt="test"></p><h3 id="9-Draw-类"><a href="#9-Draw-类" class="headerlink" title="9 Draw 类"></a>9 Draw 类</h3><p>我们成功渲染出了二维图形，不过目前我们的渲染流程全都写在主函数中，需要一定的封装，于是我们定义一个 <code>Draw</code> 类来封装渲染过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRAW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> Width;</span><br><span class="line"><span class="type">int</span> Height;</span><br><span class="line">FrameBuffer* FrontBuffer;</span><br><span class="line">Shader* shader;</span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line"><span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">~<span class="built_in">Draw</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">shader = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setModelMatrix</span>(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setViewMatrix</span>(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">setProjectMatrix</span>(project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (FrontBuffer)</span><br><span class="line"><span class="keyword">delete</span> FrontBuffer;</span><br><span class="line"><span class="keyword">if</span> (shader)</span><br><span class="line"><span class="keyword">delete</span> shader;</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">Width = w;</span><br><span class="line">Height = h;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">Resize</span>(w, h);</span><br><span class="line">ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">FrontBuffer-&gt;<span class="built_in">ClearColorBuffer</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), Width, Height, <span class="number">4</span>, FrontBuffer-&gt;colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F o1 = shader-&gt;<span class="built_in">VertexShader</span>(v1);</span><br><span class="line">V2F o2 = shader-&gt;<span class="built_in">VertexShader</span>(v2);</span><br><span class="line">V2F o3 = shader-&gt;<span class="built_in">VertexShader</span>(v3);</span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"><span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">****************** 扫描线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">V2F left, right, top;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">top = v3;</span><br><span class="line"><span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line"><span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line"><span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">V2F left, right, bottom;</span><br><span class="line">left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">bottom = v3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line"><span class="comment">//从上往下插值</span></span><br><span class="line"><span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">&#125;</span><br><span class="line">V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line"><span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">nowY--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line"><span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">arr[<span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line"><span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后主函数就变得非常简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;test.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line">dw.<span class="built_in">Init</span>();</span><br><span class="line"><span class="comment">// 三角形三个顶点</span></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line"><span class="comment">// 设定背景并画三角形，这次有透明效果</span></span><br><span class="line">dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">dw.<span class="built_in">DrawTriangle</span>(V1, V2, V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出图片</span></span><br><span class="line">std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test-16530173154901.png" alt="test"></p><p>到此为止整个渲染器的框架就搭建完成，之后只需要在这个框架上添加算法和各种功能即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【光栅化渲染器】（一）环境配置</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-05-19T03:46:26.000Z</published>
    <updated>2022-05-23T08:21:34.937Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。</p><p><em><span id="more"></span></em></p><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h3><p>我们使用 GLFW 和 GLAD 来显示最终渲染的图片，这些可以参照<a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/#glfw">LearnOpenGL CN</a>上的教程来进行配置。</p><p>使用 GLM 作为数学库，下载地址：<a href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm · GitHub</a></p><p>也可以使用和光线追踪器中一样的 STB 图像库来输出图片。</p><h3 id="2-OpenGL-基础"><a href="#2-OpenGL-基础" class="headerlink" title="2 OpenGL 基础"></a>2 OpenGL 基础</h3><p>下面是一个简单的 OpenGL 程序，但展示了所有 OpenGL 程序的通用流程和框架，包含详细注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些回调函数</span></span><br><span class="line"><span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line"><span class="comment">// 这里我们在改变窗口大小的时候也改变视口大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测是否按下 ESC 键，如果按下则将WindowShouldClose属性设置为true，这样既可退出渲染循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像设置</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器代码，存放在字符串中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW，并配置版本信息等</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GLFW 创建一个窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 用来来管理OpenGL的函数指针，使其在不同版本不同硬件上能够正确运行</span></span><br><span class="line">    <span class="comment">// 因此在使用 OpenGL 函数前需要先初始化 GLAD</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并编译顶点着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并编译片元着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将着色器代码链接为一个着色器程序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 检查链接错误</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ；链接完成后即可删除着色器对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个三角形</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点缓冲区VBA和顶点数组缓冲区VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 绑定顶点数组缓冲</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">// 绑定顶点缓冲，顶点缓冲是GL_ARRAY_BUFFER类型</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 将上面的顶点数据复制到顶点缓冲中</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 链接顶点属性，即告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除缓冲区绑定，非必要</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 是否按下ESC关闭窗口</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置清空屏幕缓冲所用的颜色</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 用设置的颜色清空颜色缓冲，可选的还有深度缓冲和模板缓冲</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双缓冲渲染，屏幕显示前缓冲区，渲染在后缓冲进行，因此每一帧交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行效果如图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20220519114457379.png" alt="image-20220519114457379"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="光栅化渲染器" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    
    
    <category term="实时渲染" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/"/>
    
    <category term="OpenGL" scheme="https://lz328.github.io/LycTechStack.github.io/tags/OpenGL/"/>
    
  </entry>
  
</feed>
