<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-04-24T02:45:21.544Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【RayTracer】（十八）重要性采样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/</id>
    <published>2022-04-24T02:42:48.000Z</published>
    <updated>2022-04-24T02:45:21.544Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。</p><p><em><span id="more"></span></em></p><h3 id="1-再谈渲染方程"><a href="#1-再谈渲染方程" class="headerlink" title="1 再谈渲染方程"></a>1 再谈渲染方程</h3><p>首先我们来回顾图形学中学过的渲染方程：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320143225898.png" alt="image-20220320143225898"></p><p>实际上在前面的光线追踪器中我们已经实现了这个渲染方程，但是只实现了一个特殊情况，现在我们来深入分析一下我们是如何实现的。</p><p>我们是在 <code>ray_color</code> 函数中实现这个渲染方程的，渲染方程中的入射光线和出射光线的强度在我们的代码中其实就是 <code>ray_color</code> 函数计算的颜色。</p><p><code>ray_color</code> 函数的<code>r_in</code> 参数最开始传入的是我们从像素中投射出的视线，也就是观察方向，我们根据观察方向通过材质的散射函数随机采样出一条对于我们来说真正的入射光线，然后递归的计算这个入射光线的颜色，并返回 <code>albedo * ray_color</code>，其中反射率 <code>albedo</code> 就是出射光线和入射光线的比值，乘以入射光线颜色，自然就得到了出射光线的颜色，也就是我们最终观察到的颜色。整个过程不断递归，每次传入 <code>ray_color</code> 函数的入射光线实际上是上一次计算的入射光线，是本次计算的出射光线。</p><p>但是我们发现在 <code>ray_color</code> 函数中并没有体现出 BRDF 的存在。这是由于我们实现的是一个特殊情况。</p><p>首先我们对渲染方程中的 BRDF 项做一些变形。我们知道 BRDF 可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320141430022.png" alt="image-20220320141430022"></p><p>从公式上看，BRDF 计算的是从每个散射方向 $\omega_r$ 出射的光的能量，和从每个入射方向 $\omega_i$ 上入射的光被着色点吸收的全部能量（在法线方向上投影的能量）的比值。<strong>双向反射分布函数的意义在于既描述了光线能量的反射比率，也描述了光线散射方向的分布。</strong></p><p>如果一个材质会发生散射，那么就会存在一个散射光线的分布，这个分布是关于方向的，我们称之为散射光线的概率密度函数 $s(direction)$，根据上面的 BRDF 公式，我们可以把 BRDF 改写为：<br>$$<br>BRDF &#x3D; \frac{albedo·s(direction)}{cos\theta}<br>$$<br>其中反射率是出射光线和入射光线的比值，描述光线的能量反射比率，散射光线的概率密度函数描述了光线散射方向的概率分布，这和上面的 BRDF 表达式是一致的。</p><p>接下来将这个 BRDF 表达式带入渲染方程中，其中夹角余弦可以写成表面法线和入射光线的点乘。于是我们可以得到：<br>$$<br>color_{out} &#x3D; color_{emit} + \int_{\Omega^+}albedo·s(direction)·color_{in}<br>$$<br>这和我们代码中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一致的，只是代码中缺少了散射光线的概率密度函数 $s(direction)$。这是为什么呢？</p><p>在我们实现的材质中，以漫反射 lambertian 材质为例，它的计算散射方向的方法是：使用表面法线偏移着色点 p 作为单位球的球心，在该单位球面上均匀采样一点并连接该点和点 p ，形成的向量即为散射方向。这样计算出的散射方向并不是在以点 p 为球心的半球上均匀分布的，所以概率密度并不是的 $\frac{1}{2\pi}$，而是与散射光线和法线的夹角余弦 $cos\theta$ 成正比的，我们可以推导出这个概率密度函数是什么。</p><p>首先我们知道，方向表示为单位立体角 $d\omega$，单位立体角是球面上的一块面积 $dA$ 和半径平方的比值，在图形学中我们推导过：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; \frac{r^2sin\theta \ d\theta \ d\phi}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>于是对于半球面上的均匀采样，有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}pdf·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>而单位半球面的积分就是半球的表面积 $2\pi$，于是半球面上的均匀分布就是：<br>$$<br>pdf(x) &#x3D; \frac{1}{2\pi}<br>$$<br>同理，我们现在要求的概率密度函数和 $cos\theta$ 成正比，于是可以表示为：<br>$$<br>pdf(x) &#x3D; C·cos\theta<br>$$<br>带入上面的积分有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}C·cos\theta·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>半球面上对 $cos\theta$ 积分结果为 $\pi$，因此：<br>$$<br>C·\pi &#x3D; 1<br>$$<br>于是可以得到我们实现的 lambertian 材质的散射光线的概率密度函数为：<br>$$<br>s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>接下来继续回顾图形学中的知识，我们求解渲染方程使用的是蒙特卡洛积分的方法，也就是按照某个概率分布 $p(x)$ 对被积变量进行随机采样，于是原积分可以通过如下方式计算：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>那么现在的渲染方程就可以通过蒙特卡洛积分计算：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum \frac{albedo·s(direction)·color_{in}}{p(direction)}<br>$$<br>如果我们选择对光线随机采样的概率密度和散射光线本身的概率密度分布一致，即：<br>$$<br>p(direction) &#x3D; s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>显然渲染方程变为：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum albedo·color_{in}<br>$$<br>也就是我们现在代码中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在我们之前的实现中，<strong>隐式的把对光线随机采样的概率密度设置为了永远和散射光线的概率密度一样</strong>，无论是漫反射材质还是金属材质又或者是其他材质，我们不关注他们散射光线的概率密度什么，反正我们采样的概率密度和它们一致，所以渲染方程永远可以表示为上面那样。</p><p>那么这样做为什么可以得到正确的结果呢？之前我们在图形学中也提到过，随机采样的概率分布越接近该变量原本的概率分布，蒙特卡洛积分收敛的也就越好，这会在之后展开讨论。</p><p>现在为了使我们实现更一般的渲染方程，我们需要改写现在的代码。</p><p>首先修改材质抽象类，为散射光线的计算加入采样光线的 pdf：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 带有采样pdf的散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 lambertian 材质的散射函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到和之前一样的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox.png" alt="CornellBox"></p><p>如果我们把采样光线改为在半球上均匀采样，此时采样光线的 pdf 就是 $\frac{1}{2\pi}$ ，于是我们只要修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//auto scatter_direction = rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 改为半球均匀采样 </span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        <span class="comment">//pdf = dot(rec.normal, scattered.direction()) / pi;</span></span><br><span class="line">        pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox2.png" alt="CornellBox2"></p><p>使用什么样的采样 pdf 完全取决于我们的选择，但是使用什么样的 pdf 效果好刚才已经给出了答案，随机采样的 pdf 形状越接近函数原本的形状，蒙特卡洛估计收敛的效果就会越好。下面我们来推导这是为什么。</p><h3 id="2-重要性采样"><a href="#2-重要性采样" class="headerlink" title="2 重要性采样"></a>2 重要性采样</h3><p>要了解重要性采样的原理就要先深入理解蒙特卡洛积分，首先我们来分析为什么蒙特卡洛积分可以得到原积分的估计值。根据蒙特卡洛积分的计算方法：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>首先我们把积分变量看做了一个随机变量 X，然后构造了一个随机采样的分布 p(X)，利用这个分布我们可以构造一个新的随机变量：<br>$$<br>Y &#x3D; \frac{f(X)}{p(X)}<br>$$<br>概率论告诉我们的如果一个随机变量 X 的期望是 E(X)，那么随机变量 f(X) 的期望就是 E(f(X))，于是蒙特卡洛积分 $F_N$ 的期望就是：<br>$$<br>E[F_N] &#x3D; E[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>也就是：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^NE[Y_i]<br>$$<br>连续型随机变量的期望就是对概率密度函数的积分，所以：<br>$$<br>E[Y_i] &#x3D; \int_a^b \frac{f(x)}{p(x)}p(x)dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>带入上式得：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N\int_a^b{f(x)}dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>以上证明过程表明，若我们根据公式来构造一个新的随机变量 $F_N$ ，则 $F_N$ 的期望就是原积分的结果，随着 N 的增加，$F_N$ 就越逼近理论上的积分值，即蒙特卡洛积分是原积分的一个无偏估计。</p><p>接下来我们看蒙特卡洛估计的方差：<br>$$<br>\sigma^2[F_N] &#x3D; \sigma^2[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>即：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}\sum_{i&#x3D;1}^N\sigma^2[Y_i]<br>$$<br>于是可以得到：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}N\sigma^2[Y]&#x3D;\frac{1}{N}\sigma^2[Y]<br>$$<br>所以蒙特卡洛积分的标准差就是：<br>$$<br>\sigma[F_N] &#x3D; \frac{1}{\sqrt{n}}\sigma[Y]<br>$$<br>这个结果告诉我们，估计值的不稳定来源于随机变量 Y 的取值不稳定。换句话说，如果随机变量：<br>$$<br>Y_i &#x3D; \frac{f(X_i)}{p(X_i)}<br>$$<br>因不同 $X_i$ 的取值变化地越剧烈，就会造成 Y 的方差较大，也就导致估计值的收敛速度越慢。这证明了，<strong>如果 p(x) 的形状越接近 f(x)，则有益于最终结果的收敛</strong>。</p><p><strong>上述思想就是“重要性采样”的方法，即对积分值有重要贡献，即 f(x) 较大的被积函数区间，我们以较大概率生成处于这个区间附近的随机变量，就可以快速逼近理论值。</strong> </p><p>应用到光线追踪中，光源方向的光线对最终渲染方程积分结果的贡献更大，如果使用我们现在的均匀随机采样，由于光源很小，得到光源方向的光线的概率就很小，自然对最终结果的估计就会产生较大的偏差，体现在画面上就是有很大的噪声。于是为了消除噪声，我们应该使用重要性采样，生成更多光源方向的光线。</p><p>当然，如果我们采样更多的随机光线到光源，会导致积分结果过大，也就是画面过亮，而产生不正确的效果，因此我们需要降低这些样本的权重，在蒙特卡洛积分的公式中，除以概率密度函数就是为了解决这个问题，概率密度大的样本取到的相对概率大，除以这个概率可以削弱该样本的权重，以抵消这种不均衡。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十七）新特性最终场景</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/</id>
    <published>2022-04-22T12:46:58.000Z</published>
    <updated>2022-04-23T11:39:14.771Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。</p><p><em><span id="more"></span></em></p><h3 id="1-创建新场景"><a href="#1-创建新场景" class="headerlink" title="1 创建新场景"></a>1 创建新场景</h3><p>创建一个包含所有特性的场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新特性最终场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高低起伏的盒子组成地面</span></span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i * w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j * w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(x0, y0, z0), <span class="built_in">point3</span>(x1, y1, z1), ground));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line">    <span class="comment">// 构建地面的BVH树</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 光源</span></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line">    <span class="comment">// 移动的球体</span></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line">    <span class="comment">// 透明球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    <span class="comment">// 金属球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">1.0</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与介质</span></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>)));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">.0001</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地球</span></span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(</span><br><span class="line">        <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, emat));</span><br><span class="line">    <span class="comment">// 噪声纹理</span></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一堆小球</span></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> center = <span class="built_in">random_vec</span>(<span class="number">0</span>, <span class="number">165</span>);</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">            center, center, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, white));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旋转平移一堆小球</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">270</span>, <span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-渲染效果"><a href="#2-渲染效果" class="headerlink" title="2 渲染效果"></a>2 渲染效果</h3><p>修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            world = <span class="built_in">final_scene</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">800</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">            min_bounce = <span class="number">95</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">478</span>, <span class="number">278</span>, <span class="number">-600</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/FinalSence.png" alt="FinalSence"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十六）参与介质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/</id>
    <published>2022-04-22T12:45:02.000Z</published>
    <updated>2022-04-22T12:47:38.346Z</updated>
    
    <content type="html"><![CDATA[<p>之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。</p><p><em><span id="more"></span></em></p><h3 id="1-恒定密度介质"><a href="#1-恒定密度介质" class="headerlink" title="1 恒定密度介质"></a>1 恒定密度介质</h3><p>因为我们之前所有的实现都是基于“表面”的，而参与介质是基于“体积”的，这二者之间还是有很大的不同的，但是一个简单的办法是可以把整个参与介质看作是由表面构成的，但这个表面可以在物体内部，只要在一定范围内的点都算作该物体的表面，所以都可以和光线发生作用。</p><p>我们在图形学中学过，光线穿过烟雾会在其内部发生各种散射，我们可以用一个概率模型来描述这种过程，如果一个烟雾的密度越大，那么光线在其中发生散射的几率也就越大，如果光线越稀薄，光线就越有可能直接穿过介质而不发生散射，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/fig-2.08-ray-vol.jpg" alt="fig-2.08-ray-vol"></p><p>我们认为光线在烟雾中走过 $\Delta L$ 距离发生散射的几率是：<br>$$<br>probability &#x3D; C·\Delta L<br>$$<br>其中 $C$ 与介质的密度成正比，于是对于一个随机数就可以用上面的式子计算得到概率，并把这个概率认为是散射发生的距离。如果散射发生的距离大于光线在介质中传播的距离，说明光线没有击中介质，而是直接穿过。</p><p>因此一个恒定密度的介质只需要一个密度和边界就可以描述，边界使用另一个物体来确定，相当于该物体形状的烟雾，一个恒定密度的介质类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 恒定密度的参与介质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(a))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, color c)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(c))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; boundary;          <span class="comment">// 边界</span></span><br><span class="line">    shared_ptr&lt;material&gt; phase_function;    <span class="comment">// 各向同性材质，保证光线向各个方向等概率均匀散射</span></span><br><span class="line">    <span class="type">double</span> neg_inv_density;                 <span class="comment">// 密度的负倒数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于debug</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求光线和边界的两个交点</span></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t + <span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">&quot;\nt_min=&quot;</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">&quot;, t_max=&quot;</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线在介质中的距离</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="comment">// 光线发生散射的距离，两个相乘的数都是小于1的负数，所以密度越大值越小</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生散射的距离大于光线在介质中的距离则没有发生散射，直接穿过介质</span></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散射发生的位置</span></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;hit_distance = &quot;</span> &lt;&lt; hit_distance &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.t = &quot;</span> &lt;&lt; rec.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.p = &quot;</span> &lt;&lt; rec.p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法线方向这些属性可以随便设置</span></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.front_face = <span class="literal">true</span>;</span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的实现中我们默认光线一旦出了介质就不会再在介质中弹射了，因此只适用于凸多边形物体，不适用于凹多边形物体。其中控制光线向各个方向等概率散射的材质在 <code>material.h</code> 中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 各向同性材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">isotropic</span>(color c) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line">    <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 光线向各个方向等概率均匀散射</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-用烟雾渲染-Cornell-Box"><a href="#2-用烟雾渲染-Cornell-Box" class="headerlink" title="2 用烟雾渲染 Cornell Box"></a>2 用烟雾渲染 Cornell Box</h3><p>我们使用上面实现的介质新建一个 Cornell Box 场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 烟雾Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            world = <span class="built_in">cornell_smoke</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/CornellBoxSmoke.png" alt="CornellBoxSmoke"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十五）立方体和变换</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/</id>
    <published>2022-04-22T11:40:41.000Z</published>
    <updated>2022-04-22T11:46:22.765Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。</p><p><em><span id="more"></span></em></p><h3 id="1-轴对齐立方体"><a href="#1-轴对齐立方体" class="headerlink" title="1 轴对齐立方体"></a>1 轴对齐立方体</h3><p>先使用轴对齐矩形实现一个轴对齐立方体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 box_min;</span><br><span class="line">    point3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr) &#123;</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后将 box 添加到 Cornell Box 场景中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxComplete.png" alt="CornellBoxComplete"></p><h3 id="2-Instances"><a href="#2-Instances" class="headerlink" title="2 Instances"></a>2 Instances</h3><p>接下来我们要实现立方体的旋转，更一般地，我们不止要让立方体旋转，而是要让场景中的所有物体都能够运动，运动包括平移和旋转。在光线追踪器中，这些都是通过 Instances 来实现的，Instances 可以认为是一个几何变换器，可以将传入的物体按照给定的参数和方式进行变换，因此我们要实现这些几何变换的 Instances 类。</p><h4 id="2-1-平移"><a href="#2-1-平移" class="headerlink" title="2.1 平移"></a>2.1 平移</h4><p>首先是平移变换类，在光线追踪器中实现物体平移不是通过真的把物体移动到某个位置，因为物体一旦被放入场景再去变换位置就需要费很大的功夫，所以实现物体平移是通过向反方向移动光线来实现的，比如：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/fig-2.06-ray-box.jpg" alt="fig-2.06-ray-box"></p><p>要把粉色的正方形沿 x 轴向右移动两个单位，我们可以通过把光线沿 x 轴向左移动两个单位来实现。</p><p>注意和之前实现的移动的球体做区分，这里的移动不是在一段时间内的运动，而是改变场景中物体的摆放方式。</p><p>平移变换类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平移变换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">        : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    vec3 offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 光线向反方向平移</span></span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算交点，这里计算出的交点是相对坐标，物体还在原本的地方</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把物体和光线的交点加上偏移，得到平移后的物体和光线的交点在世界空间的绝对坐标</span></span><br><span class="line">    <span class="comment">// 这才相当于把物体移动了</span></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><p>旋转的思路和平移一样，也是先反方向旋转光线，得到交点后对交点再进行正向旋转，不同的是旋转后交点法线也要相应变换，在 Shader 学习中我们知道对法线变换要用变换矩阵的逆转置矩阵，旋转矩阵是正交矩阵，逆转置矩阵就是其本身。</p><p>绕 y 轴旋转的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绕y轴旋转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = bbox;</span><br><span class="line">        <span class="keyword">return</span> hasbox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    <span class="type">double</span> sin_theta;</span><br><span class="line">    <span class="type">double</span> cos_theta;</span><br><span class="line">    <span class="type">bool</span> hasbox;</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，计算旋转后的bounding box及其他的基本成员</span></span><br><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) &#123;</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degrees_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">(infinity, infinity, infinity)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bounding box的每个顶点，并进行变换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = i * bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span> - i) * bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j * bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span> - j) * bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k * bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span> - k) * bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx = cos_theta * x + sin_theta * z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta * x + cos_theta * z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line">                    min[c] = <span class="built_in">fmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">fmax</span>(max[c], tester[c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    <span class="keyword">auto</span> direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线向反方向旋转</span></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 因为光线方向实际上是两个点的差，所以也可以直接应用变换矩阵</span></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到的交点同样是相对的坐标</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = rec.p;</span><br><span class="line">    <span class="keyword">auto</span> normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将交点进行旋转</span></span><br><span class="line">    p[<span class="number">0</span>] = cos_theta * rec.p[<span class="number">0</span>] + sin_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta * rec.p[<span class="number">0</span>] + cos_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 法线也要旋转，法线变换应该用原变换矩阵的逆转置矩阵，旋转矩阵正交因此逆转置矩阵就是原矩阵</span></span><br><span class="line">    normal[<span class="number">0</span>] = cos_theta * rec.normal[<span class="number">0</span>] + sin_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta * rec.normal[<span class="number">0</span>] + cos_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-完整的-Cornell-Box"><a href="#3-完整的-Cornell-Box" class="headerlink" title="3 完整的 Cornell Box"></a>3 完整的 Cornell Box</h3><p>利用实现的立方体和几何变换类，来得到完整的 Cornell Box 场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxComplete-16506279092151.png" alt="CornellBoxComplete"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十四）光源</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/</id>
    <published>2022-04-22T08:42:25.000Z</published>
    <updated>2022-04-22T08:43:39.530Z</updated>
    
    <content type="html"><![CDATA[<p>之前的场景中一直缺少一个重要的元素，那就是光源，这一节我们来实现光源，这样我们之后就可以随意控制场景中的光照了。</p><p><em><span id="more"></span></em></p><h3 id="1-自发光材质"><a href="#1-自发光材质" class="headerlink" title="1 自发光材质"></a>1 自发光材质</h3><p>光源可以认为是会自发光的材质，并且其他光线到达其表面也不会发生散射，这样的材质实现非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自发光材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到上面还重载了另一个虚函数 <code>emitted</code>，因此要在 <code>material</code> 抽象类中加入 <code>emitted</code> 的声明，但因为我们不需要所有派生类都实现这个方法，因此不必定义为纯虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，产生散射光线并给定光线衰减系数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自发光虚函数，不必所有派生类都进行实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-为场景添加背景颜色"><a href="#2-为场景添加背景颜色" class="headerlink" title="2 为场景添加背景颜色"></a>2 为场景添加背景颜色</h3><p>为了之后测试光源，我们需要一个全黑的背景，这样所有的光线就都来自于光源了，为此我们在 <code>ray_color</code> 函数中增加一个背景颜色的参数，并作相应的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">hit_record rec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line"><span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line"><span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line"><span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line"><span class="keyword">return</span> background;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">ray scattered;</span><br><span class="line">color attenuation;</span><br><span class="line">color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line"><span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line"><span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line"><span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在主函数中增加背景颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="function">color <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    pixel_color += <span class="built_in">ray_color</span>(r, background, world, min_bounce, RR);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为了方便，我们把之前的场景的背景统一设置为了天空的蓝白色。</p><h3 id="3-矩形物体"><a href="#3-矩形物体" class="headerlink" title="3 矩形物体"></a>3 矩形物体</h3><p>接下来我们实现另一类物体——矩形，矩形在我们之后的场景中非常重要，它既可以作为面光源，也可以组合成立方体等等。为了实现矩形物体类，我们首先要考虑的就是它的 <code>hit</code> 函数，这里为了实现方便，我们实现的矩形是一个轴对齐矩形。</p><p>对于一个三维空间中存在于 xy 平面内的矩形，可以直接用它的 z 坐标来描述它的位置，比如 z &#x3D; k，又因为它是轴对齐矩形，因此可以用四条线 x &#x3D; x0, x &#x3D; x1, y &#x3D; y0, y &#x3D; y1 来定义这个矩形，这和之前的轴对齐包围盒非常相似，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/fig-2.05-ray-rect.jpg" alt="fig-2.05-ray-rect"></p><p>于是求光线和矩形的交点可以类似于图形学中求光线和三角形的交点，分为两步，先求光线和 z &#x3D; k 平面的交点，然后判断该交点是否在矩形内部。光线和 z &#x3D; k 平面的交点非常容易求得，对于光线 $P(t) &#x3D; A + tb$，可以直接用它的 z 坐标和 z &#x3D; k 联立：<br>$$<br>P_z(t) &#x3D; A_z + tb_z &#x3D; k<br>$$<br>于是可以求得与 z &#x3D; k 平面相交的 t：<br>$$<br>t &#x3D; \frac{k-A_z}{b_z}<br>$$<br>然后将该 t 带入光线的其他两个维度的坐标方程就可以得到 x 和 y 的坐标：<br>$$<br>x &#x3D; A_x + tb_x,\ y &#x3D; A_y+tb_y<br>$$<br>如果光线和矩形有交点，那么必须满足：<br>$$<br>x_0 &lt; x &lt; x_1 \ 且\ y_0 &lt; y &lt; y_1<br>$$<br>有了 <code>hit</code> 函数，接下来考虑一个矩形物体的包围盒，由于我们的轴对齐矩形是没有 z 方向的厚度的，这在 BVH 随机维度划分的时候会出问题，因此我们为矩形物体包围盒的 z 方向填充一个很小的长度。</p><p>一个 xy 平面的轴对齐矩形物体类的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 轴对齐矩形类aarect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AARECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AARECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xy_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xy_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// z 方向填充一个很小的长度，防止 BVH 划分出问题</span></span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, y0, k - <span class="number">0.0001</span>), <span class="built_in">point3</span>(x1, y1, k + <span class="number">0.0001</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, y0, y1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xy_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-测试光源"><a href="#4-测试光源" class="headerlink" title="4 测试光源"></a>4 测试光源</h3><p>现在我们来创建一个包含一个面光源的简单场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单光照场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">simple_light</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> difflight = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, difflight));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我们给定的光源的颜色是大于 (1, 1, 1) 的，这是为了保证光源足够亮，以照亮其他物体。</p><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sence.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            world = <span class="built_in">simple_light</span>();</span><br><span class="line">            samples_per_pixel = <span class="number">400</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">26</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">20.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight.png" alt="SimpleLight"></p><p>我们也可以使用球体作为光源：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight2.png" alt="SimpleLight2"></p><h3 id="5-其他轴对齐矩形"><a href="#5-其他轴对齐矩形" class="headerlink" title="5 其他轴对齐矩形"></a>5 其他轴对齐矩形</h3><p>现在我们增加其他两个平面的轴对齐矩形的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xz_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, k - <span class="number">0.0001</span>, z0), <span class="built_in">point3</span>(x1, k + <span class="number">0.0001</span>, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">y</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">yz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yz_rect</span>(<span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(k - <span class="number">0.0001</span>, y0, z0), <span class="built_in">point3</span>(k + <span class="number">0.0001</span>, y1, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> y0, y1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">yz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">x</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-创建-Cornell-Box"><a href="#6-创建-Cornell-Box" class="headerlink" title="6 创建 Cornell Box"></a>6 创建 Cornell Box</h3><p>有了矩形物体，我们可以创建一个著名的 Cornell Box 场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            world = <span class="built_in">cornell_box</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/CornellBox.png" alt="CornellBox"></p><p>由于光源太小，导致图片中噪声非常大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前的场景中一直缺少一个重要的元素，那就是光源，这一节我们来实现光源，这样我们之后就可以随意控制场景中的光照了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（七）背包动态规划</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-04-22T07:12:20.000Z</published>
    <updated>2022-04-22T07:13:59.335Z</updated>
    
    <content type="html"><![CDATA[<p>背包问题是动态规划中最经典的问题之一，也是机试中最常出现的问题。背包问题大体可分为九种类型。</p><p><em><span id="more"></span></em></p><h3 id="1-0-1背包问题"><a href="#1-0-1背包问题" class="headerlink" title="1 0-1背包问题"></a>1 0-1背包问题</h3><p><a href="https://www.acwing.com/problem/content/2/">AcWing02. 01背包问题</a></p><blockquote><p>有 N 件物品和一个容量是 V 的背包。每件物品<strong>只能使用一次</strong>。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p></blockquote><p>0-1 背包是最简单的背包问题，定义状态 $dp[i][curv]$ 表示将前 i 件物品放入体积为 curv 的背包所能获得的最大价值，其中 $(curv \leq V)$，对于第 i 件物品，只存在拿与不拿两种情况，如果不拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入容量为 curv 的背包中所能获得的最大价值”，于是价值为 $dp[i-1][curv]$；如果拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入剩下的容量为 curv - vi 的背包中所能获得的最大价值”，此时能获得的最大价值就是 $dp[i-1][curv-vi]$ 再加上通过放入第 i 件物品获得的价值 wi，因此状态转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv-v[i]] + w[i]);</span><br></pre></td></tr></table></figure><p>于是可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][curv] = dp[i<span class="number">-1</span>][curv];</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= volume[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i<span class="number">-1</span>][curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">ZeroOnePack</span>(volume, value, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为状态 i 至于状态 i - 1 有关，因此可以使用一维数组优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意体积必须逆序遍历，否则就需要一个额外的数组来存储上一次的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是使用一维数组的话，遍历体积 curv 的时候要从大到小遍历，因为如果从小到大遍历，那么后面需要的 <code>dp[curv - volume[i-1]] + value[i-1]</code> 就不是第 i - 1 的状态了，而是更新过的第 i 次的状态。此外遍历体积 curv 只需要遍历到当前物品的体积 <code>volume[i-1]</code> 即可，因为背包体积比当前物品体积小的话，一定装不进去，状态不需要更新，沿用前一次的状态即可。</p><p>如果将题目的要求改为<strong>必须将背包装满所能获得的最大价值</strong>，只需要修改动态规划的边界条件即可。现在的边界条件是 dp 数组全部初始化为 0 ，因为题目没有要求全部装满，只要不超过就可以，所以对于任意体积的背包，初始时都不装物品，最大价值都是 0；当要求背包必须装满时，初始化动态数组 dp 只有 $dp[0][0] &#x3D; 0$，这代表将体积为 0 的背包用一个体积为0 的物体装满获得的最大价值为 0，而其它情况都初始化为 <code>INT_MIN</code> ，这代表其他体积的背包还没有装满，不符合要求，所以获得的价值也不存在。</p><p>0-1 背包问题虽然简单，但后面几乎所有的背包问题都是 0-1 背包问题的变体，都要用到 0-1 背包的方法去解决，因此 0-1 背包是最重要的背包问题。</p><h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2 完全背包问题"></a>2 完全背包问题</h3><p><a href="https://www.acwing.com/problem/content/3/"> AcWing03. 完全背包问题</a></p><blockquote><p>有 N 种物品和一个容量是 V 的背包，每种物品都有<strong>无限件可用</strong>。第 i 种物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p></blockquote><p>完全背包问题与 0-1 背包非常相似，只是这一次每件物品可以无限次数使用，如果还按照求解 0-1 背包时的思路，定义状态 $dp[i][curv]$ 表示将前 i 种物品放入体积为 curv 的背包所能获得的最大价值，这时要求解的总状态数还是 NV 个，但求解每个状态时就不是 $O(1)$ 复杂度了，而是 $O(curv &#x2F; vi)$ 的复杂度，因为一个物体最多可以放入 curv &#x2F; vi 次。于是总复杂度就是：<br>$$<br>O(NV \times \sum{\frac{curv}{vi}} )<br>$$<br>是比较大的。因此我们要考虑对它进行一些优化，稍微试用一下贪心的思想，对于每件物品 i，如果有物品 j 比它的重量小，价值大，那么就不需要考虑物品 i 了，因为我们任何情况下都可将价值小费用高的 i 换成物美价廉的 j，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据会一件物品也去不掉。而且这个优化方案往往需要 $O(N^2)$ 的时间。</p><p>一个更好的优化方案是，首先将费用大于容量 V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，这个过程只需要 $O(V+N)$ 时间，但可能会需要额外的空间，比如借助哈希表。</p><p>一般来说，我们不需要用上面如此复杂的思路，但是经过这些推导可以加深对问题的理解。同时也说明了 0-1 背包的重要性，因为以上思路全都是基于 0-1 背包，针对完全背包问题进行优化的。</p><p>解决这个问题更直接的思路一般是转化为 0-1 背包问题，事实上大多数的背包问题都可以这样做，再一次说明了 0-1 背包有多重要。</p><p>具体思路是：因为每件物品 i 最多只能选 V &#x2F; vi 件，因此我们可以把物品 i 拆分成 V &#x2F; vi 件体积和价值完全一样的物品，然后就转化成了一个 0-1 背包问题。</p><p>这样的思路完全没有改进基本思路的时间复杂度，但这却给了我们将完全背包问题转化为 0-1 背包问题的基本思路：将一种物品拆成多件物品。</p><p>于是我们可以进一步优化，将物品 i 拆成体积为 $vi * 2^k$ ，价值为 $wi*2^k$ 的若干件物品，这里用了二进制的思想，因为不管最优策略选几件第 i 种物品，总可以表示成若干个$2^k$ 件物品的和。这样我们把物品拆成了 $O(logV &#x2F; vi)$ 件物品，是一个很大的优化。</p><p>但还有更好的方法，和 0-1 背包问题一样的 $O(NV)$ 复杂度的方法。我们只需要把 0-1 背包问题的一维数组解法遍历体积 curv 的顺序从逆序改为正序即可。之前逆序遍历是因为每件物品只能选一次，所以第 i 件物品的状态必须从没有选择第 i 件物品的状态 i - 1 得来，而现在物品 i 可以选择多次，所以第 i 种物品的状态恰好需要从已选入第 i 种物品的子结果转移而来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = volume[i<span class="number">-1</span>]; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的两种遍历顺序可以颠倒，这在特定数据量的情况下可以做出常数级别的优化。</p><p>完全背包问题也是一个简单问题，但往往简单问题才更需要深刻理解，因为复杂的问题也都只是简单问题的变体。</p><p>因为 0-1 背包和完全背包是两个最基础的背包问题，因此我们可以将这两个问题的求解方法抽象成两个函数，在之后更复杂的问题中，可能会转换成这两种问题，直接调用这两个函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3 多重背包问题"></a>3 多重背包问题</h3><p><a href="https://www.acwing.com/problem/content/4/">AcWing04. 多重背包问题 I</a></p><blockquote><p>有 N 种物品和一个容量是 V 的背包。第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p></blockquote><p>多重背包问题同样可以转化为 0-1 背包实现，只需要把物品 i 拆分成 si 件同样的物品即可，然后我们按照 0-1 背包的方法求解。因此对于每件物品，只需要增加一重循环，遍历物品数量，代表这个物品拿几次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为是基于0-1背包，所以要逆序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= amount[i<span class="number">-1</span>] &amp;&amp; curv &gt;= s * volume[i<span class="number">-1</span>]; ++s)</span><br><span class="line">                    dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - s * volume[i<span class="number">-1</span>]] + s * value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">amount</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; amount[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">MultiPack</span>(volume, value, amount, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/5/">AcWing05. 多重背包问题 II</a></p><blockquote><p>问题相同，但数据范围变为：<br>0 &lt; N ≤ 1000<br>0 &lt; V ≤ 2000<br>0 &lt; vi, wi, si ≤ 2000</p></blockquote><p>数据量过大的时候，上面的方法将物品拆分成了 si 件，复杂度太高，于是可以借鉴之前的二进制优化，将物品拆分成 $O(logsi)$ 件，具体的做法是将物品 i 拆分成系数为 $1, 2, 4, … , 2^{k-1},si-2^k+1$ 的若干件物品，其中 $si-2^k+1$ 其实就是物品总数减去之前拆分的数量总和，这样可以保证所有拆分的物品的系数加起来等于物品 i 的数量 si。例如，物品 i 的数量为 13 件，那么就拆分成系数为 1，2，4，6 的四件物品，四件物品的体积和价值为物品 i 的体积和价值乘以对应的系数。然后再利用 0-1 背包求解。另外如果物品 i 的数量 si 使得 si * vi 大于了背包总容量 V，那么问题就转化成了一个完全背包问题，因为相当于物品 i 可以在不超过背包容量的前提下无限次使用。于是可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(volume[i<span class="number">-1</span>] * amount[i<span class="number">-1</span>] &gt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CompletePack</span>(dp, volume[i<span class="number">-1</span>], value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = <span class="number">1</span>, s = amount[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">while</span>(s - k &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ZeroOnePack</span>(dp, k * volume[i<span class="number">-1</span>], k * value[i<span class="number">-1</span>], v);</span><br><span class="line">                    s -= k;</span><br><span class="line">                    k *= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, s * volume[i<span class="number">-1</span>], s * value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二进制拆分方法是求解多重背包问题的一般写法，时间复杂度较好并且不难理解。实际上多重背包问题也有 $O(NV)$ 的解法，利用了单调队列优化状态求解过程，但已经超出了常规算法的范畴，证明起来也比较困难，不在我们的讨论范围内。</p><h3 id="4-混合背包问题"><a href="#4-混合背包问题" class="headerlink" title="4 混合背包问题"></a>4 混合背包问题</h3><p><a href="https://www.acwing.com/problem/content/7/">AcWing07. 混合背包问题</a></p><blockquote><p>有 N 种物品和一个容量是 V 的背包。<br>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 sisi 次（多重背包）；</li></ul><p>每种体积是 vi，价值是 wi。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p><p>输入第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi, wi, si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><ul><li>si &#x3D; −1 表示第 i 种物品只能用1次；</li><li>si &#x3D; 0 表示第 i 种物品可以用无限次；</li><li>si &gt; 0 表示第 i 种物品可以使用 si 次；</li></ul></blockquote><p>混合背包是较为困难的背包问题，但经过前面的推导，实际上只要对三类物品分别应用上面的三个过程就可以。之前的代码都是全部读取数据后再处理，但实际上不需要全部读取，每读一件物品就可以更新一次 dp 数组了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 0-1 背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= total; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多重背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> amount, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount * volume &gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CompletePack</span>(dp, volume, value, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(amount - k &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, k * volume, k * value, total);</span><br><span class="line">                amount -= k;</span><br><span class="line">                k *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ZeroOnePack</span>(dp, amount * volume, amount * value, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="comment">// 不要求必须装满，所以初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value, amount;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value &gt;&gt; amount;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) ans.<span class="built_in">ZeroOnePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (amount == <span class="number">0</span>) ans.<span class="built_in">CompletePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> ans.<span class="built_in">MultiPack</span>(dp, volume, value, amount, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-二维费用的背包问题"><a href="#5-二维费用的背包问题" class="headerlink" title="5 二维费用的背包问题"></a>5 二维费用的背包问题</h3><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价 1 和代价 2 ，第 i 件物品所需的两种代价分别为 a[i] 和 b[i]。两种代价可付出的最大值（两种背包容量）分别为 V 和 U。物品的价值为 value[i]。</p><p>这相当于在之前的基础上费用增加了一维，所以动态规划的状态也增加一维即可，于是原来的状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>就可以改写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][cur_v][cur_u] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][cur_v][cur_u], dp[i<span class="number">-1</span>][cur_v - a[i]][cur_u - b[i]] + value[i])</span><br></pre></td></tr></table></figure><p>显然也可以不用三维数组，改用二维数组，当问题类似于 0-1 背包时，逆序遍历，类似于完全背包时，正序遍历，类似于多重背包时应用多重背包的解法。</p><p>当然，实际的题目中往往不会显式的告诉我们有两种代价，题目一般是这样描述的：</p><p><a href="https://www.acwing.com/problem/content/8/">AcWing08. 二维费用的背包问题</a></p><blockquote><p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。<br>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。</p></blockquote><p>背包能承受的最大重量就相当于增加了一个代价——重量。于是我们就要同时考虑体积和重量两种代价。按照上面的思路，只要在 0-1 背包的基础上增加一重循环，遍历重量即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">int</span> total_v, <span class="type">int</span> total_w</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= volume; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_w = total_w; cur_w &gt;= weight; --cur_w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[cur_v][cur_w] = <span class="built_in">max</span>(dp[cur_v][cur_w], dp[cur_v - volume][cur_w - weight] + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, weight, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; weight &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, volume, weight, value, v, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v][m] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-分组背包问题"><a href="#6-分组背包问题" class="headerlink" title="6 分组背包问题"></a>6 分组背包问题</h3><p><a href="https://www.acwing.com/problem/content/description/9/">AcWing09. 分组背包问题</a></p><blockquote><p>有 N 组物品和一个容量是 V 的背包。<br>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。</p></blockquote><p>同样是 0-1 背包问题的变体，只是这次的一个物品变成了一组物品，相当于我们每次拿一个物品的时候，可以用同组内的其他物品替换。因此只要遍历所有组，更新 dp 状态，在更新时遍历组内每一个物品即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GroupPack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> amount_in_group, vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> total_v</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= <span class="number">0</span>; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_index = <span class="number">0</span>; cur_index &lt; amount_in_group; ++cur_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur_v &gt;= volume[cur_index])</span><br><span class="line">                    dp[cur_v] = <span class="built_in">max</span>(dp[cur_v], dp[cur_v - volume[cur_index]] + value[cur_index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> amount;</span><br><span class="line">        cin &gt;&gt; amount;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; amount; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; volume[j] &gt;&gt; value[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">GroupPack</span>(dp, amount, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-有依赖的背包问题"><a href="#7-有依赖的背包问题" class="headerlink" title="7 有依赖的背包问题"></a>7 有依赖的背包问题</h3><p><a href="https://www.acwing.com/problem/content/10/">AcWing10. 有依赖的背包问题</a></p><p>背包问题的终极难度，对于机试、面试来说，属实没必要，碰到就算倒霉。</p><h3 id="8-背包问题求方案数"><a href="#8-背包问题求方案数" class="headerlink" title="8 背包问题求方案数"></a>8 背包问题求方案数</h3><p><a href="https://www.acwing.com/problem/content/11/">AcWing11. 背包问题求方案数</a></p><blockquote><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p></blockquote><p>求解方案数一般都要用的动态规划状态之间的递加，主要思考如何递加。除了之前的记录最大价值的数组 dp 外，再定义一个记录达到最大价值的方案数的数组 cnt，因为是 0-1 背包问题，只有两种可能的情况：</p><ul><li>选择当前物品得到的总价值比之前的价值高，即 <code>dp[curv] &lt; dp[curv-volume] + value</code>，此时最大价值的方案数和之前一样，不会发生改变，相当于用当前物品替换之前的一件物品，即 <code>cnt[curv] = cnt[curv - volume]</code></li><li>选择当前物品得到的总价值和之前的价值一样高，即 <code>dp[curv] == dp[curv-volume] + value</code>，这时达到最大价值的方案数增加了 <code>cnt[curv - volume]</code>，因为原本不超过 curv 的最大总价值方案数是 <code>cnt[curv]</code>，现在选择当前物品也可以达到这个最大价值，因此达到这个最大价值的方案总数就增加了  <code>cnt[curv - volume]</code> 种，即 <code>cnt[curv] += cnt[curv - volume]</code></li></ul><p>初始化 cnt 数组每一项都为 1， 因为每一个体积都不装物品也至少是一种方案，最后编码时记得取模即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, vector&lt;<span class="type">int</span>&gt;&amp; cnt, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[curv] &lt; dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv - volume] + value;</span><br><span class="line">                cnt[curv] = cnt[curv - volume] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[curv] == dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[curv] = (cnt[curv] + cnt[curv - volume]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(v + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, cnt, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[v] % mod &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-背包问题求具体方案"><a href="#9-背包问题求具体方案" class="headerlink" title="9 背包问题求具体方案"></a>9 背包问题求具体方案</h3><p><a href="https://www.acwing.com/problem/content/12/">AcWing12. 背包问题求具体方案</a></p><blockquote><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N</p></blockquote><p>因为要保证字典序最小，那我们就要保证编号小的物品优先选到，也就是说，假设存在一个包含第 1 个物品的最优解，为了确保字典序最小那么我们必然要选该物品。那么问题就转化成从 2～N 这些物品中找到最优解。于是状态定义应该稍作修改，<code>dp[i][curv]</code> 表示从第 i 个物品到第 n 个物品总容量为 curv 的最大价值，于是状态转移也要相应的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>显然遍历物品的次序也要变为从后向前遍历。那么如何根据结果还原出路径呢？</p><p>我们拿着背包，即总体积 V，从第一个物品开始遍历，如果 <code>dp[i][curv] == dp[i+1][curv - volume[i]] + value[i] </code>，说明选择了第 i 个物品，于是将 i 加入结果，总体积 V 减去物品 i 的体积，这样就可以还原出字典序最小的一个物品选取方案了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">0</span>; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][curv] = dp[i+<span class="number">1</span>][curv];</span><br><span class="line">            <span class="keyword">if</span>(curv &gt;= volume[i])</span><br><span class="line">                dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> curv = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curv - volume[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][curv] == dp[i+<span class="number">1</span>][curv - volume[i]] + value[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curv -= volume[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-相关题目"><a href="#10-相关题目" class="headerlink" title="10 相关题目"></a>10 相关题目</h3><h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p></blockquote><p>完全背包问题，并且背包必须被装满。唯一的区别是，这次不是求最大价值，而是求最小数量，这相当于每个硬币的体积是 coins[i]，价值都是 1，求把背包装满的最小价值，只要把 max 改为 min 即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv-coins[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求装满，初始化只有dp[0] = 0</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 完全背包，顺序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[curv - c] != INT_MAX)<span class="comment">//防止越界</span></span><br><span class="line">                    dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv - c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></h4><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中最多有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的子集 。</p></blockquote><p>经典的二维费用 0-1 背包，两种费用分别是 0 和 1 的最大数量，每个物品的价值都是 1，直接写出优化后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calone</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ones = <span class="built_in">calone</span>(s);</span><br><span class="line">            <span class="type">int</span> zeros = s.<span class="built_in">size</span>() - ones;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= zeros; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= ones; --j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h4><blockquote><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><ul><li>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</li><li>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li></ul><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量 。如果没有石头剩下，就返回 0</p></blockquote><p>题目的难点在于如何转化为背包问题，原问题相当于把石头分为两堆，使得两堆石头的差值最小，进一步可以转化为：如果所有石头的总重量是 sum，那么我们要把所有石头装入容量为 sum&#x2F;2 的背包，并使背包内石头的总重量尽可能大，最终剩下的石头的最小重量就是 sum 减去两倍的背包内石头重量。这样转化的具体思路见<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/">详解为何能转换为背包问题</a>。</p><p>转化后就是一个普通的 0-1 背包问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= stones[i]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4><blockquote><p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><p>0-1 背包问题，并且要求把背包装满，这道题只问了是否可以，因此状态转移更简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv] || dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h4><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个表达式。</p><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同表达式的数目。</p></blockquote><p>问题可以转化为将数组中的数分为两组，且两组数字的和的差值为 target。假设数组中所有数字总和为 sum，那么问题等价于将数组中的数放入容量为 (sum+target)&#x2F;2 的背包中，且必须装满的方案总数。于是就是一个简单的 0-1 背包求方案总数的问题。只要注意特殊情况的判断即可，如果 (sum+target)&#x2F;2 不是整数则无法分配，如果 target 的绝对值比数组中所有数字的总和都大也无法分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum + target;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum || total % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        total /= <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h4><blockquote><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p></blockquote><p>完全背包求方案数，且背包必须装满：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h4><blockquote><p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p></blockquote><p>由于每个数字可以使用多次，因此这也是一个完全背包求方案数问题。与上面的完全背包求方案数问题稍有不同的是，这里不同顺序代表不同的组合，也就是物品的顺序不同也代表一种不同的方案，所以对于每一个当前容积的背包 curv，把背包装满的方案数等于所有 curv-x 的背包的方案数的总和，x 是每个体积小于 curv 的物品，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= curv) dp[curv] += dp[curv - x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要改变完全背包原本的内外层遍历即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= target; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[curv] += dp[curv - x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="盈利计划"><a href="#盈利计划" class="headerlink" title="盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a></h4><blockquote><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 minProfit 利润的子集称盈利计划 。并且工作的成员总数最多为 n 。</p><p>有多少种计划可以选择？因为答案很大，所以返回结果模 10^9 + 7 的值。</p></blockquote><p>显然是一个二维费用的 0-1 背包问题，但第二个费用限制是<strong>至少</strong>产生 minProfit 的价值，与之前稍有不同，但总体思路还是完全一样的，注意对于至少产生 minProfit 的处理，非常巧妙：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(minProfit + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = group.<span class="built_in">size</span>(), MOD = (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> members = group[i - <span class="number">1</span>], earn = profit[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= members; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = minProfit; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    dp[j][k] = (dp[j][k] + dp[j - members][<span class="built_in">max</span>(<span class="number">0</span>, k - earn)]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][minProfit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;背包问题是动态规划中最经典的问题之一，也是机试中最常出现的问题。背包问题大体可分为九种类型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十三）图片纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-21T09:53:17.000Z</published>
    <updated>2022-04-21T09:57:36.800Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。</p><p><em><span id="more"></span></em></p><h3 id="1-图片纹理类"><a href="#1-图片纹理类" class="headerlink" title="1 图片纹理类"></a>1 图片纹理类</h3><p>要实现图片纹理类，我们先要读入一张图片，这可以用到一开始存图使用的轻量而强大的 <code>stb_image</code> 库，然后我们要找到纹理坐标和图片坐标的映射关系，非常简单，对于一张 M * N 的图片上的像素 (i, j)，它的纹理坐标是：<br>$$<br>u &#x3D; \frac{i}{M-1},\ v &#x3D; \frac{j}{N-1}<br>$$<br>于是可以实现一个图片纹理类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 纹理类，包含各种纹理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;perlin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 图片纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>()</span><br><span class="line">        : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">bytes_per_scanline</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        <span class="keyword">auto</span> components_per_pixel = bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        data = <span class="built_in">stbi_load</span>(</span><br><span class="line">            filename, &amp;width, &amp;height, &amp;components_per_pixel, components_per_pixel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load texture image file &#x27;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">            width = height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_per_scanline = bytes_per_pixel * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">image_texture</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有图片的话返回一个固定的颜色，便于debug</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入的纹理坐标截断在[0,1]区间</span></span><br><span class="line">        u = <span class="built_in">clamp</span>(u, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 由于图片是从上到下存储的，相当于原点在左上角，而纹理坐标原点在左下角，因此纵坐标要翻转一下</span></span><br><span class="line">        v = <span class="number">1.0</span> - <span class="built_in">clamp</span>(v, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">        <span class="comment">// 纹理坐标映射到图片坐标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(u * width);</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(v * height);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= width)  i = width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= height) j = height - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们返回的颜色都在[0,1]之间，因此要除以255</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> pixel = data + j * bytes_per_scanline + i * bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale * pixel[<span class="number">0</span>], color_scale * pixel[<span class="number">1</span>], color_scale * pixel[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="type">int</span> bytes_per_scanline;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-测试效果"><a href="#2-测试效果" class="headerlink" title="2 测试效果"></a>2 测试效果</h3><p>新建一个场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地球</span></span><br><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string TexturePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(TexturePath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并对应修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> sence = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        world = <span class="built_in">earth</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/Earth.png" alt="Earth"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十二）Perlin噪声</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/</id>
    <published>2022-04-19T12:48:53.000Z</published>
    <updated>2022-04-19T13:01:37.621Z</updated>
    
    <content type="html"><![CDATA[<p>噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。</p><p><em><span id="more"></span></em></p><h3 id="1-Perlin-噪声原理"><a href="#1-Perlin-噪声原理" class="headerlink" title="1 Perlin 噪声原理"></a>1 Perlin 噪声原理</h3><p>Perlin 噪声的产生是由于，如果我们用完全随机的噪声，比如白噪声，生成的纹理或者效果会显得非常不自然，因为很多真实世界中看似没有规律的事物，实际上是存在一定规律的，只是看起来是杂乱无章的。因此 Perlin 噪声诞生了，Perlin 噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影、动画等多媒体领域广泛应用。在游戏领域，Perlin 噪声可以用于生成波形，起伏不平的材质或者纹理。Perlin 噪声绝大部分应用在二维，三维层面上，但某种意义上也能拓展到四维。Perlin 噪声在一维层面上可用于卷轴地形、模拟手绘线条等，在二维或三维上用于生成随机地形，火焰燃烧特效，水和云等等。如果将 Perlin 噪声拓展到四维层面，即 w 轴代表时间，就能利用 Perlin 噪声生成动画。</p><p>Perlin噪声实现需要三个步骤：</p><ul><li>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量。所谓“伪随机”是指，对于给定的输入得到的值是一样的，因此并不是真正的随机。但并不影响效果，因为只要相同的值离得足够远，就看不出来是伪随机。对于二维的 Perlin 噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</li><li>输入一个点（二维的话就是二维坐标，三维就是三维坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到二维下 4 个，三维下 8 个点乘结果。</li><li>使用缓和曲线（ease curves）来计算它们的权重和。在原始的 Perlin 噪声实现中，缓和曲线是 $s(t)&#x3D;3t^2−2t^3$，在2002年的论文中，Perlin 改进为 $s(t)&#x3D;6t^5−15t^4+10t^3$。</li></ul><blockquote><p>这里简单解释一下，为什么不直接使用线性插值，即 $s(t) &#x3D; t$。直接使用的线性插值的话，它的一阶导在晶格顶点处（即 t &#x3D; 0 或 t &#x3D; 1）不为 0，会造成明显的不连续性。 $s(t)&#x3D;3t^2−2t^3$ 在一阶导满足连续性， $s(t)&#x3D;6t^5−15t^4+10t^3$ 在二阶导上仍然满足连续性。</p></blockquote><p>下图描述了前两个步骤：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/20151218110535114.png" alt="20151218110535114"></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>我们从简到繁一步一步实现 Perlin 噪声，首先实现一个简化版本。Perlin 噪声函数实际上就是对于一个给定的输入点，输出一个 double 类型的噪声值，这个值是伪随机的，也就是说对于相同的给定点，得到的值会是一样的。因此我们实现一个 Perlin 噪声类，在类中根据以上步骤计算噪声值。</p><p>在具体实现中，我们使用 256 个晶格，但是先不去计算每个晶格顶点的随机梯度向量，也不去计算给定的点和周围八个晶格顶点的距离向量和随机梯度向量的点乘，我们直接随机生成这些点乘结果存在一个查找表中（只是这样理解，因为点乘也只是一个数字而已，但实际上这是一种并不正确的简化，之后会正确的实现），然后根据给定点的坐标去查找点乘结果，然后将这些点乘结果利用三线性插值结合起来。</p><p>在查找的时候，我们预先计算一个随机排列数组 P[n]，P[n] 里面存储的是打乱后的 0-255 的排列值，然后我们根据给定点的坐标作为索引，到 P[n] 中找到一个 0-255 的下标，用这个下标取到查找表中对应的点乘结果。对于三维空间，我们要分别计算三个维度的 P[n] 数组，然后将三个下标值加起来并限制在  0~255 的范围，再去查找对应的点乘结果，作为一个顶点的点乘，这样查找八次即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机点乘结果</span></span><br><span class="line">        ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">        <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranfloat[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span>* ranfloat;   <span class="comment">// 存储随机点乘结果的查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">trilinear_interp</span><span class="params">(<span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    accum += (i * u + (<span class="number">1</span> - i) * (<span class="number">1</span> - u)) *</span><br><span class="line">                    (j * v + (<span class="number">1</span> - j) * (<span class="number">1</span> - v)) *</span><br><span class="line">                    (k * w + (<span class="number">1</span> - k) * (<span class="number">1</span> - w)) * c[i][j][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3 测试效果"></a>3 测试效果</h3><p>然后我们创建一个 Perlin 噪声纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再创建一个新场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后修改主函数部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        world = <span class="built_in">two_perlin_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise.png" alt="PerlinNoise"></p><h3 id="4-改进实现"><a href="#4-改进实现" class="headerlink" title="4 改进实现"></a>4 改进实现</h3><p>接下来我们改进上面的简化版实现，首先是插值系数，我们使用 $s(t)&#x3D;6t^5−15t^4+10t^3$ 来改进插值系数，在 Perlin 类中加一个 <code>fade</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>noise</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">    <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">    <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">    <span class="comment">// 使用fade函数修改插值系数</span></span><br><span class="line">    u = <span class="built_in">fade</span>(u);</span><br><span class="line">    v = <span class="built_in">fade</span>(v);</span><br><span class="line">    w = <span class="built_in">fade</span>(w);</span><br><span class="line">    <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">    <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                c[di][dj][dk] = ranfloat[</span><br><span class="line">                perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">            ];</span><br><span class="line">    <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise2-16503697126921.png" alt="PerlinNoise2"></p><p>可以看出一些随机效果，但是频率太低了，我们可以为纹理加上一个频率属性，控制随机的频率，这可以通过对传入 <code>noise</code> 函数的顶点值 p 进行缩放实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景中的纹理，给定一个缩放系数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise3.png" alt="PerlinNoise3"></p><p>最后我们来实现真正的 Perlin 噪声函数，现在只要将随机生成的点乘结果，变为随机生成梯度向量，然后和点 p 到八个晶格顶点的距离向量做点乘，再利用三线性插值融合点乘结果即可。为此我们需要修改 Perlin 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机梯度向量</span></span><br><span class="line">        ranvec = <span class="keyword">new</span> vec3[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranvec[i] = <span class="built_in">normalize</span>(<span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranvec;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量</span></span><br><span class="line">        vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个随机梯度向量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranvec[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 用八个梯度向量和距离向量点乘并线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">perlin_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    vec3* ranvec;       <span class="comment">// 存储随机梯度向量查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将八个顶点的梯度向量和点p到八个顶点的距离向量点乘，并做三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过改进的线性插值系数</span></span><br><span class="line">        <span class="keyword">auto</span> uu = <span class="built_in">fade</span>(u);</span><br><span class="line">        <span class="keyword">auto</span> vv = <span class="built_in">fade</span>(v);</span><br><span class="line">        <span class="keyword">auto</span> ww = <span class="built_in">fade</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u - i, v - j, w - k)</span></span>;</span><br><span class="line">                    accum += (i * uu + (<span class="number">1</span> - i) * (<span class="number">1</span> - uu))</span><br><span class="line">                        * (j * vv + (<span class="number">1</span> - j) * (<span class="number">1</span> - vv))</span><br><span class="line">                        * (k * ww + (<span class="number">1</span> - k) * (<span class="number">1</span> - ww))</span><br><span class="line">                        * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓和曲线，用于缓和线性插值系数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>按照这样的实现，由于向量点乘可能为负，因此 <code>noise</code> 函数输出的值可能为负，这样得到的颜色值就可能为负，最后进行伽马校正的时候我们要开根号，就会得到不正确的值。所以我们要在纹理类中将得到的噪声值从 [-1, 1] 映射到 [0, 1]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到的noise值范围是[-1,1]，防止颜色为负，映射到[0,1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1.0</span> + noise.<span class="built_in">noise</span>(scale * p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后看一下真正的 Perlin 噪声的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise4.png" alt="PerlinNoise4"></p><h3 id="5-Turbulence"><a href="#5-Turbulence" class="headerlink" title="5 Turbulence"></a>5 Turbulence</h3><p>将多个不同频率的噪声混合起来得到的噪声称为 Turbulence，利用 Turbulence 可以实现许多随机纹理，我们可以通过多次调用 <code>noise</code> 函数并将结果融合来得到 Turbulence。在 Perlin 类中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个noise组合形成turbulence</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">int</span> depth = <span class="number">7</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> temp_p = p;</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">        accum += weight * <span class="built_in">noise</span>(temp_p);</span><br><span class="line">        weight *= <span class="number">0.5</span>;</span><br><span class="line">        temp_p *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改噪声纹理类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于turb函数对最终融合的噪声取了绝对值，这里不需要再做任何映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">turb</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise5.png" alt="PerlinNoise5"></p><h3 id="6-大理石纹理"><a href="#6-大理石纹理" class="headerlink" title="6 大理石纹理"></a>6 大理石纹理</h3><p>一般来说，Turbulence 不会像上面那样直接使用。而是会作为一个随机扰动来生成不同的纹理，比如大理石纹理。我们可以让点 p 的某一维度和三角函数成正比，这样就可以模拟大理石的裂痕曲线，但是为了不让曲线有规律，我们使用 Turbulence 来改变三角函数的相位，这样就可以实现一个随机的大理石纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大理石纹理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise6.png" alt="PerlinNoise6"></p><p>如果我们把点 p 和三角函数成正比的维度改为 y 轴，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise7.png" alt="PerlinNoise7"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十一）纹理</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/</id>
    <published>2022-04-18T12:48:03.000Z</published>
    <updated>2022-04-18T12:59:48.661Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。</p><p><em><span id="more"></span></em></p><h3 id="1-实现纯色纹理"><a href="#1-实现纯色纹理" class="headerlink" title="1 实现纯色纹理"></a>1 实现纯色纹理</h3><p>纯色纹理的实现非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯色纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">solid_color</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">solid_color</span>(color c) : <span class="built_in">color_value</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue)</span><br><span class="line">        : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red, green, blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    color color_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来要更新 <code>hit_record</code> ，存储交点的纹理坐标：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">double</span> u;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">double</span> v;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-计算纹理坐标"><a href="#2-计算纹理坐标" class="headerlink" title="2 计算纹理坐标"></a>2 计算纹理坐标</h3><p>对于球体来说，计算纹理坐标其实就是把球面上每一个点映射到纹理平面 uv 上。最简单的表示一个球面上的点的方法是用方位角 $\phi$ 和俯仰角 $\theta$，由于 uv 平面的范围是 [0, 1]，所以映射关系为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200148322.png" alt="image-20220418200148322"></p><p>给定方位角和俯仰角，可以计算球心在原点的单位球面上的一点：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200253256.png" alt="image-20220418200253256"></p><p>于是我们可以通过光线和球面的交点坐标解出方位角和俯仰角然后映射为纹理坐标。根据以上公式可以看出俯仰角 $\theta &#x3D; arccos(-y)$，方位角 $\phi &#x3D; arctan(-z &#x2F; x)$，反三角函数计算可以直接使用 <code>&lt;cmath&gt;</code> 提供的函数 <code>acos</code> 和 <code>atan2</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(z, -x);</span><br></pre></td></tr></table></figure><p>但是 <code>atan2</code> 返回的值的范围是 $[-\pi, \pi]$ ，并且是从 0 到 $\pi$，再从 $-\pi$ 到 0，这样映射的话，纹理坐标 u 就会是从 0 到 1&#x2F;2，再从 -1&#x2F;2 到 0，是不对的，但是可以利用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atan2</span>(a, b) == <span class="built_in">atan2</span>(-a, -b) + pi;</span><br></pre></td></tr></table></figure><p> 这个公式返回的是从 0 到 $2\pi$ 的连续值，就可以映射为正确的纹理坐标了。因此可以通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(-z, x) + pi;</span><br></pre></td></tr></table></figure><p>得到正确的方位角和俯仰角，然后映射得到纹理坐标。在球体类中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算给定球面上的点p的纹理坐标，p是圆心在原点的单位球面上的坐标，一般用归一化的法线</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">        u = phi / (<span class="number">2</span> * pi);</span><br><span class="line">        v = theta / pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时更新球体的 <code>hit</code> 函数，将纹理坐标记录到 <code>hit_record</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-为材质类添加纹理"><a href="#3-为材质类添加纹理" class="headerlink" title="3 为材质类添加纹理"></a>3 为材质类添加纹理</h3><p>现在我们可以为所有的材质增加纹理，代替之前的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-格子纹理"><a href="#4-格子纹理" class="headerlink" title="4 格子纹理"></a>4 格子纹理</h3><p>我们利用两种纹理交替形成一个格子纹理，这是一种经典的生成格子纹理的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格子纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; _even, shared_ptr&lt;texture&gt; _odd)</span><br><span class="line">        : <span class="built_in">even</span>(_even), <span class="built_in">odd</span>(_odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(color c1, color c2)</span><br><span class="line">        : <span class="built_in">even</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c1)), <span class="built_in">odd</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5 测试效果"></a>5 测试效果</h3><p>我们把随机场景中的地面的球体改为格子纹理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>得到的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/CheckerTexture.png" alt="CheckerTexture"></p><h3 id="6-新的场景"><a href="#6-新的场景" class="headerlink" title="6 新的场景"></a>6 新的场景</h3><p>接下来我们构建一个新的场景，由于之后我们可能还会有其他场景，为了便于管理，我们新建一个 <code>sence.h</code> 来存放各种场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个球体场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/TwoSphere.png" alt="TwoSphere"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（十）实现BVH</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/</id>
    <published>2022-04-18T11:23:08.000Z</published>
    <updated>2022-04-18T12:54:51.151Z</updated>
    
    <content type="html"><![CDATA[<p>这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的<strong>层次包围盒（BVH）</strong>去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>。</p><p><em><span id="more"></span></em></p><h3 id="1-轴对齐包围盒（AABB）"><a href="#1-轴对齐包围盒（AABB）" class="headerlink" title="1 轴对齐包围盒（AABB）"></a>1 轴对齐包围盒（AABB）</h3><p>构建 BVH 首先需要我们实现一个轴对齐包围盒类，并实现光线和 AABB 的交点计算。在图形学中我们学过计算光线和 AABB 三对平面的交点只需要用一个维度的坐标计算即可，因此我们只需要存储三对平面的坐标，这里的坐标是指一个数字，因为 AABB 是轴对齐的，因此一对平面可以表示为：<br>$$<br>x &#x3D; x_0 ,\ x&#x3D;x_1<br>$$<br>的形式，所以只需要用六个数字就可以表示一个轴对齐包围盒。</p><p>于是我们计算出光线和三对平面的交点 tmin 和 tmax ，然后用三对 tmin 和 tmax 判断光线是否和 AABB 有交点。判断方法也在图形学中有学过，这里不再赘述。</p><p>需要注意的是在实现中因为我们是用单独一个维度坐标计算的，那就有可能出现分母为 0 的情况，好消息是只要光线的起点不在两对平面之间，即使分母为 0 ，那么得到的 tmin 和 tmax 就会是同样为正无穷或者负无穷，因为计算机中 0 只是一个很小的有符号浮点数。所以我们可以使 tmin 永远为二者中较小的，tmax 永远为二者中较大的，就可以得到正确的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    轴对齐包围盒类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 minslab;</span><br><span class="line">    point3 maxslab;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; m1, <span class="type">const</span> point3&amp; m2) &#123; minslab = m1; maxslab = m2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> minslab; &#125;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> maxslab; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            tmin = <span class="built_in">fmax</span>(tmin, t0);</span><br><span class="line">            tmax = <span class="built_in">fmin</span>(tmax, t1);</span><br><span class="line">            <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>一个更稳定的 <code>hit</code> 函数的实现方式是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的图形学中推导光线和 AABB 有交点的时候，得出的条件是 <code>tmax &gt; tmin</code> 且 <code>tmax &gt;= 0</code>，但是在上面的代码中我们并没有考虑是否满足 <code>tmax &gt;= 0</code>，这是因为这里的 <code>hit</code> 函数的 <code>tmin</code> 和 <code>tmax</code> 是作为参数给定的，我们在传入参数的时候就会保证得到的交点的 t 值一定是大于 0 的。</p><h3 id="2-计算-BoundingBox"><a href="#2-计算-BoundingBox" class="headerlink" title="2 计算 BoundingBox"></a>2 计算 BoundingBox</h3><p>现在需要为物体类 <code>hittable</code> 添加一个计算物体 BoundingBox 的方法，并在不同的物体中有不同的实现，该函数返回 bool 类型，因为不是所有物体都能有 BoundingBox ，比如一个无限大的平面。此外对于移动的物体，需要 BoundingBox 能够覆盖所有时刻物体所在的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aabb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后实现球体的 <code>bounding_box</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> _time0, <span class="type">double</span> _time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>surrounding_box</code> 函数在 <code>aabb.h</code> 中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个包围盒形成一个大的包围盒</span></span><br><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small, big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现物体列表 <code>hittable_list</code> 的包围盒计算，思路是计算每个物体的包围盒，然后利用 <code>surrounding_box</code> 函数合并这些包围盒形成整个场景的包围盒：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现-BVH-树"><a href="#3-实现-BVH-树" class="headerlink" title="3 实现 BVH 树"></a>3 实现 BVH 树</h3><p>在图形学中我们学过，BVH 树的中间节点只存储包围盒，叶子节点存储物体，因此我们可以实现一个 BVH 节点类，每个 BVH 节点的孩子节点可以是另外的 BVH 节点或者是场景中的物体，同时每个 BVH 节点也需要计算和光线的交点，因此我们可以让 BVH 节点类也继承于 <code>hittable</code> 基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BVH类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>();</span><br><span class="line">    <span class="comment">// 可以通过hittable_list来构建BVH</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(<span class="type">const</span> hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造BVH树</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">        <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 孩子节点可以是其他的BVH节点也可以是物体</span></span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    <span class="comment">// 如果和左子树中有交点，要更新t_max，使得最终的交点是最近的交点</span></span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>比较复杂的是构建 BVH 树，我们在构造函数中构造整个 BVH 树，对于给定的物体列表，我们将其按照某一方向（x，y，z随机选择）排序，然后一分为二，一部分放到左子树，一部分放到右子树，因此这是一个类似于二分的递归过程。当物体列表中只有两个物体的时候，左右子树各放一个物体，当只有一个物体的时候，我们把这个物体复制一份，同时放到左右子树中，这样可以保证整个 BVH 树是一个完全二叉树，并且所有非叶子节点都一定有两个孩子节点，可以方便我们之后的处理，不需要判断孩子节点是否存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 不要修改原来的物体列表</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects;</span><br><span class="line">    <span class="comment">// 随机选择一个划分方向，并传递相应的比较函数指针</span></span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                    : box_z_compare;</span><br><span class="line">    <span class="comment">// 区间内的物体数量</span></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">// 只有一个物体，同时放到两个孩子节点</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个物体，左右孩子结点各一个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start + <span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start + <span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个物体递归的进行划分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先按照指定的维度进行排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span / <span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的box由左右两个子树的box的合并而来</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_left)</span><br><span class="line">        || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">        )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面用到了 <code>random_int</code> 函数，在 <code>utilities.h</code> 中增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成[min,max]之间的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及自定义的比较函数，我们根据不同的方向，按照物体或者 BVH 节点的包围盒位置从小到大排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的&lt;strong&gt;层次包围盒（BVH）&lt;/strong&gt;去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记&lt;a href=&quot;https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/&quot;&gt;【计算机图形学】（十一）Whitted 风格光线追踪&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（九）运动模糊</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/</id>
    <published>2022-04-17T06:15:22.000Z</published>
    <updated>2022-04-17T06:17:08.858Z</updated>
    
    <content type="html"><![CDATA[<p>从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。</p><p><em><span id="more"></span></em></p><h3 id="1-运动模糊实现原理"><a href="#1-运动模糊实现原理" class="headerlink" title="1 运动模糊实现原理"></a>1 运动模糊实现原理</h3><p>在实际拍照的时候，运动模糊是由于在快门时间内，物体的位置发生了变化，使得一个像素融合了物体在不同位置的颜色，从而产生模糊的效果。快门时间是指从快门开启到快门关闭的这段时间。因此我们也可以加入快门时间这一概念，在投射光线的时候，随机在快门时间内投射一条光线，并且保证场景内的物体在该时间下在它应该在的位置即可。这样就可以让一个像素融合物体在多个位置的颜色，产生运动模糊效果。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>根据以上原理，我们首先要为每一条光线加上一个时间属性，说明这条光线是在什么时刻被投射出的，然后就可以根据这个时刻找到该时刻场景中物体的位置，再去计算交点等后续步骤。修改 <code>ray.h</code> 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    光线类ray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time = <span class="number">0.0</span>) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;    <span class="comment">// 光线被投射出的时刻</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改相机类，使它能够在给定快门时间内随机投射光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist,  <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">        <span class="type">double</span> _time0 = <span class="number">0</span>,  <span class="comment">// 快门开启时间</span></span><br><span class="line">        <span class="type">double</span> _time1 = <span class="number">0</span>   <span class="comment">// 快门关闭时间</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 快门时间</span></span><br><span class="line">        time0 = _time0;</span><br><span class="line">        time1 = _time1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦，并在快门时间内随机选择一个时刻作为该光线投射出的时刻</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset, </span><br><span class="line">            <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">    <span class="type">double</span> time0;</span><br><span class="line">    <span class="type">double</span> time1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后还要记得修改材质类中构造散射光线的地方，散射光线的时刻和入射光线一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后修改场景中的物体类，使其能够随时间移动，目前我们只有球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">    支持移动，time0时球心在center0，time1时球心在enter1，线性移动</span></span><br><span class="line"><span class="comment">    不移动的球体可以将初始位置和结束位置设为相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(</span><br><span class="line">        point3 cen0, point3 cen1, <span class="type">double</span> _time0, <span class="type">double</span> _time1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">        : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到物体在某一时刻的球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time1 - time0 == <span class="number">0</span>) <span class="keyword">return</span> center0;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>修改主函数，还是用随机构建的场景，但是球体的初始化要用新的方法，同时为了渲染快一些，我们还是用之前的 16 : 9 的 400 * 225 的分辨率，每个像素采样 100 根光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>,  <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\The Next Week\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MotionBlur.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/MotionBlur.png" alt="MotionBlur"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（八）构建随机场景</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/</id>
    <published>2022-04-16T13:41:00.000Z</published>
    <updated>2022-04-17T05:52:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。</p><p><em><span id="more"></span></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.75</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;final.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/FinalRender2.png" alt="FinalRender2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（七）景深效果</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/</id>
    <published>2022-04-16T12:28:52.000Z</published>
    <updated>2022-04-17T06:17:32.688Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。</p><p><em><span id="more"></span></em></p><h3 id="1-更强大的相机"><a href="#1-更强大的相机" class="headerlink" title="1 更强大的相机"></a>1 更强大的相机</h3><p>到目前为止我们的相机基本上还是固定的，我们希望能够让相机更强大一些。比如可以调节视场角大小以扩充我们的视野，以及能够移动相机，从不同的角度观察整个场景。</p><h4 id="1-1-自定义视场"><a href="#1-1-自定义视场" class="headerlink" title="1.1 自定义视场"></a>1.1 自定义视场</h4><p>对于视场角，一般使用垂直视场角，我们将视场角加到相机类的构造函数中，通过视场角和宽高比来计算视口尺寸，这是一个简单的几何计算：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.14-cam-view-geom.jpg" alt="fig-1.14-cam-view-geom"></p><p>我们假设视口平面在 z &#x3D; -1 处，于是视口的高度 h 即为：<br>$$<br>h &#x3D; tan(\frac{\theta}{2})<br>$$<br>由此我们可以修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">    <span class="built_in">camera</span>(<span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="1-2-自定义指向和位置"><a href="#1-2-自定义指向和位置" class="headerlink" title="1.2 自定义指向和位置"></a>1.2 自定义指向和位置</h4><p>接下来我们希望摄像机能在任何位置任何角度观察场景。首先回顾之前图形学中学习的如何固定一个相机位置和姿态，我们需要一个位置、观察方向，以及一个 up 向量，这个 up 向量指定了相机旋转的角度，然后我们要根据这些值来计算在这个对应的角度下视口平面是怎样的，这可以通过两次叉乘得到：</p><ul><li>up 向量和观察方向 w 叉乘得到视口平面 u 方向</li><li>u 方向和 w 方向叉乘得到视口平面 v 方向</li></ul><p>其中观察方向 w 可以通过给定的相机位置 lookfrom 和要观察的点 lookat 得到，我们沿着 -w 方向观察，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.16-cam-view-up.jpg" alt="fig-1.16-cam-view-up"></p><p>于是我们可以继续修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(point3 lookfrom, point3 lookat, vec3 vup, <span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        <span class="keyword">auto</span> w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        <span class="keyword">auto</span> u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        horizontal = viewport_width * u;</span><br><span class="line">        vertical = viewport_height * v;</span><br><span class="line">        <span class="comment">// 视口平面左下角点</span></span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s * horizontal + t * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;CameraView.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>), point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraView.png" alt="CameraView"></p><p>调整视场角为 30 度，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraViewTiny.png" alt="CameraViewTiny"></p><h3 id="2-散焦模糊"><a href="#2-散焦模糊" class="headerlink" title="2 散焦模糊"></a>2 散焦模糊</h3><p>之前我们投射光线都假设相机的镜头是一个只容纳一根光线的针孔，一根光线投射出去会打到场景中的一个点，但实际相机的镜头是一个透镜，透镜会将场景中多束光线汇聚到一个点上，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/20200301194134436.png" alt="20200301194134436"></p><p>对于树的顶点P，其传入到成像屏幕的范围，从之前的一条光线，扩大到 L1 到 L2 两条光线之间的部分，尽管采样的光线变多了，但并不影响这一棵树的清晰成像，因为目前这棵树到相机的距离，刚好是新的屏幕到相机的距离，即焦点距离。焦点距离不等同于焦距，焦距是投影点到图像平面的距离。</p><p>但是如果我们的相机向前移动一点，原本能采样到树顶的像素颜色，变成了多条光线采样值的混合色，也就是树顶部下面一片区域的颜色，从而导致这个像素变模糊，越往前移动，越模糊，因为 L1 和 L2 的区间会扩大更多；而如果我们的相机向后移动一点，并延长光线L1 和 L2 至树的纵切平面，则会采样天空和树头顶的颜色的混合色，同样实现模糊。越往后，L1 和 L2 的区间将会扩大，从而越模糊。</p><p>因此，只要物体到相机的距离不等于焦点距离，就会出现模糊，光圈越大，采样射线的跨度越大，模糊效果越明显，这就是散焦模糊的原理。我们为了简单的模拟这一过程，可以将原本相机位置的一个点，变为相机所在位置为中心的一个圆盘内的点，然后从圆盘内的多个点出发，投射光线到场景中并采样求平均，就可以实现上述镜头景深的效果。</p><p>首先先增加一个生成单位圆盘内随机点的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成单位圆盘内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改相机类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist   <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后修改相机参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom - lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur.png" alt="DefoucsBlur"></p><p>减小光圈将会降低模糊：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> aperture = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur1.0.png" alt="DefoucsBlur1.0"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（六）电介质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/</id>
    <published>2022-04-16T09:29:46.000Z</published>
    <updated>2022-04-17T06:32:06.329Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。</p><p><em><span id="more"></span></em></p><h3 id="1-折射光线"><a href="#1-折射光线" class="headerlink" title="1 折射光线"></a>1 折射光线</h3><p>之前在图形学中我们知道，Snell‘s law 描述了折射光线和入射光线之间存在关系：<br>$$<br>\eta·sin\theta &#x3D; \eta’·sin\theta’<br>$$<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/fig-1.13-refraction.jpg" alt="fig-1.13-refraction"></p><p>所以求解折射光线就是求解折射角 $\theta’$，$\theta’$ 是折射光线 $R’$ 和法线的夹角，我们可以把  $R’$ 分解为垂直于法线的分量和平行于法线的分量 ：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220435357.png" alt="image-20220416220435357"></p><p>然后可以根据两个分量的计算公式得到折射光线：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220421971.png" alt="image-20220416220421971"></p><p>其中 $cos\theta$ 可以通过归一化的入射光线和法线的点乘得到，因此垂直分量可以改写为：<br>$$<br>R’_{perp} &#x3D; \frac{\eta}{\eta’}(R + (-R·n) \ n)<br>$$<br>由此我们可以编写一个计算折射光线的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算折射光线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">refract</span><span class="params">(<span class="type">const</span> vec3&amp; R, <span class="type">const</span> vec3&amp; n, <span class="type">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-R, n), <span class="number">1.0</span>);</span><br><span class="line">    vec3 r_out_perp = etai_over_etat * (R + cos_theta * n);</span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.<span class="built_in">length_squared</span>())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-电介质材质"><a href="#2-电介质材质" class="headerlink" title="2 电介质材质"></a>2 电介质材质</h3><p>有了折射光线计算，我们可以实现一个只计算折射光线的电介质材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景，将中间和左边的球体材质更换为电介质，设置折射率为1.5，模拟玻璃材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract.png" alt="Refract"></p><p>这看起来显然是不对的，因为我们现在只计算了折射光线，但是当介质折射率较大的时候，有可能存在无法发生折射的情况，也就是 $\theta’$ 无解，比如上面的玻璃，折射率为 1.5，那么：<br>$$<br>sin\theta’ &#x3D; \frac{1.5}{1}sin\theta<br>$$<br>可能出现 $sin\theta’$ 大于 1 的情况，此时不会发生折射，这个现象我们在图形学中也有学过。</p><p>因此我们需要在材质的散射函数中做一个判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 折射</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是修改我们的电介质材质类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract)</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改场景中的材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract1.png" alt="Refract1"></p><h3 id="3-加入菲涅尔项"><a href="#3-加入菲涅尔项" class="headerlink" title="3 加入菲涅尔项"></a>3 加入菲涅尔项</h3><p>现在为电介质材质加入菲涅尔项，使其随着观察角度变化发生更多的反射，依然使用 Schlick’s 近似计算菲涅尔项，修改后的最终材质类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们现在实现的电介质材质类是简化后的版本，光线打到物体上要么发生反射，要么发生折射，我们并没有同时考虑折射光线和反射光线。</p><h3 id="4-空心玻璃球"><a href="#4-空心玻璃球" class="headerlink" title="4 空心玻璃球"></a>4 空心玻璃球</h3><p>对于玻璃球来说，如果使用负半径，几何形状不受影响，但表面法线指向内（可以回顾球体类中 <code>hit</code> 方法的实现）。这可以作为一个气泡来制作一个中空的玻璃球：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.4</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure><p>我们向场景中左边球体内加了一个同心半径为负的球体，使它们构成了一个空心玻璃球，渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/RefractHollow.png" alt="RefractHollow"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（五）金属材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/</id>
    <published>2022-04-16T07:25:48.000Z</published>
    <updated>2022-04-16T08:30:17.884Z</updated>
    
    <content type="html"><![CDATA[<p>这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。</p><p><em><span id="more"></span></em></p><h3 id="1-材质抽象类"><a href="#1-材质抽象类" class="headerlink" title="1 材质抽象类"></a>1 材质抽象类</h3><p>材质简单来说需要做两件事情：</p><ul><li>描述光现在材质表面如何散射（或者说如何被吸收）</li><li>如果发生散射描述光线如何衰减</li></ul><p>因此对于所有材质都要有一个产生散射光线的函数。所以我们可以先定义一个材质抽象类，然后让具体的材质去实现不同的产生散射光线的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>之后我们的渲染流程变为，投射光线到场景中计算和场景中所有物体最近的交点并记录下来，这个记录要有交点的位置、法线等信息，现在还要加上物体的材质信息，这样在之后才能利用该材质产生散射光线，然后计算颜色。因此我们先修改记录交点的结构体，并将该结构体移入 <code>material.h</code> 头文件中避免循环引用，在结构体声明之前加上 <code>class material</code> 告诉该结构体 material 这个类，不然会找不到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改物体类，为每个物体也加上材质，并在 <code>hit</code> 函数中把材质传递给上面的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r, shared_ptr&lt;material&gt; m) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;                  <span class="comment">// 球心</span></span><br><span class="line">    <span class="type">double</span> radius;                  <span class="comment">// 半径</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">// 物体材质</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-实现漫反射材质"><a href="#2-实现漫反射材质" class="headerlink" title="2 实现漫反射材质"></a>2 实现漫反射材质</h3><p>现在可以实现各种材质派生类了，先把上一节中的漫反射材质封装在类中，首先是 Lambertian 材质，可以理解为它以发生散射并以反射率 R 衰减，也可以理解为发生散射但不衰减，只是吸收了 1-R 的光线，上一节中我们把反射率直接固定了 rgb 都等于 0.5 ，但在材质类中反射率应该可以自定义。我们直接把上一节中的实现拿来组织成一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的实现中还有一个问题，如果随机生成的方向和法线方向刚好相反，这两个向量的和将为 0 ，这将会导致散射方向为 0 ，进而使渲染出来的场景出现问题。因此我们需要阻止这种情况发生，我们在 <code>vec3</code> 类中增加一个判断向量是否接近 0 的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">near_zero</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有维度都接近 0 则返回 true</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(e[<span class="number">0</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">1</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">2</span>]) &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在材质类中的散射函数中增加判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后顺便实现另外两种散射方法的漫反射材质，在半球采样不需要考虑散射方向为 0 的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单位球体内部采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_insphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_insphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在半球采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_hemisphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_hemisphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-实现金属材质"><a href="#3-实现金属材质" class="headerlink" title="3 实现金属材质"></a>3 实现金属材质</h3><h4 id="3-1-镜面反射"><a href="#3-1-镜面反射" class="headerlink" title="3.1 镜面反射"></a>3.1 镜面反射</h4><p>金属材质因为足够光滑，因此光线会在表面发生完美的镜面反射，因此金属材质的散射方向就是入射光线的镜面反射方向，首先我门要考虑如何求镜面反射方向，这在图形学中已经学过，但在我们的实现稍微有些不同，我们的代码中入射光线（从像素投射的光线）是指向表面的（之前都是从表面向外指的）：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.11-reflection.jpg" alt="fig-1.11-reflection"></p><p>入射光线方向为 $\vec v$ ，法线为 $\vec n$，则反射方向为 $\vec v + 2\vec b$，$\vec b$ 和法线同方向，长度为 $\vec v$ 在法线方向的投影，因此镜面反射光线为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 镜面反射方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="number">2</span> * <span class="built_in">dot</span>(-v, n) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设传入该函数的都是单位向量，所以 $\vec v$ 在法线方向的投影就可以表示成点乘。</p><p>然后就可以定义金属材质类了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数，让它使用材质类计算颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改主函数，向场景中加入各种材质的物体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Metal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Metal.png" alt="Metal"></p><p>随着场景变得复杂，我们现在的算法又暴露出一个小问题，噪声过大，这是因为使用了俄罗斯轮盘赌算法，我们现在的生存概率是 0.8，也就说当光线第一次打到物体上的时候就会有 0.2 概率返回 0 颜色，所以会产生很多噪点。因此我们可以先让光线至少弹射几次，之后再应用俄罗斯轮盘赌算法终止递归。为了方便之后修改，可以将生存概率和最少弹射次数作为可修改参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数中设定最少弹射次数为 3 次，生存概率为 0.9，渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/MetalDenoise.png" alt="MetalDenoise"></p><h4 id="3-2-Glossy-反射"><a href="#3-2-Glossy-反射" class="headerlink" title="3.2 Glossy 反射"></a>3.2 Glossy 反射</h4><p>可以看到金属球上的倒影是完美的镜面反射，接下来我们可以向金属材质中添加 Glossy 反射，在镜面反射方向找一个小的球体对镜面反射方向进行扰动，使得光线朝着镜面反射方向周围一定范围散射：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.12-reflect-fuzzy.jpg" alt="fig-1.12-reflect-fuzzy"></p><p>我们可以在材质类中定义一个扰动球半径，扰动球半径越大，模糊越严重，扰动球半径为 0 就是完美的镜面反射，同时扰动球半径不能大于 1 ，否则光线可能被扰动到物体内部，所以如果给定的扰动球半径大于 1 ，我们要截断到 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在创建材质的时候可以赋予不同的扰动系数，是的物体产生不同的表现，修改主函数创建两种不同扰动系数的金属材质：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MetalDenoise.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Glossy.png" alt="Glossy"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（四）漫反射材质</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/</id>
    <published>2022-04-15T09:37:14.000Z</published>
    <updated>2022-04-15T12:38:45.814Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。</p><p><em><span id="more"></span></em></p><h3 id="1-简单的漫反射材质"><a href="#1-简单的漫反射材质" class="headerlink" title="1 简单的漫反射材质"></a>1 简单的漫反射材质</h3><p>回顾漫反射的形成原理，光线打到物体表面后一部分光会折射进入物体，并在物体内部发生各种次表面散射后从物体表面的某个方向再折射出去，因此漫反射的颜色主要取决于环境光颜色，并用物体自身的颜色去调节这些来自环境的光线，因此也可以认为漫反射反映了物体自身的颜色。从宏观来看漫反射就像是光线向各个方向均匀散射，而在我们的简单实现中可以认为光线在物体表面的反射方向是随机的，比如三根光线打到两个物体的夹缝处，他们可能产生完全不同的行为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.08-light-bounce.jpg" alt="fig-1.08-light-bounce"></p><p>因此要模拟漫反射材质，我们首先要能够随机生成漫反射弹射光线。可以使用如下方法生成：</p><ul><li>光线与物体表面相交于一点 $p$</li><li>在 $p + \vec n$ 处构造一个与点 $p$ 相切的单位球体，其中 $\vec n$ 是点 $p$ 处的法线</li><li>随机在单位球体中选择一点 $s$ ，漫反射弹射光线的方向就是 $s - p &#x3D; \vec{ps}$</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.09-rand-vec.jpg" alt="fig-1.09-rand-vec"></p><p>为此我们要先增加一些工具函数用于在单位球体内生成随机点，由于直接生成单位球体内的点并不是很方便实现，我们可以先生成单位立方体内的点，即三个维度的坐标都在 [-1, 1] 范围内，然后判断该点是否在球体内，如果不在球体内就重新随机选择，直到满足条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[0,1]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[min,max]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成单位球体内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> point3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以递归的计算光线弹射多次所得到的漫反射颜色了。</p><h3 id="2-限制光线弹射次数"><a href="#2-限制光线弹射次数" class="headerlink" title="2 限制光线弹射次数"></a>2 限制光线弹射次数</h3><p>上面的实现中，没有递归结束的条件，也就是限制光线弹射的次数，因此需要加一个递归深度来限制光线的弹射次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 限制弹射次数</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world, depth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Diffuse.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/Diffuse.png" alt="Diffuse"></p><p>使用固定弹射次数会导致很多没用的计算，仅仅渲染上面这样一张图就要用掉近三分钟，效率非常低，并且固定弹射次数会影响最终渲染效果。之前在图形学中我们学习过，更好的限制光线弹射次数的方法是使用俄罗斯轮盘赌算法（RR），该算法在保证期望正确的情况下大幅提高了渲染效率，因此我们用 RR 算法来限制光线弹射次数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 要记得除以生存概率才能得到正确的期望</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中之前做的修改可以 Ctrl + Z 了，现在无需做任何修改，得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRR.png" alt="DiffuseRR"></p><p>渲染这张图只用了不到 20 秒，效率大幅提升并且渲染效果更好。</p><h3 id="3-伽马校正"><a href="#3-伽马校正" class="headerlink" title="3 伽马校正"></a>3 伽马校正</h3><p>在上面的例子中我们设置了一半的光线被吸收，一半的光线被反射，在现实中这个球体看起来应该更亮一些，呈现灰色，但上面的渲染结果中球体颜色非常暗，尤其是球体下的阴影处，这是因为我们没有进行<strong>伽马校正（Gamma Correction）</strong>。</p><p>伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下：<br>$$<br>L_{out} &#x3D; L_{in}^\gamma<br>$$<br>其中指数部分的发音就是伽马。最开始的时候，人们使用伽马曲线来对拍摄的图像进行伽马编码。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可以简化为，把进入到镜头内的光线亮度编码成图像中的像素。如果采集到的亮度是 0，像素就是 0，亮度是 1，像素就是 1，亮度是 0.5，像素就是 0.5。如果我们只用 8 位空间来存储像素的每个通道的话，这意味着 0~1 区间可以对应 256 种不同的亮度值。但是，后来人们发现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/image-20220415161441639.png" alt="image-20220415161441639"></p><p>颜色越暗，我们就感觉从左到右的变化越明显。<strong>所以亮度上的线性变化对人眼的感知来说是非均匀的。</strong></p><p>另一个例子可以说明这个现象，当一个屋子的光照由一盏灯增加到两盏灯的时候，人眼对这种亮度变化的感知性要远远大于从 101 盏灯增加到 102 盏灯的变化，但是从物理上来说这两种变化基本是相同的。</p><p>所以，如果使用 8 位空间来存储每个通道的话，我们仍然把 0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费。一种更好的方法是，我们应该把把更多的空间来存储更多的暗部区域，这样存储空间就可以被充分利用起来了。摄影设备如果使用了 8 位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5，而大约为 0.22。这是因为：<br>$$<br>0.5 \approx 0.22^{0.45}<br>$$<br>如上所见，对拍摄图像使用的伽马编码使得我们可以充分利用图像的存储空间。但当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p><p>这时，人们发现了一个奇妙的巧合—— CRT 显示器本身几乎已经自动做了这个解码操作。在早期，CRT（Cathode Ray Tube，阴极射线管）几乎是唯一的显示设备。这类设备的显示机制是，使用一个电压轰击它屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但 CRT 显示器有一个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为**显示伽马 (diplay gamma)**。非常巧合的是，CRT 的显示伽马值大约就是编码伽马的倒数。CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线。虽然现在 CRT 设备很少见了，并且后来出现的显示设备有着不同的伽马响应曲线，但是，人们仍在硬件上做了调整来提供兼容性。</p><p>随后，微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 $2.2 \times 0.45 \approx 1$ ）。绝大多数的摄像机、 PC 和打印机都使用了上述的 sRGB 标准。</p><p>对于我们的渲染来说，如果我们直接输出渲染结果而不做任何处理，在经过显示器的显示伽马处理后，就会导致颜色偏暗的现象。因此我们在计算像素颜色时有必要进行伽马校正。</p><p>为了简化计算我们假设显示伽马为 2.0，因此我们的编码伽马为 0.5，在写入像素的时候对像素的最终颜色值进行伽马编码，就可以让颜色显示正常了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过伽马矫正后的渲染结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRRGammaCorrect.png" alt="DiffuseRRGammaCorrect"></p><h3 id="4-True-Lambertian-Reflection"><a href="#4-True-Lambertian-Reflection" class="headerlink" title="4 True Lambertian Reflection"></a>4 True Lambertian Reflection</h3><p>现在回顾上面在<strong>单位球体内</strong>选取随机点的实现。这样的实现会使得选取到的随机反射方向大概率接近法线，而以很小的概率接近掠射角方向，这是因为整个球体中大部分位置和表面交点的连线都接近法线方向，只有很小一部分接近掠射角方向，这代表我们随机选取的反射方向不是均匀分布的，但这似乎是合理的，因为越接近掠射角代表光线越接近该交点的切线方向，所以对最终颜色的贡献也更小。</p><p>而 True Lambertian Reflection 并不是这样的， True Lambertian Reflection 的随机方向更均匀，因为它是在<strong>单位球面上</strong>随机取点并构成反射方向，这样显然随机选取的反射方向会更加均匀。</p><p>我们可以通过先在球面内随机取点，并将其单位化，以得到球面上随机一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成单位球面上随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这次使用球面上的随机点</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/TrueLambertianReflection.png" alt="TrueLambertianReflection"></p><p>可以注意到和之前的结果中两个不同的视觉变化：</p><ul><li>阴影变得不那么明显了</li><li>物体变得稍微亮了一点</li></ul><p>这两种变化都是由于光线散射更均匀，向法线附近散射的光线更少而产生的。对于漫反射物体，它们会显得更亮是因为更多的光线会反射到相机上。对于阴影，因为向法线附近散射的光线更少，所以大球体表面和上面的小球体的夹缝处就会有更多的光线散射出去，而不是在夹缝处一直弹射。</p><h3 id="5-另一种散射方法"><a href="#5-另一种散射方法" class="headerlink" title="5 另一种散射方法"></a>5 另一种散射方法</h3><p>除了上面的在球体内随机取点和在球面上随机取点之外，还有一种随机散射的方法。在之前的方法中我们选取了一个单位球，这个单位球的球心相比于光线和表面的交点偏移了一个法线，但很难解释我们为什么这么做。一个更直观的方法是不进行法线偏移，在单位球体内随机取一点作为光线和物体的交点 p 的偏移，然后用偏移后的点 p 和原来的点 p 构成随机反射方向。这相当于以 p 为球心，在一个半球上随机取点构成反射方向，在实现中要注意如果偏移后的点 p 落入了下半球，意味着反射光线指向了物体内部，这是错误的，此时要对偏移量取反，以保证反射光线和该点的法线在同一个半球。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在半球内随机取点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="type">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="comment">// 判断该偏移量是否落入了下半球，如果落入下半球则偏移量应该取反</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 <code>ray_color</code> 部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体内部随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体表面随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 在以交点为球心的半径为 1 的半球内随机取一点得到反射方向</span></span><br><span class="line">        point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/RandomInHemisphere.png" alt="RandomInHemisphere"></p><p>以上三种散射方法没有对错之分，在后面场景变得越来越复杂之后，可以通过尝试切换这三种漫反射渲染器来观察不同的方法对渲染效果的影响。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（三）相机类和反走样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/</id>
    <published>2022-04-15T03:37:24.000Z</published>
    <updated>2022-04-19T11:56:08.877Z</updated>
    
    <content type="html"><![CDATA[<p>上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。</p><p><em><span id="more"></span></em></p><h3 id="1-生成随机数的工具函数"><a href="#1-生成随机数的工具函数" class="headerlink" title="1 生成随机数的工具函数"></a>1 生成随机数的工具函数</h3><p>首先我们要向 <code>utilities.h</code> 中添加两个生成随机数的函数，用于在像素内部随机采样，一个生成 [0 ,1] 之间的随机数，另一个可以定制随机数范围，在 C++ 11 中可以不使用传统的 <code>rand()</code> 实现，可以使用 <code>&lt;random&gt;</code> 中提供的方法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成[0,1]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0~1之间的均匀分布</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// random_device用于生成均匀整数，用来给mt19937播种，类似于之前的srand()</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="comment">// 生成符合分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成[min,max]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-实现相机类"><a href="#2-实现相机类" class="headerlink" title="2 实现相机类"></a>2 实现相机类</h3><p>现在我们实现一个相机类来管理虚拟摄像机以及场景中的各种采样任务，我们先使用之前的轴对齐摄像机作为默认构造方法，来实现一个简单的相机类，只需要把之前主函数中的设置相机的代码拿过来组织一下即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-反走样"><a href="#3-反走样" class="headerlink" title="3 反走样"></a>3 反走样</h3><p>光线追踪中最简单的反走样就是在一个像素内部投射出多条光线，将他们的得到的颜色混合起来作为该像素的颜色。</p><p>在实现时，我们可以将多根光线的颜色先全部累加到像素中，然后在 <code>write_color</code> 函数中将该像素颜色除以采样数量即可。在此之前我们先在 <code>utilities.h</code> 中添加一个截断函数，用于将给定值截取在指定范围内，同时修改 <code>write_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的数字截取到[min,max]范围内</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">clamp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-测试反走样效果"><a href="#4-测试反走样效果" class="headerlink" title="4 测试反走样效果"></a>4 测试反走样效果</h3><p>接下来修改主函数，测试一下反走样实现效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Antialiasing.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/Antialiasing.png" alt="Antialiasing"></p><p>没有反走样的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/WorldSphereNormal.png" alt="WorldSphereNormal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（二）实现物体类</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/</id>
    <published>2022-04-15T02:29:14.000Z</published>
    <updated>2022-04-15T03:40:10.840Z</updated>
    
    <content type="html"><![CDATA[<p>有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。<br><em><span id="more"></span></em></p><h3 id="1-渲染一个球体"><a href="#1-渲染一个球体" class="headerlink" title="1 渲染一个球体"></a>1 渲染一个球体</h3><p>在光线追踪中如果投射出的光线碰到了物体，就计算该点的颜色作为像素值，那么我们从最简单的情形开始，渲染一个球体，我们在 z &#x3D; -1 处放置一个球体，然后计算投射出的每一条光线和该球体是否有交点，如果有的话我们将该像素设置为一个定值，这样就可以在屏幕上显示出这个球体了。</p><p>计算光线和空间中球体是否有交点我们在图形学中已经学过，非常简单，对于射线 $P(t)$ 和一个空间中球心在 $C$ ，半径为 $r$  的球体，如果射线上的点在球面上，则满足：<br>$$<br>(P(t)−C)⋅(P(t)−C)&#x3D;r^2<br>$$<br>将 $P(t) &#x3D; A + t \vec b$ 代入得：<br>$$<br>(A+t\vec b−C)⋅(A+t\vec b−C)&#x3D;r^2<br>$$<br>再展开即可得到关于 $t$ 的一元二次方程：<br>$$<br>t^2 \vec b⋅\vec b+2t\vec b⋅(A−C)+(A−C)⋅(A−C)−r^2&#x3D;0<br>$$<br>只需要判断这个一元二次方程有没有实数根即可。于是我们可以写出判断光线是否和球体相交的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在之前的 <code>ray_color</code> 函数中加上判断光线是否和球体相交的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//放置在 z = -1 处的一个半径为0.5的球体</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r)) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/Sphere.png" alt="Sphere"></p><p>需要注意的是，现在我们只考虑了是否有实数根，并没有考虑 t 的正负，这会导致即使把球体放到 z &#x3D; 1 处，也能得到和上图相同的结果，这相当于我们看到了在相机后面的物体，这个问题之后我们会解决。</p><h3 id="2-表面法线"><a href="#2-表面法线" class="headerlink" title="2 表面法线"></a>2 表面法线</h3><h4 id="2-1-可视化物体表面法线"><a href="#2-1-可视化物体表面法线" class="headerlink" title="2.1 可视化物体表面法线"></a>2.1 可视化物体表面法线</h4><p>我们计算光线与物体交点的光照时首先需要知道该交点的法线，对于一个球体来说，表面上任意一点的法线方向就是该点和球心连线的方向并从球心向外指。因此我们只要计算出投射的光线和球体的交点就可以得到该点的法向量，由于法向量是单位向量，每个分量范围都在 [-1, 1] ，因此我们可以将每个分量都映射到 [0, 1]，作为颜色值显示出来。</p><p>为此我们先修改刚才的 <code>hit_sphere</code> 使其返回交点的 t 值，由于我们的球体放在 z &#x3D; -1 处，所以两个交点都一定是正实数，我们返回较小的那个一根即可，即：<br>$$<br>t_{return} &#x3D; \frac{-b - \sqrt{b^2-4ac} }{2a}<br>$$<br>因为只能看到离我们最近的点，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line"><span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> (-b - <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//放置在 z = -1 处的一个半径为0.5的球体，计算交点法线作为颜色返回</span></span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vec3 normal = <span class="built_in">normalize</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> (normal + <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/SphereNormal.png" alt="SphereNormal"></p><h4 id="2-2-代码优化"><a href="#2-2-代码优化" class="headerlink" title="2.2 代码优化"></a>2.2 代码优化</h4><p>上面的 <code>hit_sphere</code> 函数有一些可以优化的地方，首先两个相同向量的点乘，可以通过我们在 <code>vec3</code> 类中定义的 <code>length_squared()</code> 方法得到，另外考虑方程的求根公式：<br>$$<br>\frac{-b \pm \sqrt{b^2-4ac} }{2a}<br>$$<br>如果把 b 替换成 2h，可以得到：<br>$$<br>\frac{-2h \pm \sqrt{(2h)^2-4ac} }{2a}<br>$$<br>展开整理得：<br>$$<br>\frac{-h \pm \sqrt{h^2-ac} }{a}<br>$$<br>于是我们只需要计算 b 的一半即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line"><span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line"><span class="keyword">auto</span> h = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line"><span class="keyword">auto</span> discriminant = h * h - a * c;</span><br><span class="line"><span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> (-h - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多个物体"><a href="#3-多个物体" class="headerlink" title="3 多个物体"></a>3 多个物体</h3><h4 id="3-1-实现物体类"><a href="#3-1-实现物体类" class="headerlink" title="3.1 实现物体类"></a>3.1 实现物体类</h4><p>在实际场景中我们不可能只有一个物体，并且物体也不可能只是球体，还可能有有各种各样的模型，因此为了能让所有模型都可以放置到场景中并计算我们投射光线和物体的交点，我们可以先定义一个可计算交点的抽象物体类 <code>hittable</code>，这个类定义一个纯虚函数 <code>hit</code> 用来判断物体和光线的交点，然后再以该抽象类为基类，实现各种物体类即可，这样一来，不同的物体的 <code>hit</code> 函数有可以有不同的实现了。</p><p><code>hit</code> 函数也和我们上面写的稍有不同，除了要接收一根光线作为参数外，还要有一个限定范围 $t_{min}$ 和 $t_{max}$，只有当交点的 t 在这个范围内才会与物体相交，这部分也在之前的图形学中也有学过，同时这个范围也可以用于后面计算多个物体中最近的交点。</p><p>此外，光线可能和物体有多个交点，我们需要取在限定范围内的离我们最近的交点，把该交点及其法线等属性记录下来，因此还要定义一个存储交点属性的结构体。</p><p>最后还需要考虑一个问题，交点是物体的正面还是背面？这对我们渲染来说非常重要，尤其是一些双面不同的物体。这可以通过光线和法线的点乘来判断，如果光线和交点的法线反向，这说明交点在物体的正面，因为法线都是从物体中心指向表面的；相反如果光线和交点的法线同向，这说明交点在物体的背面。同向和反向实际上是两个向量的夹角，因此点乘即可。如果交点在物体背面，那么计算光照时用到的法线应该是这个点表面法线的反方向，所以要对原法线取反。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/fig-1.06-normal-sides.jpg" alt="fig-1.06-normal-sides"></p><p>现在我们可以开始实现上面的思路了，首先是抽象类和结构体的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"><span class="comment">// utilities.h 包含了常用的工具函数并整合了常用头文件，避免循环嵌套，我们在后面会实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来实现一个球体类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重载虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-实现物体列表类"><a href="#3-2-实现物体列表类" class="headerlink" title="3.2 实现物体列表类"></a>3.2 实现物体列表类</h4><p>现在我们已经有了可以与光线相交的物体的基类 <code>hittable</code>，可以在其基础上实现各种物体类，接下来我们要定义一个类来存储多个物体，代码比较容易理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">物体列表类hittable_list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line">    <span class="comment">// 一个物体列表的hit函数用于得到光线和这个列表中所有物体最近的一个交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="type">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录当前的最近的t</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line">    <span class="comment">// 遍历每一个物体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 更新最近的t</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="3-3-关于智能指针"><a href="#3-3-关于智能指针" class="headerlink" title="3.3 关于智能指针"></a>3.3 关于智能指针</h4><p>上面的物体列表类中使用了智能指针，在之后的代码中我们也会经常使用，智能指针能帮助我们自动管理内存，防止内存泄漏，一般来说初始化一个智能指针可以使用如下形式的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>auto 支持对智能指针类型的自动推导，因此我们写起来会更方便：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line"><span class="keyword">auto</span> vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line"><span class="keyword">auto</span> sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>声明后就可以像正常指针一样使用了。更多关于智能指针的内容可以查看 C++ 与 STL 部分的笔记。</p><h3 id="4-常用常量和工具函数"><a href="#4-常用常量和工具函数" class="headerlink" title="4 常用常量和工具函数"></a>4 常用常量和工具函数</h3><p>接下来需要定义一些常用的常量以及角度转弧度等工具函数，并将一些类的头文件整合起来，使代码组织更整洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常用常量及工具函数</span></span><br><span class="line"><span class="comment">整合包含其他头文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> infinity = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="type">double</span> degrees)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用头文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> UTILITIES_H</span></span><br></pre></td></tr></table></figure><h3 id="5-再次可视化法线"><a href="#5-再次可视化法线" class="headerlink" title="5 再次可视化法线"></a>5 再次可视化法线</h3><p>使用上面实现的一系列代码，再次实现一个可视化法线的效果，首先修改 <code>ray_color</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">hit_record rec;</span><br><span class="line"><span class="comment">// 计算和世界中的物体的交点的法线</span></span><br><span class="line"><span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line"><span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;WorldSphereNormal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******场景属性*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/WorldSphereNormal.png" alt="WorldSphereNormal"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。&lt;br&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>【算法】排序算法</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-13T09:00:01.000Z</published>
    <updated>2022-04-13T09:02:25.442Z</updated>
    
    <content type="html"><![CDATA[<p>排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：</p><ul><li>时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序</li><li>时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序</li><li>时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序</li></ul><p>可以通过<a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a>题目实践这些算法。</p><p><em><span id="more"></span></em></p><h2 id="1-时间复杂度为-O-n-2-的排序"><a href="#1-时间复杂度为-O-n-2-的排序" class="headerlink" title="1 时间复杂度为 $O(n^2)$ 的排序"></a>1 时间复杂度为 $O(n^2)$ 的排序</h2><p>这一类排序算法属于入门算法，性能较差，在实际工程中几乎不会用到，但他们的思想对解决一些特定问题还是很有启发的。</p><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="1-1-1-算法思想"><a href="#1-1-1-算法思想" class="headerlink" title="1.1.1 算法思想"></a>1.1.1 算法思想</h4><p>冒泡排序是入门级排序算法，但也有一些优化的写法，首先来看最简单的冒泡排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-算法优化"><a href="#1-1-2-算法优化" class="headerlink" title="1.1.2 算法优化"></a>1.1.2 算法优化</h4><p>稍微优化一下，因为在每一次冒泡的过程中，多次交换不仅会把最大&#x2F;最小的数放到末尾，还会使中间一部分变得有序，这样会导致在后面的冒泡过程中没有任何交换，但还是进行了遍历，从而造成性能的浪费。因此使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;<span class="comment">//初始化为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;<span class="comment">//如果前一轮没有发生过交换说明已经有序，无需继续进行下去</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步进行优化，除了记录当前轮次是否发生过交换外，再用一个变量记录最后一次发生交换的位置，下一次遍历只要到该位置即可，因为该位置之后必然都已经有序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> indexOfLastUnsortedElement = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-swap-函数"><a href="#1-1-3-swap-函数" class="headerlink" title="1.1.3 swap 函数"></a>1.1.3 swap 函数</h4><p>优化后的冒泡排序的平均时间复杂度实际上还是 $O(n^2)$，所以这些优化对算法的性能并没有质的提升，因此冒泡排序也并不会在实际工程中使用，面试中也几乎不可能会问到，但是现在学习冒泡排序的另一个价值是关于上面的 swap 函数，这是面试中一个经典的问题：<strong>不使用额外空间交换数组中的两个数</strong>。做法非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] - nums[i];</span><br></pre></td></tr></table></figure><p>另一种实现，先减后加，原理一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] -= nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] + nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i] - nums[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面两种方法都可能会数字越界，最好的方法是位运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[j] ^ arr[i];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br></pre></td></tr></table></figure><h4 id="1-1-4-相关练习"><a href="#1-1-4-相关练习" class="headerlink" title="1.1.4 相关练习"></a>1.1.4 相关练习</h4><h5 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h5><blockquote><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p></blockquote><p>自己定义一个比较函数即可，如果两个数字的字符串拼接 <code>sx + xy &lt; sy + sx</code>，则可以认为 sx 小于 sy ，即 sx 应该排在前面。</p><p>至于排序算法的选择，可以用任意排序，冒泡就不再重新写了，这里直接用 c++ 的 sort 函数，如果不用 sort 函数可以不使用额外空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string&amp; x, string&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res += strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></h5><p>在双指针时做过，双指针自然是最好的解法，不过显然用冒泡的思想更加直观。</p><h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="1-2-1-算法思想"><a href="#1-2-1-算法思想" class="headerlink" title="1.2.1 算法思想"></a>1.2.1 算法思想</h4><p>选择排序的思想是，双重遍历数组，每一轮遍历都将数组中最小&#x2F;最大的值交换到数组首位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序与冒泡排序时间复杂度和空间复杂度完全一致，但二者有一个非常大的差异就是冒泡排序是稳定的，而选择排序是不稳定的。</p><h4 id="1-2-2-排序的稳定性"><a href="#1-2-2-排序的稳定性" class="headerlink" title="1.2.2 排序的稳定性"></a>1.2.2 排序的稳定性</h4><p>对于排序算法来说，<strong>稳定</strong>是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p>在冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p><p>那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。</p><p>举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。</p><p>当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。同样地，不稳定排序算法也可以经过修改，达到稳定的效果。比如选择排序算法实现稳定排序一种最简单的思路是：新开一个数组，将每轮找出的最小值依次添加到新数组中，这样选择排序算法就变成稳定的了。</p><p>但如果将寻找最小值的比较条件由 arr[minIndex] &gt; arr[j] 修改为 arr[minIndex] &gt;&#x3D; arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。</p><h4 id="1-2-3-算法优化"><a href="#1-2-3-算法优化" class="headerlink" title="1.2.3 算法优化"></a>1.2.3 算法优化</h4><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想，每轮选择时记录最小值和最大值，这样可以把数组需要遍历的范围缩小一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 相等，说明当前遍历范围内所有元素都相等，整个数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 刚已经交换了，所以这里 maxIndex 的值要更新一下</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> lastIndex = arr.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二元选择排序中，需要遍历的数组范围缩小了一倍，但效率并不能提高一倍，这是因为在内层循环中普通选择排序只要做一次比较，而二元选择循环需要做两次比较，因此提升的效率并不是线性的。不过由于在上面的二元选择排序中，我们使用了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>来做优化，因此当数组中重复元素很多时，二元选择排序效率将远高于选择排序。</p><h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="1-3-1-算法思想"><a href="#1-3-1-算法思想" class="headerlink" title="1.3.1 算法思想"></a>1.3.1 算法思想</h4><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p><p>插入排序的基本思想就是：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// j 记录当前数字下标</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新当前数字下标</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-算法优化"><a href="#1-3-2-算法优化" class="headerlink" title="1.3.2 算法优化"></a>1.3.2 算法优化</h4><p>我们发现，在上面的插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。</p><p>由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前新插入的数字</span></span><br><span class="line">        <span class="type">int</span> cur = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前面已经有序的数字如果比当前数字大，就往后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序时间复杂度同样是 $O(n^2)$，空间复杂度为 $O(1)$，且插入排序是稳定的排序算法。</p><h4 id="1-3-3-相关练习"><a href="#1-3-3-相关练习" class="headerlink" title="1.3.3 相关练习"></a>1.3.3 相关练习</h4><h5 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></h5><blockquote><p>给定单个链表的头 <code>head</code> ，使用<strong>插入排序</strong>对链表进行排序，并返回排序后链表的头。</p></blockquote><p>单向链表的插入排序比数组困难一些，我们无法从插入的新元素的位置向前遍历寻找插入位置，只能从头开始寻找插入位置，为此我们需要记录链表有序部分的最后一个节点，先判断该节点和当前待插入节点的大小，如果待插入节点比链表有序部分的最后一个节点的值大，那么无需插入，直接向后继续即可，否则从头结点开始寻找插入位置。</p><p>为了方便在头节点前插入节点，事先定义一个哑节点，这是链表题目的常规操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN, head);</span><br><span class="line">        ListNode* last_sorted = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= last_sorted-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                last_sorted = last_sorted-&gt;next;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = dummy, *t = pre-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;val &lt;= cur-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = t-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                last_sorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-时间复杂度为-O-nlogn-的排序"><a href="#2-时间复杂度为-O-nlogn-的排序" class="headerlink" title="2 时间复杂度为 $O(nlogn)$ 的排序"></a>2 时间复杂度为 $O(nlogn)$ 的排序</h2><p>这一类排序是排序中最为重要的算法，因为他们普适性好，效率高，许多编程语言内置的排序函数的实现就综合了这里面的各类算法。</p><h3 id="2-1-希尔排序"><a href="#2-1-希尔排序" class="headerlink" title="2.1 希尔排序"></a>2.1 希尔排序</h3><p>希尔排序本质上是对插入排序的一种优化，虽然现在几乎不被使用，但作为第一批将时间复杂度降到 $O(n^2)$ 以下的排序算法，还是有必要了解一下。</p><h4 id="2-1-1-算法思想"><a href="#2-1-1-算法思想" class="headerlink" title="2.1.1 算法思想"></a>2.1.1 算法思想</h4><p>希尔排序的基本思想是：</p><ul><li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li><li>逐渐缩小间隔进行下一轮排序</li><li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的宏观调控，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li></ul><p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，增量依次递减，最后一个增量必须为 1，所以希尔排序又被称为「缩小增量排序」。</p><p>增量序列的选择会极大地影响希尔排序的效率。本例中，我们采用的增量序列为 $D_m &#x3D; N&#x2F;2$，$D_k &#x3D; D_{k+1} &#x2F; 2$ 。这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> groupStartIndex = <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.<span class="built_in">size</span>(); currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> currentNumber = arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> preIndex = currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h4><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> currentNumber = arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与插入排序非常相似，但多了一层外层的间隔序列循环。</p><h4 id="2-1-3-算法性能"><a href="#2-1-3-算法性能" class="headerlink" title="2.1.3 算法性能"></a>2.1.3 算法性能</h4><p>之前说过，增量序列的选择将直接影响希尔排序的性能，因此它也是希尔排序的核心优化点，学界有不少的大牛做过这方面的研究。比较著名的有 <code>Hibbard</code> 增量序列、<code>Knuth</code> 增量序列、<code>Sedgewick</code> 增量序列。由于希尔排序已经逐渐不被使用，因此这部分内容也不是我们学习的重点。</p><p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。</p><p>我们现在学习希尔排序的意义在于，要理解希尔排序为什么能打破排序算法 $O(n^2)$ 的壁障，理解了这一点就明白了为什么希尔排序能承上启下，引发出之后一系列 $O(n^2)$ 以下的排序算法。</p><p>这可以通过逆序对来理解，所谓逆序对是指：当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。排序算法本质上就是一个消除逆序对的过程。对于随机数组，逆序对的数量是 $O(n^2)$ 级的，如果采用交换相邻元素的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$ 级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$ 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p><p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度为 $O(n^2)$ 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p><h3 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h3><h4 id="2-2-1-算法思想"><a href="#2-2-1-算法思想" class="headerlink" title="2.2.1 算法思想"></a>2.2.1 算法思想</h4><p>我们之前已经学习过优先队列和堆，并且自己动手实现了一个堆，因此堆排序的思想现在并不难理解。我们将该数组初始构建为一个大顶堆，然后每次将堆顶元素交换到数组末尾，剩下的元素调整形成新的大顶堆，重复以上过程即可。我们之前自己动手实现堆的时候已经知道了如何调整数组元素，现在只需要了解如何通过给定数组高效的构建一个大顶堆。</p><p>我们可以把给定数组直接视作一个大顶堆，而不要再开辟额外空间，直接在该数组上调整元素使其成为大顶堆就行了。 对于一个长度为 n 的数组形成的堆，它的最后一个非叶子节点的编号为 <code>n / 2 - 1</code>，我们从最后一个非叶子节点开始向前遍历，每个节点和它的孩子节点比较，并作相应的交换，所以叶子节点不需要调整，直接从最后一个非叶子节点开始即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建大顶堆,从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> root, <span class="type">int</span> heapsize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftchild = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightchild = leftchild + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxindex = root;</span><br><span class="line">        <span class="keyword">if</span>(leftchild &lt; heapsize &amp;&amp; nums[leftchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightchild &lt; heapsize &amp;&amp; nums[rightchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxindex == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root], nums[maxindex]);</span><br><span class="line">        <span class="comment">//保证交换后下面的子树也是一个大顶堆</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(nums, maxindex, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> heapsize = nums.<span class="built_in">size</span>() - <span class="number">1</span>; heapsize &gt; <span class="number">0</span>; --heapsize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[heapsize]);</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-算法性能"><a href="#2-2-2-算法性能" class="headerlink" title="2.2.2 算法性能"></a>2.2.2 算法性能</h4><p>根据数学运算可以推导出初始化建堆的时间复杂度为 $O(n)$，重建堆的时间复杂度为 $O(n\log n)$，所以堆排序总的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p><h4 id="2-2-3-相关练习"><a href="#2-2-3-相关练习" class="headerlink" title="2.2.3 相关练习"></a>2.2.3 相关练习</h4><h5 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">相对名次</a></h5><blockquote><p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都互不相同 。</p><p>运动员将根据得分决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p><ul><li>名次第 1 的运动员获金牌 “Gold Medal” 。</li><li>名次第 2 的运动员获银牌 “Silver Medal” 。</li><li>名次第 3 的运动员获铜牌 “Bronze Medal” 。</li><li>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。</li></ul><p>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况.</p></blockquote><p>比较简单，堆排序记录下标即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxscore = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) ans[maxscore.second] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) ans[maxscore.second] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) ans[maxscore.second] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[maxscore.second] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h5><blockquote><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></blockquote><p>这是一道很简单的题目，排序后数组的中位数一定是多数元素，因此只需要对数组排序即可，自己手写堆排序可以不使用额外空间。</p><p>对于上述结论的证明以及这道题更好的解法——摩尔投票法，参考<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解方法五</a>。</p><h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-算法思想"><a href="#2-3-1-算法思想" class="headerlink" title="2.3.1 算法思想"></a>2.3.1 算法思想</h4><p>快速排序在时间复杂度为 $O(nlogn)$ 级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p><p>快速排序算法的基本思想是：</p><ul><li>从数组中取出一个数，称之为基数（pivot）</li><li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li><li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li></ul><p>依据上面的思路，我们可以先写出快速排序的框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架存在一个严重的问题，就是没有退出递归的边界条件，显然当某个分区内只有一个数字或者没有数字的时候就不需要继续排序了，分区内只有一个数字即 <code>start == end</code>，分区内没有数字即 <code>start &gt; end</code>，因此退出递归的条件是 <code>start &gt;= end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间只有一个数字或者没有数字的时候，退出递归</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现最关键的分区函数，分区函数的目的是选择一个基数，然后将所有小于基数的数都放到基数左边，将所有大于基数的数都放到基数右边，最后返回基数所在的下标。</p><p>因此如何选择基数就成为了一个问题，一般来说有三种选择方案：</p><ul><li>选择第一个数作为基数</li><li>选择最后一个数作为基数</li><li>随机选择一个数作为基数</li></ul><p>这里我们以第一种基数选择方法为例来实现快速排序，但实际上随机选择一个数作为基数的快速排序平均时间复杂度最优，我们将在后面讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> pivot = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始</span></span><br><span class="line">    <span class="type">int</span> left = start + <span class="number">1</span>, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于等于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; arr[pivot]) ++left;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">        <span class="comment">// 交换二者位置，保证左边都是小于基数的数，右边都是大于等于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出上面的while的时候，left == right，这时left和right同时指向的数还没有和基数做判断</span></span><br><span class="line">    <span class="comment">// 因此要加上这一句判断</span></span><br><span class="line">    <span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">    <span class="comment">// 将基数交换到中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(right != pivot) <span class="built_in">swap</span>(arr[pivot], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的分区函数使用了双指针的方法，这也是容易想到的比较好的实现方法。上面的代码中有一个细节，在while循环结束后，还加了一个额外的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br></pre></td></tr></table></figure><p>这是因为在上面的 while 退出的时候，left 和 right 同时指向的数还没有和基数做判断，所以需要额外做一次判断；同时这行代码还解决了 [start, end] 区间内只有两个数字的情况，这种情况下第一个数字做为基数，那么 [left, right] 区间内就只有一个数字，因此不会进入 while 循环，所以需要判断一次。</p><p>另外要注意的是，这里不能用 left 指针来判断，因为 left 指针递加有可能超出数组范围，而 right 指针递减至少也是和 pivot 相等，即指向区间内第一个元素，所以不会出现问题，最后交换和返回也都是用 right 指针更为安全。</p><p>双指针实现比较简单直观，但是要写的代码比较多，也要考虑比较多的特殊情况，更为简单的分区函数实现一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> piovt = start;</span><br><span class="line">    <span class="comment">// ret记录最后基数应该在的位置，初始为我们选择的基数的位置，也就是start</span></span><br><span class="line">    <span class="type">int</span> ret = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = start + <span class="number">1</span>; right &lt;= end; ++right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这个数小于基数，ret向后移动一位然后换位，这样保证ret左边都是小于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(arr[right] &lt; arr[piovt])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="built_in">swap</span>(arr[ret], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把基数放到ret处，返回ret</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[ret]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无需更多的特殊判断，是一种更高效的写法。</p><h4 id="2-3-2-算法分析"><a href="#2-3-2-算法分析" class="headerlink" title="2.3.2 算法分析"></a>2.3.2 算法分析</h4><p>快排的平均时间复杂度为 $O(nlogn)$，最坏情况下的时间复杂度为 $O(n^2)$；空间复杂度与递归的层数有关，最好情况下空间复杂度为 $O(logn)$，最坏情况下为 $O(n^2)$，平均空间复杂度为 $O(logn)$。</p><p>现在我们来分析以下为什么随机选择基数的平均复杂度更低，首先我们要搞清楚上面说的最坏情况是什么情况。理想中的快速排序在第 k 轮遍历中，可以排好 $2^{k-1}$ 个基数，假设我们用刚才实现的方法，即选择数组第一个数作为基数，考虑下面两种情况：</p><ul><li><p>数组为正序，比如 <code>nums = [1, 2, 3, 4, 5, 6]</code>，这时第一次分区将原数组分为了 [0, 0] 和 [1, 5] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一次分区也是同样，因此每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，所以总的比较次数为 $(n-1) + (n-2) + …+1 &#x3D; n(n-1)&#x2F;2$ 次，此时快排的时间复杂度就达到了 $O(n^2)$。</p></li><li><p>数组为逆序，比如 <code>nums = [6, 5, 4, 3, 2, 1]</code>，这时第一次分区将原数组分为了 [0, 4] 和 [5, 5] 两个区间，而 5 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一轮分区时数组变为了 <code>nums = [1, 5, 4, 3, 2, 6]</code> ，我们要在 [0, 4] 区间上继续分区，经过这一轮，将区间 [0, 4] 分为了 [0, 0] 和 [1, 4] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，以此类推，每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，因此这种情况下快排的时间复杂度也是 $O(n^2)$。</p></li></ul><p>所以为了避免这种情况，我们在数组中随机选择一个数作为基数，这样选到数组中最大值或者最小值的概率就很低，自然可以避免最坏情况的发生。</p><h4 id="2-3-3-算法优化"><a href="#2-3-3-算法优化" class="headerlink" title="2.3.3 算法优化"></a>2.3.3 算法优化</h4><p>根据上面的分析，一般来说快速排序前可以对原数组进行“洗牌”，以防止原数组有序的情况，洗牌算法的思想非常简单，从后向前遍历数组，然后随机选择一个数组中的数字与当前元素交换，最终所有元素都被交换一次，就打乱了原数组的顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandIntRange</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">RandIntRange</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(p != i) <span class="built_in">swap</span>(nums[p], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以在排序前对原数组进行一个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。显然洗牌算法的时间复杂度为 $O(n)$。实际实现快速排序的时候我们不需要把数组完整洗牌，每次选择基数的时候随机选择一个基数即可。</p><h4 id="2-3-4-快速选择"><a href="#2-3-4-快速选择" class="headerlink" title="2.3.4 快速选择"></a>2.3.4 快速选择</h4><p>基于快速排序的选择算法是面试中的高频考题，我们可以再次回顾一下 TopK 问题。</p><h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p></blockquote><p>之前我们是用堆排序解决的，堆排序的方法时间复杂度为 $O(nlogn)$，空间复杂度为 $O(logn)$。使用基于快速排序的选择算法可以将平均时间复杂度降低至 $O(n)$。</p><p>快速选择的思想非常简单，在快速排序中，每一轮都可以确定区间内一个基数的最终位置，partition 函数会返回这个位置，因此我们从小到大进行快速排序，当确定的基数的位置为 <code>nums.size() - k</code> 时，就得到了第 K 个最大的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机选择基数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select_piovt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分区函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> piovt = <span class="built_in">select_piovt</span>(nums, low, high);</span><br><span class="line">        <span class="type">int</span> ret = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = low + <span class="number">1</span>; right &lt;= high; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; piovt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++ret], nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[ret], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = high - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">partition</span>(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target) low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a>2.4 归并排序</h3><h4 id="2-4-1-算法思想"><a href="#2-4-1-算法思想" class="headerlink" title="2.4.1 算法思想"></a>2.4.1 算法思想</h4><p>归并排序也是一种性能很优秀的排序算法，并且由于它是稳定的排序算法，因此也被广泛应用。归并排序的基本思想是对原数组不停的二分，直到每个区间都只有 1 个数字，这时这个区间可以视为一个有序区间，然后再不停的合并两个有序区间即可。</p><p>合并两个有序数组是我们做过的一道题，一般来说可以开辟一个长度为两个区间之和的数组，然后双指针遍历两个数组即可。由此我们可以写出归并排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了节省空间，我们始终在一个额外数组上操作，避免创建很多新的临时变量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间内只有一个数字，开始回溯</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 把[start,mid]的合并结果存到temp的[start,mid]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">    <span class="comment">// 把[mid+1,end]的合并结果存到temp的[mid+1,end]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">// 合并[start, end]区间内两个有序区间</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 第一个区间的指针从start开始</span></span><br><span class="line">    <span class="type">int</span> index1 = start;</span><br><span class="line">    <span class="comment">// 第二个区间的指针从mid+1开始，同时记下第二个区间的开始位置</span></span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">            <span class="comment">// temp数组每次要放的位置是start+(index1-start)+(index2-start2)</span></span><br><span class="line">            <span class="comment">// 展开整理一下就是index1 + index2 - start2</span></span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下没遍历到的元素接到temp末尾</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">        ++index1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">        ++index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把temp合并的结果放回nums对应区间上，这样nums对应区间就变得有序了，便于下次合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-算法分析"><a href="#2-4-2-算法分析" class="headerlink" title="2.4.2 算法分析"></a>2.4.2 算法分析</h4><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$。空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 temp 数组。</p><p>我们在合并数组的时候的判断条件是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[index1] &lt;= nums[index2])</span><br></pre></td></tr></table></figure><p>这保证了归并排序是稳定的。如果没有等号则归并排序不再稳定。</p><h4 id="2-4-3-相关练习"><a href="#2-4-3-相关练习" class="headerlink" title="2.4.3 相关练习"></a>2.4.3 相关练习</h4><h5 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">合并排序的数组</a></h5><blockquote><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p></blockquote><p>因为 A 数组末尾提供了足够的空间，我们使用双指针逆序从两个数组末尾取出数字，把最大的放到A的末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa &gt;= <span class="number">0</span> &amp;&amp; pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[pa] &gt;= B[pb])</span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = A[pa];</span><br><span class="line">                --pa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">                --pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">            --pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h5><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p></blockquote><p>使用暴力法很简单但时间复杂度太高，这道题非常考验对归并排序的理解。</p><p>关键在于归并排序中合并有序数组的时候，如果左边数组中当前指针指向的数字 nums[left] 比右边数组中当前指针指向的数字 nums[right] 小，那么就把 nums[left] 加入答案，同时判断右边数组中有多少数字比 nums[left] 小，这就是 nums[left] 对整个数组逆序对数量的贡献，因为右边数组中比 nums[left] 小的数原本排在了 nums[left] 的右边，就构成了一个逆序对。而右边数组中比 nums[left] 小的数字数量刚好就是右边数组的当前指针 right 相对于右边数组起始位置 mid + 1 的偏移，因为在右边数组当前指针之前的数字都已经加入到了结果中，一定比 nums[left] 小。</p><p>按照上面的思路，我们只需要在归并排序中加一个统计逆序对数量的变量即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">        <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序区间，并统计逆序对数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> index1 = start;</span><br><span class="line">        <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">                ++index1;</span><br><span class="line">                <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">                cnt += index2 - start2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">            <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">            cnt += index2 - start2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后面的数组没有遍历完，说明剩下的所有数字都比前面的大，没有逆序对贡献</span></span><br><span class="line">        <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-时间复杂度为-O-n-的排序"><a href="#3-时间复杂度为-O-n-的排序" class="headerlink" title="3 时间复杂度为 $O(n)$ 的排序"></a>3 时间复杂度为 $O(n)$ 的排序</h2><p>这一类排序算法平均时间复杂度最优，但一般只适用于特定场景，在特定问题下的排序效率将高于其他算法。</p><h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><h4 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h4><p>计数排序的思想很简单，假设一个数组只包含 0 ~ 9 范围内的数字，那我们可以建立一个长度为 10 的数组，统计原数组中 0 ~ 9 各出现了几次，统计完成后再按顺序把数字填到数组中即可，整个过程如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="1620707085-FdqElS-计数排序"></p><p>但这样排序并不是真正的计数排序，因为我们这样做相当于只是把和原数组中数字相同的值放回了原数组中，而这些值已经不是原来的数字了，这在实际工程中如果待排序的对象有其他属性的话，这样做就会丢掉其他属性，于是我们可以建立一个哈希表，去存储每个数字对应的原来的数字（对象），最后再按顺序放回去即可。</p><p>真正的计数排序使用的方法更为巧妙，统计完计数数组后，遍历原数组，对原数组的每一个元素可以根据计数数组的结果得到它排序后应该在的位置，他应该在的位置就是起始位置加上所有比它小的数字之和，因此直接把该数字放到对应的位置上即可。同时为了处理更一般的情况，而不是只有 0 ~ 9，要先统计计数范围，计数范围就是数组中的最小值到最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> preCounts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置，即前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很好理解，计数排序还有另一种写法，即在统计对应元素所在位置的时候，不统计该元素在结果中起始位置的下标，而是统计最后一个位置的下标，然后遍历原数组的时候从后向前遍历，这样的写法可以避免记录 preCounts，效率更高，一般也常使用这种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数字在结果中的最后一个下标位置 = 比它小的数字数量 + 该数字的数量 - 1</span></span><br><span class="line">    <span class="comment">// 我们预先对counting[0]减去1，这样之后就不需要每次都减了</span></span><br><span class="line">    counting[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; range; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置</span></span><br><span class="line">        counting[i] += counting[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在遍历原数组放到结果数组中相应位置的时候，不逆序遍历也可以得到正确的结果，但只有逆序遍历才能保证计数排序的稳定性。</p><h4 id="3-1-2-算法分析"><a href="#3-1-2-算法分析" class="headerlink" title="3.1.2 算法分析"></a>3.1.2 算法分析</h4><p>从计数排序的实现代码中可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 $O(n + k)$，k 表示数据的范围大小。用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n + k)$。</p><p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。并且由此我们可以发现计数排序的一个致命的缺点，如果对下面的数组使用计数排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, INT_MAX&#125;;</span><br></pre></td></tr></table></figure><p>我们将会创建一个从 1 到 INT_MAX 的计数数组，C++ 中 int 占 4 字节，一个长度为 $2^{31}$ 的数组要占用 8G 的空间。所以计数排序只适用于数据范围不大的场景，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p><p>接下来我们考虑为什么计数排序可以突破 $O(nlogn)$ 的时间复杂度。<strong>因为计数排序不是基于比较的排序算法</strong>。</p><p>根据决策树理论可以推导出<strong>所有基于比较的排序算法最坏情况下都要做 $O(nlogn)$ 次比较</strong>，因此所有基于比较的排序算法无论怎么优化都不可能突破 $O(nlogn)$ 的下界，而基数排序不是基于比较的算法，是利用数字本身的属性进行排序，整个算法中没有出现任何一次比较。</p><h4 id="3-1-3-相关练习"><a href="#3-1-3-相关练习" class="headerlink" title="3.1.3 相关练习"></a>3.1.3 相关练习</h4><h5 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">数组的相对排序</a></h5><blockquote><p>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。</p><p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p></blockquote><p>我们可以按照计数排序的思想，统计每个数字出现的次数，然后根据 arr2 计算每个数字应该在结果中对应的左右一个下标位置，这样就可以把在 arr2 中出现过的数字排好，剩下没有出现过的放到数组末尾，然后再利用其他排序微调。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + countings[arr2[i<span class="number">-1</span>] - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(i + min) != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = map[i + min];</span><br><span class="line">                countings[i] = countings[i] + presum[t] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = countings[i];</span><br><span class="line">                countings[i] = countings[i] + presum[m] + offset - <span class="number">1</span>;</span><br><span class="line">                offset += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[countings[arr1[i] - min]] = arr1[i];</span><br><span class="line">            countings[arr1[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>() + presum[m], res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然这样做显然使问题变得更复杂了，上面用到了哈希表、前缀和等复杂的技巧，对于这道简单题来说是完全没有必要的，我们只要用伪计数排序的思想，统计数字出现的次数，然后按照 arr2 提供的顺序找到计数数组中该数字出现的次数，放到结果数组中即可，之后再遍历一次计数数组把出现次数不为 0 的数按顺序放到结果末尾即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[e - min]) &#123;</span><br><span class="line">                arr1[index] = e;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[e - min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr1[index] = i + min;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-基数排序"><a href="#3-2-基数排序" class="headerlink" title="3.2 基数排序"></a>3.2 基数排序</h3><h4 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h4><p>基数排序是通过对比数字的关键字进行排序的，关键字就称为基数，比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：</p><ul><li>先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系</li><li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li><li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li></ul><p>这就是基数排序的思路，上面的过程我们是从数字的最高位开始比较的，这样的基数排序叫做「最高位优先法」，简称 <code>MSD (Most significant digital)</code>，与之对应的还有「最低位优先法」，简称 <code>LSD (Least significant digital)</code>。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p><p>一般来说 LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p><p>基数排序可以分为以下三个步骤：</p><ul><li>找出数组中最大的数字的位数 maxDigitLength</li><li>获取数组中每个数字的基数</li><li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序</li></ul><p>对基数进行排序最好的办法就是使用计数排序，因为基数只可能在 0 ~ 9 之间，使用计数排序效率会很高，并且还能保证稳定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组中存在负数时，我们可以把计数排序的统计数组改为长度为19，用来统计 -9 ~ 9 出现的次数，但是要注意计算出的基数要加 9，以从 [-9, 9] 映射到计数数组下标 [0, 18]，完整的基数排序算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(value) &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">abs</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix + <span class="number">9</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix + <span class="number">9</span>]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-算法分析"><a href="#3-2-2-算法分析" class="headerlink" title="3.2.2 算法分析"></a>3.2.2 算法分析</h4><p>基数排序需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。所以基数排序的时间复杂度为 $O(d(n + k))$，其中 d 表示最长数字的位数，k 表示每个基数可能的取值范围大小。</p><p>基数排序使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。</p><h4 id="3-2-3-相关练习"><a href="#3-2-3-相关练习" class="headerlink" title="3.2.3 相关练习"></a>3.2.3 相关练习</h4><h5 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p><p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p></blockquote><p>因为要保证线性时间和空间复杂度，因此使用基数排序符合要求，排序后再遍历找到最大差值即可。</p><h5 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h5><blockquote><p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p><p>返回该最大总和 。</p></blockquote><p>排序后拆分即可。使用基数排序会使时间复杂度更低。</p><h3 id="3-3-桶排序"><a href="#3-3-桶排序" class="headerlink" title="3.3 桶排序"></a>3.3 桶排序</h3><h4 id="3-3-1-算法思想"><a href="#3-3-1-算法思想" class="headerlink" title="3.3.1 算法思想"></a>3.3.1 算法思想</h4><p>桶排序的思想是：</p><ul><li>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶</li><li>遍历数组，将每个数字装入桶中</li><li>对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等</li><li>最后按照顺序将所有桶内的数字合并起来</li></ul><p>桶排序一般只能在特定情况下使用，因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。</p><p>影响桶排序的效率的因素主要有两个：</p><ul><li>一个是桶的数量，桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。一般来说设置桶的数量要根据数组的数据量和数组内的最大值和最小值确定，一般用如下公式确定可以保证每个桶内的数字尽量均匀：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个桶的间距</span></span><br><span class="line">gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 桶的数量</span></span><br><span class="line">bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 数组内数字所在的桶的编号</span></span><br><span class="line">index = (nums[i] - min) / gap;</span><br></pre></td></tr></table></figure><ul><li>桶内排序算法，桶内排序算法可以使用插入排序、快速排序等，可以根据实际需要选择。</li></ul><p>基于插入排序的桶排序的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxnum = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minnum = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketnum);</span><br><span class="line">    <span class="comment">// 装桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (x - minnum) / gap;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序并放回原数组</span></span><br><span class="line">    arr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertsort</span>(buckets[i]);</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-算法分析"><a href="#3-3-2-算法分析" class="headerlink" title="3.3.2 算法分析"></a>3.3.2 算法分析</h4><p>我们逐步分析桶排序的时间复杂度和空间复杂度。</p><p>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><p>第二步：装桶的过程需要遍历一轮数组，时间复杂度 $O(n)$，空间复杂度与$O(n)$。</p><p>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 $n&#x2F;k$,</p><ul><li><p>如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n&#x2F;k)^2)$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k)^2)$，即 $O(n^2 &#x2F; k)$。</p></li><li><p>如果采用 $O(n\log n)$ 级排序算法，每个桶内排序的时间复杂度 $O((n&#x2F;k) \log (n&#x2F;k))$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k) \log (n&#x2F;k))$，即 $O(n \log (n&#x2F;k))$。</p></li></ul><p>在桶的数量合适的情况下，时间复杂度 $O(n^2 &#x2F; k)$ 和 $O(n \log (n&#x2F;k))$ 都约等于 $O(n)$。桶内排序的空间复杂度也和具体的排序算法有关，$O(1)$ 或者 $O(n)$。</p><p>第四步：桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p><p>综上，桶排序的时间复杂度为 $O(n)$，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快。空间复杂度为 $O(n)$。</p><h4 id="3-3-3-相关练习"><a href="#3-3-3-相关练习" class="headerlink" title="3.3.3 相关练习"></a>3.3.3 相关练习</h4><h5 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote><p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p><p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p></blockquote><p>使用桶排序解决这个问题更加巧妙。甚至不需要真正进行排序，只要把所有数字放到对应的桶里，然后记录每个桶的最大值和最小值，最后从左到右遍历桶，用后一个桶的最小值减去前一个桶的最大值，所有这些差值中最大的就是题目所要求的最大间距。具体证明参考<a href="https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/">官方题解方法二</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = (maxVal - minVal) / n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketnum = (maxVal - minVal) / gap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketnum, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (nums[i] - minVal) / gap;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序&lt;/li&gt;
&lt;li&gt;时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序&lt;/li&gt;
&lt;li&gt;时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;排序数组&lt;/a&gt;题目实践这些算法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【RayTracer】（一）实现基本工具类</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-04-11T12:39:03.000Z</published>
    <updated>2022-04-11T13:36:40.833Z</updated>
    
    <content type="html"><![CDATA[<p>这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。</p><p><em><span id="more"></span></em></p><h3 id="1-三维向量类"><a href="#1-三维向量类" class="headerlink" title="1 三维向量类"></a>1 三维向量类</h3><p>尽管在正规的光线追踪器中使用更多的是四维向量，比如齐次坐标和带有 A 通道的颜色，但是对于我们这个简化的光线追踪器来说，三维向量已经足够了，我们可以使用三维向量表示位置、方向、颜色等，为了区分这三种表示，我们给三维向量类 <code>vec3</code>起两个别名 <code>point3</code> 和 <code>color</code> 以方便之后代码的编写和阅读，但他们实质上没有任何区别，我们没有为了不同的表示构造一个专门的类，这意味着一个颜色和一个位置可以进行相加，这在正常的光线追踪工程实现中是不被允许的，但我们毕竟是简化版本，只要在使用的时候注意即可。</p><p>我们首先在该类中实现一些基本的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  实现三维向量类，用于存储位置、向量、颜色等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类及常用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> e[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec3</span>() : e&#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="type">double</span> e0, <span class="type">double</span> e1, <span class="type">double</span> e2) : e&#123; e0, e1, e2 &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3 <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">        e[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">        e[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">        e[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        e[<span class="number">0</span>] *= t;</span><br><span class="line">        e[<span class="number">1</span>] *= t;</span><br><span class="line">        e[<span class="number">2</span>] *= t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e[<span class="number">0</span>] * e[<span class="number">0</span>] + e[<span class="number">1</span>] * e[<span class="number">1</span>] + e[<span class="number">2</span>] * e[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义vec3的别名，分别用于存储点和颜色，提升代码可读性</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;</span><br><span class="line"><span class="keyword">using</span> color = vec3;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在工程实践中，文件开头的 <code>#pragma once</code> 是必须的，否则可能因为头文件重复包含导致编译错误，定义类时的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也是必须的，同样是为了防止重复编译。</p><p>然后实现一些对向量操作的工具函数，大部分是运算符重载，以让我们可以按照之前的习惯操作三维向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******一些工具函数*******/</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应元素相乘</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向量和标量运算</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">double</span> t, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t * v.e[<span class="number">0</span>], t * v.e[<span class="number">1</span>], t * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>] + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>] + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叉乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">        u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">        u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单位化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">normalize</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用于最后的图像输出，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 注意输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-光线类"><a href="#2-光线类" class="headerlink" title="2 光线类"></a>2 光线类</h3><p>光线类是基于三维向量类的，我们按照图形学中射线的定义来实现一个光线类，给定空间中一个位置和一个方向就可以确定一条射线，再给定时间 t，就可以得到射线上任意一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现光线类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-图像输出"><a href="#3-图像输出" class="headerlink" title="3 图像输出"></a>3 图像输出</h3><p>我们所有渲染结果最终都要输出到一张图片中，我们可以选择任何输出格式，这里使用了非常方便的开源的图像工具 <a href="https://github.com/nothings/stb">stb_image </a>，将结果保存到数组中然后使用 <code>stbi_write_png</code> 函数保存为 PNG 格式图片。我们用一个生成渐变图片的例子来了解图像输出流程。</p><p>首先定义一个 <code>ray_color</code> 函数，根据给定的方向机型简单的线性插值，以混合两种不同的颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据归一化的方向的y坐标线性混合白色和蓝色，以得到自上而下的蓝白色渐变效果</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义相机所在位置为 (0, 0, 0)，屏幕（输出的图片）比例为 16 : 9，因此我们的视口比例也要和最终的图片比例一致，然后从屏幕左上角开始遍历，从相机向屏幕投射光线，根据该光线方向通过 <code>ray_color</code> 函数计算插值颜色显示到屏幕上。场景大致如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/fig-1.03-cam-geom.jpg" alt="fig-1.03-cam-geom"></p><p>下面实现主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;BlendColor.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename; </span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，可以刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/BlendColor.png" alt="BlendColor"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="RayTracer" scheme="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="光线追踪" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
</feed>
