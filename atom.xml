<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LycTechStack</title>
  
  <subtitle>Lyc的个人成长技术栈</subtitle>
  <link href="https://lz328.github.io/LycTechStack.github.io/atom.xml" rel="self"/>
  
  <link href="https://lz328.github.io/LycTechStack.github.io/"/>
  <updated>2022-03-10T13:34:02.029Z</updated>
  <id>https://lz328.github.io/LycTechStack.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【计算机图形学】（八）图形管线</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-03-10T13:29:33.000Z</published>
    <updated>2022-03-10T13:34:02.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图形管线（Graphics-Pipeline）"><a href="#图形管线（Graphics-Pipeline）" class="headerlink" title="图形管线（Graphics Pipeline）"></a>图形管线（Graphics Pipeline）</h3><p>这一节将对前面的所有内容做一个总结，因为图形管线就是由前面的所有内容组成的一个图形渲染流水线，空间中的点经过图形管线就被渲染到屏幕上成为图形。</p><p><em><span id="more"></span></em></p><p>图形管线是基于物体顺序渲染的一系列绘制操作的序列。相对于基于物体顺序渲染还有基于图像顺序渲染，会在之后会讲到。基于物体顺序渲染由于其极高的运行效率而统治了图形学的渲染方法，从早期人们提出了软件图形管线后，图形管线的流程思路又被硬件优化内置到显卡中成为硬件图形管线，这两个管线后来呈现出并行关系，负责不同的事务。</p><p>图形管线的主要流程如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/image-20220310201713743.png" alt="image-20220310201713743"></p><h4 id="1-顶点数据处理"><a href="#1-顶点数据处理" class="headerlink" title="1 顶点数据处理"></a>1 顶点数据处理</h4><p>输入图形管线的是三维空间中的顶点，这些输入的顶点数据不止有坐标，还包括纹理坐标、顶点法线和顶点颜色等各种属性，顶点数据处理就是对这些属性数据进行处理，首先把顶点连成空间中的一个个面，可以是三角形也可以是四边形，这里我们就用常用的三角形，空间中的三角形称为<strong>图元</strong>。</p><p>之后就是经过各种矩阵变换把三维映射到二维屏幕上，在变换的时候还会进行一步重要的操作，叫做视体裁剪，视体就是指透视投影近平面和远平面组成的四棱台。这需要回顾透视投影部分的内容。</p><p>透视投影有一个重要的性质就是它会将直线映射为直线，平面映射为平面，线段映射为线段，并且保留了所有点的排序正确，这保证了三角形正确映射为三角形。</p><p>但是经过透视投影矩阵，原本的 $z$ 将会被映射为 $z’&#x3D;n+f-nf&#x2F;z$。于是我们就会发现在这个映射中，正的 $z$ 值会被映射到负 $z$ 上，负的 $z$  值被映射到正 $z$  上，当我们要渲染的物体都在视体内时自然还能正确投影到屏幕上，但是一旦出现了跨越 $z&#x3D;0$ 的线段，线段就会有一部分被映射到正负无穷因而被撕裂。</p><p>详细来看其实是下面的图所导致的。下图所表示经过透视投影处理后的 $z$ 值情况，可以看到由于视体标准化的原因 $n+f$ 是真正意义上的 0 点，$z$ 值在 $n+f$ 的位置发生的翻转，这个翻转导致了图的下半部分的三角形 $c$ 点经过透视投影后出现在了另一个方向，这将会导致光栅化的时候绘制出错误三角形。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/q3tenh9i8t.png" alt="q3tenh9i8t"></p><p>观察上面的图我们还可以发现在视体中的部分(也就是z&#x3D;n到z&#x3D;f的区域)，经过透视投影后也会保持原来的顺序和位置，因而解决这个问题的方法就很直观了，在透视投影前就先将视体之外的面片裁剪掉，这就是视体裁剪。视体裁剪除了防止撕裂外还有一个显而易见的好处就是减少了后面进行投影变换时需要处理的顶点数量，而且减少掉的内容本来就在视体之外所以不会影响到最终的画面。</p><p>具体如何进行裁剪，我们可以根据视体的顶点坐标计算出六个平面的方程，然后将空间中的点带入视体面方程，但平面方程计算比较复杂，更多关于裁剪的内容可以查看本篇的参考内容。</p><h4 id="2-曲面细分"><a href="#2-曲面细分" class="headerlink" title="2 曲面细分"></a>2 曲面细分</h4><p>曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量，是渲染管线一个可选的阶段。它由外壳着色器(Hull Shader)、镶嵌器(Tessellator)和域着色器(Domain Shader)构成，其中外壳着色器和域着色器是可编程的，而镶嵌器是由硬件管理的。我们可以借助曲面细分的技术实现细节层次(Level-of-Detail)的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。</p><h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>经过前面的处理我们得到了许多图元，并且最后通过视口变换变换到了屏幕坐标系下，然后就是进行光栅化，光栅化阶段会把图元变成屏幕坐标系中的离散的片元，片元可以理解为像素，但它与像素的区别在于片元拥有比像素更多的信息，例如深度值，法线，纹理坐标等信息。因此片元只是尺度和像素相同，但片元还不能直接显示到屏幕，一个像素会有很多个候选片元，这些片元还要经过一系列计算才能决定哪些片元显示在屏幕上。</p><h4 id="4-片元处理"><a href="#4-片元处理" class="headerlink" title="4 片元处理"></a>4 片元处理</h4><p>片元处理阶段会对各个片元计算深度、颜色等属性信息，这里用到的就是三角形重心坐标插值，计算颜色还要用到纹理映射，因为片元相当于一个像素，所以这里的着色频率相当于是对每一个像素计算着色，也就是Phong Shading。有的图形管线也会在顶点处理时进行着色，也就是进行Gouraud Shading，但效果肯定不如逐片元着色好。</p><h4 id="5-混合测试"><a href="#5-混合测试" class="headerlink" title="5 混合测试"></a>5 混合测试</h4><p>经过片元处理我们就得到了所有片元的颜色，最后就是要选择哪些片元能够显示在屏幕上，这里要经过一系列的混合测试，比如深度测试，也就是要用到之前说过的Z-Buffer，选择深度小的片元进行显示，当然除了深度测试之外还有切测试、Alpha测试、模板测试等等。</p><h4 id="6-Shader"><a href="#6-Shader" class="headerlink" title="6 Shader"></a>6 Shader</h4><p>刚才说到过，在图形管线中我们可以选择在顶点处理阶段进行着色或者在片元处理阶段进行着色，而且我们还可以对着色进行专门的编程，控制GPU对对一个着色点执行什么样的着色操作，这就是Shader。</p><p>Shader（着色器）是指一组供计算机图形资源在执行渲染任务时使用的指令，用于计算图像的颜色或明暗。通俗地说，着色器告诉电脑如何用特有的一种方法去绘制物体。</p><p>关于Shader，后面会有专门的文章详细的讲解。</p><h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1685227">【笔记】《计算机图形学》(8)——图形管线 - 云+社区 - 腾讯云 (tencent.com)</a></li><li><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html">细说图形渲染管线</a></li><li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;图形管线（Graphics-Pipeline）&quot;&gt;&lt;a href=&quot;#图形管线（Graphics-Pipeline）&quot; class=&quot;headerlink&quot; title=&quot;图形管线（Graphics Pipeline）&quot;&gt;&lt;/a&gt;图形管线（Graphics Pipeline）&lt;/h3&gt;&lt;p&gt;这一节将对前面的所有内容做一个总结，因为图形管线就是由前面的所有内容组成的一个图形渲染流水线，空间中的点经过图形管线就被渲染到屏幕上成为图形。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（七）纹理映射</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</id>
    <published>2022-03-10T11:29:26.000Z</published>
    <updated>2022-03-10T12:07:42.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h3><p>上一节介绍了着色模型和着色频率，回忆漫反射的计算，漫反射系数 $k_d$ 通常就是物体本身的颜色，但很多时候物体本身的颜色并没有那么简单，大多数情况下，物体上每一个部分的颜色都不同，物体表面具有一定的纹理，比如木质的地板，此时我们在渲染的时候也需要把这样的纹理渲染出来，这就是纹理映射。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310165904624.png" alt="image-20220310165904624"></p><p><em><span id="more"></span></em></p><h4 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1 纹理映射"></a>1 纹理映射</h4><p>首先是一个非常简单的结论：每一个三维物体表面上的点，都可以对应一个二维平面上的点。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310170619028.png" alt="image-20220310170619028"></p><p>比如一个地球仪，我们把地球仪展开成一个平面，就是世界地图，相反，实际上纹理映射就是把世界地图“贴”到地球仪上。</p><p>因此对于三维物体表面的点，我们都可以把它映射到一个纹理空间中，这个纹理空间和屏幕空间一样，都是二维的，纹理空间的坐标用 $(u,v)$ 来表示，这样我们就把屏幕空间，三维空间和纹理空间联系到了一起，当然通过上图也可以看出来这三个坐标之间的关系：三维空间坐标是联系屏幕空间坐标和纹理空间坐标的桥梁，我们无法直接通过屏幕空间坐标得到对应的纹理空间坐标，因为他们之间不存在一一对应关系，屏幕上一个像素可能对应纹理空间的一个区域。这里不理解也没关系，后面我们就会遇到这种情况。</p><p>于是，最理想的情况下，三维物体上每个点都对应纹理空间的一个点，自然三维空间的三角形也就可以对应纹理图上的一个三角形，我们把这些对应的三角形的颜色都“复制”到三维图形表面的三角形上，也就相当于把一张纹理图“贴”到了模型上。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310171049609.png" alt="image-20220310171049609"></p><p>具体怎么做呢？我们对于每一个屏幕上的采样点，可以通过上一次说的三角形重心坐标插值的方法，得到这个采样点的纹理坐标$(u,v)$，然后我们根据纹理坐标直接到纹理图上查询，就可以得到纹理颜色，然后把纹理颜色作为漫反射系数 $k_d$ 去计算颜色就可以了。</p><h4 id="2-纹理过小"><a href="#2-纹理过小" class="headerlink" title="2 纹理过小"></a>2 纹理过小</h4><p>上面我们了解了纹理映射的过程，其实非常简单。但实际上也没有那么简单，我们先考虑一种情况，那就是如果纹理图很小，会发生什么？</p><p>比如我们要在屏幕上画一面 4K 的墙面，但是纹理图只有不到 1K 的分辨率，这个时候屏幕上的多个像素都会映射到纹理图上的同一个像素内，我们把纹理图上的像素称为纹素 <strong>Texel</strong>，如果我们使用最近邻的方式去获得纹理颜色，那么这些像素的颜色就都会是一样的，这相当于把原本低分辨率的图暴力的放大了，于是就会出现下面左边的图这样的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p><p>因此我们肯定不能用最近邻方法获取纹理颜色值，对于这种问题，自然想到插值，比如最简单的双线性插值。假如屏幕上的一个像素映射到纹理图上的坐标对应红色的点，周围黑色的点是纹素中心：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173834882.png" alt="image-20220310173834882"></p><p>双线性插值选取该点周围最近的四个纹素：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174007656.png" alt="image-20220310174007656"></p><p>计算在水平和垂直两个方向上的相对偏移系数，偏移系数都在0~1之间，我们假设两个纹素之间的距离是 1：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174055457.png" alt="image-20220310174055457"></p><p>然后先做一次水平插值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174217122.png" alt="image-20220310174217122"></p><p>再做一次竖直插值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174310943.png" alt="image-20220310174310943"></p><p>一共做了两种线性插值，所以叫做双线性插值。然后将插值的颜色作为该点的纹理颜色返回，这样就可以使得屏幕上的像素过度的更柔和一些，下面中间的图就是双线性插值的结果。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p><p>当然还可以使用更复杂的双cubic插值，会选取周围16个点做两次cubic插值，效果会更好，当然运算开销也更大，最右边的图把眼角处细微的锯齿都去掉了。</p><h4 id="3-纹理过大"><a href="#3-纹理过大" class="headerlink" title="3 纹理过大"></a>3 纹理过大</h4><p>讨论完了纹理图过小产生的问题，接下来考虑如果纹理图过大又会发生什么呢？</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175039809.png" alt="image-20220310175039809"></p><p>可以看到，当纹理图的分辨率过大时，产生了锯齿和摩尔纹，也就是发生了走样。为什么会走样呢，回顾之前说的走样产生的原因，是因为采样频率跟不上信号变化的频率，当纹理图过大时，屏幕上一个像素对应到纹理图上可能是一片区域：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175322646.png" alt="image-20220310175322646"></p><p>这一片区域中每一个纹素颜色都可能不同，这相当于在一个像素内，信号（也就是颜色）发生了剧烈的变化，这也就是采样频率低于了信号的变化频率，也就发生了走样。此时如果我们用区域内的一个纹素值代表整个区域的颜色显然是不合理的。因此我们要进行纹理映射的反走样。</p><p>反走样之前也讲过，最简单的反走样就是增大采样频率，比如类似于MSAA的超采样，我们可以把一个像素分成好多个像素去映射到纹理图上，然后获取这些子像素的纹理颜色，最后加权整合成像素颜色。效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175853537.png" alt="image-20220310175853537"></p><p>可以看到效果还不错，但为了得到这样的效果进行了512倍超采样，消耗太大了，如果纹理图更大呢？我们没有办法无穷尽的进行超采样，因此最好是换一种方法。</p><p>反走样是因为采样产生的，那我们可以不直接不采样，如果我们能直接获取到纹理图上某个区域的平均值，就不需要进行采样了。我们直接把像素对应的区域的平均值拿到就可以了。如何做到呢？</p><h5 id="3-1-Mipmap"><a href="#3-1-Mipmap" class="headerlink" title="3.1 Mipmap"></a>3.1 Mipmap</h5><p>Mipmap是一种非常<strong>快速的</strong>，<strong>空间开销很低的</strong>，<strong>近似的</strong>，区域查询方法，但<strong>只能查询方形区域</strong>。</p><p>Mipmap的思想非常简单，我们把一张图片每四个像素计算一个平均值，这样全图计算一次之后，图片尺寸就缩小了一半，这个图片中每个像素的值就是原图一个正方形区域四个像素的平均值，之后继续这样缩小下去，就得到了不同级别的原图的多个像素的平均值构成的图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310180712996.png" alt="image-20220310180712996"></p><p>由于每次图片尺寸缩小一半，那么像素数就只有原来的四分之一，所有级别的图加起来所花费的额外存储空间也不过原图大小的三分之一（简单的等比数列求和）。</p><p>接下来就是如何去查询信息了。我们把屏幕空间中的一个点和它水平和垂直方向相邻的点都映射到纹理空间中，就得到了纹理空间中的三个点（也可以是四个，把对角线上相邻的点也映射过去就是四个点，具体看后续是否用得到）；</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181400709.png" alt="image-20220310181400709"></p><p>然后我们计算映射后该点和其他两个点的距离，把这个距离取最大值作为以该点为中心的正方形区域的边长，这样就<strong>近似</strong>得到了屏幕上一个像素在纹理空间中对应的一片正方形区域。然后查询这片区域的平均值即可，查询的级别 $D&#x3D;log_2L$，D取整数。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181820489.png" alt="image-20220310181820489"></p><p>下面是按照上面的算法，一个场景中每个像素要查询的Mipmap的级别可视化的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181932739.png" alt="image-20220310181932739"></p><p>可以发现Mipmap级别 D 取整数会造成屏幕上相邻像素查询的级别可能差别很大，最后渲染出来的图可能会有严重的割裂现象，因此我们希望查询的级别也能平滑过渡，我们希望可以查询 1.8 级的Mipmap，又是平滑过渡，因此又是插值。</p><p>我们可以去查询两个级别的Mipmap，在Mipmap内部使用双线性插值得到两个级别的平均值，然后再将这两个级别进行线性插值得到最终结果，也就是进行了三线性插值：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182407725.png" alt="image-20220310182407725"></p><p>使用三线性插值后，Mipmap级别可视化的效果如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182449283.png" alt="image-20220310182449283"></p><p>过度非常平滑，达到了我们想要的效果。</p><p>最后看一下使用Mipmap渲染出来的图片是什么样子：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182543245.png" alt="image-20220310182543245"></p><h5 id="3-2-各向异性过滤"><a href="#3-2-各向异性过滤" class="headerlink" title="3.2 各向异性过滤"></a>3.2 各向异性过滤</h5><p>可以看到Mipmap渲染的图形中，近处的锯齿消失了，但远处产生了过度模糊，这是因为Mipmap只能近似方形区域，而这张图上近处的像素映射到纹理空间中对应的区域非常小，因此无论这个区域是什么形状，近似成正方形都不会有太大的问题，但是远处的一个像素对应到纹理图上可能是很大一片区域，此时这个区域的形状就会对结果产生影响了，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183141960.png" alt="image-20220310183141960"></p><p>区域很大时，如果形状不是正方形而是一个矩形，那我们按照Mipmap的方法实际近似的区域其实是这个矩形的Bounding box，这与原来的矩形区域差别很大，所以Mipmap不能完美的解决走样问题。</p><p>因此现在游戏中使用的更多的是各向异性过滤技术。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183403325.png" alt="image-20220310183403325"></p><p>各向异性过滤是Mipmap的改进，它不仅每次等比例的缩小原图，还会长宽不等比例的去计算Mipmap，这样缩小的图上一个像素对应的就是原图上一个矩形区域内像素的平均值了，然后我们就可以支持矩形的查询了。但斜向的矩形查询仍然存在问题。</p><p>除此之外的反走样方法还有EWA过滤，如下图，是用多个圆形或者椭圆形去近似填充任意几何图形，但是需要多次查询，不过可以查询任意形状的区域。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183733788.png" alt="image-20220310183733788"></p><h4 id="4-纹理的应用"><a href="#4-纹理的应用" class="headerlink" title="4 纹理的应用"></a>4 纹理的应用</h4><p>前面就是纹理映射的全部基本的内容，现在我们要把纹理推广开来。</p><p>纹理不是一张简单的图片。在现代GPU中，纹理就可以理解为<strong>一块可以支持快速范围查询的内存</strong>。而上面我们所说的纹理图，只不过是纹理的一种用法而已，纹理图其实就是把颜色存入这块内存，供我们随时查询，取用。当然我们也可以存别的东西，所以纹理可以有各种各样的用途。</p><h5 id="4-1-环境贴图"><a href="#4-1-环境贴图" class="headerlink" title="4.1 环境贴图"></a>4.1 环境贴图</h5><p>一些光面的物体还会反射环境中的景象，这怎么做到呢？也是利用纹理实现的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184622644.png" alt="image-20220310184622644"></p><p>我们可以提前把整个环境的图存下来，渲染物体颜色的时候把环境作为一个纹理应用到物体上就可以了。</p><p>我们假设用一个球来存储环境贴图，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184801387.png" alt="image-20220310184801387"></p><p>那把这球的表面展开成平面，就得到了整个场景的环境贴图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184850501.png" alt="image-20220310184850501"></p><p>但我们会发现这张帖图有一点问题，就是边缘会产生扭曲，因为球顶部的面积更小，所以造成了扭曲。因此人们想到用立方体存储不是更好吗？</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185057776.png" alt="image-20220310185057776"></p><p>把球的每一个面“贴到”立方体的每一个面上，就可以用立方体存储整个环境，大概的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185159502.png" alt="image-20220310185159502"></p><h5 id="4-2-凹凸贴图"><a href="#4-2-凹凸贴图" class="headerlink" title="4.2 凹凸贴图"></a>4.2 凹凸贴图</h5><p>有时候我们希望渲染出物体表面凹凸不平的样子：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185306391.png" alt="image-20220310185306391"></p><p>这时我们可以用凹凸贴图来解决。想要造成凹凸的效果，其实就是在计算光照时，将顶点或者平面的法向量向上或者向下移动一定的距离，这样计算出的光照就有明显的明暗变化，在我们看起来也就产生了凹凸的效果，因此我们可以用纹理存储每一个顶点法向量的扰动量，然后再计算光照时取到这个扰动量施加到原本的法向量上去计算光照，就得到了凹凸的效果。具体怎么计算扰动后的法向量呢？</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185709262.png" alt="image-20220310185709262"></p><p>我们先考虑简单的二维情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185827357.png" alt="image-20220310185827357"></p><p>假设原本平面的法向量是$(0,1)$，我们可以计算出扰动后的点在曲线上的导数（切线），然后可以直接得到和切线垂直的方向，这就是扰动后的点的法线方向，最后别忘了归一化。</p><p>推广到三维空间中，我们每次计算都把当前点的法向量转换到以这个点为基准的局部坐标系下，这样当前点的法向量就是$(0,0,1)$，然后同样计算在两个方向上的导数：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190221871.png" alt="image-20220310190221871"></p><p>于是扰动后的法线方向就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190327571.png" alt="image-20220310190327571"></p><p>最后再从局部坐标系转换回原本的坐标系即可。</p><h5 id="4-3-位移贴图"><a href="#4-3-位移贴图" class="headerlink" title="4.3 位移贴图"></a>4.3 位移贴图</h5><p>使用凹凸贴图可以渲染出凹凸的效果，但是其实只是在计算光照时改变了顶点的法向量，而顶点本身没有发生任何变化，所以我们看到的凹凸效果只是一个假象，很容易看出破绽：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190611021.png" alt="image-20220310190611021"></p><p>凹凸贴图渲染出来的模型边缘还是平滑的。而位移贴图可以渲染出真正凹凸不平的效果。</p><p>位移贴图存储的是每个顶点的位移，也就是它真正改变了点在空间中的位置，这样自然模型的形状也就发生了变化，渲染的效果也会更真实。</p><p>那为什么不直接做一个这样的模型呢？显然这么复杂的模型如果直接在建模的时候就做好，要花费大量的精力，所以位移贴图要方便许多。</p><h5 id="4-4-三维噪声和固体纹理"><a href="#4-4-三维噪声和固体纹理" class="headerlink" title="4.4 三维噪声和固体纹理"></a>4.4 三维噪声和固体纹理</h5><p>有一些纹理比如瓷器上的纹路，是完全不规则并且独一无二的，这时候如果我们给每一个花瓶一个不同的贴图显然是不现实的，因此我们可以给定一个三维程序噪声函数，在计算颜色的时候利用这个噪声函数生成随机的纹路。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191026718.png" alt="image-20220310191026718"></p><p>有时候我们的模型内部也需要有一定的纹理，比如大理石切开之后的纹理，那我们可以把整个大理石的表面和内部的全部纹理信息都存下来，存储成一个三维的纹理，这样对应空间中每一个点都有不同的纹理。</p><h5 id="4-5-环境光遮蔽"><a href="#4-5-环境光遮蔽" class="headerlink" title="4.5 环境光遮蔽"></a>4.5 环境光遮蔽</h5><p>我们在计算shading的时候并不会考虑模型本身对模型光照的影响，比如下面这张图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191426063.png" alt="image-20220310191426063"></p><p>模型本身可能会对光照有一定的遮挡，导致不同部分产生一些阴影，左边的图就是正常着色的结果，可以看到眼眉处没有阴影，显得不是很真实，因此我们可以预先计算模型本身对光照的影响，生成一张阴影纹理图，在之后着色的时候加到着色结果上，就有了更真实的渲染结果，这也是环境光遮蔽的原理。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;纹理映射（Texture-Mapping）&quot;&gt;&lt;a href=&quot;#纹理映射（Texture-Mapping）&quot; class=&quot;headerlink&quot; title=&quot;纹理映射（Texture Mapping）&quot;&gt;&lt;/a&gt;纹理映射（Texture Mapping）&lt;/h3&gt;&lt;p&gt;上一节介绍了着色模型和着色频率，回忆漫反射的计算，漫反射系数 $k_d$ 通常就是物体本身的颜色，但很多时候物体本身的颜色并没有那么简单，大多数情况下，物体上每一个部分的颜色都不同，物体表面具有一定的纹理，比如木质的地板，此时我们在渲染的时候也需要把这样的纹理渲染出来，这就是纹理映射。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310165904624.png&quot; alt=&quot;image-20220310165904624&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】（二）线性动态规划之带维度单串问题</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2/</id>
    <published>2022-03-10T08:44:11.000Z</published>
    <updated>2022-03-10T08:48:18.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="带维度单串问题"><a href="#带维度单串问题" class="headerlink" title="带维度单串问题"></a>带维度单串问题</h3><p>上一篇中的单串问题，子问题仅与位置 i 有关，也就是 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 $dp[i][k]$。其中 k 上可能有二分，贪心等算法。这类问题相比于普通单串问题要更复杂，需要多见多积累。</p><p><em><span id="more"></span></em></p><h4 id="1-经典问题：最大平均值和的分组"><a href="#1-经典问题：最大平均值和的分组" class="headerlink" title="1 经典问题：最大平均值和的分组"></a>1 经典问题：<a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">最大平均值和的分组</a></h4><blockquote><p>问题描述：</p><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成最多 k 个相邻的非空子数组 。 <strong>分数</strong>由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大<strong>分数</strong>是多少。</p></blockquote><p>我们用 $dp[i][k]$ 表示把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数，于是 $dp[i][k]$ 在状态转移时取决于 $dp[j][k-1]$ 和 $avg(i,j-1)$，其中$j&gt;i$，$avg(i,j-1)$表示从 i 到 j-1 区间内的平均值，<strong>也就是把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数取决于把数组 nums[j…n-1] （j &gt; i）分成 k-1 个区间取得的最大分数加上从 nums[i] 到 nums[j-1] 的平均值</strong>。于是可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = dp[j][k-1] + avg(i, j-1);</span><br></pre></td></tr></table></figure><p>可以看出，k状态的推导与 k-1 状态有关，因此我们先从小到大枚举k，k&#x3D;1时，$dp[i][1]$相当于不划分子区间，也就是从nums[i] 到 nums[n-1] 的平均值。在每一次枚举k时，也就相当于一个单独的单串问题，枚举 i 和 j 进行状态转移即可。</p><p>因为 k 状态的推导只与 k-1 状态有关，所以利用滚动数组的思想，不需要使用二维数组存储状态信息，只用一维数组即可，因为我们从小到大遍历位置 i ，每次状态转移时，比 i 大的位置 dp[j] 还存储着 k-1 时的状态，然后我们利用这个状态更新 dp[i] ，此时 dp[i] 就被更新到了 k 状态。</p><p>另外计算区间平均值可以利用前缀和，避免重复计算，可以在O(1)时间内算出区间平均值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和方便快速计算区间平均值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第k次推导只与k-1的状态有关，因此只用一维数组就可以</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，相当于k=1的情况，初始化dp[i][1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = (sums[n]-sums[i])/<span class="built_in">double</span>(n-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; ++k)    <span class="comment">//为了好理解k从2开始枚举，实际上无所谓</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//普通的单串问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], (sums[j]-sums[i])/(j-i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-经典问题：股票系列"><a href="#2-经典问题：股票系列" class="headerlink" title="2 经典问题：股票系列"></a>2 经典问题：股票系列</h4><p>股票系列问题是 $dp[i][k]$ 这种状态设计模式的经典问题。同时还包含更复杂的情况 $dp[i][k][state]$ .</p><h5 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h5><blockquote><p>问题描述：</p><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>你可以在某一天买入，在之后的某一天卖出，返回你能获得的最大利润 。</p></blockquote><p>股票系列的入门问题，只能买卖一次股票，因此只是一个简单的单串问题，第 k 天能够获得的最大利润只与第 k-1 天能获得的最大利润有关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k] = max(dp[k-1], prices[k] - minprice)</span><br></pre></td></tr></table></figure><p>当然因为这道题非常简单，一次遍历记录 minprice 和 maxprofits就可以解决。</p><h5 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h5><blockquote><p>问题描述：</p><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>这次我们可以多次买卖股票，但同一时间只能最多持有一股股票。</p></blockquote><p>因此每天我们都只可能有两种状态，一种是持有股票，一种是不持有股票。于是定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大利润，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大利润。分别考虑这两种状态如何转移即可。</p><ul><li>如果第 i 天交易完后手里没有股票，那么那么可能的转移状态为前一天已经没有股票，即 $dp[i-1][0]$，或者前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，并获得 $prices[i]$ 的收益。因此为了收益最大化，我们列出如下的转移方程：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br></pre></td></tr></table></figure><ul><li>如果第 i 天交易完后手里有1股股票，那么那么可能的转移状态为前一天已经有1股股票，即 $dp[i-1][1]$，或者前一天结束的时候手里没有股票，即$dp[i-1][0]$，这时候我们要买入1股，所以总利润要减去今天的股票价格 $prices[i]$。因此可以列出如下的转移方程：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span><br></pre></td></tr></table></figure><p>对于初始状态，根据状态的定义，我们可以知道第 0 天交易结束的时候 $dp[0][0]&#x3D;0$， $dp[0][1]&#x3D;-prices[0]$。</p><p>由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，所以最终结果返回 $dp[n-1][0]$即可。</p><p><strong>另外</strong>，本题使用贪心算法会更简单，但不容易想到，不过这道题中我们<strong>可以用动态规划推导出贪心算法</strong>。</p><p>动态规划的状态定义定义和上面的方法稍有不同，定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大<strong>纯利润</strong>，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大<strong>纯利润</strong>。什么是纯利润呢，也就是我们不考虑买入和卖出股票本身的花费，只考虑买入和卖出时，所获得的股票差价。比如第一天买入时价格是7，第二天卖出时价格是1，我们的纯利润就是-6。 所以按照这个状态定义，初始状态 $dp[0][0]$ 和 $dp[0][1]$ 都是0。然后我们可以重新考虑这次状态该如何转移：</p><ul><li>如果第 i 天交易完后手里没有股票，那么可能的情况是前一天已经没有股票，那么今天的纯利润就是前一天的纯利润，即 $dp[i-1][0]$，因为今天什么操作都没做；另一种情况是前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，卖出后我们获得的纯利润是 $prices[i] - prices[i-1]$，于是今天的纯利润就是前一天持有1股股票的纯利润加上今天卖出后的纯利润。因此可以写出状态转移方程：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure><ul><li>如果第 i 天交易完后手里持有1股股票，那么可能的情况是前一天就持有1股股票，并且今天我们不卖出，那么到今天为止我们应该得到的纯利润，就是前一天的纯利润加上今天和昨天的差价，虽然我们今天没有卖出，但是还是要知道今天我们的盈亏是多少，因为每一天的盈亏加起来就是之后某一天卖出的时候我们能获得的纯利润；另一种情况就是前一天没有持有股票，今天买入，那么今天获得的纯利润就是前一天的纯利润，因为今天只是买入一股股票，也并没有收益，因此我们可以写出状态转移方程：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure><p>神奇事情发生了，<strong>两种情况的状态转移方程一模一样</strong>，那就说明无论我们今天是否卖出，对于我们能获得的<strong>纯利润</strong>这一个属性来说，都是一样的，要么是前一天不持股时的纯利润，要么是前一天持股的纯利润加上昨天和今天股票的差价，这二者取最大值就是我们到今天为止获得的最大纯利润。</p><p>于是状态方程可以改写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = max(dp, dp + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure><p>因为$dp[i][0]&#x3D;dp[i][1]$，那就可以都用 $dp$ 替换，也就得到了上面的方程，再改变一下写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp += max(0, prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure><p>这个关系式其实代表了贪心算法的思想，那就是：要使我们最后的纯利润最大，就要保证每一天的纯利润最大。</p><p>因此我们只要计算每一天和前一天的差价，把所有不小于 0 的差价全加起来，也就是我们最终能获得的最大总利润了。这个过程我们不需要考虑实际是否买入和卖出，因为最后加起来就相当于一次性买入和卖出了。</p><p>比如题目中的例子[1, 2, 3, 4, 5]，按照贪心算法，答案很简单等于4，相当于每一天都卖出前一天再买入，但是实际的交易过程并不是进行 4 次买入和 4 次卖出，而是在第 1 天买入，第 5 天卖出。</p><p>关于贪心算法的正常推导思路，可以查看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">官方题解方法二</a>。</p><h5 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h5><blockquote><p>问题描述：</p><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>这次我们最多可以进行 <strong>2</strong> 次交易，但同一时间只能最多持有一股股票。例如：</p><p>股票价格 [1, 2, 3, 4, 5]，我们不能在第 1 天和第 2 天接连购买股票，之后第 5 天再将它们卖出。</p></blockquote><p>这一次我们不能无限次进行交易了，题目规定了最多只能交易 2 次，因此我们的状态设计要把当前交易的次数考虑进去。</p><p>在上一个股票问题中，我们定义的状态 $dp[i][state]$ 表示的是第 i 天我们持有 state 支股票（state等于0或1）时最大的利润，那么这次我们定义状态 $dp[i][k][state]$ 表示<strong>第 i 天我们已经购买了 k 次股票后手中还持有 state 支股票时的最大利润</strong>，其中 k 只能是0，1或者2，因为我们最多只能交易 2 次，也就代表最多只能两次买入股票。那么我们的状态转移将分为下面 4 种情况：</p><ul><li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][1][0]$，这种情况下有两种可能性：</p><ul><li>要么我们在第 i 天之前已经完成了一次交易（买入并卖出），并且第 i 天也没有买入， 此时最大总利润就是前一天已经购买了 1 次股票且手中持有 0 支股票时的最大总利润 $dp[i-1][1][0]$，因为我们在第 i 天什么也没有做</li><li>要么我们在第 i 天之前买入了一支股票，并在第 i 天卖出，完成了 1 次交易，此时最大总利润是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$ 加上卖出股票获得的 $prices[i]$</li></ul><p>因此 $dp[i][1][0]$ 取决于上面两种情况的较大者，于是可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br></pre></td></tr></table></figure></li><li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][1][1]$，这种情况下有两种可能性：</p><ul><li>要么我们在第 i 天之前一次都没有买入股票，并在第 i 天买入，此时最大总利润就是买入股票的花费 $-prices[i]$</li><li>要么我们在第 i 天之前买入了 1 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$，因为我们什么操作都没有做</li></ul><p>于是可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</span><br></pre></td></tr></table></figure></li><li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][2][0]$，这种情况下有两种可能性：</p><ul><li>要么我们在第 i 天之前已经完成了两次交易（买入并卖出），此时我们无法再进行交易，因此最大总利润就是前一天已经完成两次交易后的最大总利润 $dp[i-1][2][0]$</li><li>要么我们在第 i 天之前已经完成了 一次交易（买入并卖出），并且第 2 次购买了一只股票，然后在第 i 天卖出，完成第 2 次交易，此时最大总利润就是前一天已经购买了 2 次股票并且手中还持有 1 支股票时的最大总利润 $dp[i-1][2][1]$ 加上卖出股票获得的利润 $prices[i]$</li></ul><p>于是可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span><br></pre></td></tr></table></figure></li><li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][2][1]$，这种情况下有两种可能性：</p><ul><li>要么我们在第 i 天之前完成了一次交易并且没有再进行买入，然后在第 i 天买入，此时最大总利润就是前一天已经购买了 1 次股票并且手持 0 支股票时的最大总利润 $dp[i-1][1][0]$ 加上买股票的支出 $-prices[i]$</li><li>要么我们在第 i 天之前买入了 2 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 2 次股票并且手持 1 支股票时的最大总利润 $dp[i-1][2][1]$，因为我们什么操作都没有做</li></ul><p>于是可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span><br></pre></td></tr></table></figure></li></ul><p>最后返回的结果自然是最后一天已经购买了 1 次或者 2 次股票后并且手中还持有 0 支股票时的最大总利润 $dp[n-1][1][0]$ 和 $dp[n-1][2][0]$ 中的最大值。</p><p>根据上面的状态转移方程，直接可以写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然第 i 天的最大总利润只与第 i - 1 天的最大总利润有关，因此不需要使用三维数组，并且因为每一天只有 4 种状态，所以我们只需要 4 个整数就可以完成动态规划推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp10 = <span class="number">0</span>, dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp20 = <span class="number">0</span>, dp21 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp10 = <span class="built_in">max</span>(dp10, dp11 + prices[i]);</span><br><span class="line">            dp11 = <span class="built_in">max</span>(dp11, - prices[i]);</span><br><span class="line">            dp20 = <span class="built_in">max</span>(dp20, dp21 + prices[i]);</span><br><span class="line">            dp21 = <span class="built_in">max</span>(dp21, dp10 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp10, dp20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到虽然推导过程很复杂，但代码非常简洁，这也正是动态规划的魅力。</p><h5 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h5><blockquote><p>问题描述：</p><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>这次我们最多可以进行 <strong>k</strong> 次交易，但同一时间只能最多持有一股股票。</p></blockquote><p>和上一题几乎一样，理解了上题的思路，本题没有难度，只是在状态转移时要遍历购买股票的次数 k ，而不是只有 2 次了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化要注意，要把第一天购买1...k次后持有1支股票的情况都初始化，和上题一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j][<span class="number">0</span>]);<span class="comment">//结果是最后一天购买1...k次股票后还持有0支股票的最大利润的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h5><blockquote><p>题目描述：</p><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong><br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><p>这道题是 股票问题 II 的变体，多了一个冷却期，状态的推导并不难，关键在于状态要定义好，详细可以看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">力扣官方题解</a>。</p><h5 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h5><blockquote><p>问题描述：<br>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p></blockquote><p>同样是 股票问题 II 的变体，现在看来非常简单。</p><h4 id="3-粉刷房子系列"><a href="#3-粉刷房子系列" class="headerlink" title="3 粉刷房子系列"></a>3 粉刷房子系列</h4><h5 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">粉刷房子</a></h5><blockquote><p>问题描述：</p><p>给一排房子上色，相邻房子颜色不能相同，一共有三种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p></blockquote><p>因为只有三种颜色，比较简单，$dp[i][k](k &#x3D; 0,1,2)$表示粉刷到第 i 间房子为止，将房间 i 粉刷成颜色 k ，最小总花费，因为只有三种颜色，因此状态转移方程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i][0]</span><br><span class="line">dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i][1]</span><br><span class="line">dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i][2]</span><br></pre></td></tr></table></figure><p>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上前一间房子粉刷成其他两种颜色时总花费的较小者。由于房间 i 的状态只取决于房间 i-1 ，因此也不需要用矩阵存储状态，只需要两个大小为3的数组（或者6个int）就可以。</p><h5 id="粉刷房子-II"><a href="#粉刷房子-II" class="headerlink" title="粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">粉刷房子 II</a></h5><blockquote><p>问题描述：</p><p>给一排房子上色，相邻房子颜色不能相同，一共有 K 种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p></blockquote><p>现在有 K 种颜色，状态转移方程就没有上面那么简单了，我们要遍历每一种颜色 k，计算$dp[i][k]$，那么此时的状态转移方程应该变为：<br>$$<br>dp[i][k] &#x3D; \min_{t&#x3D;0…K,t\neq k}(dp[i-1][t]) + costs[i][k]<br>$$<br>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上<strong>前一间房子粉刷成除颜色 k 以外的其他 K-1 种颜色时总花费的最小者</strong>。</p><p>所以只要求出第 i-1 个房间所有花费的最小值即可，但如果当前颜色 k 刚好是第 i-1 个房间的最小花费对应的颜色，那此时就应该取第 i-1 个房间第二小的花费，所以对每一个房间求出最小花费 min1st 和第二小花费 min2nd 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp_second[j] = (dp_first[j] == min1st ? min2nd : min1st) + costs[i][j]</span><br></pre></td></tr></table></figure><h5 id="粉刷房子-III"><a href="#粉刷房子-III" class="headerlink" title="粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/">粉刷房子 III</a></h5><p>有余力可以了解</p><h4 id="4-经典问题：鸡蛋掉落"><a href="#4-经典问题：鸡蛋掉落" class="headerlink" title="4 经典问题：鸡蛋掉落"></a>4 经典问题：<a href="https://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a></h4><blockquote><p>问题描述：</p><p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p><p>已知存在楼层 f ，满足 0 &lt;&#x3D; f &lt;&#x3D; n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;&#x3D; x &lt;&#x3D; n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p></blockquote><p>这是一道非常经典的面试题，但是难度较大，如果是作为机试题，对动态规划和数学理论的灵活运用要求非常高，因为不仅要推导动态规划方程，还要在编码过程中对动态规划过程进行优化，否则会超时无法通过全部测试用例。而如果不用动态规划的方法，就已经达到了竞赛级别，远超出了面试难度。当然因为问题过于经典，各方大佬也想出了各种容易理解的动态规划解法。</p><p>但是作为面试题，理解这道题的思路还是非常有必要而且不是那么困难的，因为面试题通常不会像原题这样问，面试通常会直接问：100层楼给你2个鸡蛋，怎么得出最小操作次数？显然也不是让你当场计算出正确答案14次，毕竟这道题即使是知道算法的情况下去手算也相当复杂，所以更重要的是思路。</p><p>这里放几个比较容易理解的题解，方法也比较主流，可以结合起来看，熟悉思路：</p><p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/">鸡蛋掉落官方题解</a></p><p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/">题目理解 + 基本解法 + 进阶解法</a></p><p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/887-by-ikaruga/">【鸡蛋掉落】5 行代码，从求扔几次变为求多少层楼</a></p><h4 id="5-其他带维度单串问题"><a href="#5-其他带维度单串问题" class="headerlink" title="5 其他带维度单串问题"></a>5 其他带维度单串问题</h4><ul><li><p><a href="https://leetcode-cn.com/problems/toss-strange-coins/">抛掷硬币</a>：比较简单的带维度单串问题</p></li><li><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a>：与上面的最大平均值和的分组非常相似，只是把分组的平均值改成了分组的和，然后求这些分组和最大值的最小值，整体思路完全一致，状态转移方程稍有不同，另外本题用动态规划不是最优解，用<strong>贪心+二分查找</strong>的方法时空复杂度更优秀，思路也不难理解，具体可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">分割数组的最大值官方题解方法二</a></p></li><li><p><a href="https://leetcode-cn.com/problems/frog-jump/solution/">青蛙过河</a>：给定一个数组表示一条河上石头所在的位置，青蛙只能向前跳，且每次跳跃的距离只能是 k-1、k、k+1 其中之一，k是上一次跳跃的步数，第一次跳一步，问青蛙是是否能过河？</p></li></ul><p><strong>思路</strong>：动态规划解法比较难想，并且难优化，时空复杂度也并不友好，了解即可，这道题实际上使用记忆化搜索的方法会更好，这里顺便说一下记忆化搜索的思路，因为非常简单。</p><p>首先这显然是一个典型回溯问题，因此很自然想到使用深搜，深搜的递归代码也很好写，只要用当前位置加上跳跃距离，然后搜索石头数组看是否存在对应的石头就行了，搜索这里可以用二分查找（因为数组一定是严格递增的），也可以用哈希表，我这里使用哈希表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;<span class="comment">//在O（1）时间内找到下一次跳的石头是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这样会超时，超时的原因在于递归的时候存在重复递归，回溯的时候会有之前已经解决的子问题被重复计算，因此我们只要把每次计算的子问题的结果存下来，之后再遇到这个子问题直接返回对应的结果就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;&gt; memo;<span class="comment">//存储子问题结果</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果遇到已经解决过的问题，直接返回对应结果</span></span><br><span class="line">        <span class="keyword">if</span>(memo[start].<span class="built_in">find</span>(step) != memo[start].<span class="built_in">end</span>()) <span class="keyword">return</span> memo[start][step];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] = <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] =  <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start][step];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.<span class="built_in">resize</span>(stones.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把哈希表换成二分查找还可以进一步降低空间复杂度。</p><ul><li><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">安排邮筒</a>：适当了解思路</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;带维度单串问题&quot;&gt;&lt;a href=&quot;#带维度单串问题&quot; class=&quot;headerlink&quot; title=&quot;带维度单串问题&quot;&gt;&lt;/a&gt;带维度单串问题&lt;/h3&gt;&lt;p&gt;上一篇中的单串问题，子问题仅与位置 i 有关，也就是 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 $dp[i][k]$。其中 k 上可能有二分，贪心等算法。这类问题相比于普通单串问题要更复杂，需要多见多积累。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（六）着色</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/</id>
    <published>2022-03-09T11:42:32.000Z</published>
    <updated>2022-03-09T12:59:22.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="着色（Shading）"><a href="#着色（Shading）" class="headerlink" title="着色（Shading）"></a>着色（Shading）</h3><p>前几节我们介绍了三维中的各种变换，三维到二维的映射，以及如何在屏幕空间中渲染三维空间中我们所看到的物体，也就是光栅化。光栅化的过程实际上就是判断像素是否在三角形内，如果在就填上对应的颜色的过程。那么从这一节开始，我们将讨论“填上对应的颜色”这里的颜色从何而来。</p><p><em><span id="more"></span></em></p><h4 id="1-什么是着色？"><a href="#1-什么是着色？" class="headerlink" title="1 什么是着色？"></a>1 什么是着色？</h4><p>现实生活中我们之所以能看见东西，是因为光线和物体本身发生了某些”作用“，而我们看到的世界实际上是发生这个作用之后的世界，那对于计算机而言，我们给定了相机、模型以及场景，利用前几节的内容我们实际上就能显示出相机看到了什么，但显示出的内容和实际我们应该看到的内容有很大的区别，原因在于我们没有考虑光线和物体所发生的”作用“，当光线照到物体上时，我们所看到的物体的颜色，一定和实际物体的颜色是不同的，比如下面这张图，相信这也很好理解：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165537111.png" alt="image-20220309165537111"></p><p>立方体本身的颜色一定是一样的，但我们看到的每一个面颜色都不同，这就是光线的作用，因此我们要想画出来实际看到的场景，就要知道我们看到的模型的每一个部分是什么颜色的，而不是模型本身是什么颜色的，这也就是着色所做的工作。当然上面的图是很简单的情况，实际应用中我们渲染的场景可能非常复杂：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165746676.png" alt="image-20220309165746676"></p><p>可以看到这个场景具有复杂的光照条件，包含了各种不同材质的物体，还包括透明的液体，还有右边杯子上倒映出的周围环境的镜像，这些都是我们眼睛看到的，而不是物体本身具有的，<strong>着色就是要根据物体本身具有的属性，以及环境的光照计算出物体上每一个点在我们的视角下，应该被看到的颜色。</strong></p><h4 id="2-Blinn-Phong着色模型"><a href="#2-Blinn-Phong着色模型" class="headerlink" title="2 Blinn-Phong着色模型"></a>2 Blinn-Phong着色模型</h4><p>通常来说光线与物体之间的”作用“可以描述为以下三种，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309170238290.png" alt="image-20220309170238290"></p><p>一种是我们看到的非常亮的反光，叫做<strong>高光（Specular highlights）</strong>；另一种是物体颜色上细微的渐变，也就是<strong>漫反射（Diffuse reflection）</strong>；最后是没有被光线直接照射到但也可以被看到的部分，因为有间接的光线照射到了这部分，也就是<strong>环境光或间接光照（Ambient lighting）</strong>。</p><blockquote><p>在展开介绍之前要先明确，我们计算着色永远是在进行局部的计算，因为物体上的每一部分都和光线有不同的角度，所以也就发生不同的反应，我们计算的这个局部的点称为<strong>着色点</strong>，这也是一个抽象的概念，着色点可以是一个点也可以是一个平面，平面可以理解为这个点抽象而成的无限小的平面，我们计算各种光照时，都是光线在与这个平面发生作用。</p></blockquote><p>计算着色其实就是计算上面三种光照，对于这三种光照的计算，输入都是一样的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171357997.png" alt="image-20220309171357997"></p><p>输入包含我们观察的方向向量$\vec v$，着色点的法向量$\vec n$，光线的入射方向$\vec l$以及着色点表面的属性，也就是颜色等信息。需要说明的是这三个表示方向的向量只表示方向，因此都是单位向量。</p><h5 id="2-1-漫反射"><a href="#2-1-漫反射" class="headerlink" title="2.1 漫反射"></a>2.1 漫反射</h5><p>漫反射非常简单，就是光线射到物体表面时会朝各个方向均匀的发散：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171931199.png" alt="image-20220309171931199"></p><p>也就是说，物体表面的颜色从各个方向看都是相同的，决定物体颜色深浅的，只有物体<strong>接收</strong>到光线之后，<strong>吸收</strong>了多少光，又<strong>反射</strong>出去了多少光，反射出去的这部分，也就是我们看到的颜色。</p><p>于是首先要考虑物体能<strong>接收</strong>到多少光。如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172156026.png" alt="image-20220309172156026"></p><p>物体表面如果和光线入射方向垂直，那就接收到了几乎全部的光，而如果物体旋转一定的角度，就有一部分光到达不了物体表面，也就无法被接收，而到达物体表面的光，也与物体表面有一定的角度，能量也是无法被完全接收的，那如何描述这个关系呢，Lambert’s余弦定理给出了答案：<strong>物体表面单位面积的光照与平面法线和光线夹角的余弦成正比</strong>。这里的光线方向是从物体表面指向光源的方向，是光线入射方向的反方向。</p><p>那么光的强度又该如何描述呢，光可以理解为一种能量，所以在传播的过程中能量一定是有所损失的，所以光的强度与传播距离是成反比的，如果光源处强度为$I$，那么距离光源 $r$ 处的强度为$I&#x2F;r^2$.</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172942182.png" alt="image-20220309172942182"></p><p>于是我们就可以得出漫反射的计算公式：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309173151067.png" alt="image-20220309173151067"></p><p>$k_d$ 是漫反射系数，也就是着色点的颜色；平面法线和光线夹角的余弦也就是着色点的法向量$\vec n$和光线的入射方向$\vec l$的点乘，因而二者都是单位向量所以点乘就是余弦，$max(0, \vec n·\vec l)$的含义是有时夹角余弦为负，那我们认为这是无意义的，因为这相当于光线从平面下方射入，实际上就是看不到任何颜色，所以如果夹角余弦为负我们就取0.</p><p>可以看出漫反射计算中不包含视线方向 $\vec v$ ，正好对应开头说的，漫反射与观察方向无关，漫反射的颜色从任何方向看都是一样的。</p><p>下面的图展示了$k_d$ 逐渐增大对应的漫反射表现，也就是颜色逐渐变亮。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175149118.png" alt="image-20220309175149118"></p><h5 id="2-2-高光"><a href="#2-2-高光" class="headerlink" title="2.2 高光"></a>2.2 高光</h5><p>当我们的视线方向和光线的镜面反射方向比较接近时，就产生了高光：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175403769.png" alt="image-20220309175403769"></p><p>所以我们只要计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦就可以，高光和这个夹角余弦成正比。</p><p>在布林冯模型中没有直接计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦，而是进行了优化：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175724874.png" alt="image-20220309175724874"></p><p>镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 接近可以转化为着色点法向量和<strong>半程向量</strong>接近。所谓半程向量是指光线入射方向和观察方向的角平分线方向，这个向量非常容易计算，根据向量的平行四边形法则，半程向量就是光线入射方向向量和观察方向向量的和。</p><p>于是我们就得到了上面的高光计算公式，和漫反射非常类似，$k_s$ 是高光系数，也就是高光的颜色，一般就是白色，与漫反射唯一不同的是，高光计算公式中夹角余弦部分多了一个指数 $p$，这是因为余弦函数本身的容忍度太高，如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180233721.png" alt="image-20220309180233721"></p><p>如果直接使用余弦函数，那么镜面反射方向和观察方向夹角45°甚至更大时，我们还会取到一个比较大的值，此时意味着我们还可以看到比较明显的高光，但实际上我们只有在镜面反射方向和观察方向夹角非常小时才能看到高光。可以看到随着余弦函数幂次的增大，我们能看到高光的夹角阈值在变小，当我们使用余弦函数的64次方时，只有在镜面反射方向和观察方向夹角大约20°范围内才能看到高光，当然这还是太大了，所以在布林冯模型中 $p$ 的取值一般在100~200左右。</p><p>下面的图每一行展示的是随着 $p$ 取值增大所看到的高光的效果，每一列代表的是高光系数 $k_s$ 增大带来的变化，就是高光部分的颜色越来越亮。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180800693.png" alt="image-20220309180800693"></p><h5 id="2-3-间接光照"><a href="#2-3-间接光照" class="headerlink" title="2.3 间接光照"></a>2.3 间接光照</h5><p>间接光照最为简单，间接光照就是从四面八方射向物体表面的各种光对物体颜色产生的影响的总和，与光线的入射方向、物体表面的法线方向和我们的观察方向都没有关系，所以间接光照就是一个常数。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181612011.png" alt="image-20220309181612011"></p><h5 id="2-4-布林冯模型"><a href="#2-4-布林冯模型" class="headerlink" title="2.4 布林冯模型"></a>2.4 布林冯模型</h5><p>将上面的三个光照项加起来就得到了物体表面受光照影响的总和，这就是布林冯着色模型。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181732816.png" alt="image-20220309181732816"></p><p>可以看到最左边间接光照就是一个固定的颜色（常数），漫反射表现的是物体表面颜色的变化，这个变化是由物体表面和光线方向不同引起的，高光是一些白色的亮光，只有物体上使得光线镜面反射方向和观察方向夹角比较小的部分才会显示出高光。这些项全部叠加起来也就是最终我们看到的物体的颜色了。</p><h4 id="3-着色频率"><a href="#3-着色频率" class="headerlink" title="3 着色频率"></a>3 着色频率</h4><p>到此为止我们了解了对一个着色点应该如何着色，那么对于一个物体，我们该以什么样的方式去对整个物体表面进行着色呢？有以下三种方式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182145738.png" alt="image-20220309182145738"></p><ul><li>最左边是对物体上的每一个片面（也就是组成物体的基本几何图形，可以是三角形，可以是矩形），进行一次着色，此时这一个片面就是一个着色点，所以这个片面内计算出的颜色是一致的，可以看出着色效果并不好</li><li>中间是对物体上的每一个片面的每一个顶点进行一次着色，此时每个片面的顶点是一个着色点，片面的颜色取决于计算出的这些顶点的颜色，可以用插值的方法得到每个片面的颜色</li><li>右边是对物体上每一个点进行一次着色，此时每一个点都是一个着色点，因此效果也最细腻</li></ul><p>上面三种着色方式代表着三种不同的着色频率，其中也包含很多具体的问题，接下来具体介绍这三种着色方式。</p><h5 id="3-1-Flat-shading"><a href="#3-1-Flat-shading" class="headerlink" title="3.1 Flat shading"></a>3.1 Flat shading</h5><p>Flat shading对物体每一个片面三角形进行着色，是最简单的着色方式，但是对于平滑表面着色效果不好。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182705236.png" alt="image-20220309182705236"></p><h5 id="3-2-Gouraud-shading"><a href="#3-2-Gouraud-shading" class="headerlink" title="3.2 Gouraud shading"></a>3.2 Gouraud shading</h5><p>Gouraud shading对物体上的每一个三角形的每一个顶点进行一次着色，计算出每个顶点的颜色后，对三个顶点颜色进行插值就可以得到三角形上每一个点的颜色。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182821004.png" alt="image-20220309182821004"></p><p>具体如何插值后面会专门介绍，除此之外还存在一个问题，就是一个顶点怎么计算它的法向量？</p><p>我们首先考虑一个简单的二维情况，如果这个顶点是一个圆上的点，那么这个点的法线方向就是圆心和这个点连线的方向，如果这个点是圆某个内接多边形的顶点（圆上任何一个点都可以是内接多边形的顶点），那么法线方向就是与这个顶点相邻的两条边的法线的角平分线方向，也就是两条边的法向量的和。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309183734717.png" alt="image-20220309183734717"></p><p>推广到三维中，<strong>物体上一个点的法线方向就是与它相邻的所有平面法向量的加权和</strong>。加权是因为实际应用中三维物体不可能都是一个均匀球体，会是各种形状，所以每个相邻的平面也不一样大，自然对这个顶点法线方向的贡献也不同。</p><p>知道了如何计算点的法向量，也就知道如何进行Gouraud shading了。关于三角形颜色的插值，后面会统一介绍。</p><h5 id="3-3-Phong-shading"><a href="#3-3-Phong-shading" class="headerlink" title="3.3 Phong shading"></a>3.3 Phong shading</h5><p>Phong shading对模型上每一个点进行着色计算，因此每一个点都是一个单独的着色点。那么又出现一个问题，我们如何计算物体上每一个点的法向量呢？</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184149978.png" alt="image-20220309184149978"></p><p>由于这些点大部分都不是片面三角形的顶点，所以上面的法线计算方法并不适用。但我们可以先计算出片面三角形顶点的法向量，再利用插值的方法得到三角形内每一个点的法向量，当然别忘了计算完成后对法向量进行归一化，法向量只指示方向，一定是单位向量。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184601435.png" alt="image-20220309184601435"></p><p>和上面的颜色插值一样，这里又要用到三角形的插值，只不过这次插值的内容是法向量。接下来我们专门介绍三角形的插值方法——利用重心坐标。</p><h4 id="4-重心坐标（Barycentric-Coordinates）"><a href="#4-重心坐标（Barycentric-Coordinates）" class="headerlink" title="4 重心坐标（Barycentric Coordinates）"></a>4 重心坐标（Barycentric Coordinates）</h4><p>三角形插值是图形学中经常使用的操作，因为很多时候我们只知道三角形三个顶点对应的某些属性值，那么想要使得三角形内部每一个点的属性值平滑的变化，就需要利用已有值进行插值。于是引入三角形重心坐标的概念。</p><p>重心坐标实际上是一个坐标表示方法，对于空间中的三角形ABC，任意一个在三角形ABC平面上的点$(x,y)$，都可以表示为三角形三个顶点坐标的线性组合$\alpha A+\beta B+ \gamma C$，其中三个系数就是这个点在这个三角形下的重心坐标，重心坐标需要满足约束$\alpha + \beta + \gamma&#x3D;1$，如果不满足这个约束，表示出来的点就不在三角形ABC这个平面上；并且如果这个点在三角形内部，重心坐标三个数都非负。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309185358567.png" alt="image-20220309185358567"></p><p>有了重心坐标的定义，那对于三角形内部的任意一个点，怎么去得到它的重心坐标呢？</p><p>对于三角形内部任意一个点，将它和三个顶点相连，会形成三个子三角形，重心坐标可以根据三个子三角形面积求出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190117856.png" alt="image-20220309190117856"></p><p>每个顶点对应的系数等于该顶点<strong>对面</strong>的子三角形面积除以三角形的总面积，比如点 A 的系数 $\alpha$ 等于点 A 对面的子三角形，也就是和点 A 不相邻的子三角形$A_A$的面积除以三角形ABC的总面积。</p><p>显然三角形重心的重心坐标就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190751306.png" alt="image-20220309190751306"></p><p>给定三角形的三个顶点和三角形内任意一个点坐标，我们可以根据下面的式子求出该点的重心坐标：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190924381.png" alt="image-20220309190924381"></p><p>得到重心坐标后，再进行三角形内部的线性插值就非常容易了，因为线性插值就是把三角形内任意一个点的某项属性（属性可以是坐标、颜色、深度、法向量等等）表示为三角形三个顶点属性的线性组合，至于怎么组合，重心坐标就是“坐标”这个属性的组合系数，自然也可以用在其他任何属性上。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309191134142.png" alt="image-20220309191134142"></p><p>需要注意的是，<strong>重心坐标不具有投影不变性</strong>，因为空间中的三角形投影到平面上，形状可能会变化，那么三角形内每个点的重心坐标自然会发生变化，因此计算和空间有关的属性的插值时，要先在三维空间中计算，再投影到二维空间。</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>总之，着色就是计算模型上每一个点应该被我们看到的颜色，根据着色频率的不同，着色时又分为三种着色策略：</p><ul><li>Flat shading</li><li>Gouraud shading</li><li>Phong shading</li></ul><p>下面是这三种着色策略的对比，可以看出，当模型片面不够多时，Flat shading的效果较差，但随着模型复杂度的提升，Flat shading的效果并不差，并且由于不需要插值运算，当模型足够精细时，使用Flat shading是性价比更高的。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309192158594.png" alt="image-20220309192158594"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;着色（Shading）&quot;&gt;&lt;a href=&quot;#着色（Shading）&quot; class=&quot;headerlink&quot; title=&quot;着色（Shading）&quot;&gt;&lt;/a&gt;着色（Shading）&lt;/h3&gt;&lt;p&gt;前几节我们介绍了三维中的各种变换，三维到二维的映射，以及如何在屏幕空间中渲染三维空间中我们所看到的物体，也就是光栅化。光栅化的过程实际上就是判断像素是否在三角形内，如果在就填上对应的颜色的过程。那么从这一节开始，我们将讨论“填上对应的颜色”这里的颜色从何而来。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（五）深度缓冲</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</id>
    <published>2022-03-08T10:15:14.000Z</published>
    <updated>2022-03-08T10:19:34.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h3><p>到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。</p><p><em><span id="more"></span></em></p><p>比如一个立方体，在这样的视角下我们是看不到它的左平面、下平面和后平面的，但是在光栅化的过程中，我们依然会取这个立方体左平面上的三个点组成三角形并画在屏幕上，如果不考虑遮挡关系，那画出来的正方体显然和我们看到的就不一样了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308174826553.png" alt="image-20220308174826553"></p><p>那如何在光栅化过程中考虑这种遮挡关系，并把这种关系正确的画出来呢？这就是这一节要讨论的内容。</p><p>在开始之前，要先明确一个概念，这一节所说的 Z ，并不是物体的 Z 坐标，<strong>而是代表物体离我们的远近，也就是深度，这个深度永远是正数，而且数值越小离我们越近</strong>。因为之前说了相机指向 -Z 方向，所以如果是 Z 坐标的话，离我们越近的反而数值上越大，这不符合我们的直觉。因此需要重新给出这个深度的概念。</p><h4 id="1-画家算法"><a href="#1-画家算法" class="headerlink" title="1 画家算法"></a>1 画家算法</h4><p>画家算法指的是我们像画家画画一样，从远处往近处画，这样近处的画面自然会遮挡住远处的画面，光栅化的时候也可以这样，我们先对三角形的深度排序，然后从远往近画在屏幕上。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175526241.png" alt="image-20220308175526241"></p><p>但是这样的算法无法解决下面这种情况：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175553407.png" alt="image-20220308175553407"></p><p>三角形的遮挡关系往往没有那么简单，因此画家算法大多情况下并不适用。</p><h4 id="2-Z-Buffer"><a href="#2-Z-Buffer" class="headerlink" title="2 Z-Buffer"></a>2 Z-Buffer</h4><p>Z-Buffer的思想非常简单，那就是我们在渲染图形时，除了维护frame-buffer（显示在屏幕上的图）外，再维护一个Z-buffer（深度图），<strong>Z-buffer中存储屏幕上每一个像素当前的最小深度</strong>，在光栅化开始时，Z-buffer中每一个像素的深度都设为无穷大，之后渲染三角形的时候，每次都先判断当前渲染的三角形的深度和Z-buffer中当前像素的深度谁更小（谁离我们更近），如果三角形的深度更小，那么就把三角形的颜色存入frame-buffer中这个像素的位置，同时把Z-buffer中当前像素的最小深度更新一次，这样我们总能保证深度小的颜色遮挡深度大的颜色。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180155386.png" alt="image-20220308180155386"></p><p>Z-buffer和frame-buffer总是同时渲染的，因此当我们生成一张图片的时候，也就生成了这张图片的深度图。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180255018.png" alt="image-20220308180255018"></p><p>可以看到深度图中越远的地方像素值越大，越近的地方像素值越小。</p><p>Z-buffer的伪代码如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180341613.png" alt="image-20220308180341613"></p><p>相比于画家算法 O(nlogn) ，Z-buffer只需要 O(n) 的时间复杂度。</p><blockquote><p>为什么是O(n)？</p><p>假设每个三角形只覆盖常数个像素，那么Z-buffer做的就是对每一个三角形判断对应的深度，然后填充像素，因此只需要花费 O(1) 时间，那么有n个三角形，复杂度就是O(n).</p></blockquote><p>最后说一下Z-buffer的优势，就是与画三角形的顺序无关，只要维护对了深度信息，画出来的一定是正确是遮挡关系，并且对硬件没有特殊需求，容易实现。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;深度缓冲（Z-Buffer）&quot;&gt;&lt;a href=&quot;#深度缓冲（Z-Buffer）&quot; class=&quot;headerlink&quot; title=&quot;深度缓冲（Z-Buffer）&quot;&gt;&lt;/a&gt;深度缓冲（Z-Buffer）&lt;/h3&gt;&lt;p&gt;到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】（一）线性动态规划之单串问题</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/</id>
    <published>2022-03-07T04:11:05.000Z</published>
    <updated>2022-03-09T11:45:35.864Z</updated>
    
    <content type="html"><![CDATA[<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p><p>大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p><p>按照问题的输入格式，<strong>线性动态规划解决的问题主要是单串，双串，矩阵上的问题</strong>，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。</p><p><em><span id="more"></span></em></p><h3 id="单串问题"><a href="#单串问题" class="headerlink" title="单串问题"></a>单串问题</h3><p>单串 <code>dp[i]</code> 是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]上，原问题的解</code>，其中<code>考虑[0..i]上，原问题的解</code>又可以分为两大类，即我们要考虑[0..i]上所有子问题的解（考虑O(n)个子问题的解），还是只考虑考虑[0..i]上常数个子问题的解（考虑O(1)个子问题的解），一般只考虑常数个子问题的解就是考虑 dp[i-1] 或（和）dp[i-2]。单串问题基本上可以分为以下几大类。</p><h4 id="1-最长递增子序列（LIS问题）"><a href="#1-最长递增子序列（LIS问题）" class="headerlink" title="1 最长递增子序列（LIS问题）"></a>1 最长递增子序列（LIS问题）</h4><p>这是最经典的线性动态规划问题，也是最能体现线性动态规划思想的问题之一。</p><blockquote><p>问题描述：</p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7] </code>是数组 <code>[0,3,1,6,2,2,7] </code>的子序列。</p></blockquote><p>我们用$f(i)$表示以nums[i]结尾的子数组的LIS长度，因为子序列需要上升，因此以 nums[i] 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。于是可以写出状态转移方程：<br>$$<br>\begin{equation}<br>f(i)&#x3D;\left{<br>\begin{aligned}<br>max(f(i),f(j)+1) &amp; , &amp; nums[i]&gt;nums[j], \<br>1 &amp; , &amp; nums[i]&lt;&#x3D;nums[j].<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>其中$j &lt; i$，显然求解$f(i)$需要遍历所有$f(j)$，因此我们要考虑O(n)个子问题的解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LIS问题及其变体问题：</strong></p><ul><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li><li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a>：除了维护记录长度的dp数组外，还要维护一个记录子序列个数的cnt数组</li><li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></li><li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">最大整除子集</a>：动态规划过程类似于最长上升子序列，难点在于还原出子集的所有元素</li></ul><h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2 最大子数组和"></a>2 最大子数组和</h4><p>另一个经典单串问题</p><blockquote><p>问题描述：</p><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>同样的思路，我们用 dp[i] 表示以nums[i]结尾的最大子数组和，因为状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。因此可以写出状态转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure><p>显然这个问题中，我们只要考虑O(1)个子问题的解，因此也没有必要维护 dp 数组了，运用滚动数组的思想，只要记录下来 dp[i-1] 就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(fi + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>最大子数组和及其变体问题：</strong></p><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></li><li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/huan-xing-shu-zu-zui-da-he-by-bu-luo-bu-7bqj/">环形数组最大和</a></li><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-bu-luo-bu-xvsx/">乘积最大子数组</a></li><li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/">最大子矩阵</a>：二维转换为一维的典型题目</li><li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a>：上一题的进阶版</li></ul><h4 id="3-打家劫舍问题"><a href="#3-打家劫舍问题" class="headerlink" title="3 打家劫舍问题"></a>3 打家劫舍问题</h4><p>打家劫舍类似于最大子数组和，但这里的子数组不能连续，也就是不相邻子序列的最大和问题。</p><blockquote><p>问题描述：</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，<strong>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</strong>，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p></blockquote><p>问题的关键在于我们如果偷了第 i 个房间，那么就不能偷第 i-1 个房间，所以 dp[i] 表示到第 i 个房间为止的最大金额，这个最大金额的取值有两种情况，如果我们不偷第 i 个房间，那么 dp[i] &#x3D; dp[i-1]；如果我们偷第 i 个房间， 那么 dp[i] &#x3D; dp[i-2] + num[i]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp1 = nums[<span class="number">0</span>];              <span class="comment">//屋子能偷盗的最大金额</span></span><br><span class="line">        <span class="type">int</span> dp2 = <span class="built_in">max</span>(dp1,nums[<span class="number">1</span>]);     <span class="comment">//前一间屋子能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp1, dp2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(dp1 + nums[i], dp2);</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>打家劫舍及其变体问题：</strong></p><ul><li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>：数组变成了环形，也就是偷了第1个房间就不能偷最后一个房间，在区间 [0, nums.size()-1] 和 [1, nums.size()] 上应用两次打家劫舍的算法即可</li><li><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/">删除并获得点数</a>：难点在于怎么转换成打家劫舍问题</li><li><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/">3n 块披萨</a>：难点在于动态规划状态的定义，因为一定有 3n 个数，我们最多只能拿其中 n 个数字，所以相当于打家劫舍中我们只能偷 3n 个房间中的 n 个</li></ul><h4 id="4-需要记录两个位置的问题"><a href="#4-需要记录两个位置的问题" class="headerlink" title="4 需要记录两个位置的问题"></a>4 需要记录两个位置的问题</h4><p>有一些单串问题在涉及状态时需要考虑相邻两个元素的情况，因为只考虑最后一个的话无法对状态描述清楚，例如：</p><ul><li><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a>：$dp[i][j]$表示以 $j, i$ 结尾的最长斐波那契子序列长度，转移时在 [0..j] 中找满足条件的 k </li><li><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">最长等差数列</a>：同上，但是两道题的具体实现细节稍有不同</li></ul><h4 id="5-其他没有显式给定数组的线性动态规划问题"><a href="#5-其他没有显式给定数组的线性动态规划问题" class="headerlink" title="5 其他没有显式给定数组的线性动态规划问题"></a>5 其他没有显式给定数组的线性动态规划问题</h4><p>线性 DP 还有一些问题没有显式的数组，字符串等。此类问题一般没有什么固定的模式，只能通过多做题来积累。</p><ul><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/">最长有效括号</a>：这道题最容易想到的是用栈，但其实算法过程比较难做对，用动态规划更简单，但对于状态转移的过程比较难想到</li><li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a>：最长等差数列的简单版本，给定的数组是严格递增或递减的，处理起来会简单很多</li><li><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>：关键在于有效数字只有可能是一位或者两位，因此对于任何一个数字，要么本身一位进行编码，要么和前一位组成两位数字进行编码</li><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a>：主要考察的是深搜回溯的方法，但是使用动态规划对字符串预处理可以在O(1)时间内判断回文子串</li><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">分割回文串 II</a>：dp[i] 表示以 s[i] 结尾的字符串的最小分割次数，状态转移时如果 s[i] 能与前面的某个位置 j 组成回文子串 s[j…i]，那么dp[i] &#x3D; dp[j] + 1，遍历所有满足条件的 j &lt; i ，dp[i]取这些值里面的最小值，判断回文子串 s[j…i] 时同样可以用分割回文串中的动态规划方法，所以本题进行了两次动态规划，较为复杂。</li><li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/liang-ge-zi-fu-chuan-de-shan-chu-cao-zuo-14uw/">两个字符串的删除操作</a>：转化成LCS问题可以很简单的解决，但还可以用更符合题意的状态定义$dp[i][j]$</li><li><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a>：比较简单</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。&lt;/p&gt;
&lt;p&gt;大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。&lt;/p&gt;
&lt;p&gt;按照问题的输入格式，&lt;strong&gt;线性动态规划解决的问题主要是单串，双串，矩阵上的问题&lt;/strong&gt;，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
    <category term="算法" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（四）反走样</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/</id>
    <published>2022-03-06T13:24:47.000Z</published>
    <updated>2022-03-08T13:00:50.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反走样（Antialiasing）"><a href="#反走样（Antialiasing）" class="headerlink" title="反走样（Antialiasing）"></a>反走样（Antialiasing）</h3><p>上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。</p><p><em><span id="more"></span></em></p><h4 id="1-什么是走样？"><a href="#1-什么是走样？" class="headerlink" title="1 什么是走样？"></a>1 什么是走样？</h4><p>要解决问题，就要先了问题。</p><p>走样有很多种形式，比如上文中的<strong>锯齿</strong>：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191713343-16465731903111.png" alt="image-20220306191713343"></p><p>还有我们日常生活中经常遇到的<strong>摩尔纹</strong>：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191741271-16465731903114.png" alt="image-20220306191741271"></p><p>甚至一些视觉假象，比如一个顺时针旋转的轮子，当他的速度很快时，我们可能看到它是逆时针旋转的。</p><p>以上都属于走样，而产生这些走样的原因都一样，那就是<strong>采样速度跟不上信号变化的速度</strong>。</p><p>要理解这句话可不容易，接下来我们慢慢来看。</p><h4 id="2-产生走样的原因"><a href="#2-产生走样的原因" class="headerlink" title="2 产生走样的原因"></a>2 产生走样的原因</h4><p>上面说了，走样产生的原因就是采样速度跟不上信号变化的速度，更细致一点来说就是，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠。</strong></p><p>关于<strong>频域</strong>，是信号处理中的重要概念，简单来说就是只存在正弦波的一个世界，也就是只能用 sin 和 cos 函数，而我们日常描述一个信号（函数）是在时域中描述的，这个函数可以是任何形状，那么频域存在的意义是什么呢。</p><p>频域存在的意义就是任何一个函数都可以分解为多个正弦波函数和常数的组合，也就是<strong>傅里叶变换</strong>。有了这个伟大的变换，我们就可以把在时域中不好解释、不好研究的问题，放到频域中去研究。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193355754-16465731903113.png" alt="image-20220306193355754"></p><p>时域中的信号通过傅里叶变换，可以变为频域中的信号，同样，频域中的信号通过傅里叶逆变换，可以变为时域中的信号。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193545813-16465731903112.png" alt="image-20220306193545813"></p><p>了解了频域，再来回顾一下上篇文章提到的<strong>采样</strong>，采样就是计算函数在采样点上的值，我们光栅化的过程其实就是采样的过程，在信号中，采样其实也就是在整个信号的波形上选一些点拿出来，比如下面的图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193918481-16465731903115.png" alt="image-20220306193918481"></p><p>垂直的虚线就代表一次采样，和不同的波形的交点，就是采样出来的点，然后我们连接这些点，会发现在同样的采样频率下，对频率不同的信号进行采样得到的效果天差地别，例如最上面的信号$f_1(x)$，频率比较小，那我们连接采样点后的折线就和原来的信号非常接近，但是越往下信号频率越大，我们用同样的频率采样得到的折线，就和原来的信号差别越大，$f_4(x)$和$f_5(x)$的折线已经和原信号完全不同了。</p><p>再进一步说，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306194603851-16465731903126.png" alt="image-20220306194603851"></p><p>对频率相差很大的两个信号进行同频率采样，我们得到的折线是完全一样的，那我们就无法分辨原来的信号长什么样，尤其如果一个信号是高频信号，如果我们用低频采样，就会得到和原来信号完全不同的结果，这就是<strong>走样</strong>产生的原因，现在回过头来看开头说的，<strong>走样产生的原因就是采样速度跟不上信号变化的速度</strong>，是不是就完全理解了。但是这还不够，我们继续。</p><p>开头说的另一句话，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠</strong>，这又是什么意思呢。</p><p>刚才对于采样的分析，完全是在时域下分析的，那么采样在频域的表现是什么样的呢？</p><p>采样在频域表现为<strong>信号的重复</strong>。如下图：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195205688-16465731903127.png" alt="image-20220306195205688"></p><p>左边一列是时域信号，右边是它对应的频域信号。图（a）是时域中的一个信号，图（b）是它在频域中的样子，图（c）是采样信号，也叫做冲击信号，图（d）是冲击信号在频域中的样子，图（e）就是用冲击信号对原信号进行采样的过程，冲击的点就取原信号对应的值，图（f）就是这个采样过程在频域中得到的结果，可以看到，每采样一个点，都相当于复制了原信号在频域中的内容，所以采样在频域中表现为信号的重复。</p><p><strong>而且采样越密集，在频域中信号间隔越大</strong>，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p><p>上面的图是使用密集采样得到的结果，采样越密集，频域中间隔越大，所以信号没有发生重叠交错，下面的图是稀疏采样，采样越稀疏，频域间隔越小，也就发生了重叠交错，自然也就产生了<strong>走样</strong>。</p><p>到这里，我们差不多搞明白了产生走样的原因，现在回到光栅化上面来，光栅化的过程就是采样的过程，因为我们的像素点相对于三角形来说没有那么密集，所以相当于进行了稀疏采样，也就产生了走样，那么如何来进行反走样呢？</p><p>根据上面的理论，只要我们不进行稀疏采样，使采样尽量密集就可以了。</p><h4 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3 滤波"></a>3 滤波</h4><p>在讨论反走样之前还要了解一个概念，<strong>滤波</strong>，滤波在数字图像处理和信号处理中都很重要，图像也可以抽象为信号，所以本质都是一样的，那么滤波的意义也就是一样的，对于信号来说，<strong>滤波的作用就是去掉信号中特定频率的内容</strong>。</p><p>比如一张图片和它在频域中的图像：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306200708255-16465731903129.png" alt="image-20220306200708255"></p><p>要说明的是，时域到频域的转换，默认信号是周期性的，对于图片来说，就是把一张图片水平和垂直重复的拼在一起，不停的重复这张图片，然后就可以转换到频域中。频域图中越靠近中心的越低频，越发散的越高频。所谓高频，就是指图像中像素变化剧烈的部分，比如边缘。所以频域图中有一个很明显的“十”字的形状，就是图片重复拼接的时候产生的边缘高频信号，其他高频信号就是图像中的边缘。可以看到图片中大部分都集中在低频。</p><p>现在我们对图片进行一个边缘提取：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201235273-164657319031210.png" alt="image-20220306201235273"></p><p>此时图片只剩下了边缘，对应的频域图中低频信号全部被滤掉了，只剩下了高频信号，这种滤波也就是所谓的<strong>高通滤波</strong>，只允许高频信号通过。</p><p>如果我们对图片的边缘进行平滑处理，也就是给图片加模糊：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201404735-164657319031211.png" alt="image-20220306201404735"></p><p>显然，高频信号都被滤掉了，模糊是<strong>低通滤波</strong>。</p><p>如果我们想要某一特定频率的信号，那就可以进行特定的滤波：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201511142-164657319031212.png" alt="image-20220306201511142"></p><p>这样就得到了图像在某一特定频率下的特征。</p><p>搞清了滤波的作用，滤波的过程实际上就是<strong>卷积</strong>的过程，无论信号还是图像，滤波就是卷积，关于图像卷积就不赘述了。</p><p>但还是要特别说明两个重要的性质：</p><ul><li>时域中的卷积，相当于频域中的乘积，时域中的乘积相当于频域中的卷积。这是一个非常神奇的性质，利用这个性质，我们对图像卷积时，可以把图像和卷积核转到频域进行乘积，得到的结果再转回时域，就得到卷积后的图片了。</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201946817-164657319031213.png" alt="image-20220306201946817"></p><ul><li>卷积核越大，频率越低，所以我们用越大的模糊核去模糊一张图片时，模糊效果越严重，图片剩下的信号频率越低</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202316849-164657319031214.png" alt="image-20220306202316849"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202325681-164657319031215.png" alt="image-20220306202325681"></p><h4 id="4-反走样原理"><a href="#4-反走样原理" class="headerlink" title="4 反走样原理"></a>4 反走样原理</h4><p>有了滤波，我们再回顾刚才产生走样的原因：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p><p>发生重叠的部分正是信号的高频部分，那我们通过滤波，把高频部分滤掉，再进行采样，就不会重叠了。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202657939-164657319031216.png" alt="image-20220306202657939"></p><p>对应到图像上，模糊就是低通滤波，所以我们先对图形模糊，再进行采样，这样的光栅化就可以避免走样，这就是<strong>反走样</strong>。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202815314-164657319031217.png" alt="image-20220306202815314"></p><p>试试效果，这是没有反走样的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202929823-164657319031218.png" alt="image-20220306202929823"></p><p>这是反走样的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203002692-164657319031219.png" alt="image-20220306203002692"></p><p>锯齿有了明显改善，更明显的对比：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203030537-164657319031220.png" alt="image-20220306203030537"></p><p>那么我们怎么进行模糊呢，反走样具体要如何实现？</p><p>我们对每一个像素，进行一个1像素的滤波，所谓1像素的滤波是指，每个像素的像素值等于三角形在像素内覆盖的加权平均值。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203643492-164657319031221.png" alt="image-20220306203643492"></p><p>但这个滤波对于计算机是很难实现的，我们无法准确的判断三角形覆盖了这个像素百分之多少的位置，因此就出现了各种近似的方法，这些方法基本达到了我们理想中反走样的目的。</p><h4 id="5-反走样方法"><a href="#5-反走样方法" class="headerlink" title="5 反走样方法"></a>5 反走样方法</h4><p>根据上面的理论分析，产生走样是因为我们的像素不够密集，那只要像素足够密集，进行足够密集的采样，走样就可以得到缓解，所以屏幕分辨率越高，显示越清晰。当然，不停提升屏幕分辨率是不现实的，因此需要进行软件反走样，游戏领域中，反走样（AA）最具代表性、应用最广泛的方法有以下几种。</p><h5 id="5-1-多重采样反走样-MSAA"><a href="#5-1-多重采样反走样-MSAA" class="headerlink" title="5.1 多重采样反走样-MSAA"></a>5.1 多重采样反走样-MSAA</h5><p>MSAA把一个像素分为多个亚像素，然后根据亚像素有多少在三角形内部，对这个像素的像素值做相应比例的改变。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204044700-164657319031222.png" alt="image-20220306204044700"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204102154-164657319031223.png" alt="image-20220306204102154"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204111526-164657319031224.png" alt="image-20220306204111526"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204121336-164657319031225.png" alt="image-20220306204121336"></p><p>这里给出最简单的MSAA的C++版本代码，在上一节的判断每个像素是否在三角形内部的函数的基础上稍作修改即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x), <span class="type">float</span>(y), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MSAA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> count = <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(count / <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看效果，左边是没使用反走样生成的图形，右边是MSAA的效果：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220308210015557.png" alt="image-20220308210015557"></p><p>优点：</p><ul><li>对几何反走样效果良好</li><li>不支持延迟渲染（关于延迟渲染之后会详细说）</li><li>画面更清晰</li></ul><p>缺点：</p><ul><li>像素的亮度与覆盖区域的面积成正比，而与覆盖区域落在像素内的位置无关，这仍会导致锯齿效应；</li><li>只能消除几何走样，无法解决高光区域的着色走样</li><li>静态画面表现良好，时域上不稳定</li></ul><h5 id="5-2-时域反走样-Temporal-AA"><a href="#5-2-时域反走样-Temporal-AA" class="headerlink" title="5.2 时域反走样-Temporal AA"></a>5.2 时域反走样-Temporal AA</h5><p>Temporal AA严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p><p>简单来说，Temporal AA是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p><p>具体的原理可以查看<a href="https://zhuanlan.zhihu.com/p/57503885">TAA 反走样算法研究 | 时域超采样技术</a>。</p><p>优点：</p><ul><li>效果好，开销小</li><li>时域稳定性强</li><li>支持延迟渲染</li></ul><p>缺点：</p><ul><li>随着历史颜色的累积，会导致不可绝对消除的模糊（运动模糊），尤其在移动过快的镜头或物体情况下，会导致重影现象</li><li>需要额外内存开销，保存历史信息</li><li>不能应对半透明物体</li></ul><h5 id="5-3-快速近似反走样-FXAA"><a href="#5-3-快速近似反走样-FXAA" class="headerlink" title="5.3 快速近似反走样-FXAA"></a>5.3 快速近似反走样-FXAA</h5><p>最简单的、高效率的抗锯齿方式，对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p><p>优点：</p><ul><li>性能开销极小</li></ul><p>缺点：</p><ul><li>画面会更模糊</li><li>对像绒毛一类的复杂物体效果不好</li></ul><h5 id="5-4-深度学习超采样-DLSS"><a href="#5-4-深度学习超采样-DLSS" class="headerlink" title="5.4 深度学习超采样-DLSS"></a>5.4 深度学习超采样-DLSS</h5><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p><p>优点：</p><ul><li>DLSS能同时在几何、着色、时域上进行反走样</li><li>深度学习解决了TAA种画面模糊、透明、遮挡、残影等现象</li></ul><p>缺点：</p><ul><li>性能开销高，仅仅反走样就占用了画面 20% 的渲染时长</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;反走样（Antialiasing）&quot;&gt;&lt;a href=&quot;#反走样（Antialiasing）&quot; class=&quot;headerlink&quot; title=&quot;反走样（Antialiasing）&quot;&gt;&lt;/a&gt;反走样（Antialiasing）&lt;/h3&gt;&lt;p&gt;上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（三）光栅化</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/</id>
    <published>2022-03-06T10:33:25.000Z</published>
    <updated>2022-03-09T11:47:51.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="光栅化（Rasteriztion）"><a href="#光栅化（Rasteriztion）" class="headerlink" title="光栅化（Rasteriztion）"></a>光栅化（Rasteriztion）</h3><p>首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：</p><ul><li>为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）</li><li>然后对物体做同样的变换以使得相机和物体不发生相对运动</li><li>最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）</li></ul><p>接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是<strong>光栅化</strong>的过程。</p><p><em><span id="more"></span></em></p><h4 id="1-屏幕的定义"><a href="#1-屏幕的定义" class="headerlink" title="1 屏幕的定义"></a>1 屏幕的定义</h4><p>屏幕可以看作是一个二维矩阵，矩阵中的每一个元素存储的是像素值，屏幕显示图形的过程，就是遍历整个数组，显示对应像素值的过程。这个二维数组的大小也就是常说的分辨率。</p><p>为了简化后面的推导，这里我们把每一个像素简单的抽象成为一个方格，并且这个方格中的颜色是一致的，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306172222268.png" alt="image-20220306172222268"></p><p>蓝色像素的坐标是 (2, 1) ，这个像素的中心点的坐标是 (2.5, 1.5) ，也就是像素 (x, y) 的中心点坐标是 (x+0.5, y+0.5) .</p><p>这里的屏幕坐标系原点定义在了左下角，通常计算机中屏幕原点在左上角，这个定义不影响后面的推导。</p><h4 id="2-视口变换"><a href="#2-视口变换" class="headerlink" title="2 视口变换"></a>2 视口变换</h4><p>有了屏幕的定义，我们想要把投影后的立方体显示在屏幕上，接下来要做的一步叫做<strong>视口变换</strong>，也就是将立方体转换到屏幕空间中，只有先转换到屏幕空间中，才能进一步计算屏幕空间中的点（像素）都应该是什么颜色。</p><p>这是一个3D空间到2D空间的转换，因此我们先考虑简化的情况，也就是不考虑Z方向，即不考虑3D空间中的远近、遮挡等关系，先只将XY平面转换到屏幕平面上，这个过程很简单，只要将立方体的XY平面映射到和屏幕一样的比例就可以。也就是把 [-1, 1] 映射到 [0, width] 和 [0, height]上。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306173109581.png" alt="image-20220306173109581"></p><p>同时还要进行平移，因为透视坐标系中原点是在 (0,0) 的位置，我们当然希望这个原点在屏幕的中央，而屏幕的左下角是原点，所以需要把透视坐标原点平移(width&#x2F;2, height&#x2F;2).</p><p>这样就完成了从透视坐标系到屏幕坐标系的转换。</p><h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>在介绍光栅化之前，有必要再次重申一下我们现在在干嘛。</p><p>我们的目标是把一个三维的物体显示在二维的屏幕上，那么我们首先做的就是坐标转换，之前的所有变换都是在做坐标转换，直到视口变换，我们终于完成了从三维坐标到二维坐标的映射；下一步就是计算三维物体顶点的颜色，我们得知道这个三维物体每个部分原来是什么颜色，才能把它显示在二维屏幕上，这个过程会通过UV贴图的颜色，结合光照，透明度等等，计算出模型每个顶点的具体颜色（R, G, B），这里我们先不管；最后就是在二维平面上绘制，所谓绘制也就是把这个二维平面填上颜色，前面说了，屏幕就是存储像素值的二维数组，所以绘制也就是计算每一个像素的颜色，然后屏幕根据这个数组就能显示出三维场景了。</p><p>OK，光栅化就是在屏幕上填充颜色的过程，但是根据什么来填颜色呢，就根据之前计算出来的三维物体上的顶点颜色来填。我们每次从三维物体上取三个点，映射到二维空间，形成一个三角形，这个三角形的颜色取决于三个顶点的颜色，具体有几种取法：</p><ul><li>三个顶点颜色取平均值</li><li>取某一个顶点的颜色</li><li>三个顶点颜色渐变</li></ul><p>使用哪种取法可以根据实际需求来定，不是我们目前讨论的关键。</p><blockquote><p><strong>为什么是三角形？</strong></p><p>因为三角形是最最基本的几何图形，任何多边形都可以拆分成若干三角形，并且三角形有许多优秀的性质，比如对于图形的内外有严格的定义，再比如很好进行插值运算，上面三角形颜色取三个顶点颜色的渐变就是三角形优势的体现之一。</p></blockquote><p>有了这个三角形之后，我们要做的事情就很简单了，判断每一个像素是否在这个三角形内部，如果在内部，就填上三角形的颜色。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180614301.png" alt="image-20220306180614301"></p><p>这个过程其实是一个<strong>采样</strong>的过程，采样这个概念非常重要，简单而不严谨的来说就是定义一个函数，计算每个采样点在这个函数上的值就是采样。这里的函数就是判断一个点 (x, y) 是否在给定的三角形内部，那么如何实现这个函数的功能呢？</p><p>最简单的方法就是<strong>向量叉乘</strong>，如下图所示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180926083.png" alt="image-20220306180926083"></p><p>对于点 P，计算向量$\vec{AB}$与向量$\vec{AP}$的叉乘，得到的方向朝向屏幕外，这意味着点 P 在 AB 的左边，同理计算向量$\vec{BC}$与向量$\vec{BP}$的叉乘，得到的向量方向也是朝向屏幕外，这意味着点 P 在 BC 的左边，同样计算向量$\vec{CA}$与向量$\vec{CP}$的叉乘，得到的向量方向还是朝向屏幕外，这意味着点 P 在 CA 的左边，于是我们可以判定点 P 在三角形 ABC 的内部。</p><p>如果三个叉乘得到的某一个向量方向朝屏幕内，就说明点 P 在某一条边的右侧，那么点 P 一定在三角形ABC外部。这里给出C++版本代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个方法就可以判断任意一个点是否在三角形内部了，当然还可以算出三条边的方程，带入 P 点坐标得到三个值，判断同号异号，本质上和向量叉乘是一样的。</p><blockquote><p>如果一个点在三角形边缘怎么算？</p><p>这个可以根据需求自己规定，而且几乎所有的图形API，比如OpenGL、DirectX都对这种情况有明确的规定，无需担心。</p></blockquote><p>到此我们其实就完成了光栅化的过程。总结一下：</p><ul><li>取三个点构成三角形并计算三角形颜色</li><li>判断屏幕上每一个像素是否在三角形内部，在则上色</li></ul><p>这个过程很简单，但存在许多问题，比如按照上面的流程，我们的代码应该这样写：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182055653.png" alt="image-20220306182055653"></p><p>显然十分暴力，对于下大多数情况来说，我们完全不必遍历所有像素点，使用一个Bounding Box就可以大幅降低时间复杂度：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182158250.png" alt="image-20220306182158250"></p><p>但这还不够，如果三角形非常细长，而且还刚好倾斜45°左右，那么实际上它也只占整个Bounding Box很少一部分，于是我们可以进一步改进：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182343897.png" alt="image-20220306182343897"></p><p>先算出每一行的起点坐标，逐行扫描，遇到不在三角形内部的点就开始扫描下一行。</p><p>现在我们来看一下光栅化之后的结果是什么样的：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182649751.png" alt="image-20220306182649751"></p><p>而我们想得到的样子却是这样：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182717888.png" alt="image-20220306182717888"></p><p>不能说毫无关系，但确实不是一个东西，这是因为我们现在得到的光栅化结果有太多的<strong>锯齿</strong>了，更专业一点的说法就是我们的光栅化过程使得图形<strong>走样（Aliasing）</strong>了，因此我们必须对光栅化的过程进行<strong>抗锯齿</strong>，更准确的说法叫做<strong>反走样</strong>。关于反走样将在下一篇文章中进行详细介绍。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;光栅化（Rasteriztion）&quot;&gt;&lt;a href=&quot;#光栅化（Rasteriztion）&quot; class=&quot;headerlink&quot; title=&quot;光栅化（Rasteriztion）&quot;&gt;&lt;/a&gt;光栅化（Rasteriztion）&lt;/h3&gt;&lt;p&gt;首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &amp;#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）&lt;/li&gt;
&lt;li&gt;然后对物体做同样的变换以使得相机和物体不发生相对运动&lt;/li&gt;
&lt;li&gt;最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是&lt;strong&gt;光栅化&lt;/strong&gt;的过程。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】二叉树</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-03-03T04:01:58.000Z</published>
    <updated>2022-03-09T11:46:26.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote><p><strong>摘要</strong></p><p>本文主要总结与二叉树有关的关键知识以及具有代表性的题目，后续将持续更新。</p></blockquote><p><em><span id="more"></span></em></p><h4 id="1、前序、中序、后序遍历的迭代算法："><a href="#1、前序、中序、后序遍历的迭代算法：" class="headerlink" title="1、前序、中序、后序遍历的迭代算法："></a>1、前序、中序、后序遍历的迭代算法：</h4><p><strong>对于前序遍历</strong>，遍历顺序为“根、左、右”，因此对于任意一个节点，直接将节点值加入结果列表并入栈，然后遍历左子树，直到节点为空，开始遍历右子树即可，前序遍历代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//直接加入结果</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);<span class="comment">//入栈</span></span><br><span class="line">           root = root-&gt;left;<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于中序遍历</strong>，遍历顺序为“左、根、右”，因此只需要将前序遍历的顺序改为，对于任意一个节点，先遍历左子树入栈，直到节点为空，取栈顶节点加入结果列表（此时栈顶节点的左节点为空，因此栈顶结点即为子树的根节点，加入结果列表），然后遍历右子树，中序遍历代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);<span class="comment">//入栈</span></span><br><span class="line">           root = root-&gt;left;<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树为空此时栈顶结点就作为子树的根节点，加入结果列表，并出栈，然后遍历右子树</span></span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;<span class="comment">//遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历</strong>，遍历顺序为“左、右、根”，考虑其和前序遍历顺序“根、左、右”的关系，如果前序遍历时把节点值放入结果的、列表尾部的操作改为插入列表头部，则遍历顺序变为“右、左、根”，此时只需要再将前序遍历时，先遍历左子树在遍历右子树的顺序对调，就可以将遍历顺序改为“左、右、根”，即为后序遍历了，后序遍历代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),root-&gt;val);<span class="comment">//结果插到列表开头</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);<span class="comment">//入栈</span></span><br><span class="line">           root = root-&gt;right;<span class="comment">//先遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;left;<span class="comment">//再遍历左子树</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、层序遍历：使用广度优先搜索即可"><a href="#2、层序遍历：使用广度优先搜索即可" class="headerlink" title="2、层序遍历：使用广度优先搜索即可"></a>2、层序遍历：使用广度优先搜索即可</h4><h4 id="3、构造二叉树："><a href="#3、构造二叉树：" class="headerlink" title="3、构造二叉树："></a>3、构造二叉树：</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-yu-zhong-xu-gou-jian-er-cha-shu-7dznd/">前序与中序构建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-yu-zhong-xu-gou-jian-er-cha-shu-d-kmrr/">后序与中序构建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/">二叉树的序列化与反序列化</a></p><h4 id="4、递归解决二叉树问题："><a href="#4、递归解决二叉树问题：" class="headerlink" title="4、递归解决二叉树问题："></a>4、递归解决二叉树问题：</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">二叉树的最大深度</a></p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p><p><a href="https://leetcode-cn.com/problems/path-sum/solution/">路径总和</a></p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文主要总结与二叉树有关的关键知识以及具有代表性的题目，后续将持续更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（二）旋转与四元数</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/</id>
    <published>2022-03-03T03:45:31.000Z</published>
    <updated>2022-03-06T10:32:46.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h3><blockquote><p><strong>摘要</strong></p><p>本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。</p></blockquote><p><em><span id="more"></span></em></p><h4 id="一、三维旋转变换的表示方式"><a href="#一、三维旋转变换的表示方式" class="headerlink" title="一、三维旋转变换的表示方式"></a>一、三维旋转变换的表示方式</h4><p><strong>1、欧拉角</strong></p><p>直接给出$x$（俯仰）、$y$（偏航）、$z$（滚转）三个轴向的旋转角，优点是表示简单直接，容易理解，但存在万向节死锁的问题（当两个轴重合时，会损失一个自由度）。</p><p><strong>2、轴角</strong></p><p>顾名思义，用一个轴$n$和一个角$\theta$表示旋转，其中轴是旋转轴，默认用一个过坐标原点的三维向量表示，角表示绕这个轴旋转的角度，轴角表示为一个四元组$(x,y,z,\theta)$。</p><p>但轴角也存在明显的缺陷，一方面，因为角度的周期性，任何$2n\pi$的旋转都等价于没有旋转，这在某些情况下是不可接受的；另一方面，由于轴角描述的“四元组”并不是一个空间下的东西，首先$(x,y,z)$是一个3维坐标下的矢量，而$\theta$则是极坐标下的角度，简单的将他们组合到一起并不能保证他们插值结果的稳定性，因为他们无法归一化，所以不能保证最终插值后得到的矢量长度（经过旋转变换后两点之间的距离）相等；此外，轴角形式的旋转不能直接施于点或矢量，必转换为矩阵或者四元数。</p><p><strong>3、矩阵</strong></p><p>计算机图形学中，一般以矩阵形式表示旋转，对于三维空间的点或向量，将其表示为齐次坐标形式，则绕不同旋转轴的旋转矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162321017.png" alt="image-20220301162321017"></p><p>而对于任意旋转，都可以分解为这三个轴的旋转，可以利用<strong>Rodrigues旋转公式</strong>将轴角表示的任意旋转转换为矩阵形式：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162445459.png" alt="image-20220301162445459"></p><p>矩阵表示法可以直接施加于点或向量，计算相对方便，也叫容易理解，但在实际工程中，如果我们要存储一个对象的旋转参数，就要存储这个对象的旋转矩阵，一共16个浮点数，对空间消耗较大，并且矩阵形式同样无法进行简单的插值，因此在实际的游戏开发及其他工程应用中，存储一个对象的旋转，通常采用四元数的形式。</p><p><strong>4、四元数</strong></p><p>四元数像是轴角表示法的优化版本，但解决了所有轴角可能存在的问题，最大的优势就是便于插值，并且存储时只需要存储4个浮点数，而且求逆、串联等操作比矩阵更方便，相比于轴角和矩阵优势巨大。</p><p>对于四元数的理解，可以看作是有一个实部和三个虚部构成的虚数，描述的是四维空间，具体可以看<a href="https://zhuanlan.zhihu.com/p/53872740">可视化理解四元数</a>。</p><hr><h4 id="二、四元数"><a href="#二、四元数" class="headerlink" title="二、四元数"></a>二、四元数</h4><p>四元数的全部公式和运算法则以及与矩阵等形式的转化，可以查看<a href="https://zhuanlan.zhihu.com/p/97186723">四元数(Quaternions)</a>，这里对常用的关键公式进行总结。</p><p>四元数表示为$(x,y,z,w)$，其中<br>$$<br>x&#x3D;i·q_1·sin(\theta&#x2F;2) \<br>y&#x3D;j·q_2·sin(\theta&#x2F;2) \<br>z&#x3D;k·q_3·sin(\theta&#x2F;2) \<br>w&#x3D;cos(\theta&#x2F;2)<br>$$<br>其中$(iq_1,jq_2,kq_3)$是表示旋转轴的矢量，$\theta$表示绕此轴旋转的角度。对四元数$q_2$左乘一个四元数$q_1$，其作用是将$q_2$拉伸$q_1$的模长，再作用一个特殊的四维旋转。所以我们用<strong>单位四元数</strong>来表示三维空间中的旋转，因为单位四元数模长为1$(w^2+x^2+y^2+z^2&#x3D;1)$，而旋转时必须要保证的就是，一个向量旋转前后模长不变。</p><ul><li>乘法</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184920885.png" alt="image-20220301184920885"></p><ul><li>标量乘法</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185303072.png" alt="image-20220301185303072"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185318122.png" alt="image-20220301185318122"></p><ul><li>加法</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184949807.png" alt="image-20220301184949807"></p><ul><li>共轭</li></ul><p>$$<br>q&#x3D;(w,x,y,z) \<br>q^*&#x3D;(w,-x,-y,-z)<br>$$</p><ul><li>模</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185026298.png" alt="image-20220301185026298"></p><ul><li>Identity</li></ul><p>$$<br>i&#x3D;(0,0,0,1)<br>$$</p><ul><li>逆</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185208658.png" alt="image-20220301185208658"></p><ul><li>单位四元数表示旋转：单位四元数模为1，因此可以表示为</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185635142.png" alt="image-20220301185635142"></p><p>将一个三维向量$p$写成四元数形式</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185811398.png" alt="image-20220301185811398"></p><p>则运算</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185855191.png" alt="image-20220301185855191"></p><p>表示向量$p$在三维空间中绕轴$u_q$旋转$2\phi$弧度。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;旋转与四元数&quot;&gt;&lt;a href=&quot;#旋转与四元数&quot; class=&quot;headerlink&quot; title=&quot;旋转与四元数&quot;&gt;&lt;/a&gt;旋转与四元数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【计算机图形学】（一）变换</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/</id>
    <published>2022-03-02T12:44:31.000Z</published>
    <updated>2022-03-09T11:47:12.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变换（Transform）"><a href="#变换（Transform）" class="headerlink" title="变换（Transform）"></a>变换（Transform）</h2><blockquote><p><strong>摘要</strong></p><p>本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&#x2F;视角变换以及投影。</p></blockquote><p><em><span id="more"></span></em></p><h3 id="1-二维变换"><a href="#1-二维变换" class="headerlink" title="1 二维变换"></a>1 二维变换</h3><h4 id="1-1-缩放、反射、错切、旋转"><a href="#1-1-缩放、反射、错切、旋转" class="headerlink" title="1.1 缩放、反射、错切、旋转"></a>1.1 缩放、反射、错切、旋转</h4><p>缩放、反射、错切、旋转都属于<strong>线性变换</strong>，可以用<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式表示，其中M是变换矩阵。</p><p><strong>1.1.1 缩放变换</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163710187.png" alt="image-20220302163741174"></p><p><strong>1.1.2 反射变换</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163741174.png" alt="image-20220302163741174"></p><p><strong>1.1.3 错切变换</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163814166.png" alt="image-20220302163814166"></p><p><strong>1.1.4 旋转变换</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163954343.png" alt="image-20220302163954343"></p><h4 id="1-2-平移变换"><a href="#1-2-平移变换" class="headerlink" title="1.2 平移变换"></a>1.2 平移变换</h4><p><strong>平移变换不是线性变换</strong>，因为不可以用矩阵乘法的形式表示，而是在原向量上加一个平移向量</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164304998.png" alt="image-20220302164304998"></p><h4 id="1-3-齐次坐标"><a href="#1-3-齐次坐标" class="headerlink" title="1.3 齐次坐标"></a>1.3 齐次坐标</h4><p>为了使得所有变换都能成为线性变换，即让所有变换都能表示成<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式，引入齐次坐标的概念。为二维坐标引入第三维，二维点的第三维填充1，二维向量的第三维填充0：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164609617.png" alt="image-20220302164609617"></p><blockquote><p>为什么点是1，向量是0？</p><p>因为这样的规定符合点和向量的运算关系：</p><p>点 - 点 &#x3D; 向量</p><p>向量 +(-) 向量 &#x3D; 向量</p><p>点 + 点 &#x3D; 点（两点之和在齐次坐标中是二者中点，因为<strong>齐次坐标中规定，$(x,y,z,1)$和$(kx,ky,kz,k)$表示的是同一个点。</strong>）</p></blockquote><p>由此，平移变换也可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164639435.png" alt="image-20220302164639435"></p><p>于是对于二维空间的任意变换，使用齐次坐标都可以进行表示：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164801021.png" alt="image-20220302164801021"></p><p>对于任何线性变换+平移的组合，称为仿射变换</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164926591.png" alt="image-20220302164926591"></p><p>仿射变换在齐次坐标下的通用形式就可以表示为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164916131.png" alt="image-20220302164916131"></p><h4 id="1-4-逆变换"><a href="#1-4-逆变换" class="headerlink" title="1.4 逆变换"></a>1.4 逆变换</h4><p>一个变换矩阵的逆矩阵就是这个变换的逆变换。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165438620.png" alt="image-20220302165438620"></p><h4 id="1-5-组合变换"><a href="#1-5-组合变换" class="headerlink" title="1.5 组合变换"></a>1.5 组合变换</h4><p>组合变换按顺序将每一步变换矩阵施加于原来的点或向量即可，但变换顺序不能随意交换，因为矩阵乘法不满足交换律。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165628966.png" alt="image-20220302165628966"></p><h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><h4 id="2-1-三维齐次坐标"><a href="#2-1-三维齐次坐标" class="headerlink" title="2.1 三维齐次坐标"></a>2.1 三维齐次坐标</h4><p>二维齐次坐标的概念可以完全推广到三维：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165804338.png" alt="image-20220302165804338"></p><p>仿射变换矩阵也同样可以进行推广：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165829764.png" alt="image-20220302165829764"></p><p>但对于三维旋转变换，有一定的特殊性，三维旋转变换矩阵表示如下：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165915330.png" alt="image-20220302165915330"></p><blockquote><p>注意绕y轴旋转时的矩阵，与绕另外两轴旋转时略有不同，这是由于在右手坐标系中，y轴正方向定义为z轴叉乘x轴，而不是x轴叉乘z轴，所以sin的正负号会有换位，而x轴正方向定义为y轴叉乘z轴，z轴正方向定义为x轴叉乘y轴，所以矩阵形式和二维一样。</p><p>更多关于三维旋转的内容，查看<a href="%E2%80%AA%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0.md">‪补充内容：旋转与四元数</a></p></blockquote><h4 id="2-2-视图变换（Viewing-Transformation）"><a href="#2-2-视图变换（Viewing-Transformation）" class="headerlink" title="2.2 视图变换（Viewing Transformation）"></a>2.2 视图变换（Viewing Transformation）</h4><p>视图变换模拟现实世界中拍照的过程，指把三维空间中的物体，投影到我们的观察视角上的过程，也称为<strong>MVP变换（model、view、projection）</strong></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302170639587.png" alt="image-20220302170639587"></p><p>首先将物体变换到指定位置（model变换），再把相机（视角）摆放到指定位置（view变换），然后进行拍照（投影变换）。</p><h4 id="2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）"><a href="#2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）" class="headerlink" title="2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）"></a>2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）</h4><p>如何让固定一个相机的位置？首先要有一个位置向量$\vec e$指示相机摆放的位置，然后要有一个视角（凝视）向量指向$\vec g$观察方向，最后要有一个上方向向量$\vec t$指示当前向上的方向是什么，相当于固定相机的旋转。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171338777.png" alt="image-20220302171338777"></p><p>再考虑一个关键点，对于相机和被拍摄的物体，如果二者之间不存在相对运动，那么拍摄出的画面永远是一样的</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171432219.png" alt="image-20220302171432219"></p><p>因此，为了计算和表示方便，我们对于任意给定的相机和物体，把相机放置到坐标系原点，观察方向沿-Z轴方向，up方向为Y轴方向，物体随着相机做相同的变换，这样相机和物体没有发生相对运动，观察到的画面也不发生改变，这一过程即为视角&#x2F;相机变换，这个过程完成了MVP变换中M和V两步。<br>​因为对相机和物体的变换是相同的，所以他们的变换矩阵也相同，我们按照相机推导出变换矩阵即可。相机要做的变换分为3步：</p><ul><li>位置向量$\vec e$平移到坐标原点</li><li>方向向量$\vec g$旋转到-Z轴方向</li><li>up向量$\vec t$旋转到Y轴方向</li><li>做完这些后，自然$\vec g \times \vec t$指向X轴方向</li></ul><p>于是，平移矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172209907.png" alt="image-20220302172209907"></p><p>旋转矩阵不好写出，但是将X轴旋转到$\vec g \times \vec t$方向，Y轴旋转到$\vec t$方向，-Z轴旋转到$\vec g$方向的旋转矩阵可以直接写出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172334394.png" alt="image-20220302172334394"></p><p>于是这个变换的逆变换就是我们要的旋转矩阵，又因为旋转矩阵是正交矩阵，所以逆矩阵就是转置矩阵，因此我们要的旋转矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172437821.png" alt="image-20220302172437821"></p><p>于是整个视角&#x2F;相机变换的矩阵为：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172458878.png" alt="image-20220302172458878"></p><h4 id="2-4-投影变换"><a href="#2-4-投影变换" class="headerlink" title="2.4 投影变换"></a>2.4 投影变换</h4><p>投影变换分为正交投影和透视投影，透视投影更为常用，但要以正交投影为基础。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172624799.png" alt="image-20220302172624799"></p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172700695.png" alt="image-20220302172700695"></p><p><strong>2.4.1 正交投影（Orthographic projection）</strong></p><p>正交投影的一般过程为：</p><ul><li>在三维空间中的任意一个立方体，其左右区间为$(l,r)$，上下区间为$(b,t)$，远近区间为$(f,n)$，需要注意的是右手坐标系中远坐标f要小于近坐标n，因为观察方向是沿-Z轴方向。</li><li>先将该立方体的中心平移到坐标原点</li><li>再将三个区间缩放到[-1,1]，最终得到一个规范立方体</li></ul><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172959740.png" alt="image-20220302172959740"></p><p>以上一系列变换的矩阵很好写出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173201783.png" alt="image-20220302173201783"></p><p>这就是正交投影矩阵。</p><p><strong>2.4.2 透视投影（Perspective Projection）</strong></p><p>透视投影也就是人眼正常情况下观察到的画面，近大远小，平行线不再平行。对比透视投影和正交投影，可以发现，只要我们把透视投影的四棱台“压缩”成正交投影的立方体，再做正交投影即可。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173404924.png" alt="image-20220302173404924"></p><p>那么“压缩”这一步如何用矩阵形式表示呢？通过侧视图，可以看出远平面上的点$(x,y,z)$和近平面上的点$(x’,y’,z’)$的y坐标的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173616684.png" alt="image-20220302173616684"></p><p>同理也可以得到x坐标的关系：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173700210.png" alt="image-20220302173700210"></p><p>因此在齐次坐标系下，远平面上的点$(x,y,z)$经过“压缩”的过程就可以写成：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173827446.png" alt="image-20220302173827446"></p><p>根据这个关系，这个“压缩”矩阵$M_{persp\rightarrow ortho}^{4\times 4}$我们就可以确定一部分，因为</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173918746.png" alt="image-20220302173918746"></p><p>所以</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174126707.png" alt="image-20220302174126707"></p><p>但是第三啊行如何确定呢，直接推导任意点的Z坐标变换前后是如何变化的是非常困难的，但是我们可以从特殊点入手，我们知道以下两个关键信息：</p><ul><li>对于任意近平面上的点，变换前后所有坐标都不发生变化</li><li>对于任意远平面上的点，变换前后Z坐标不发生变化</li></ul><p>对于第一点，任意近平面上的点可以写成$(x,y,n,1)$，所以写成数学形式就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174358169.png" alt="image-20220302174358169"></p><p>可以看到变换后的Z坐标变成了$n^2$，显然与$x$和$y$无关，因此矩阵$M_{persp\rightarrow ortho}^{4\times 4}$的第三行一定是$(0,0,A,B)$的形式。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174644740.png" alt="image-20220302174644740"></p><p>所以我们可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174719504.png" alt="image-20220302174719504"></p><p>同样的，对于第二点，任意远平面上的点变换前后Z坐标不变，我们取远平面中心点$(x,y,f,1)$，于是可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174908764.png" alt="image-20220302174908764"></p><p>两个未知数，两个方程，联立可以把A和B解出来：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174938303.png" alt="image-20220302174938303"></p><p>这样我们就知道了完整的$M_{persp\rightarrow ortho}^{4\times 4}$矩阵：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220303144633780.png" alt="image-20220303144633780"></p><p>于是透视投影变换的矩阵就是：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302175347739.png" alt="image-20220302175347739"></p><p><strong>2.4.3 视场角与宽高比</strong></p><p>很多情况下，不会给定上面说到的立方体的 l, r, t, b 等数值，而是以视场角（field-of-view）和宽高比（aspect ratio）的形式给出的，当然，近平面 n 和远平面 f 的是一定会给出的。</p><p>在这种情况下我们认为 l &#x3D; -r , t &#x3D; -b，也就是我们在做正交投影矩阵时不需要再做平移变换了，只要通过视场角和宽高比计算得到立方体的宽和高就知道X方向和Y方向的缩放比，也就可以构造正交投影矩阵了 。</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142910300.png" alt="image-20220307142910300"></p><p>从侧面看这幅图可以得到：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142946563.png" alt="image-20220307142946563"></p><p>因此可以得出：</p><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307143010470.png" alt="image-20220307143010470"></p><p>这样我们就得到了宽度的一半 r 和高度的一半 t ，长度依然是 f - n ，然后就可以像之前一样构造投影矩阵了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;变换（Transform）&quot;&gt;&lt;a href=&quot;#变换（Transform）&quot; class=&quot;headerlink&quot; title=&quot;变换（Transform）&quot;&gt;&lt;/a&gt;变换（Transform）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&amp;#x2F;视角变换以及投影。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】线性数据结构</title>
    <link href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://lz328.github.io/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-02T12:44:31.000Z</published>
    <updated>2022-03-09T11:46:09.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote><p><strong>摘要</strong></p><p>对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。</p></blockquote><p><em><span id="more"></span></em></p><h4 id="1、数组和字符串"><a href="#1、数组和字符串" class="headerlink" title="1、数组和字符串"></a>1、<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/">数组和字符串</a></h4><ul><li>二分查找（一般用于给定的数组是有序的，或先手动排序，如<a href="https://leetcode-cn.com/problems/search-insert-position/solution/">搜索插入位置</a>、<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/">寻找旋转排序数组中的最小值</a>）</li><li>首尾双指针（<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/">两数之和 II - 输入有序数组</a>）</li><li>快慢双指针（<a href="https://leetcode-cn.com/problems/remove-element/solution/">移除元素</a>、<a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/">最大连续 1 的个数</a>、<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/">长度最小的子数组</a>、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/">删除有序数组中的重复项</a>、<a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a>）</li><li>滑动窗口（<a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/">子数组最大平均数</a>、<a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/">可获得的最大点数</a>、<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/">爱生气的书店老板</a>、<a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/">定长子串中元音的最大数目</a>、<a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/submissions/">将 x 减到 0 的最小操作数</a>、<a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-you-hua-jie-fa-by-bu-1i5e/">最小覆盖子串</a>）</li><li><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/">字符串匹配KMP算法</a>：关键在于构建next数组的方法</li><li><a href="https://leetcode-cn.com/leetbook/read/array-and-string/y1nke/">二维数组</a></li></ul><h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/leetbook/detail/linked-list/">链表</a></h4><ul><li>递归（大部分问题都可以用递归，典型问题如<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/">两两交换链表中的节点</a>）</li><li>快慢指针（<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/">环形链表II</a>、<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/">相交链表</a>等）</li><li>经典问题（<a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a>、<a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">回文链表</a>等）</li><li><strong>一般处理链表问题时在原链表前加一个虚节点就可以避免对头节点的特殊判断</strong></li></ul><h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><ul><li><a href="https://leetcode-cn.com/leetbook/read/queue-stack/kc5ge/">广搜BFS</a>（<a href="https://leetcode-cn.com/problems/walls-and-gates/">墙与门</a>、<a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a>、<a href="https://leetcode-cn.com/problems/open-the-lock/">打开转盘锁</a>）:一般用来二叉树的层序遍历、求最短路径、最小数量之类的题目</li><li>广度优先搜索模板：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;节点或状态&gt; map;<span class="comment">//可选，看是否需要重复入队</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(根节点或状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)<span class="comment">//遍历当前层所有节点并扩展相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            节点或状态 cur = q.<span class="built_in">front</span>();<span class="comment">//取队列头节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == 目标节点或状态)<span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">                map.<span class="built_in">insert</span>(x);<span class="comment">//可选</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><ul><li>深搜DFS（<a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-shen-sou-he-yan-sou-nn8j/">钥匙和房间</a>、<a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-dfshe-bfs-by-bu-luo-bu-2tg4/">图像渲染</a>、以及上面可以用BFS做的题）：一般能用广搜的也能用深搜，但是深搜不能保证是最短路径或者最小数量，还用于二叉树的前中后序遍历</li><li>DFS模板（非递归，类似于上面的BFS）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    unordered_set&lt;节点&gt; visited;<span class="comment">//可选，看是否需要重复入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    visited.<span class="built_in">insert</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        节点 cur = q.<span class="built_in">top</span>();<span class="comment">//取栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);<span class="comment">//可选</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DFS模板（递归）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target, unordered_set&lt;节点&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(节点 x : root的所有相邻节点)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(x);<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x,target,visited)) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;线性数据结构&quot;&gt;&lt;a href=&quot;#线性数据结构&quot; class=&quot;headerlink&quot; title=&quot;线性数据结构&quot;&gt;&lt;/a&gt;线性数据结构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://lz328.github.io/LycTechStack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://lz328.github.io/LycTechStack.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C++" scheme="https://lz328.github.io/LycTechStack.github.io/tags/C/"/>
    
  </entry>
  
</feed>
