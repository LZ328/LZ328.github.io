<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【计算机图形学】（一）变换</title>
    <url>/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="变换（Transform）"><a href="#变换（Transform）" class="headerlink" title="变换（Transform）"></a>变换（Transform）</h2><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&#x2F;视角变换以及投影。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h3 id="1-二维变换"><a href="#1-二维变换" class="headerlink" title="1 二维变换"></a>1 二维变换</h3><h4 id="1-1-缩放、反射、错切、旋转"><a href="#1-1-缩放、反射、错切、旋转" class="headerlink" title="1.1 缩放、反射、错切、旋转"></a>1.1 缩放、反射、错切、旋转</h4><p>缩放、反射、错切、旋转都属于<strong>线性变换</strong>，可以用<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式表示，其中M是变换矩阵。</p>
<p><strong>1.1.1 缩放变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163710187.png" alt="image-20220302163741174"></p>
<p><strong>1.1.2 反射变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163741174.png" alt="image-20220302163741174"></p>
<p><strong>1.1.3 错切变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163814166.png" alt="image-20220302163814166"></p>
<p><strong>1.1.4 旋转变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163954343.png" alt="image-20220302163954343"></p>
<h4 id="1-2-平移变换"><a href="#1-2-平移变换" class="headerlink" title="1.2 平移变换"></a>1.2 平移变换</h4><p><strong>平移变换不是线性变换</strong>，因为不可以用矩阵乘法的形式表示，而是在原向量上加一个平移向量</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164304998.png" alt="image-20220302164304998"></p>
<h4 id="1-3-齐次坐标"><a href="#1-3-齐次坐标" class="headerlink" title="1.3 齐次坐标"></a>1.3 齐次坐标</h4><p>为了使得所有变换都能成为线性变换，即让所有变换都能表示成<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式，引入齐次坐标的概念。为二维坐标引入第三维，二维点的第三维填充1，二维向量的第三维填充0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164609617.png" alt="image-20220302164609617"></p>
<blockquote>
<p>为什么点是1，向量是0？</p>
<p>因为这样的规定符合点和向量的运算关系：</p>
<p>点 - 点 &#x3D; 向量</p>
<p>向量 +(-) 向量 &#x3D; 向量</p>
<p>点 + 点 &#x3D; 点（两点之和在齐次坐标中是二者中点，因为<strong>齐次坐标中规定，$(x,y,z,1)$和$(kx,ky,kz,k)$表示的是同一个点。</strong>）</p>
</blockquote>
<p>由此，平移变换也可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164639435.png" alt="image-20220302164639435"></p>
<p>于是对于二维空间的任意变换，使用齐次坐标都可以进行表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164801021.png" alt="image-20220302164801021"></p>
<p>对于任何线性变换+平移的组合，称为仿射变换</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164926591.png" alt="image-20220302164926591"></p>
<p>仿射变换在齐次坐标下的通用形式就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164916131.png" alt="image-20220302164916131"></p>
<h4 id="1-4-逆变换"><a href="#1-4-逆变换" class="headerlink" title="1.4 逆变换"></a>1.4 逆变换</h4><p>一个变换矩阵的逆矩阵就是这个变换的逆变换。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165438620.png" alt="image-20220302165438620"></p>
<h4 id="1-5-组合变换"><a href="#1-5-组合变换" class="headerlink" title="1.5 组合变换"></a>1.5 组合变换</h4><p>组合变换按顺序将每一步变换矩阵施加于原来的点或向量即可，但变换顺序不能随意交换，因为矩阵乘法不满足交换律。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165628966.png" alt="image-20220302165628966"></p>
<h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><h4 id="2-1-三维齐次坐标"><a href="#2-1-三维齐次坐标" class="headerlink" title="2.1 三维齐次坐标"></a>2.1 三维齐次坐标</h4><p>二维齐次坐标的概念可以完全推广到三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165804338.png" alt="image-20220302165804338"></p>
<p>仿射变换矩阵也同样可以进行推广：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165829764.png" alt="image-20220302165829764"></p>
<p>但对于三维旋转变换，有一定的特殊性，三维旋转变换矩阵表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165915330.png" alt="image-20220302165915330"></p>
<blockquote>
<p>注意绕y轴旋转时的矩阵，与绕另外两轴旋转时略有不同，这是由于在右手坐标系中，y轴正方向定义为z轴叉乘x轴，而不是x轴叉乘z轴，所以sin的正负号会有换位，而x轴正方向定义为y轴叉乘z轴，z轴正方向定义为x轴叉乘y轴，所以矩阵形式和二维一样。</p>
<p>更多关于三维旋转的内容，查看<a href="%E2%80%AA%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0.md">‪补充内容：旋转与四元数</a></p>
</blockquote>
<h4 id="2-2-视图变换（Viewing-Transformation）"><a href="#2-2-视图变换（Viewing-Transformation）" class="headerlink" title="2.2 视图变换（Viewing Transformation）"></a>2.2 视图变换（Viewing Transformation）</h4><p>视图变换模拟现实世界中拍照的过程，指把三维空间中的物体，投影到我们的观察视角上的过程，也称为<strong>MVP变换（model、view、projection）</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302170639587.png" alt="image-20220302170639587"></p>
<p>首先将物体变换到指定位置（model变换），再把相机（视角）摆放到指定位置（view变换），然后进行拍照（投影变换）。</p>
<h4 id="2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）"><a href="#2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）" class="headerlink" title="2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）"></a>2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）</h4><p>如何让固定一个相机的位置？首先要有一个位置向量$\vec e$指示相机摆放的位置，然后要有一个视角（凝视）向量指向$\vec g$观察方向，最后要有一个上方向向量$\vec t$指示当前向上的方向是什么，相当于固定相机的旋转。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171338777.png" alt="image-20220302171338777"></p>
<p>再考虑一个关键点，对于相机和被拍摄的物体，如果二者之间不存在相对运动，那么拍摄出的画面永远是一样的</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171432219.png" alt="image-20220302171432219"></p>
<p>因此，为了计算和表示方便，我们对于任意给定的相机和物体，把相机放置到坐标系原点，观察方向沿-Z轴方向，up方向为Y轴方向，物体随着相机做相同的变换，这样相机和物体没有发生相对运动，观察到的画面也不发生改变，这一过程即为视角&#x2F;相机变换，这个过程完成了MVP变换中M和V两步。<br>​因为对相机和物体的变换是相同的，所以他们的变换矩阵也相同，我们按照相机推导出变换矩阵即可。相机要做的变换分为3步：</p>
<ul>
<li>位置向量$\vec e$平移到坐标原点</li>
<li>方向向量$\vec g$旋转到-Z轴方向</li>
<li>up向量$\vec t$旋转到Y轴方向</li>
<li>做完这些后，自然$\vec g \times \vec t$指向X轴方向</li>
</ul>
<p>于是，平移矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172209907.png" alt="image-20220302172209907"></p>
<p>旋转矩阵不好写出，但是将X轴旋转到$\vec g \times \vec t$方向，Y轴旋转到$\vec t$方向，-Z轴旋转到$\vec g$方向的旋转矩阵可以直接写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172334394.png" alt="image-20220302172334394"></p>
<p>于是这个变换的逆变换就是我们要的旋转矩阵，又因为旋转矩阵是正交矩阵，所以逆矩阵就是转置矩阵，因此我们要的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172437821.png" alt="image-20220302172437821"></p>
<p>于是整个视角&#x2F;相机变换的矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172458878.png" alt="image-20220302172458878"></p>
<h4 id="2-4-投影变换"><a href="#2-4-投影变换" class="headerlink" title="2.4 投影变换"></a>2.4 投影变换</h4><p>投影变换分为正交投影和透视投影，透视投影更为常用，但要以正交投影为基础。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172624799.png" alt="image-20220302172624799"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172700695.png" alt="image-20220302172700695"></p>
<p><strong>2.4.1 正交投影（Orthographic projection）</strong></p>
<p>正交投影的一般过程为：</p>
<ul>
<li>在三维空间中的任意一个立方体，其左右区间为$(l,r)$，上下区间为$(b,t)$，远近区间为$(f,n)$，需要注意的是右手坐标系中远坐标f要小于近坐标n，因为观察方向是沿-Z轴方向。</li>
<li>先将该立方体的中心平移到坐标原点</li>
<li>再将三个区间缩放到[-1,1]，最终得到一个规范立方体</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172959740.png" alt="image-20220302172959740"></p>
<p>以上一系列变换的矩阵很好写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173201783.png" alt="image-20220302173201783"></p>
<p>这就是正交投影矩阵。</p>
<p><strong>2.4.2 透视投影（Perspective Projection）</strong></p>
<p>透视投影也就是人眼正常情况下观察到的画面，近大远小，平行线不再平行。对比透视投影和正交投影，可以发现，只要我们把透视投影的四棱台“压缩”成正交投影的立方体，再做正交投影即可。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173404924.png" alt="image-20220302173404924"></p>
<p>那么“压缩”这一步如何用矩阵形式表示呢？通过侧视图，可以看出远平面上的点$(x,y,z)$和近平面上的点$(x’,y’,z’)$的y坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173616684.png" alt="image-20220302173616684"></p>
<p>同理也可以得到x坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173700210.png" alt="image-20220302173700210"></p>
<p>因此在齐次坐标系下，远平面上的点$(x,y,z)$经过“压缩”的过程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173827446.png" alt="image-20220302173827446"></p>
<p>根据这个关系，这个“压缩”矩阵$M_{persp\rightarrow ortho}^{4\times 4}$我们就可以确定一部分，因为</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173918746.png" alt="image-20220302173918746"></p>
<p>所以</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174126707.png" alt="image-20220302174126707"></p>
<p>但是第三啊行如何确定呢，直接推导任意点的Z坐标变换前后是如何变化的是非常困难的，但是我们可以从特殊点入手，我们知道以下两个关键信息：</p>
<ul>
<li>对于任意近平面上的点，变换前后所有坐标都不发生变化</li>
<li>对于任意远平面上的点，变换前后Z坐标不发生变化</li>
</ul>
<p>对于第一点，任意近平面上的点可以写成$(x,y,n,1)$，所以写成数学形式就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174358169.png" alt="image-20220302174358169"></p>
<p>可以看到变换后的Z坐标变成了$n^2$，显然与$x$和$y$无关，因此矩阵$M_{persp\rightarrow ortho}^{4\times 4}$的第三行一定是$(0,0,A,B)$的形式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174644740.png" alt="image-20220302174644740"></p>
<p>所以我们可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174719504.png" alt="image-20220302174719504"></p>
<p>同样的，对于第二点，任意远平面上的点变换前后Z坐标不变，我们取远平面中心点$(x,y,f,1)$，于是可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174908764.png" alt="image-20220302174908764"></p>
<p>两个未知数，两个方程，联立可以把A和B解出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174938303.png" alt="image-20220302174938303"></p>
<p>这样我们就知道了完整的$M_{persp\rightarrow ortho}^{4\times 4}$矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220303144633780.png" alt="image-20220303144633780"></p>
<p>于是透视投影变换的矩阵就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302175347739.png" alt="image-20220302175347739"></p>
<p><strong>2.4.3 视场角与宽高比</strong></p>
<p>很多情况下，不会给定上面说到的立方体的 l, r, t, b 等数值，而是以视场角（field-of-view）和宽高比（aspect ratio）的形式给出的，当然，近平面 n 和远平面 f 的是一定会给出的。</p>
<p>在这种情况下我们认为 l &#x3D; -r , t &#x3D; -b，也就是我们在做正交投影矩阵时不需要再做平移变换了，只要通过视场角和宽高比计算得到立方体的宽和高就知道X方向和Y方向的缩放比，也就可以构造正交投影矩阵了 。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142910300.png" alt="image-20220307142910300"></p>
<p>从侧面看这幅图可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142946563.png" alt="image-20220307142946563"></p>
<p>因此可以得出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307143010470.png" alt="image-20220307143010470"></p>
<p>这样我们就得到了宽度的一半 r 和高度的一半 t ，长度依然是 f - n ，然后就可以像之前一样构造投影矩阵了。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（二）旋转与四元数</title>
    <url>/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h3 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="一、三维旋转变换的表示方式"><a href="#一、三维旋转变换的表示方式" class="headerlink" title="一、三维旋转变换的表示方式"></a>一、三维旋转变换的表示方式</h4><p><strong>1、欧拉角</strong></p>
<p>直接给出$x$（俯仰）、$y$（偏航）、$z$（滚转）三个轴向的旋转角，优点是表示简单直接，容易理解，但存在万向节死锁的问题（当两个轴重合时，会损失一个自由度）。</p>
<p><strong>2、轴角</strong></p>
<p>顾名思义，用一个轴$n$和一个角$\theta$表示旋转，其中轴是旋转轴，默认用一个过坐标原点的三维向量表示，角表示绕这个轴旋转的角度，轴角表示为一个四元组$(x,y,z,\theta)$。</p>
<p>但轴角也存在明显的缺陷，一方面，因为角度的周期性，任何$2n\pi$的旋转都等价于没有旋转，这在某些情况下是不可接受的；另一方面，由于轴角描述的“四元组”并不是一个空间下的东西，首先$(x,y,z)$是一个3维坐标下的矢量，而$\theta$则是极坐标下的角度，简单的将他们组合到一起并不能保证他们插值结果的稳定性，因为他们无法归一化，所以不能保证最终插值后得到的矢量长度（经过旋转变换后两点之间的距离）相等；此外，轴角形式的旋转不能直接施于点或矢量，必转换为矩阵或者四元数。</p>
<p><strong>3、矩阵</strong></p>
<p>计算机图形学中，一般以矩阵形式表示旋转，对于三维空间的点或向量，将其表示为齐次坐标形式，则绕不同旋转轴的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162321017.png" alt="image-20220301162321017"></p>
<p>而对于任意旋转，都可以分解为这三个轴的旋转，可以利用<strong>Rodrigues旋转公式</strong>将轴角表示的任意旋转转换为矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162445459.png" alt="image-20220301162445459"></p>
<p>矩阵表示法可以直接施加于点或向量，计算相对方便，也叫容易理解，但在实际工程中，如果我们要存储一个对象的旋转参数，就要存储这个对象的旋转矩阵，一共16个浮点数，对空间消耗较大，并且矩阵形式同样无法进行简单的插值，因此在实际的游戏开发及其他工程应用中，存储一个对象的旋转，通常采用四元数的形式。</p>
<p><strong>4、四元数</strong></p>
<p>四元数像是轴角表示法的优化版本，但解决了所有轴角可能存在的问题，最大的优势就是便于插值，并且存储时只需要存储4个浮点数，而且求逆、串联等操作比矩阵更方便，相比于轴角和矩阵优势巨大。</p>
<p>对于四元数的理解，可以看作是有一个实部和三个虚部构成的虚数，描述的是四维空间，具体可以看<a href="https://zhuanlan.zhihu.com/p/53872740">可视化理解四元数</a>。</p>
<hr>
<h4 id="二、四元数"><a href="#二、四元数" class="headerlink" title="二、四元数"></a>二、四元数</h4><p>四元数的全部公式和运算法则以及与矩阵等形式的转化，可以查看<a href="https://zhuanlan.zhihu.com/p/97186723">四元数(Quaternions)</a>，这里对常用的关键公式进行总结。</p>
<p>四元数表示为$(x,y,z,w)$，其中<br>$$<br>x&#x3D;i·q_1·sin(\theta&#x2F;2) \<br>y&#x3D;j·q_2·sin(\theta&#x2F;2) \<br>z&#x3D;k·q_3·sin(\theta&#x2F;2) \<br>w&#x3D;cos(\theta&#x2F;2)<br>$$<br>其中$(iq_1,jq_2,kq_3)$是表示旋转轴的矢量，$\theta$表示绕此轴旋转的角度。对四元数$q_2$左乘一个四元数$q_1$，其作用是将$q_2$拉伸$q_1$的模长，再作用一个特殊的四维旋转。所以我们用<strong>单位四元数</strong>来表示三维空间中的旋转，因为单位四元数模长为1$(w^2+x^2+y^2+z^2&#x3D;1)$，而旋转时必须要保证的就是，一个向量旋转前后模长不变。</p>
<ul>
<li>乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184920885.png" alt="image-20220301184920885"></p>
<ul>
<li>标量乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185303072.png" alt="image-20220301185303072"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185318122.png" alt="image-20220301185318122"></p>
<ul>
<li>加法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184949807.png" alt="image-20220301184949807"></p>
<ul>
<li>共轭</li>
</ul>
<p>$$<br>q&#x3D;(w,x,y,z) \<br>q^*&#x3D;(w,-x,-y,-z)<br>$$</p>
<ul>
<li>模</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185026298.png" alt="image-20220301185026298"></p>
<ul>
<li>Identity</li>
</ul>
<p>$$<br>i&#x3D;(0,0,0,1)<br>$$</p>
<ul>
<li>逆</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185208658.png" alt="image-20220301185208658"></p>
<ul>
<li>单位四元数表示旋转：单位四元数模为1，因此可以表示为</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185635142.png" alt="image-20220301185635142"></p>
<p>将一个三维向量$p$写成四元数形式</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185811398.png" alt="image-20220301185811398"></p>
<p>则运算</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185855191.png" alt="image-20220301185855191"></p>
<p>表示向量$p$在三维空间中绕轴$u_q$旋转$2\phi$弧度。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性数据结构</title>
    <url>/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote>
<p><strong>摘要</strong></p>
<p>对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、数组和字符串"><a href="#1、数组和字符串" class="headerlink" title="1、数组和字符串"></a>1、<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/">数组和字符串</a></h4><ul>
<li>二分查找（一般用于给定的数组是有序的，或先手动排序，如<a href="https://leetcode-cn.com/problems/search-insert-position/solution/">搜索插入位置</a>、<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/">寻找旋转排序数组中的最小值</a>）</li>
<li>首尾双指针（<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/">两数之和 II - 输入有序数组</a>）</li>
<li>快慢双指针（<a href="https://leetcode-cn.com/problems/remove-element/solution/">移除元素</a>、<a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/">最大连续 1 的个数</a>、<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/">长度最小的子数组</a>、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/">删除有序数组中的重复项</a>、<a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a>）</li>
<li>滑动窗口（<a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/">子数组最大平均数</a>、<a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/">可获得的最大点数</a>、<a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/">爱生气的书店老板</a>、<a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/">定长子串中元音的最大数目</a>、<a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/submissions/">将 x 减到 0 的最小操作数</a>、<a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-you-hua-jie-fa-by-bu-1i5e/">最小覆盖子串</a>）</li>
<li><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/">字符串匹配KMP算法</a>：关键在于构建next数组的方法</li>
<li><a href="https://leetcode-cn.com/leetbook/read/array-and-string/y1nke/">二维数组</a></li>
</ul>
<h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/leetbook/detail/linked-list/">链表</a></h4><ul>
<li>递归（大部分问题都可以用递归，典型问题如<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/">两两交换链表中的节点</a>）</li>
<li>快慢指针（<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/">环形链表II</a>、<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/">相交链表</a>等）</li>
<li>经典问题（<a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a>、<a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">回文链表</a>等）</li>
<li><strong>一般处理链表问题时在原链表前加一个虚节点就可以避免对头节点的特殊判断</strong></li>
</ul>
<h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><ul>
<li><a href="https://leetcode-cn.com/leetbook/read/queue-stack/kc5ge/">广搜BFS</a>（<a href="https://leetcode-cn.com/problems/walls-and-gates/">墙与门</a>、<a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a>、<a href="https://leetcode-cn.com/problems/open-the-lock/">打开转盘锁</a>）:一般用来二叉树的层序遍历、求最短路径、最小数量之类的题目</li>
<li>广度优先搜索模板：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;节点或状态&gt; map;	<span class="comment">//可选，看是否需要重复入队</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(根节点或状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)	<span class="comment">//遍历当前层所有节点并扩展相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            节点或状态 cur = q.<span class="built_in">front</span>();	<span class="comment">//取队列头节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == 目标节点或状态)	<span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">                map.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><ul>
<li>深搜DFS（<a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-shen-sou-he-yan-sou-nn8j/">钥匙和房间</a>、<a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-dfshe-bfs-by-bu-luo-bu-2tg4/">图像渲染</a>、以及上面可以用BFS做的题）：一般能用广搜的也能用深搜，但是深搜不能保证是最短路径或者最小数量，还用于二叉树的前中后序遍历</li>
<li>DFS模板（非递归，类似于上面的BFS）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    unordered_set&lt;节点&gt; visited;	<span class="comment">//可选，看是否需要重复入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    visited.<span class="built_in">insert</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        节点 cur = q.<span class="built_in">top</span>();	<span class="comment">//取栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS模板（递归）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target, unordered_set&lt;节点&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(节点 x : root的所有相邻节点)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x,target,visited)) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】二叉树</title>
    <url>/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要总结与二叉树有关的关键知识以及具有代表性的题目，后续将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、前序、中序、后序遍历的迭代算法："><a href="#1、前序、中序、后序遍历的迭代算法：" class="headerlink" title="1、前序、中序、后序遍历的迭代算法："></a>1、前序、中序、后序遍历的迭代算法：</h4><p><strong>对于前序遍历</strong>，遍历顺序为“根、左、右”，因此对于任意一个节点，直接将节点值加入结果列表并入栈，然后遍历左子树，直到节点为空，开始遍历右子树即可，前序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//直接加入结果</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于中序遍历</strong>，遍历顺序为“左、根、右”，因此只需要将前序遍历的顺序改为，对于任意一个节点，先遍历左子树入栈，直到节点为空，取栈顶节点加入结果列表（此时栈顶节点的左节点为空，因此栈顶结点即为子树的根节点，加入结果列表），然后遍历右子树，中序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树为空此时栈顶结点就作为子树的根节点，加入结果列表，并出栈，然后遍历右子树</span></span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于后序遍历</strong>，遍历顺序为“左、右、根”，考虑其和前序遍历顺序“根、左、右”的关系，如果前序遍历时把节点值放入结果的、列表尾部的操作改为插入列表头部，则遍历顺序变为“右、左、根”，此时只需要再将前序遍历时，先遍历左子树在遍历右子树的顺序对调，就可以将遍历顺序改为“左、右、根”，即为后序遍历了，后序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),root-&gt;val);	<span class="comment">//结果插到列表开头</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;right;	<span class="comment">//先遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;left;		<span class="comment">//再遍历左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、层序遍历：使用广度优先搜索即可"><a href="#2、层序遍历：使用广度优先搜索即可" class="headerlink" title="2、层序遍历：使用广度优先搜索即可"></a>2、层序遍历：使用广度优先搜索即可</h4><h4 id="3、构造二叉树："><a href="#3、构造二叉树：" class="headerlink" title="3、构造二叉树："></a>3、构造二叉树：</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-yu-zhong-xu-gou-jian-er-cha-shu-7dznd/">前序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-yu-zhong-xu-gou-jian-er-cha-shu-d-kmrr/">后序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/">二叉树的序列化与反序列化</a></p>
<h4 id="4、递归解决二叉树问题："><a href="#4、递归解决二叉树问题：" class="headerlink" title="4、递归解决二叉树问题："></a>4、递归解决二叉树问题：</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">二叉树的最大深度</a></p>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum/solution/">路径总和</a></p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（三）光栅化</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<h3 id="光栅化（Rasteriztion）"><a href="#光栅化（Rasteriztion）" class="headerlink" title="光栅化（Rasteriztion）"></a>光栅化（Rasteriztion）</h3><p>首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：</p>
<ul>
<li>为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）</li>
<li>然后对物体做同样的变换以使得相机和物体不发生相对运动</li>
<li>最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）</li>
</ul>
<p>接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是<strong>光栅化</strong>的过程。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-屏幕的定义"><a href="#1-屏幕的定义" class="headerlink" title="1 屏幕的定义"></a>1 屏幕的定义</h4><p>屏幕可以看作是一个二维矩阵，矩阵中的每一个元素存储的是像素值，屏幕显示图形的过程，就是遍历整个数组，显示对应像素值的过程。这个二维数组的大小也就是常说的分辨率。</p>
<p>为了简化后面的推导，这里我们把每一个像素简单的抽象成为一个方格，并且这个方格中的颜色是一致的，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306172222268.png" alt="image-20220306172222268"></p>
<p>蓝色像素的坐标是 (2, 1) ，这个像素的中心点的坐标是 (2.5, 1.5) ，也就是像素 (x, y) 的中心点坐标是 (x+0.5, y+0.5) .</p>
<p>这里的屏幕坐标系原点定义在了左下角，通常计算机中屏幕原点在左上角，这个定义不影响后面的推导。</p>
<h4 id="2-视口变换"><a href="#2-视口变换" class="headerlink" title="2 视口变换"></a>2 视口变换</h4><p>有了屏幕的定义，我们想要把投影后的立方体显示在屏幕上，接下来要做的一步叫做<strong>视口变换</strong>，也就是将立方体转换到屏幕空间中，只有先转换到屏幕空间中，才能进一步计算屏幕空间中的点（像素）都应该是什么颜色。</p>
<p>这是一个3D空间到2D空间的转换，因此我们先考虑简化的情况，也就是不考虑Z方向，即不考虑3D空间中的远近、遮挡等关系，先只将XY平面转换到屏幕平面上，这个过程很简单，只要将立方体的XY平面映射到和屏幕一样的比例就可以。也就是把 [-1, 1] 映射到 [0, width] 和 [0, height]上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306173109581.png" alt="image-20220306173109581"></p>
<p>同时还要进行平移，因为透视坐标系中原点是在 (0,0) 的位置，我们当然希望这个原点在屏幕的中央，而屏幕的左下角是原点，所以需要把透视坐标原点平移(width&#x2F;2, height&#x2F;2).</p>
<p>这样就完成了从透视坐标系到屏幕坐标系的转换。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>在介绍光栅化之前，有必要再次重申一下我们现在在干嘛。</p>
<p>我们的目标是把一个三维的物体显示在二维的屏幕上，那么我们首先做的就是坐标转换，之前的所有变换都是在做坐标转换，直到视口变换，我们终于完成了从三维坐标到二维坐标的映射；下一步就是计算三维物体顶点的颜色，我们得知道这个三维物体每个部分原来是什么颜色，才能把它显示在二维屏幕上，这个过程会通过UV贴图的颜色，结合光照，透明度等等，计算出模型每个顶点的具体颜色（R, G, B），这里我们先不管；最后就是在二维平面上绘制，所谓绘制也就是把这个二维平面填上颜色，前面说了，屏幕就是存储像素值的二维数组，所以绘制也就是计算每一个像素的颜色，然后屏幕根据这个数组就能显示出三维场景了。</p>
<p>OK，光栅化就是在屏幕上填充颜色的过程，但是根据什么来填颜色呢，就根据之前计算出来的三维物体上的顶点颜色来填。我们每次从三维物体上取三个点，映射到二维空间，形成一个三角形，这个三角形的颜色取决于三个顶点的颜色，具体有几种取法：</p>
<ul>
<li>三个顶点颜色取平均值</li>
<li>取某一个顶点的颜色</li>
<li>三个顶点颜色渐变</li>
</ul>
<p>使用哪种取法可以根据实际需求来定，不是我们目前讨论的关键。</p>
<blockquote>
<p><strong>为什么是三角形？</strong></p>
<p>因为三角形是最最基本的几何图形，任何多边形都可以拆分成若干三角形，并且三角形有许多优秀的性质，比如对于图形的内外有严格的定义，再比如很好进行插值运算，上面三角形颜色取三个顶点颜色的渐变就是三角形优势的体现之一。</p>
</blockquote>
<p>有了这个三角形之后，我们要做的事情就很简单了，判断每一个像素是否在这个三角形内部，如果在内部，就填上三角形的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180614301.png" alt="image-20220306180614301"></p>
<p>这个过程其实是一个<strong>采样</strong>的过程，采样这个概念非常重要，简单而不严谨的来说就是定义一个函数，计算每个采样点在这个函数上的值就是采样。这里的函数就是判断一个点 (x, y) 是否在给定的三角形内部，那么如何实现这个函数的功能呢？</p>
<p>最简单的方法就是<strong>向量叉乘</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180926083.png" alt="image-20220306180926083"></p>
<p>对于点 P，计算向量$\vec{AB}$与向量$\vec{AP}$的叉乘，得到的方向朝向屏幕外，这意味着点 P 在 AB 的左边，同理计算向量$\vec{BC}$与向量$\vec{BP}$的叉乘，得到的向量方向也是朝向屏幕外，这意味着点 P 在 BC 的左边，同样计算向量$\vec{CA}$与向量$\vec{CP}$的叉乘，得到的向量方向还是朝向屏幕外，这意味着点 P 在 CA 的左边，于是我们可以判定点 P 在三角形 ABC 的内部。</p>
<p>如果三个叉乘得到的某一个向量方向朝屏幕内，就说明点 P 在某一条边的右侧，那么点 P 一定在三角形ABC外部。这里给出C++版本代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个方法就可以判断任意一个点是否在三角形内部了，当然还可以算出三条边的方程，带入 P 点坐标得到三个值，判断同号异号，本质上和向量叉乘是一样的。</p>
<blockquote>
<p>如果一个点在三角形边缘怎么算？</p>
<p>这个可以根据需求自己规定，而且几乎所有的图形API，比如OpenGL、DirectX都对这种情况有明确的规定，无需担心。</p>
</blockquote>
<p>到此我们其实就完成了光栅化的过程。总结一下：</p>
<ul>
<li>取三个点构成三角形并计算三角形颜色</li>
<li>判断屏幕上每一个像素是否在三角形内部，在则上色</li>
</ul>
<p>这个过程很简单，但存在许多问题，比如按照上面的流程，我们的代码应该这样写：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182055653.png" alt="image-20220306182055653"></p>
<p>显然十分暴力，对于下大多数情况来说，我们完全不必遍历所有像素点，使用一个Bounding Box就可以大幅降低时间复杂度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182158250.png" alt="image-20220306182158250"></p>
<p>但这还不够，如果三角形非常细长，而且还刚好倾斜45°左右，那么实际上它也只占整个Bounding Box很少一部分，于是我们可以进一步改进：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182343897.png" alt="image-20220306182343897"></p>
<p>先算出每一行的起点坐标，逐行扫描，遇到不在三角形内部的点就开始扫描下一行。</p>
<p>现在我们来看一下光栅化之后的结果是什么样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182649751.png" alt="image-20220306182649751"></p>
<p>而我们想得到的样子却是这样：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182717888.png" alt="image-20220306182717888"></p>
<p>不能说毫无关系，但确实不是一个东西，这是因为我们现在得到的光栅化结果有太多的<strong>锯齿</strong>了，更专业一点的说法就是我们的光栅化过程使得图形<strong>走样（Aliasing）</strong>了，因此我们必须对光栅化的过程进行<strong>抗锯齿</strong>，更准确的说法叫做<strong>反走样</strong>。关于反走样将在下一篇文章中进行详细介绍。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（四）反走样</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<h3 id="反走样（Antialiasing）"><a href="#反走样（Antialiasing）" class="headerlink" title="反走样（Antialiasing）"></a>反走样（Antialiasing）</h3><p>上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是走样？"><a href="#1-什么是走样？" class="headerlink" title="1 什么是走样？"></a>1 什么是走样？</h4><p>要解决问题，就要先了问题。</p>
<p>走样有很多种形式，比如上文中的<strong>锯齿</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191713343-16465731903111.png" alt="image-20220306191713343"></p>
<p>还有我们日常生活中经常遇到的<strong>摩尔纹</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191741271-16465731903114.png" alt="image-20220306191741271"></p>
<p>甚至一些视觉假象，比如一个顺时针旋转的轮子，当他的速度很快时，我们可能看到它是逆时针旋转的。</p>
<p>以上都属于走样，而产生这些走样的原因都一样，那就是<strong>采样速度跟不上信号变化的速度</strong>。</p>
<p>要理解这句话可不容易，接下来我们慢慢来看。</p>
<h4 id="2-产生走样的原因"><a href="#2-产生走样的原因" class="headerlink" title="2 产生走样的原因"></a>2 产生走样的原因</h4><p>上面说了，走样产生的原因就是采样速度跟不上信号变化的速度，更细致一点来说就是，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠。</strong></p>
<p>关于<strong>频域</strong>，是信号处理中的重要概念，简单来说就是只存在正弦波的一个世界，也就是只能用 sin 和 cos 函数，而我们日常描述一个信号（函数）是在时域中描述的，这个函数可以是任何形状，那么频域存在的意义是什么呢。</p>
<p>频域存在的意义就是任何一个函数都可以分解为多个正弦波函数和常数的组合，也就是<strong>傅里叶变换</strong>。有了这个伟大的变换，我们就可以把在时域中不好解释、不好研究的问题，放到频域中去研究。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193355754-16465731903113.png" alt="image-20220306193355754"></p>
<p>时域中的信号通过傅里叶变换，可以变为频域中的信号，同样，频域中的信号通过傅里叶逆变换，可以变为时域中的信号。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193545813-16465731903112.png" alt="image-20220306193545813"></p>
<p>了解了频域，再来回顾一下上篇文章提到的<strong>采样</strong>，采样就是计算函数在采样点上的值，我们光栅化的过程其实就是采样的过程，在信号中，采样其实也就是在整个信号的波形上选一些点拿出来，比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193918481-16465731903115.png" alt="image-20220306193918481"></p>
<p>垂直的虚线就代表一次采样，和不同的波形的交点，就是采样出来的点，然后我们连接这些点，会发现在同样的采样频率下，对频率不同的信号进行采样得到的效果天差地别，例如最上面的信号$f_1(x)$，频率比较小，那我们连接采样点后的折线就和原来的信号非常接近，但是越往下信号频率越大，我们用同样的频率采样得到的折线，就和原来的信号差别越大，$f_4(x)$和$f_5(x)$的折线已经和原信号完全不同了。</p>
<p>再进一步说，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306194603851-16465731903126.png" alt="image-20220306194603851"></p>
<p>对频率相差很大的两个信号进行同频率采样，我们得到的折线是完全一样的，那我们就无法分辨原来的信号长什么样，尤其如果一个信号是高频信号，如果我们用低频采样，就会得到和原来信号完全不同的结果，这就是<strong>走样</strong>产生的原因，现在回过头来看开头说的，<strong>走样产生的原因就是采样速度跟不上信号变化的速度</strong>，是不是就完全理解了。但是这还不够，我们继续。</p>
<p>开头说的另一句话，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠</strong>，这又是什么意思呢。</p>
<p>刚才对于采样的分析，完全是在时域下分析的，那么采样在频域的表现是什么样的呢？</p>
<p>采样在频域表现为<strong>信号的重复</strong>。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195205688-16465731903127.png" alt="image-20220306195205688"></p>
<p>左边一列是时域信号，右边是它对应的频域信号。图（a）是时域中的一个信号，图（b）是它在频域中的样子，图（c）是采样信号，也叫做冲击信号，图（d）是冲击信号在频域中的样子，图（e）就是用冲击信号对原信号进行采样的过程，冲击的点就取原信号对应的值，图（f）就是这个采样过程在频域中得到的结果，可以看到，每采样一个点，都相当于复制了原信号在频域中的内容，所以采样在频域中表现为信号的重复。</p>
<p><strong>而且采样越密集，在频域中信号间隔越大</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>上面的图是使用密集采样得到的结果，采样越密集，频域中间隔越大，所以信号没有发生重叠交错，下面的图是稀疏采样，采样越稀疏，频域间隔越小，也就发生了重叠交错，自然也就产生了<strong>走样</strong>。</p>
<p>到这里，我们差不多搞明白了产生走样的原因，现在回到光栅化上面来，光栅化的过程就是采样的过程，因为我们的像素点相对于三角形来说没有那么密集，所以相当于进行了稀疏采样，也就产生了走样，那么如何来进行反走样呢？</p>
<p>根据上面的理论，只要我们不进行稀疏采样，使采样尽量密集就可以了。</p>
<h4 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3 滤波"></a>3 滤波</h4><p>在讨论反走样之前还要了解一个概念，<strong>滤波</strong>，滤波在数字图像处理和信号处理中都很重要，图像也可以抽象为信号，所以本质都是一样的，那么滤波的意义也就是一样的，对于信号来说，<strong>滤波的作用就是去掉信号中特定频率的内容</strong>。</p>
<p>比如一张图片和它在频域中的图像：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306200708255-16465731903129.png" alt="image-20220306200708255"></p>
<p>要说明的是，时域到频域的转换，默认信号是周期性的，对于图片来说，就是把一张图片水平和垂直重复的拼在一起，不停的重复这张图片，然后就可以转换到频域中。频域图中越靠近中心的越低频，越发散的越高频。所谓高频，就是指图像中像素变化剧烈的部分，比如边缘。所以频域图中有一个很明显的“十”字的形状，就是图片重复拼接的时候产生的边缘高频信号，其他高频信号就是图像中的边缘。可以看到图片中大部分都集中在低频。</p>
<p>现在我们对图片进行一个边缘提取：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201235273-164657319031210.png" alt="image-20220306201235273"></p>
<p>此时图片只剩下了边缘，对应的频域图中低频信号全部被滤掉了，只剩下了高频信号，这种滤波也就是所谓的<strong>高通滤波</strong>，只允许高频信号通过。</p>
<p>如果我们对图片的边缘进行平滑处理，也就是给图片加模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201404735-164657319031211.png" alt="image-20220306201404735"></p>
<p>显然，高频信号都被滤掉了，模糊是<strong>低通滤波</strong>。</p>
<p>如果我们想要某一特定频率的信号，那就可以进行特定的滤波：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201511142-164657319031212.png" alt="image-20220306201511142"></p>
<p>这样就得到了图像在某一特定频率下的特征。</p>
<p>搞清了滤波的作用，滤波的过程实际上就是<strong>卷积</strong>的过程，无论信号还是图像，滤波就是卷积，关于图像卷积就不赘述了。</p>
<p>但还是要特别说明两个重要的性质：</p>
<ul>
<li>时域中的卷积，相当于频域中的乘积，时域中的乘积相当于频域中的卷积。这是一个非常神奇的性质，利用这个性质，我们对图像卷积时，可以把图像和卷积核转到频域进行乘积，得到的结果再转回时域，就得到卷积后的图片了。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201946817-164657319031213.png" alt="image-20220306201946817"></p>
<ul>
<li>卷积核越大，频率越低，所以我们用越大的模糊核去模糊一张图片时，模糊效果越严重，图片剩下的信号频率越低</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202316849-164657319031214.png" alt="image-20220306202316849"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202325681-164657319031215.png" alt="image-20220306202325681"></p>
<h4 id="4-反走样原理"><a href="#4-反走样原理" class="headerlink" title="4 反走样原理"></a>4 反走样原理</h4><p>有了滤波，我们再回顾刚才产生走样的原因：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>发生重叠的部分正是信号的高频部分，那我们通过滤波，把高频部分滤掉，再进行采样，就不会重叠了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202657939-164657319031216.png" alt="image-20220306202657939"></p>
<p>对应到图像上，模糊就是低通滤波，所以我们先对图形模糊，再进行采样，这样的光栅化就可以避免走样，这就是<strong>反走样</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202815314-164657319031217.png" alt="image-20220306202815314"></p>
<p>试试效果，这是没有反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202929823-164657319031218.png" alt="image-20220306202929823"></p>
<p>这是反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203002692-164657319031219.png" alt="image-20220306203002692"></p>
<p>锯齿有了明显改善，更明显的对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203030537-164657319031220.png" alt="image-20220306203030537"></p>
<p>那么我们怎么进行模糊呢，反走样具体要如何实现？</p>
<p>我们对每一个像素，进行一个1像素的滤波，所谓1像素的滤波是指，每个像素的像素值等于三角形在像素内覆盖的加权平均值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203643492-164657319031221.png" alt="image-20220306203643492"></p>
<p>但这个滤波对于计算机是很难实现的，我们无法准确的判断三角形覆盖了这个像素百分之多少的位置，因此就出现了各种近似的方法，这些方法基本达到了我们理想中反走样的目的。</p>
<h4 id="5-反走样方法"><a href="#5-反走样方法" class="headerlink" title="5 反走样方法"></a>5 反走样方法</h4><p>根据上面的理论分析，产生走样是因为我们的像素不够密集，那只要像素足够密集，进行足够密集的采样，走样就可以得到缓解，所以屏幕分辨率越高，显示越清晰。当然，不停提升屏幕分辨率是不现实的，因此需要进行软件反走样，游戏领域中，反走样（AA）最具代表性、应用最广泛的方法有以下几种。</p>
<h5 id="5-1-多重采样反走样-MSAA"><a href="#5-1-多重采样反走样-MSAA" class="headerlink" title="5.1 多重采样反走样-MSAA"></a>5.1 多重采样反走样-MSAA</h5><p>MSAA把一个像素分为多个亚像素，然后根据亚像素有多少在三角形内部，对这个像素的像素值做相应比例的改变。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204044700-164657319031222.png" alt="image-20220306204044700"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204102154-164657319031223.png" alt="image-20220306204102154"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204111526-164657319031224.png" alt="image-20220306204111526"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204121336-164657319031225.png" alt="image-20220306204121336"></p>
<p>这里给出最简单的MSAA的C++版本代码，在上一节的判断每个像素是否在三角形内部的函数的基础上稍作修改即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x), <span class="type">float</span>(y), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MSAA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> count = <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(count / <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看效果，左边是没使用反走样生成的图形，右边是MSAA的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220308210015557.png" alt="image-20220308210015557"></p>
<p>优点：</p>
<ul>
<li>对几何反走样效果良好</li>
<li>不支持延迟渲染（关于延迟渲染之后会详细说）</li>
<li>画面更清晰</li>
</ul>
<p>缺点：</p>
<ul>
<li>像素的亮度与覆盖区域的面积成正比，而与覆盖区域落在像素内的位置无关，这仍会导致锯齿效应；</li>
<li>只能消除几何走样，无法解决高光区域的着色走样</li>
<li>静态画面表现良好，时域上不稳定</li>
</ul>
<h5 id="5-2-时域反走样-Temporal-AA"><a href="#5-2-时域反走样-Temporal-AA" class="headerlink" title="5.2 时域反走样-Temporal AA"></a>5.2 时域反走样-Temporal AA</h5><p>Temporal AA严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p>
<p>简单来说，Temporal AA是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p>
<p>具体的原理可以查看<a href="https://zhuanlan.zhihu.com/p/57503885">TAA 反走样算法研究 | 时域超采样技术</a>。</p>
<p>优点：</p>
<ul>
<li>效果好，开销小</li>
<li>时域稳定性强</li>
<li>支持延迟渲染</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着历史颜色的累积，会导致不可绝对消除的模糊（运动模糊），尤其在移动过快的镜头或物体情况下，会导致重影现象</li>
<li>需要额外内存开销，保存历史信息</li>
<li>不能应对半透明物体</li>
</ul>
<h5 id="5-3-快速近似反走样-FXAA"><a href="#5-3-快速近似反走样-FXAA" class="headerlink" title="5.3 快速近似反走样-FXAA"></a>5.3 快速近似反走样-FXAA</h5><p>最简单的、高效率的抗锯齿方式，对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p>
<p>优点：</p>
<ul>
<li>性能开销极小</li>
</ul>
<p>缺点：</p>
<ul>
<li>画面会更模糊</li>
<li>对像绒毛一类的复杂物体效果不好</li>
</ul>
<h5 id="5-4-深度学习超采样-DLSS"><a href="#5-4-深度学习超采样-DLSS" class="headerlink" title="5.4 深度学习超采样-DLSS"></a>5.4 深度学习超采样-DLSS</h5><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p>
<p>优点：</p>
<ul>
<li>DLSS能同时在几何、着色、时域上进行反走样</li>
<li>深度学习解决了TAA种画面模糊、透明、遮挡、残影等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能开销高，仅仅反走样就占用了画面 20% 的渲染时长</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（五）深度缓冲</title>
    <url>/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h3 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h3><p>到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。</p>
<p><em><span id="more"></span></em></p>
<p>比如一个立方体，在这样的视角下我们是看不到它的左平面、下平面和后平面的，但是在光栅化的过程中，我们依然会取这个立方体左平面上的三个点组成三角形并画在屏幕上，如果不考虑遮挡关系，那画出来的正方体显然和我们看到的就不一样了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308174826553.png" alt="image-20220308174826553"></p>
<p>那如何在光栅化过程中考虑这种遮挡关系，并把这种关系正确的画出来呢？这就是这一节要讨论的内容。</p>
<p>在开始之前，要先明确一个概念，这一节所说的 Z ，并不是物体的 Z 坐标，<strong>而是代表物体离我们的远近，也就是深度，这个深度永远是正数，而且数值越小离我们越近</strong>。因为之前说了相机指向 -Z 方向，所以如果是 Z 坐标的话，离我们越近的反而数值上越大，这不符合我们的直觉。因此需要重新给出这个深度的概念。</p>
<h4 id="1-画家算法"><a href="#1-画家算法" class="headerlink" title="1 画家算法"></a>1 画家算法</h4><p>画家算法指的是我们像画家画画一样，从远处往近处画，这样近处的画面自然会遮挡住远处的画面，光栅化的时候也可以这样，我们先对三角形的深度排序，然后从远往近画在屏幕上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175526241.png" alt="image-20220308175526241"></p>
<p>但是这样的算法无法解决下面这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175553407.png" alt="image-20220308175553407"></p>
<p>三角形的遮挡关系往往没有那么简单，因此画家算法大多情况下并不适用。</p>
<h4 id="2-Z-Buffer"><a href="#2-Z-Buffer" class="headerlink" title="2 Z-Buffer"></a>2 Z-Buffer</h4><p>Z-Buffer的思想非常简单，那就是我们在渲染图形时，除了维护frame-buffer（显示在屏幕上的图）外，再维护一个Z-buffer（深度图），<strong>Z-buffer中存储屏幕上每一个像素当前的最小深度</strong>，在光栅化开始时，Z-buffer中每一个像素的深度都设为无穷大，之后渲染三角形的时候，每次都先判断当前渲染的三角形的深度和Z-buffer中当前像素的深度谁更小（谁离我们更近），如果三角形的深度更小，那么就把三角形的颜色存入frame-buffer中这个像素的位置，同时把Z-buffer中当前像素的最小深度更新一次，这样我们总能保证深度小的颜色遮挡深度大的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180155386.png" alt="image-20220308180155386"></p>
<p>Z-buffer和frame-buffer总是同时渲染的，因此当我们生成一张图片的时候，也就生成了这张图片的深度图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180255018.png" alt="image-20220308180255018"></p>
<p>可以看到深度图中越远的地方像素值越大，越近的地方像素值越小。</p>
<p>Z-buffer的伪代码如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180341613.png" alt="image-20220308180341613"></p>
<p>相比于画家算法 O(nlogn) ，Z-buffer只需要 O(n) 的时间复杂度。</p>
<blockquote>
<p>为什么是O(n)？</p>
<p>假设每个三角形只覆盖常数个像素，那么Z-buffer做的就是对每一个三角形判断对应的深度，然后填充像素，因此只需要花费 O(1) 时间，那么有n个三角形，复杂度就是O(n).</p>
</blockquote>
<p>最后说一下Z-buffer的优势，就是与画三角形的顺序无关，只要维护对了深度信息，画出来的一定是正确是遮挡关系，并且对硬件没有特殊需求，容易实现。</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（一）线性动态规划之单串问题</title>
    <url>/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p>
<p>大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<p>按照问题的输入格式，<strong>线性动态规划解决的问题主要是单串，双串，矩阵上的问题</strong>，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。</p>
<p><em><span id="more"></span></em></p>
<h3 id="单串问题"><a href="#单串问题" class="headerlink" title="单串问题"></a>单串问题</h3><p>单串 <code>dp[i]</code> 是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]上，原问题的解</code>，其中<code>考虑[0..i]上，原问题的解</code>又可以分为两大类，即我们要考虑[0..i]上所有子问题的解（考虑O(n)个子问题的解），还是只考虑考虑[0..i]上常数个子问题的解（考虑O(1)个子问题的解），一般只考虑常数个子问题的解就是考虑 dp[i-1] 或（和）dp[i-2]。单串问题基本上可以分为以下几大类。</p>
<h4 id="1-最长递增子序列（LIS问题）"><a href="#1-最长递增子序列（LIS问题）" class="headerlink" title="1 最长递增子序列（LIS问题）"></a>1 最长递增子序列（LIS问题）</h4><p>这是最经典的线性动态规划问题，也是最能体现线性动态规划思想的问题之一。</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7] </code>是数组 <code>[0,3,1,6,2,2,7] </code>的子序列。</p>
</blockquote>
<p>我们用$f(i)$表示以nums[i]结尾的子数组的LIS长度，因为子序列需要上升，因此以 nums[i] 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。于是可以写出状态转移方程：<br>$$<br>\begin{equation}<br>f(i)&#x3D;\left{<br>\begin{aligned}<br>max(f(i),f(j)+1) &amp; , &amp; nums[i]&gt;nums[j], \<br>1 &amp; , &amp; nums[i]&lt;&#x3D;nums[j].<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>其中$j &lt; i$，显然求解$f(i)$需要遍历所有$f(j)$，因此我们要考虑O(n)个子问题的解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>LIS问题及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a>：除了维护记录长度的dp数组外，还要维护一个记录子序列个数的cnt数组</li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">最大整除子集</a>：动态规划过程类似于最长上升子序列，难点在于还原出子集的所有元素</li>
</ul>
<h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2 最大子数组和"></a>2 最大子数组和</h4><p>另一个经典单串问题</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>同样的思路，我们用 dp[i] 表示以nums[i]结尾的最大子数组和，因为状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。因此可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure>

<p>显然这个问题中，我们只要考虑O(1)个子问题的解，因此也没有必要维护 dp 数组了，运用滚动数组的思想，只要记录下来 dp[i-1] 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(fi + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>最大子数组和及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/huan-xing-shu-zu-zui-da-he-by-bu-luo-bu-7bqj/">环形数组最大和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-bu-luo-bu-xvsx/">乘积最大子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/">最大子矩阵</a>：二维转换为一维的典型题目</li>
<li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a>：上一题的进阶版</li>
</ul>
<h4 id="3-打家劫舍问题"><a href="#3-打家劫舍问题" class="headerlink" title="3 打家劫舍问题"></a>3 打家劫舍问题</h4><p>打家劫舍类似于最大子数组和，但这里的子数组不能连续，也就是不相邻子序列的最大和问题。</p>
<blockquote>
<p>问题描述：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，<strong>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</strong>，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>问题的关键在于我们如果偷了第 i 个房间，那么就不能偷第 i-1 个房间，所以 dp[i] 表示到第 i 个房间为止的最大金额，这个最大金额的取值有两种情况，如果我们不偷第 i 个房间，那么 dp[i] &#x3D; dp[i-1]；如果我们偷第 i 个房间， 那么 dp[i] &#x3D; dp[i-2] + num[i]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp1 = nums[<span class="number">0</span>];              <span class="comment">//屋子能偷盗的最大金额</span></span><br><span class="line">        <span class="type">int</span> dp2 = <span class="built_in">max</span>(dp1,nums[<span class="number">1</span>]);     <span class="comment">//前一间屋子能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp1, dp2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(dp1 + nums[i], dp2);</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打家劫舍及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>：数组变成了环形，也就是偷了第1个房间就不能偷最后一个房间，在区间 [0, nums.size()-1] 和 [1, nums.size()] 上应用两次打家劫舍的算法即可</li>
<li><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/">删除并获得点数</a>：难点在于怎么转换成打家劫舍问题</li>
<li><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/">3n 块披萨</a>：难点在于动态规划状态的定义，因为一定有 3n 个数，我们最多只能拿其中 n 个数字，所以相当于打家劫舍中我们只能偷 3n 个房间中的 n 个</li>
</ul>
<h4 id="4-需要记录两个位置的问题"><a href="#4-需要记录两个位置的问题" class="headerlink" title="4 需要记录两个位置的问题"></a>4 需要记录两个位置的问题</h4><p>有一些单串问题在涉及状态时需要考虑相邻两个元素的情况，因为只考虑最后一个的话无法对状态描述清楚，例如：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a>：$dp[i][j]$表示以 $j, i$ 结尾的最长斐波那契子序列长度，转移时在 [0..j] 中找满足条件的 k </li>
<li><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">最长等差数列</a>：同上，但是两道题的具体实现细节稍有不同</li>
</ul>
<h4 id="5-其他没有显式给定数组的线性动态规划问题"><a href="#5-其他没有显式给定数组的线性动态规划问题" class="headerlink" title="5 其他没有显式给定数组的线性动态规划问题"></a>5 其他没有显式给定数组的线性动态规划问题</h4><p>线性 DP 还有一些问题没有显式的数组，字符串等。此类问题一般没有什么固定的模式，只能通过多做题来积累。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/">最长有效括号</a>：这道题最容易想到的是用栈，但其实算法过程比较难做对，用动态规划更简单，但对于状态转移的过程比较难想到</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a>：最长等差数列的简单版本，给定的数组是严格递增或递减的，处理起来会简单很多</li>
<li><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>：关键在于有效数字只有可能是一位或者两位，因此对于任何一个数字，要么本身一位进行编码，要么和前一位组成两位数字进行编码</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a>：主要考察的是深搜回溯的方法，但是使用动态规划对字符串预处理可以在O(1)时间内判断回文子串</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">分割回文串 II</a>：dp[i] 表示以 s[i] 结尾的字符串的最小分割次数，状态转移时如果 s[i] 能与前面的某个位置 j 组成回文子串 s[j…i]，那么dp[i] &#x3D; dp[j] + 1，遍历所有满足条件的 j &lt; i ，dp[i]取这些值里面的最小值，判断回文子串 s[j…i] 时同样可以用分割回文串中的动态规划方法，所以本题进行了两次动态规划，较为复杂。</li>
<li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/liang-ge-zi-fu-chuan-de-shan-chu-cao-zuo-14uw/">两个字符串的删除操作</a>：转化成LCS问题可以很简单的解决，但还可以用更符合题意的状态定义$dp[i][j]$</li>
<li><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a>：比较简单</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
