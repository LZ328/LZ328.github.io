<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【计算机图形学】（一）变换</title>
    <url>/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="变换（Transform）"><a href="#变换（Transform）" class="headerlink" title="变换（Transform）"></a>变换（Transform）</h2><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍图形学中变换（Transform）的相关知识，包括二维和三维中的各类基本变换，其中重点是三维旋转变换、相机&#x2F;视角变换以及投影。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h3 id="1-二维变换"><a href="#1-二维变换" class="headerlink" title="1 二维变换"></a>1 二维变换</h3><h4 id="1-1-缩放、反射、错切、旋转"><a href="#1-1-缩放、反射、错切、旋转" class="headerlink" title="1.1 缩放、反射、错切、旋转"></a>1.1 缩放、反射、错切、旋转</h4><p>缩放、反射、错切、旋转都属于<strong>线性变换</strong>，可以用<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式表示，其中M是变换矩阵。</p>
<p><strong>1.1.1 缩放变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163710187.png" alt="image-20220302163741174"></p>
<p><strong>1.1.2 反射变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163741174.png" alt="image-20220302163741174"></p>
<p><strong>1.1.3 错切变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163814166.png" alt="image-20220302163814166"></p>
<p><strong>1.1.4 旋转变换</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302163954343.png" alt="image-20220302163954343"></p>
<h4 id="1-2-平移变换"><a href="#1-2-平移变换" class="headerlink" title="1.2 平移变换"></a>1.2 平移变换</h4><p><strong>平移变换不是线性变换</strong>，因为不可以用矩阵乘法的形式表示，而是在原向量上加一个平移向量</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164304998.png" alt="image-20220302164304998"></p>
<h4 id="1-3-齐次坐标"><a href="#1-3-齐次坐标" class="headerlink" title="1.3 齐次坐标"></a>1.3 齐次坐标</h4><p>为了使得所有变换都能成为线性变换，即让所有变换都能表示成<br>$$<br>p’&#x3D;M·p<br>$$<br>的形式，引入齐次坐标的概念。为二维坐标引入第三维，二维点的第三维填充1，二维向量的第三维填充0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164609617.png" alt="image-20220302164609617"></p>
<blockquote>
<p>为什么点是1，向量是0？</p>
<p>因为这样的规定符合点和向量的运算关系：</p>
<p>点 - 点 &#x3D; 向量</p>
<p>向量 +(-) 向量 &#x3D; 向量</p>
<p>点 + 点 &#x3D; 点（两点之和在齐次坐标中是二者中点，因为<strong>齐次坐标中规定，$(x,y,z,1)$和$(kx,ky,kz,k)$表示的是同一个点。</strong>）</p>
<p>更重要的原因是这样满足点和矢量的变换性质，位移变换对于矢量来说没有作用，因为矢量只指示方向，与起点位置无关。这会在下面看到，按照齐次坐标表示的位移矩阵可以对点进行有效位移，而对矢量无作用。</p>
</blockquote>
<p>由此，平移变换也可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164639435.png" alt="image-20220302164639435"></p>
<p>于是对于二维空间的任意变换，使用齐次坐标都可以进行表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164801021.png" alt="image-20220302164801021"></p>
<p>对于任何线性变换+平移的组合，称为仿射变换</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164926591.png" alt="image-20220302164926591"></p>
<p>仿射变换在齐次坐标下的通用形式就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302164916131.png" alt="image-20220302164916131"></p>
<h4 id="1-4-逆变换"><a href="#1-4-逆变换" class="headerlink" title="1.4 逆变换"></a>1.4 逆变换</h4><p>一个变换矩阵的逆矩阵就是这个变换的逆变换。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165438620.png" alt="image-20220302165438620"></p>
<h4 id="1-5-组合变换"><a href="#1-5-组合变换" class="headerlink" title="1.5 组合变换"></a>1.5 组合变换</h4><p>组合变换按顺序将每一步变换矩阵施加于原来的点或向量即可，但变换顺序不能随意交换，因为矩阵乘法不满足交换律。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165628966.png" alt="image-20220302165628966"></p>
<h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><h4 id="2-1-三维齐次坐标"><a href="#2-1-三维齐次坐标" class="headerlink" title="2.1 三维齐次坐标"></a>2.1 三维齐次坐标</h4><p>二维齐次坐标的概念可以完全推广到三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165804338.png" alt="image-20220302165804338"></p>
<p>仿射变换矩阵也同样可以进行推广：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165829764.png" alt="image-20220302165829764"></p>
<p>但对于三维旋转变换，有一定的特殊性，三维旋转变换矩阵表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302165915330.png" alt="image-20220302165915330"></p>
<blockquote>
<p>注意绕y轴旋转时的矩阵，与绕另外两轴旋转时略有不同，这是由于在右手坐标系中，y轴正方向定义为z轴叉乘x轴，而不是x轴叉乘z轴，所以sin的正负号会有换位，而x轴正方向定义为y轴叉乘z轴，z轴正方向定义为x轴叉乘y轴，所以矩阵形式和二维一样。</p>
<p>更多关于三维旋转的内容，查看<a href="%E2%80%AA%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0.md">‪补充内容：旋转与四元数</a></p>
</blockquote>
<h4 id="2-2-视图变换（Viewing-Transformation）"><a href="#2-2-视图变换（Viewing-Transformation）" class="headerlink" title="2.2 视图变换（Viewing Transformation）"></a>2.2 视图变换（Viewing Transformation）</h4><p>视图变换模拟现实世界中拍照的过程，指把三维空间中的物体，投影到我们的观察视角上的过程，也称为<strong>MVP变换（model、view、projection）</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302170639587.png" alt="image-20220302170639587"></p>
<p>首先将物体变换到指定位置（model变换），再把相机（视角）摆放到指定位置（view变换），然后进行拍照（投影变换）。</p>
<h4 id="2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）"><a href="#2-3-视角-x2F-相机变换（View-x2F-Camera-Transformation）" class="headerlink" title="2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）"></a>2.3 视角&#x2F;相机变换（View&#x2F;Camera Transformation）</h4><p>如何让固定一个相机的位置？首先要有一个位置向量$\vec e$指示相机摆放的位置，然后要有一个视角（凝视）向量指向$\vec g$观察方向，最后要有一个上方向向量$\vec t$指示当前向上的方向是什么，相当于固定相机的旋转。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171338777.png" alt="image-20220302171338777"></p>
<p>再考虑一个关键点，对于相机和被拍摄的物体，如果二者之间不存在相对运动，那么拍摄出的画面永远是一样的</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302171432219.png" alt="image-20220302171432219"></p>
<p>因此，为了计算和表示方便，我们对于任意给定的相机和物体，把相机放置到坐标系原点，观察方向沿-Z轴方向，up方向为Y轴方向，物体随着相机做相同的变换，这样相机和物体没有发生相对运动，观察到的画面也不发生改变，这一过程即为视角&#x2F;相机变换，这个过程完成了MVP变换中M和V两步。<br>​因为对相机和物体的变换是相同的，所以他们的变换矩阵也相同，我们按照相机推导出变换矩阵即可。相机要做的变换分为3步：</p>
<ul>
<li>位置向量$\vec e$平移到坐标原点</li>
<li>方向向量$\vec g$旋转到-Z轴方向</li>
<li>up向量$\vec t$旋转到Y轴方向</li>
<li>做完这些后，自然$\vec g \times \vec t$指向X轴方向</li>
</ul>
<p>于是，平移矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172209907.png" alt="image-20220302172209907"></p>
<p>旋转矩阵不好写出，但是将X轴旋转到$\vec g \times \vec t$方向，Y轴旋转到$\vec t$方向，-Z轴旋转到$\vec g$方向的旋转矩阵可以直接写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172334394.png" alt="image-20220302172334394"></p>
<p>于是这个变换的逆变换就是我们要的旋转矩阵，又因为旋转矩阵是正交矩阵，所以逆矩阵就是转置矩阵，因此我们要的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172437821.png" alt="image-20220302172437821"></p>
<p>于是整个视角&#x2F;相机变换的矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172458878.png" alt="image-20220302172458878"></p>
<h4 id="2-4-投影变换"><a href="#2-4-投影变换" class="headerlink" title="2.4 投影变换"></a>2.4 投影变换</h4><p>投影变换分为正交投影和透视投影，透视投影更为常用，但要以正交投影为基础。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172624799.png" alt="image-20220302172624799"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172700695.png" alt="image-20220302172700695"></p>
<p><strong>2.4.1 正交投影（Orthographic projection）</strong></p>
<p>正交投影的一般过程为：</p>
<ul>
<li>在三维空间中的任意一个立方体，其左右区间为$(l,r)$，上下区间为$(b,t)$，远近区间为$(f,n)$，需要注意的是右手坐标系中远坐标f要小于近坐标n，因为观察方向是沿-Z轴方向。</li>
<li>先将该立方体的中心平移到坐标原点</li>
<li>再将三个区间缩放到[-1,1]，最终得到一个规范立方体，这个规范立方体就是归一化设备坐标（NDC）</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302172959740.png" alt="image-20220302172959740"></p>
<p>以上一系列变换的矩阵很好写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173201783.png" alt="image-20220302173201783"></p>
<p>这就是正交投影矩阵。</p>
<p><strong>2.4.2 透视投影（Perspective Projection）</strong></p>
<p>透视投影也就是人眼正常情况下观察到的画面，近大远小，平行线不再平行。对比透视投影和正交投影，可以发现，只要我们把透视投影的四棱台“压缩”成正交投影的立方体，再做正交投影即可。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173404924.png" alt="image-20220302173404924"></p>
<p>那么“压缩”这一步如何用矩阵形式表示呢？通过侧视图，可以看出远平面上的点$(x,y,z)$和近平面上的点$(x’,y’,z’)$的y坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173616684.png" alt="image-20220302173616684"></p>
<p>同理也可以得到x坐标的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173700210.png" alt="image-20220302173700210"></p>
<p>因此在齐次坐标系下，远平面上的点$(x,y,z)$经过“压缩”的过程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173827446.png" alt="image-20220302173827446"></p>
<p>根据这个关系，这个“压缩”矩阵$M_{persp\rightarrow ortho}^{4\times 4}$我们就可以确定一部分，因为</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302173918746.png" alt="image-20220302173918746"></p>
<p>所以</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174126707.png" alt="image-20220302174126707"></p>
<p>但是第三啊行如何确定呢，直接推导任意点的Z坐标变换前后是如何变化的是非常困难的，但是我们可以从特殊点入手，我们知道以下两个关键信息：</p>
<ul>
<li>对于任意近平面上的点，变换前后所有坐标都不发生变化</li>
<li>对于任意远平面上的点，变换前后Z坐标不发生变化</li>
</ul>
<p>对于第一点，任意近平面上的点可以写成$(x,y,n,1)$，所以写成数学形式就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174358169.png" alt="image-20220302174358169"></p>
<p>可以看到变换后的Z坐标变成了$n^2$，显然与$x$和$y$无关，因此矩阵$M_{persp\rightarrow ortho}^{4\times 4}$的第三行一定是$(0,0,A,B)$的形式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174644740.png" alt="image-20220302174644740"></p>
<p>所以我们可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174719504.png" alt="image-20220302174719504"></p>
<p>同样的，对于第二点，任意远平面上的点变换前后Z坐标不变，我们取远平面中心点$(x,y,f,1)$，于是可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174908764.png" alt="image-20220302174908764"></p>
<p>两个未知数，两个方程，联立可以把A和B解出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302174938303.png" alt="image-20220302174938303"></p>
<p>这样我们就知道了完整的$M_{persp\rightarrow ortho}^{4\times 4}$矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220303144633780.png" alt="image-20220303144633780"></p>
<p>于是透视投影变换的矩阵就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220302175347739.png" alt="image-20220302175347739"></p>
<p>透视投影到正交投影之后，再利用正交投影将所有坐标归一化为 NDC ，这一步也叫做透视除法。</p>
<p><strong>2.4.3 视场角与宽高比</strong></p>
<p>很多情况下，不会给定上面说到的立方体的 l, r, t, b 等数值，而是以视场角（field-of-view）和宽高比（aspect ratio）的形式给出的，当然，近平面 n 和远平面 f 的是一定会给出的。</p>
<p>在这种情况下我们认为 l &#x3D; -r , t &#x3D; -b，也就是我们在做正交投影矩阵时不需要再做平移变换了，只要通过视场角和宽高比计算得到立方体的宽和高就知道X方向和Y方向的缩放比，也就可以构造正交投影矩阵了 。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142910300.png" alt="image-20220307142910300"></p>
<p>从侧面看这幅图可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307142946563.png" alt="image-20220307142946563"></p>
<p>因此可以得出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220307143010470.png" alt="image-20220307143010470"></p>
<p>这样我们就得到了宽度的一半 r 和高度的一半 t ，长度依然是 f - n ，然后就可以像之前一样构造投影矩阵了。</p>
<h4 id="2-5-法线变换"><a href="#2-5-法线变换" class="headerlink" title="2.5 法线变换"></a>2.5 法线变换</h4><p>当我们变换一个模型的时候，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理中计算光照等。但是使用同一个变换矩阵对法线进行变换可能无法保证法线的垂直性，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111029857.png" alt="image-20220331111029857"></p>
<p>因此我们要保证变换后的法线依然具有垂直性，就需要用另外一个矩阵对发现进行单独的变换。</p>
<p>在这之前先考虑一个顶点的切线如果使用原矩阵变换会不会有问题，切线就是两个顶点的差，因此用顶点变换的矩阵对切线进行变换不会有任何影响，可以得到正确的结果，那么我们要保证变换后的法线依然和切线垂直，假设原变换矩阵为 $M_{A-&gt;B}$，顶点切线为 $T$，法线为 $N$，对法线进行变换的矩阵是 $G$，于是有以下关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111633664.png" alt="image-20220331111633664"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/image-20220331111727818.png" alt="image-20220331111727818"></p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（二）旋转与四元数</title>
    <url>/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/</url>
    <content><![CDATA[<h3 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h3><blockquote>
<p><strong>摘要</strong></p>
<p>本文主要介绍三维旋转的几类重要表示方式，以及在游戏及其他工程领域最为常用的四元数的相关概念、性质、运算法则和常用公式。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="一、三维旋转变换的表示方式"><a href="#一、三维旋转变换的表示方式" class="headerlink" title="一、三维旋转变换的表示方式"></a>一、三维旋转变换的表示方式</h4><p><strong>1、欧拉角</strong></p>
<p>直接给出$x$（俯仰）、$y$（偏航）、$z$（滚转）三个轴向的旋转角，优点是表示简单直接，容易理解，但存在万向节死锁的问题（当两个轴重合时，会损失一个自由度）。</p>
<p><strong>2、轴角</strong></p>
<p>顾名思义，用一个轴$n$和一个角$\theta$表示旋转，其中轴是旋转轴，默认用一个过坐标原点的三维向量表示，角表示绕这个轴旋转的角度，轴角表示为一个四元组$(x,y,z,\theta)$。</p>
<p>但轴角也存在明显的缺陷，一方面，因为角度的周期性，任何$2n\pi$的旋转都等价于没有旋转，这在某些情况下是不可接受的；另一方面，由于轴角描述的“四元组”并不是一个空间下的东西，首先$(x,y,z)$是一个3维坐标下的矢量，而$\theta$则是极坐标下的角度，简单的将他们组合到一起并不能保证他们插值结果的稳定性，因为他们无法归一化，所以不能保证最终插值后得到的矢量长度（经过旋转变换后两点之间的距离）相等；此外，轴角形式的旋转不能直接施于点或矢量，必转换为矩阵或者四元数。</p>
<p><strong>3、矩阵</strong></p>
<p>计算机图形学中，一般以矩阵形式表示旋转，对于三维空间的点或向量，将其表示为齐次坐标形式，则绕不同旋转轴的旋转矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162321017.png" alt="image-20220301162321017"></p>
<p>而对于任意旋转，都可以分解为这三个轴的旋转，可以利用<strong>Rodrigues旋转公式</strong>将轴角表示的任意旋转转换为矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301162445459.png" alt="image-20220301162445459"></p>
<p>矩阵表示法可以直接施加于点或向量，计算相对方便，也叫容易理解，但在实际工程中，如果我们要存储一个对象的旋转参数，就要存储这个对象的旋转矩阵，一共16个浮点数，对空间消耗较大，并且矩阵形式同样无法进行简单的插值，因此在实际的游戏开发及其他工程应用中，存储一个对象的旋转，通常采用四元数的形式。</p>
<p><strong>4、四元数</strong></p>
<p>四元数像是轴角表示法的优化版本，但解决了所有轴角可能存在的问题，最大的优势就是便于插值，并且存储时只需要存储4个浮点数，而且求逆、串联等操作比矩阵更方便，相比于轴角和矩阵优势巨大。</p>
<p>对于四元数的理解，可以看作是有一个实部和三个虚部构成的虚数，描述的是四维空间，具体可以看<a href="https://zhuanlan.zhihu.com/p/53872740">可视化理解四元数</a>。</p>
<hr>
<h4 id="二、四元数"><a href="#二、四元数" class="headerlink" title="二、四元数"></a>二、四元数</h4><p>四元数的全部公式和运算法则以及与矩阵等形式的转化，可以查看<a href="https://zhuanlan.zhihu.com/p/97186723">四元数(Quaternions)</a>，这里对常用的关键公式进行总结。</p>
<p>四元数表示为$(x,y,z,w)$，其中<br>$$<br>x&#x3D;i·q_1·sin(\theta&#x2F;2) \<br>y&#x3D;j·q_2·sin(\theta&#x2F;2) \<br>z&#x3D;k·q_3·sin(\theta&#x2F;2) \<br>w&#x3D;cos(\theta&#x2F;2)<br>$$<br>其中$(iq_1,jq_2,kq_3)$是表示旋转轴的矢量，$\theta$表示绕此轴旋转的角度。对四元数$q_2$左乘一个四元数$q_1$，其作用是将$q_2$拉伸$q_1$的模长，再作用一个特殊的四维旋转。所以我们用<strong>单位四元数</strong>来表示三维空间中的旋转，因为单位四元数模长为1$(w^2+x^2+y^2+z^2&#x3D;1)$，而旋转时必须要保证的就是，一个向量旋转前后模长不变。</p>
<ul>
<li>乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184920885.png" alt="image-20220301184920885"></p>
<ul>
<li>标量乘法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185303072.png" alt="image-20220301185303072"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185318122.png" alt="image-20220301185318122"></p>
<ul>
<li>加法</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301184949807.png" alt="image-20220301184949807"></p>
<ul>
<li>共轭</li>
</ul>
<p>$$<br>q&#x3D;(w,x,y,z) \<br>q^*&#x3D;(w,-x,-y,-z)<br>$$</p>
<ul>
<li>模</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185026298.png" alt="image-20220301185026298"></p>
<ul>
<li>Identity</li>
</ul>
<p>$$<br>i&#x3D;(0,0,0,1)<br>$$</p>
<ul>
<li>逆</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185208658.png" alt="image-20220301185208658"></p>
<ul>
<li>单位四元数表示旋转：单位四元数模为1，因此可以表示为</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185635142.png" alt="image-20220301185635142"></p>
<p>将一个三维向量$p$写成四元数形式</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185811398.png" alt="image-20220301185811398"></p>
<p>则运算</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/image-20220301185855191.png" alt="image-20220301185855191"></p>
<p>表示向量$p$在三维空间中绕轴$u_q$旋转$2\phi$弧度。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】二叉树</title>
    <url>/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p><strong>摘要</strong></p>
<p>本文主要总结二叉树、二叉搜索树、平衡二叉树、红黑树等相关知识以及具有代表性的题目，后续将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-前序、中序、后序遍历的迭代算法"><a href="#1-前序、中序、后序遍历的迭代算法" class="headerlink" title="1 前序、中序、后序遍历的迭代算法"></a>1 前序、中序、后序遍历的迭代算法</h3><p><strong>对于前序遍历</strong>，遍历顺序为“根、左、右”，因此对于任意一个节点，直接将节点值加入结果列表并入栈，然后遍历左子树，直到节点为空，开始遍历右子树即可，前序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);	<span class="comment">//直接加入结果</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于中序遍历</strong>，遍历顺序为“左、根、右”，因此只需要将前序遍历的顺序改为，对于任意一个节点，先遍历左子树入栈，直到节点为空，取栈顶节点加入结果列表（此时栈顶节点的左节点为空，因此栈顶结点即为子树的根节点，加入结果列表），然后遍历右子树，中序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;left;	<span class="comment">//遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树为空此时栈顶结点就作为子树的根节点，加入结果列表，并出栈，然后遍历右子树</span></span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;right;		<span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于后序遍历</strong>，遍历顺序为“左、右、根”，考虑其和前序遍历顺序“根、左、右”的关系，如果前序遍历时把节点值放入结果的、列表尾部的操作改为插入列表头部，则遍历顺序变为“右、左、根”，此时只需要再将前序遍历时，先遍历左子树在遍历右子树的顺序对调，就可以将遍历顺序改为“左、右、根”，即为后序遍历了，后序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>(),root-&gt;val);	<span class="comment">//结果插到列表开头</span></span><br><span class="line">            s.<span class="built_in">push</span>(root);		<span class="comment">//入栈</span></span><br><span class="line">           	root = root-&gt;right;	<span class="comment">//先遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        root = root-&gt;left;		<span class="comment">//再遍历左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2 层序遍历"></a>2 层序遍历</h3><p>使用广度优先搜索即可</p>
<h3 id="3-构造二叉树"><a href="#3-构造二叉树" class="headerlink" title="3 构造二叉树"></a>3 构造二叉树</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-yu-zhong-xu-gou-jian-er-cha-shu-7dznd/">前序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-yu-zhong-xu-gou-jian-er-cha-shu-d-kmrr/">后序与中序构建二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/">二叉树的序列化与反序列化</a></p>
<h3 id="4-递归解决二叉树问题"><a href="#4-递归解决二叉树问题" class="headerlink" title="4 递归解决二叉树问题"></a>4 递归解决二叉树问题</h3><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">二叉树的最大深度</a></p>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum/solution/">路径总和</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-ii/">路径总和 II</a>：广搜方法值得注意，用哈希表记录每个结点的父节点，找到一条路径后从叶子节点往回找父节点就可以还原出一条路径</p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a>：双重递归</p>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/submissions/">二叉树的直径</a></p>
<h2 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h2><h3 id="1-定义与性质"><a href="#1-定义与性质" class="headerlink" title="1 定义与性质"></a>1 定义与性质</h3><p>二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性：</p>
<ul>
<li>每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。</li>
<li>每个节点中的值必须小于（或等于）存储在其右子树中的任何值。</li>
</ul>
<p>二叉搜索树的插入和删除：</p>
<ul>
<li>插入节点：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503100203815.png" alt="image-20220503100203815"></p>
<ul>
<li>删除节点：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503100239100.png" alt="image-20220503100239100"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503100300427.png" alt="image-20220503100300427"></p>
<p>总结一下二叉搜索树的性质：</p>
<ul>
<li>中序遍历可以得到递增序列</li>
<li>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</li>
<li>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</li>
</ul>
<p>可以利用二叉搜索树的性质解决许多问题。这里只给出二叉搜索树的基本操作，后面会遇到许多用到二叉搜索树的题目。</p>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpsqtv/">二叉搜索树中的搜索</a></p>
<p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-cha-ru-cao-zuo-by-le-3/">二叉搜索树中的插入</a></p>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">删除二叉搜索树中的节点</a></p>
<h3 id="2-平衡二叉搜索树"><a href="#2-平衡二叉搜索树" class="headerlink" title="2 平衡二叉搜索树"></a>2 平衡二叉搜索树</h3><p>实际使用中由于输入值不够随机，也许经过某些插入或删除操作，二叉搜索树可能会失去平衡，造成搜寻效率低落的情况。所谓二叉树平衡与否，并没有一个绝对的测量标准。 “平衡”的大致意义是：没有任何一个节点过深（深度过大）。不同的平衡条件，造就出不同的效率表现，以及不同的实现复杂度。有数种特殊结构如 AVL-tree 、RB-tree 、AA-tree，均可实现出平衡二叉搜索树，它们都比一般的（无法绝对维持平衡的）二叉搜索树复杂，因此，插入节点和删除节点的平均时间也比较长，但是它们可以避免极难应付的最坏（高度不平衡）情况，而且由于它们总是保持某种程度的平衡，所以元素的访问（搜寻）时间平均而言也就比较少。一般而言其搜寻时间可节省 25% 左右。</p>
<h3 id="3-AVL-tree"><a href="#3-AVL-tree" class="headerlink" title="3 AVL-tree"></a>3 AVL-tree</h3><p>AVL tree 是一个 “加上了额外平衡条件”的二叉搜索树。其平衡条件的建立是为了确保整棵树的深度为 O(logN)，AVL tree 要求任何节点的左右子树高度相差不超过 1。</p>
<p>当一个节点插入 AVL 树中并破坏了树的平衡时，之存在以下两种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503101339866.png" alt="image-20220503101339866"></p>
<p>其中外侧插入可以通过单旋转调整至平衡状态，内侧插入可以通过双旋转调整至平衡状态。</p>
<h4 id="3-1-单旋转"><a href="#3-1-单旋转" class="headerlink" title="3.1 单旋转"></a>3.1 单旋转</h4><p>在外侧插入状态中，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503101845780.png" alt="image-20220503101845780"></p>
<p>A 子树成长了一层，致使它比 C 子树的深度多 2，为了调整平衡状态，我们希望将 A 子树提高一层，并将 C 子树下降一层，我们可以这么想象，把 k1 向上提起，使 k2 自然下滑，并将 B 子树挂到 k2 的左侧。<br>这么做是因为，二叉搜索树的规则使我们知道， k2 &gt; k1, 所以 k2 必须成为新树中的 k1 的右子节点。二叉搜索树的规则也告诉我们， B 子树的所有节点的键值都在 k1 和 k2 之间，所以新树中的 B 子树必须落在 k2 的左侧。</p>
<p>以上所有调整操作都只需要将指针稍做搬移，就可迅速达成。完成后的新树符合 AVL-tree 的平衡条件，不需再做调整。</p>
<h4 id="3-2-双旋转"><a href="#3-2-双旋转" class="headerlink" title="3.2 双旋转"></a>3.2 双旋转</h4><p>在内侧插入状态中，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503102212390.png" alt="image-20220503102212390"></p>
<p>我们不能再以 k3 为根节点，其次，我们不能将 k3 和 k1 做一次单旋转，因为旋转之后还是不平衡，唯一的可能是以 k2 为新的根节点，这使得（根据二叉搜索树的规则） k1 必须成为 k2 的左子节点， k3 必须成为 k2 的右子节点，而这么一来也就完全决定了四个子树的位置。</p>
<p>新的树形满足 AVL-tree的平衡条件，并且，就像单旋转的情况一样，它恢复了节点插入之前的高度，因此保证不再需要任何调整。</p>
<p>而所谓双旋转是指以上操作可以通过两次单旋转完成，这为编程带来了极大的便利：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503102457468.png" alt="image-20220503102457468"></p>
<h2 id="红黑树（RB-tree）"><a href="#红黑树（RB-tree）" class="headerlink" title="红黑树（RB-tree）"></a>红黑树（RB-tree）</h2><p>RB-tree 是另一个被广泛使用的平衡二叉搜索树，也是 SGI STL 唯一实现的一种搜寻树，作为 STL 关联式容器 (associated containers) 的底部机制。STL 的关联式容器将在 STL 专题中学习。</p>
<p>所谓 RB-tree, 不仅是一个二叉搜索树，而且必须满足以下规则：</p>
<ul>
<li>每个节点不是红色就是黑色。（图中深色底纹代表黑色，浅色底纹代表红色）</li>
<li>根节点为黑色。</li>
<li>如果节点为红，其两个子节点必须为黑。（父子节点不能同时为红）</li>
<li>任一节点至 NULL （树尾端）的任何路径，所含之黑节点数必须相同。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503103014968.png" alt="image-20220503103014968"></p>
<h3 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1 插入节点"></a>1 插入节点</h3><p>现在我们为上图中的红黑树分别插入 3、8、35、75，根据二叉搜索树的规则，这 4 个新节点的落脚处如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503103404167.png" alt="image-20220503103404167"></p>
<p>可以发现，由于新增节点必为红色，不论插入哪一个节点，都会破坏 RB-tree 的规则，致使我们必须旋转树形并调整节点的颜色。</p>
<p>为了方便讨论，让我先为某些特殊节点定义一些代名，以下讨论都将沿用这些代名。假设新节点为 X，其父节点为 P，祖父节点为 G，伯父节点（父节点之兄弟节点）为 S，曾祖父节点为 GG。</p>
<p>根据二叉搜索树的规则，新节点 X 必为叶节点。根据红黑树规则 4，X 必为红。若 P 亦为红（这就违反了规则 3,  必须调整树形），则 G 必为黑（因为原为 RB-tree，必须遵循规则 3) 。于是，根据 X 的插入位置及外围节点（S 和 GG）的颜色，有了以下四种考虑：</p>
<ul>
<li><strong>S 为黑且 X 为外侧插入</strong>。对此情况，我们先对 P,G 做一次单旋转，再更改 P,G 颜色，即可重新满足红黑树的规则 3。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503103915258.png" alt="image-20220503103915258"></p>
<blockquote>
<p>注意，此时可能产生不平衡状态（高度相差 1 以上）,例如图中的 A 和 B 为 null，D 或 E 不为 null，但是没关系，因为 RB-tree 的平衡性本来就比 AVL-tree 弱。然而 RB-tree 通常能够维持良好的平衡状态。并且经验告诉我们， RB-tree 的平均搜索效率和 AVL-tree 几乎相等。</p>
</blockquote>
<ul>
<li><strong>S 为黑且 X 为内侧插入</strong>。对此情况，我们必须先对 P, X 做一次单旋转并更改 G, X 颜色，再将结果对 G 做一次单旋转，即可再次满足红黑树规则 3 。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503104705424.png" alt="image-20220503104705424"></p>
<ul>
<li><strong>S 为红且 X 为外侧插入</strong>。对此情况，先对 P 和 G 做一次单旋转，并改变 X 的颜色。此时如果 GG 为黑，一切搞定。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503104837530.png" alt="image-20220503104837530"></p>
<ul>
<li><strong>S 为红且 X 为外侧插入</strong>。对此情况，先对 P 和 G 做一次单旋转，并改变 X 的颜色。此时如果 GG 亦为红，还得持续往上做，直到不再有父子连续为红的情况。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503105019331.png" alt="image-20220503105019331"></p>
<p>在最后一种情况下， 父子节点皆为红色的情况会持续向RB-tree 的上层结构发展，形成处理时效上的瓶颈，于是我们可以施行一个由上而下的程序：假设新增节点为 A，那么就延着 A 的路径，只要看到有某节点 X 的两个子节点皆为红色，就把 X 改为红色，并把两个子节点改为黑色，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503105340003.png" alt="image-20220503105340003"></p>
<p>此时如果 A 的父节点 P 也为红色（注意，此时 S 绝不可能为红），就得像第一种情况一样做一次单旋转并改变颜色，或是像第二种情况一样做一次双旋转并改变颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220503105447823.png" alt="image-20220503105447823"></p>
<h3 id="2-对比-BST-和-AVL"><a href="#2-对比-BST-和-AVL" class="headerlink" title="2 对比 BST 和 AVL"></a>2 对比 BST 和 AVL</h3><p>红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(logN)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。</p>
<p>相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 O(logN) 的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到 O(N)。</p>
<p>红黑树的算法时间复杂度和 AVL 相同，但统计性能比 AVL 树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是 O(logN)，所以红黑树应用还是高于 AVL 树的。实际上插入 AVL 树和红黑树的速度取决于你所插入的数据。如果你的数据分布较好，则比较宜于采用 AVL树（例如随机产生系列数），但是如果你想处理比较杂乱的情况，则红黑树是比较快的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性数据结构</title>
    <url>/LycTechStack.github.io/2022/03/02/20220303-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote>
<p><strong>摘要</strong></p>
<p>对LeetCode上各种线性数据结构相关的题目做了一个分类整理，主要内容来源于LeetCode官方学习内容，这里只是一个记录和梳理，后序将持续更新。</p>
</blockquote>
<p><em><span id="more"></span></em></p>
<h4 id="1、数组和字符串"><a href="#1、数组和字符串" class="headerlink" title="1、数组和字符串"></a>1、<a href="https://leetcode-cn.com/leetbook/detail/array-and-string/">数组和字符串</a></h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>一般用于给定的数组是有序的，或先手动排序</p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/">搜索插入位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/">寻找旋转排序数组中的最小值</a></p>
<h5 id="首尾双指针"><a href="#首尾双指针" class="headerlink" title="首尾双指针"></a>首尾双指针</h5><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/">两数之和 II - 输入有序数组</a></p>
<h5 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h5><p><a href="https://leetcode-cn.com/problems/remove-element/solution/">移除元素</a><br><a href="https://leetcode-cn.com/problems/max-consecutive-ones/solution/">最大连续 1 的个数</a><br><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/">长度最小的子数组</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/">删除有序数组中的重复项</a><br><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/solution/">子数组最大平均数</a><br><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/solution/">可获得的最大点数</a><br><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/solution/">爱生气的书店老板</a><br><a href="https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/">定长子串中元音的最大数目</a><br><a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/submissions/">将 x 减到 0 的最小操作数</a><br><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-you-hua-jie-fa-by-bu-1i5e/">最小覆盖子串</a></p>
<h5 id="字符串匹配KMP算法"><a href="#字符串匹配KMP算法" class="headerlink" title="字符串匹配KMP算法"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/">字符串匹配KMP算法</a></h5><p>关键在于构建next数组的方法</p>
<h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><a href="https://leetcode-cn.com/leetbook/read/array-and-string/y1nke/">二维数组</a></h5><p>一般就是矩阵问题，矩阵问题后面在动态规划和其他算法问题中也会经常遇到。</p>
<p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">旋转矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">零矩阵</a></p>
<p><a href="https://leetcode-cn.com/problems/diagonal-traverse/">对角线遍历</a></p>
<h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、<a href="https://leetcode-cn.com/leetbook/detail/linked-list/">链表</a></h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>链表的很多问题都可以用递归，典型问题比如：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/">两两交换链表中的节点</a></p>
<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/">环形链表II</a><br><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/">相交链表</a></p>
<h5 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h5><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a><br><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">回文链表</a></p>
<blockquote>
<p><strong>一般处理链表问题时在原链表前加一个虚节点就可以避免对头节点的特殊判断</strong></p>
</blockquote>
<h4 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h4><h5 id="广搜BFS"><a href="#广搜BFS" class="headerlink" title="广搜BFS"></a><a href="https://leetcode-cn.com/leetbook/read/queue-stack/kc5ge/">广搜BFS</a></h5><p>广度优先搜索一般用来二叉树的层序遍历、求最短路径、最小数量之类的题目。<br><a href="https://leetcode-cn.com/problems/walls-and-gates/">墙与门</a><br><a href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a><br><a href="https://leetcode-cn.com/problems/open-the-lock/">打开转盘锁</a><br><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/">最小跳跃次数</a></p>
<ul>
<li>广度优先搜索模板：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    unordered_set&lt;节点或状态&gt; map;	<span class="comment">//可选，看是否需要重复入队</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(根节点或状态);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)	<span class="comment">//遍历当前层所有节点并扩展相邻节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            节点或状态 cur = q.<span class="built_in">front</span>();	<span class="comment">//取队列头节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur == 目标节点或状态)	<span class="keyword">return</span> step;</span><br><span class="line">            <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">                q.<span class="built_in">push</span>(x);</span><br><span class="line">                map.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h4><h5 id="深搜DFS"><a href="#深搜DFS" class="headerlink" title="深搜DFS"></a>深搜DFS</h5><p>一般能用广搜的也能用深搜，但是深搜不能保证是最短路径或者最小数量，深搜还用于二叉树的前中后序遍历。<br><a href="https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-shen-sou-he-yan-sou-nn8j/">钥匙和房间</a><br><a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-dfshe-bfs-by-bu-luo-bu-2tg4/">图像渲染</a><br>以及上面可以用BFS做的题</p>
<ul>
<li>DFS模板（非递归，类似于上面的BFS）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    unordered_set&lt;节点&gt; visited;	<span class="comment">//可选，看是否需要重复入栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    visited.<span class="built_in">insert</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        节点 cur = q.<span class="built_in">top</span>();	<span class="comment">//取栈顶节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(节点 x : cur的所有相邻节点)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">            visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS模板（递归）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(节点 root，节点 target, unordered_set&lt;节点&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(节点 x : root的所有相邻节点)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">count</span>(x)) <span class="keyword">continue</span>;	<span class="comment">//判断是否已经访问过，可选</span></span><br><span class="line">        visited.<span class="built_in">insert</span>(x);	<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">DFS</span>(x,target,visited)) <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>单调栈也是一种重要的数据结构，在实际解题中经常用到，简单来说单调栈内的元素保证是严格单调递增或递减的，如果一个新的元素和栈顶元素不满足这种单调关系，就将栈顶元素出栈并进行一定的操作，直到满足单调关系，将新元素入栈。</p>
<p>之前的题目中也遇到过一些比较简单的单调栈问题，这里以两道困难题目加深对单调栈的理解。</p>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p>
<p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></p>
<p>但这两道题较为困难，能够加深对单调栈的理解。柱状图中的最大矩形的思路简单来说就是遍历每一根柱子，分别找到其左边和右边离它最近的高度低于它的柱子作为左右边界，在这两个边界范围内的所有柱子的高度都高于当前柱子，因此所形成的矩形面积就是当前柱子高度乘以边界长度。寻找柱子边界的过程就是利用单调栈实现的，并且优化过后只需要遍历一次就可以找到左边界和右边界。关于单调栈的思路如何得到以及优化具体细节可以查看<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">柱状图中最大的矩形 官方题解</a>。</p>
<p>最大矩形是一道更为困难的题目，但是如果理解了柱状图问题，再看最大矩形就不是很困难了。因为我们可以对矩阵每一行的每一个位置都求出这个位置上方连续的1的个数（包含这个位置本身），这样每一行都形成了一个柱状图，再按照柱状图的解法计算最大矩形面积即可，遍历完矩阵所有行也就得到了全局最大矩形。更多细节在代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">height</span><span class="params">(n, <span class="number">0</span>)</span></span>;     <span class="comment">//记录每一行每个位置上方连续的1的个数（包含本身）</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;	<span class="comment">//每一行遍历开始都要重置right数组的初始值为n</span></span><br><span class="line">            <span class="comment">//计算每个格子上方连续1的个数，形成柱状图</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    height[j] = matrix[i][j] == <span class="string">&#x27;1&#x27;</span> ? height[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算直到当前行的柱状图最大矩形</span></span><br><span class="line">            stack&lt;<span class="type">int</span>&gt; mono;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!mono.<span class="built_in">empty</span>() &amp;&amp; height[mono.<span class="built_in">top</span>()] &gt;= height[j])	<span class="comment">//注意更新右边界的判断条件是&#x27;&gt;=&#x27;</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[mono.<span class="built_in">top</span>()] = j;</span><br><span class="line">                    mono.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = mono.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono.<span class="built_in">top</span>();</span><br><span class="line">                mono.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, height[j] * (right[j] - left[j] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（三）光栅化</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<h3 id="光栅化（Rasteriztion）"><a href="#光栅化（Rasteriztion）" class="headerlink" title="光栅化（Rasteriztion）"></a>光栅化（Rasteriztion）</h3><p>首先回顾一下MVP变换的过程（之前的文章中没有提到坐标系的概念，这里回顾的时候顺便提一下图形学中的各个坐标系的转换，其实就是之前的各种变换）：</p>
<ul>
<li>为了得到从某一个视角看到的物体的样子，我们首先要对相机和物体进行相机变换（View &#x2F; Camera Transformation），将相机的三个方向轴与世界坐标系对齐，并移到坐标原点（这一步是将相机坐标系转换到世界坐标系，或者反着说，将世界坐标系转到相机坐标系，因为相机就是我们的眼睛，是观察物体的坐标系）</li>
<li>然后对物体做同样的变换以使得相机和物体不发生相对运动</li>
<li>最后进行投影变换，无论是正交投影还是透视投影，最终物体都被投影到一个单位立方体中（这个过程是从相机坐标系到透视坐标系的过程）</li>
</ul>
<p>接下来的问题就是如何将这个投影绘制在屏幕上，形成图形，这个过程就是<strong>光栅化</strong>的过程。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-屏幕的定义"><a href="#1-屏幕的定义" class="headerlink" title="1 屏幕的定义"></a>1 屏幕的定义</h4><p>屏幕可以看作是一个二维矩阵，矩阵中的每一个元素存储的是像素值，屏幕显示图形的过程，就是遍历整个数组，显示对应像素值的过程。这个二维数组的大小也就是常说的分辨率。</p>
<p>为了简化后面的推导，这里我们把每一个像素简单的抽象成为一个方格，并且这个方格中的颜色是一致的，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306172222268.png" alt="image-20220306172222268"></p>
<p>蓝色像素的坐标是 (2, 1) ，这个像素的中心点的坐标是 (2.5, 1.5) ，也就是像素 (x, y) 的中心点坐标是 (x+0.5, y+0.5) .</p>
<p>这里的屏幕坐标系原点定义在了左下角，通常计算机中屏幕原点在左上角，这个定义不影响后面的推导。</p>
<h4 id="2-视口变换"><a href="#2-视口变换" class="headerlink" title="2 视口变换"></a>2 视口变换</h4><p>有了屏幕的定义，我们想要把投影后的立方体显示在屏幕上，接下来要做的一步叫做<strong>视口变换</strong>，也就是将立方体转换到屏幕空间中，只有先转换到屏幕空间中，才能进一步计算屏幕空间中的点（像素）都应该是什么颜色。</p>
<p>这是一个3D空间到2D空间的转换，因此我们先考虑简化的情况，也就是不考虑Z方向，即不考虑3D空间中的远近、遮挡等关系，先只将XY平面转换到屏幕平面上，这个过程很简单，只要将立方体的XY平面映射到和屏幕一样的比例就可以。也就是把 [-1, 1] 映射到 [0, width] 和 [0, height]上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306173109581.png" alt="image-20220306173109581"></p>
<p>同时还要进行平移，因为透视坐标系中原点是在 (0,0) 的位置，我们当然希望这个原点在屏幕的中央，而屏幕的左下角是原点，所以需要把透视坐标原点平移(width&#x2F;2, height&#x2F;2).</p>
<p>这样就完成了从透视坐标系到屏幕坐标系的转换。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>在介绍光栅化之前，有必要再次重申一下我们现在在干嘛。</p>
<p>我们的目标是把一个三维的物体显示在二维的屏幕上，那么我们首先做的就是坐标转换，之前的所有变换都是在做坐标转换，直到视口变换，我们终于完成了从三维坐标到二维坐标的映射；下一步就是计算三维物体顶点的颜色，我们得知道这个三维物体每个部分原来是什么颜色，才能把它显示在二维屏幕上，这个过程会通过UV贴图的颜色，结合光照，透明度等等，计算出模型每个顶点的具体颜色（R, G, B），这里我们先不管；最后就是在二维平面上绘制，所谓绘制也就是把这个二维平面填上颜色，前面说了，屏幕就是存储像素值的二维数组，所以绘制也就是计算每一个像素的颜色，然后屏幕根据这个数组就能显示出三维场景了。</p>
<p>OK，光栅化就是在屏幕上填充颜色的过程，但是根据什么来填颜色呢，就根据之前计算出来的三维物体上的顶点颜色来填。我们每次从三维物体上取三个点，映射到二维空间，形成一个三角形，这个三角形的颜色取决于三个顶点的颜色，具体有几种取法：</p>
<ul>
<li>三个顶点颜色取平均值</li>
<li>取某一个顶点的颜色</li>
<li>三个顶点颜色渐变</li>
</ul>
<p>使用哪种取法可以根据实际需求来定，不是我们目前讨论的关键。</p>
<blockquote>
<p><strong>为什么是三角形？</strong></p>
<p>因为三角形是最最基本的几何图形，任何多边形都可以拆分成若干三角形，并且三角形有许多优秀的性质，比如对于图形的内外有严格的定义，再比如很好进行插值运算，上面三角形颜色取三个顶点颜色的渐变就是三角形优势的体现之一。</p>
</blockquote>
<p>有了这个三角形之后，我们要做的事情就很简单了，判断每一个像素是否在这个三角形内部，如果在内部，就填上三角形的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180614301.png" alt="image-20220306180614301"></p>
<p>这个过程其实是一个<strong>采样</strong>的过程，采样这个概念非常重要，简单而不严谨的来说就是定义一个函数，计算每个采样点在这个函数上的值就是采样。这里的函数就是判断一个点 (x, y) 是否在给定的三角形内部，那么如何实现这个函数的功能呢？</p>
<p>最简单的方法就是<strong>向量叉乘</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306180926083.png" alt="image-20220306180926083"></p>
<p>对于点 P，计算向量$\vec{AB}$与向量$\vec{AP}$的叉乘，得到的方向朝向屏幕外，这意味着点 P 在 AB 的左边，同理计算向量$\vec{BC}$与向量$\vec{BP}$的叉乘，得到的向量方向也是朝向屏幕外，这意味着点 P 在 BC 的左边，同样计算向量$\vec{CA}$与向量$\vec{CP}$的叉乘，得到的向量方向还是朝向屏幕外，这意味着点 P 在 CA 的左边，于是我们可以判定点 P 在三角形 ABC 的内部。</p>
<p>如果三个叉乘得到的某一个向量方向朝屏幕内，就说明点 P 在某一条边的右侧，那么点 P 一定在三角形ABC外部。这里给出C++版本代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个方法就可以判断任意一个点是否在三角形内部了，当然还可以算出三条边的方程，带入 P 点坐标得到三个值，判断同号异号，本质上和向量叉乘是一样的。</p>
<blockquote>
<p>如果一个点在三角形边缘怎么算？</p>
<p>这个可以根据需求自己规定，而且几乎所有的图形API，比如OpenGL、DirectX都对这种情况有明确的规定，无需担心。</p>
</blockquote>
<p>到此我们其实就完成了光栅化的过程。总结一下：</p>
<ul>
<li>取三个点构成三角形并计算三角形颜色</li>
<li>判断屏幕上每一个像素是否在三角形内部，在则上色</li>
</ul>
<p>这个过程很简单，但存在许多问题，比如按照上面的流程，我们的代码应该这样写：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182055653.png" alt="image-20220306182055653"></p>
<p>显然十分暴力，对于下大多数情况来说，我们完全不必遍历所有像素点，使用一个Bounding Box就可以大幅降低时间复杂度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182158250.png" alt="image-20220306182158250"></p>
<p>但这还不够，如果三角形非常细长，而且还刚好倾斜45°左右，那么实际上它也只占整个Bounding Box很少一部分，于是我们可以进一步改进：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182343897.png" alt="image-20220306182343897"></p>
<p>先算出每一行的起点坐标，逐行扫描，遇到不在三角形内部的点就开始扫描下一行。</p>
<p>现在我们来看一下光栅化之后的结果是什么样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182649751.png" alt="image-20220306182649751"></p>
<p>而我们想得到的样子却是这样：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/image-20220306182717888.png" alt="image-20220306182717888"></p>
<p>不能说毫无关系，但确实不是一个东西，这是因为我们现在得到的光栅化结果有太多的<strong>锯齿</strong>了，更专业一点的说法就是我们的光栅化过程使得图形<strong>走样（Aliasing）</strong>了，因此我们必须对光栅化的过程进行<strong>抗锯齿</strong>，更准确的说法叫做<strong>反走样</strong>。关于反走样将在下一篇文章中进行详细介绍。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（四）反走样</title>
    <url>/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<h3 id="反走样（Antialiasing）"><a href="#反走样（Antialiasing）" class="headerlink" title="反走样（Antialiasing）"></a>反走样（Antialiasing）</h3><p>上一篇文章说到，光栅化的采样过程导致了图形走样，这一篇来讲如何反走样。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是走样？"><a href="#1-什么是走样？" class="headerlink" title="1 什么是走样？"></a>1 什么是走样？</h4><p>要解决问题，就要先了问题。</p>
<p>走样有很多种形式，比如上文中的<strong>锯齿</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191713343-16465731903111.png" alt="image-20220306191713343"></p>
<p>还有我们日常生活中经常遇到的<strong>摩尔纹</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306191741271-16465731903114.png" alt="image-20220306191741271"></p>
<p>甚至一些视觉假象，比如一个顺时针旋转的轮子，当他的速度很快时，我们可能看到它是逆时针旋转的。</p>
<p>以上都属于走样，而产生这些走样的原因都一样，那就是<strong>采样速度跟不上信号变化的速度</strong>。</p>
<p>要理解这句话可不容易，接下来我们慢慢来看。</p>
<h4 id="2-产生走样的原因"><a href="#2-产生走样的原因" class="headerlink" title="2 产生走样的原因"></a>2 产生走样的原因</h4><p>上面说了，走样产生的原因就是采样速度跟不上信号变化的速度，更细致一点来说就是，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠。</strong></p>
<p>关于<strong>频域</strong>，是信号处理中的重要概念，简单来说就是只存在正弦波的一个世界，也就是只能用 sin 和 cos 函数，而我们日常描述一个信号（函数）是在时域中描述的，这个函数可以是任何形状，那么频域存在的意义是什么呢。</p>
<p>频域存在的意义就是任何一个函数都可以分解为多个正弦波函数和常数的组合，也就是<strong>傅里叶变换</strong>。有了这个伟大的变换，我们就可以把在时域中不好解释、不好研究的问题，放到频域中去研究。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193355754-16465731903113.png" alt="image-20220306193355754"></p>
<p>时域中的信号通过傅里叶变换，可以变为频域中的信号，同样，频域中的信号通过傅里叶逆变换，可以变为时域中的信号。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193545813-16465731903112.png" alt="image-20220306193545813"></p>
<p>了解了频域，再来回顾一下上篇文章提到的<strong>采样</strong>，采样就是计算函数在采样点上的值，我们光栅化的过程其实就是采样的过程，在信号中，采样其实也就是在整个信号的波形上选一些点拿出来，比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306193918481-16465731903115.png" alt="image-20220306193918481"></p>
<p>垂直的虚线就代表一次采样，和不同的波形的交点，就是采样出来的点，然后我们连接这些点，会发现在同样的采样频率下，对频率不同的信号进行采样得到的效果天差地别，例如最上面的信号$f_1(x)$，频率比较小，那我们连接采样点后的折线就和原来的信号非常接近，但是越往下信号频率越大，我们用同样的频率采样得到的折线，就和原来的信号差别越大，$f_4(x)$和$f_5(x)$的折线已经和原信号完全不同了。</p>
<p>再进一步说，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306194603851-16465731903126.png" alt="image-20220306194603851"></p>
<p>对频率相差很大的两个信号进行同频率采样，我们得到的折线是完全一样的，那我们就无法分辨原来的信号长什么样，尤其如果一个信号是高频信号，如果我们用低频采样，就会得到和原来信号完全不同的结果，这就是<strong>走样</strong>产生的原因，现在回过头来看开头说的，<strong>走样产生的原因就是采样速度跟不上信号变化的速度</strong>，是不是就完全理解了。但是这还不够，我们继续。</p>
<p>开头说的另一句话，<strong>采样频率小于信号频率，导致采样后信号在频域发生了交错、重叠</strong>，这又是什么意思呢。</p>
<p>刚才对于采样的分析，完全是在时域下分析的，那么采样在频域的表现是什么样的呢？</p>
<p>采样在频域表现为<strong>信号的重复</strong>。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195205688-16465731903127.png" alt="image-20220306195205688"></p>
<p>左边一列是时域信号，右边是它对应的频域信号。图（a）是时域中的一个信号，图（b）是它在频域中的样子，图（c）是采样信号，也叫做冲击信号，图（d）是冲击信号在频域中的样子，图（e）就是用冲击信号对原信号进行采样的过程，冲击的点就取原信号对应的值，图（f）就是这个采样过程在频域中得到的结果，可以看到，每采样一个点，都相当于复制了原信号在频域中的内容，所以采样在频域中表现为信号的重复。</p>
<p><strong>而且采样越密集，在频域中信号间隔越大</strong>，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>上面的图是使用密集采样得到的结果，采样越密集，频域中间隔越大，所以信号没有发生重叠交错，下面的图是稀疏采样，采样越稀疏，频域间隔越小，也就发生了重叠交错，自然也就产生了<strong>走样</strong>。</p>
<p>到这里，我们差不多搞明白了产生走样的原因，现在回到光栅化上面来，光栅化的过程就是采样的过程，因为我们的像素点相对于三角形来说没有那么密集，所以相当于进行了稀疏采样，也就产生了走样，那么如何来进行反走样呢？</p>
<p>根据上面的理论，只要我们不进行稀疏采样，使采样尽量密集就可以了。</p>
<h4 id="3-滤波"><a href="#3-滤波" class="headerlink" title="3 滤波"></a>3 滤波</h4><p>在讨论反走样之前还要了解一个概念，<strong>滤波</strong>，滤波在数字图像处理和信号处理中都很重要，图像也可以抽象为信号，所以本质都是一样的，那么滤波的意义也就是一样的，对于信号来说，<strong>滤波的作用就是去掉信号中特定频率的内容</strong>。</p>
<p>比如一张图片和它在频域中的图像：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306200708255-16465731903129.png" alt="image-20220306200708255"></p>
<p>要说明的是，时域到频域的转换，默认信号是周期性的，对于图片来说，就是把一张图片水平和垂直重复的拼在一起，不停的重复这张图片，然后就可以转换到频域中。频域图中越靠近中心的越低频，越发散的越高频。所谓高频，就是指图像中像素变化剧烈的部分，比如边缘。所以频域图中有一个很明显的“十”字的形状，就是图片重复拼接的时候产生的边缘高频信号，其他高频信号就是图像中的边缘。可以看到图片中大部分都集中在低频。</p>
<p>现在我们对图片进行一个边缘提取：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201235273-164657319031210.png" alt="image-20220306201235273"></p>
<p>此时图片只剩下了边缘，对应的频域图中低频信号全部被滤掉了，只剩下了高频信号，这种滤波也就是所谓的<strong>高通滤波</strong>，只允许高频信号通过。</p>
<p>如果我们对图片的边缘进行平滑处理，也就是给图片加模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201404735-164657319031211.png" alt="image-20220306201404735"></p>
<p>显然，高频信号都被滤掉了，模糊是<strong>低通滤波</strong>。</p>
<p>如果我们想要某一特定频率的信号，那就可以进行特定的滤波：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201511142-164657319031212.png" alt="image-20220306201511142"></p>
<p>这样就得到了图像在某一特定频率下的特征。</p>
<p>搞清了滤波的作用，滤波的过程实际上就是<strong>卷积</strong>的过程，无论信号还是图像，滤波就是卷积，关于图像卷积就不赘述了。</p>
<p>但还是要特别说明两个重要的性质：</p>
<ul>
<li>时域中的卷积，相当于频域中的乘积，时域中的乘积相当于频域中的卷积。这是一个非常神奇的性质，利用这个性质，我们对图像卷积时，可以把图像和卷积核转到频域进行乘积，得到的结果再转回时域，就得到卷积后的图片了。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306201946817-164657319031213.png" alt="image-20220306201946817"></p>
<ul>
<li>卷积核越大，频率越低，所以我们用越大的模糊核去模糊一张图片时，模糊效果越严重，图片剩下的信号频率越低</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202316849-164657319031214.png" alt="image-20220306202316849"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202325681-164657319031215.png" alt="image-20220306202325681"></p>
<h4 id="4-反走样原理"><a href="#4-反走样原理" class="headerlink" title="4 反走样原理"></a>4 反走样原理</h4><p>有了滤波，我们再回顾刚才产生走样的原因：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306195811399-16465731903128.png" alt="image-20220306195811399"></p>
<p>发生重叠的部分正是信号的高频部分，那我们通过滤波，把高频部分滤掉，再进行采样，就不会重叠了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202657939-164657319031216.png" alt="image-20220306202657939"></p>
<p>对应到图像上，模糊就是低通滤波，所以我们先对图形模糊，再进行采样，这样的光栅化就可以避免走样，这就是<strong>反走样</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202815314-164657319031217.png" alt="image-20220306202815314"></p>
<p>试试效果，这是没有反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306202929823-164657319031218.png" alt="image-20220306202929823"></p>
<p>这是反走样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203002692-164657319031219.png" alt="image-20220306203002692"></p>
<p>锯齿有了明显改善，更明显的对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203030537-164657319031220.png" alt="image-20220306203030537"></p>
<p>那么我们怎么进行模糊呢，反走样具体要如何实现？</p>
<p>我们对每一个像素，进行一个1像素的滤波，所谓1像素的滤波是指，每个像素的像素值等于三角形在像素内覆盖的加权平均值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306203643492-164657319031221.png" alt="image-20220306203643492"></p>
<p>但这个滤波对于计算机是很难实现的，我们无法准确的判断三角形覆盖了这个像素百分之多少的位置，因此就出现了各种近似的方法，这些方法基本达到了我们理想中反走样的目的。</p>
<h4 id="5-反走样方法"><a href="#5-反走样方法" class="headerlink" title="5 反走样方法"></a>5 反走样方法</h4><p>根据上面的理论分析，产生走样是因为我们的像素不够密集，那只要像素足够密集，进行足够密集的采样，走样就可以得到缓解，所以屏幕分辨率越高，显示越清晰。当然，不停提升屏幕分辨率是不现实的，因此需要进行软件反走样，游戏领域中，反走样（AA）最具代表性、应用最广泛的方法有以下几种。</p>
<h5 id="5-1-多重采样反走样-MSAA"><a href="#5-1-多重采样反走样-MSAA" class="headerlink" title="5.1 多重采样反走样-MSAA"></a>5.1 多重采样反走样-MSAA</h5><p>MSAA把一个像素分为多个亚像素，然后根据亚像素有多少在三角形内部，对这个像素的像素值做相应比例的改变。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204044700-164657319031222.png" alt="image-20220306204044700"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204102154-164657319031223.png" alt="image-20220306204102154"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204111526-164657319031224.png" alt="image-20220306204111526"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220306204121336-164657319031225.png" alt="image-20220306204121336"></p>
<p>这里给出最简单的MSAA的C++版本代码，在上一节的判断每个像素是否在三角形内部的函数的基础上稍作修改即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x), <span class="type">float</span>(y), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">MSAA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> count = <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.25</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.25</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    count += <span class="built_in">insideTriangle</span>(x + <span class="number">0.75</span>, y + <span class="number">0.75</span>, _v) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(count / <span class="number">4.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看效果，左边是没使用反走样生成的图形，右边是MSAA的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/image-20220308210015557.png" alt="image-20220308210015557"></p>
<p>优点：</p>
<ul>
<li>对几何反走样效果良好</li>
<li>不支持延迟渲染（关于延迟渲染之后会详细说）</li>
<li>画面更清晰</li>
</ul>
<p>缺点：</p>
<ul>
<li>像素的亮度与覆盖区域的面积成正比，而与覆盖区域落在像素内的位置无关，这仍会导致锯齿效应；</li>
<li>只能消除几何走样，无法解决高光区域的着色走样</li>
<li>静态画面表现良好，时域上不稳定</li>
</ul>
<h5 id="5-2-时域反走样-Temporal-AA"><a href="#5-2-时域反走样-Temporal-AA" class="headerlink" title="5.2 时域反走样-Temporal AA"></a>5.2 时域反走样-Temporal AA</h5><p>Temporal AA严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p>
<p>简单来说，Temporal AA是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p>
<p>具体的原理可以查看<a href="https://zhuanlan.zhihu.com/p/57503885">TAA 反走样算法研究 | 时域超采样技术</a>。</p>
<p>优点：</p>
<ul>
<li>效果好，开销小</li>
<li>时域稳定性强</li>
<li>支持延迟渲染</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着历史颜色的累积，会导致不可绝对消除的模糊（运动模糊），尤其在移动过快的镜头或物体情况下，会导致重影现象</li>
<li>需要额外内存开销，保存历史信息</li>
<li>不能应对半透明物体</li>
</ul>
<h5 id="5-3-快速近似反走样-FXAA"><a href="#5-3-快速近似反走样-FXAA" class="headerlink" title="5.3 快速近似反走样-FXAA"></a>5.3 快速近似反走样-FXAA</h5><p>最简单的、高效率的抗锯齿方式，对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p>
<p>优点：</p>
<ul>
<li>性能开销极小</li>
</ul>
<p>缺点：</p>
<ul>
<li>画面会更模糊</li>
<li>对像绒毛一类的复杂物体效果不好</li>
</ul>
<h5 id="5-4-深度学习超采样-DLSS"><a href="#5-4-深度学习超采样-DLSS" class="headerlink" title="5.4 深度学习超采样-DLSS"></a>5.4 深度学习超采样-DLSS</h5><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p>
<p>优点：</p>
<ul>
<li>DLSS能同时在几何、着色、时域上进行反走样</li>
<li>深度学习解决了TAA种画面模糊、透明、遮挡、残影等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能开销高，仅仅反走样就占用了画面 20% 的渲染时长</li>
</ul>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（一）线性动态规划之单串问题</title>
    <url>/LycTechStack.github.io/2022/03/07/20220307-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p>
<p>大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<p>按照问题的输入格式，<strong>线性动态规划解决的问题主要是单串，双串，矩阵上的问题</strong>，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小，因此从前往后推位置就相当于从小到大推问题规模。</p>
<p><em><span id="more"></span></em></p>
<h3 id="单串问题"><a href="#单串问题" class="headerlink" title="单串问题"></a>单串问题</h3><p>单串 <code>dp[i]</code> 是线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]上，原问题的解</code>，其中<code>考虑[0..i]上，原问题的解</code>又可以分为两大类，即我们要考虑[0..i]上所有子问题的解（考虑O(n)个子问题的解），还是只考虑考虑[0..i]上常数个子问题的解（考虑O(1)个子问题的解），一般只考虑常数个子问题的解就是考虑 dp[i-1] 或（和）dp[i-2]。单串问题基本上可以分为以下几大类。</p>
<h4 id="1-最长递增子序列（LIS问题）"><a href="#1-最长递增子序列（LIS问题）" class="headerlink" title="1 最长递增子序列（LIS问题）"></a>1 最长递增子序列（LIS问题）</h4><p>这是最经典的线性动态规划问题，也是最能体现线性动态规划思想的问题之一。</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7] </code>是数组 <code>[0,3,1,6,2,2,7] </code>的子序列。</p>
</blockquote>
<p>我们用$f(i)$表示以nums[i]结尾的子数组的LIS长度，因为子序列需要上升，因此以 nums[i] 结尾的子序列中，nums[i] 之前的数字一定要比 nums[i] 小才行，因此目标就是先找到以此前比 nums[i] 小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比 nums[i] 小的数字，则当前问题的结果就是 1 。于是可以写出状态转移方程：<br>$$<br>f(i)&#x3D;\left{<br>\begin{aligned}<br>max(f(i),f(j))+1 &amp; , &amp; nums[i]&gt;nums[j], \<br>1 &amp; , &amp; nums[i]&lt;&#x3D;nums[j].<br>\end{aligned}<br>\right.<br>$$<br>其中$j &lt; i$，显然求解$f(i)$需要遍历所有$f(j)$，因此我们要考虑 O(n) 个子问题的解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>LIS问题及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数</a>：除了维护记录长度的dp数组外，还要维护一个记录子序列个数的cnt数组</li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">最大整除子集</a>：动态规划过程类似于最长上升子序列，难点在于还原出子集的所有元素</li>
</ul>
<h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2 最大子数组和"></a>2 最大子数组和</h4><p>另一个经典单串问题</p>
<blockquote>
<p>问题描述：</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>同样的思路，我们用 dp[i] 表示以nums[i]结尾的最大子数组和，因为状态的推导是按照 i 从 0 到 n - 1 按顺序推的，推到 dp[i]，时，dp[i - 1], …, dp[0] 已经计算完。因为子数组是连续的，所以子问题 dp[i] 其实只与子问题 dp[i - 1] 有关。如果 [0..i-1] 上以 nums[i-1] 结尾的最大子数组和(缓存在 dp[i-1] )为非负数，则以 nums[i] 结尾的最大子数组和就在 dp[i-1] 的基础上加上 nums[i] 就是 dp[i] 的结果否则以 i 结尾的子数组就不要 i-1 及之前的数，因为选了的话子数组的和只会更小。因此可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = nums[i] + max(dp[i - 1], 0)</span><br></pre></td></tr></table></figure>

<p>显然这个问题中，我们只要考虑O(1)个子问题的解，因此也没有必要维护 dp 数组了，运用滚动数组的思想，只要记录下来 dp[i-1] 就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fi = <span class="built_in">max</span>(fi + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,fi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>最大子数组和及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/solution/huan-xing-shu-zu-zui-da-he-by-bu-luo-bu-7bqj/">环形数组最大和</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-bu-luo-bu-xvsx/">乘积最大子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/solution/">最大子矩阵</a>：二维转换为一维的典型题目</li>
<li><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a>：上一题的进阶版</li>
</ul>
<h4 id="3-打家劫舍问题"><a href="#3-打家劫舍问题" class="headerlink" title="3 打家劫舍问题"></a>3 打家劫舍问题</h4><p>打家劫舍类似于最大子数组和，但这里的子数组不能连续，也就是不相邻子序列的最大和问题。</p>
<blockquote>
<p>问题描述：</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，<strong>影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统</strong>，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>问题的关键在于我们如果偷了第 i 个房间，那么就不能偷第 i-1 个房间，所以 dp[i] 表示到第 i 个房间为止的最大金额，这个最大金额的取值有两种情况，如果我们不偷第 i 个房间，那么 dp[i] &#x3D; dp[i-1]；如果我们偷第 i 个房间， 那么 dp[i] &#x3D; dp[i-2] + num[i]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp1 = nums[<span class="number">0</span>];              <span class="comment">//屋子能偷盗的最大金额</span></span><br><span class="line">        <span class="type">int</span> dp2 = <span class="built_in">max</span>(dp1,nums[<span class="number">1</span>]);     <span class="comment">//前一间屋子能偷到的最大金额</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(dp1, dp2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(dp1 + nums[i], dp2);</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">            dp2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打家劫舍及其变体问题：</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a>：数组变成了环形，也就是偷了第1个房间就不能偷最后一个房间，在区间 [0, nums.size()-1] 和 [1, nums.size()] 上应用两次打家劫舍的算法即可</li>
<li><a href="https://leetcode-cn.com/problems/delete-and-earn/solution/">删除并获得点数</a>：难点在于怎么转换成打家劫舍问题</li>
<li><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/">3n 块披萨</a>：难点在于动态规划状态的定义，因为一定有 3n 个数，我们最多只能拿其中 n 个数字，所以相当于打家劫舍中我们只能偷 3n 个房间中的 n 个</li>
</ul>
<h4 id="4-需要记录两个位置的问题"><a href="#4-需要记录两个位置的问题" class="headerlink" title="4 需要记录两个位置的问题"></a>4 需要记录两个位置的问题</h4><p>有一些单串问题在涉及状态时需要考虑相邻两个元素的情况，因为只考虑最后一个的话无法对状态描述清楚，例如：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">最长的斐波那契子序列的长度</a>：$dp[i][j]$表示以 $j, i$ 结尾的最长斐波那契子序列长度，转移时在 [0..j] 中找满足条件的 k </li>
<li><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">最长等差数列</a>：同上，但是两道题的具体实现细节稍有不同</li>
</ul>
<h4 id="5-其他没有显式给定数组的线性动态规划问题"><a href="#5-其他没有显式给定数组的线性动态规划问题" class="headerlink" title="5 其他没有显式给定数组的线性动态规划问题"></a>5 其他没有显式给定数组的线性动态规划问题</h4><p>线性 DP 还有一些问题没有显式的数组，字符串等。此类问题一般没有什么固定的模式，只能通过多做题来积累。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/solution/">最长有效括号</a>：这道题最容易想到的是用栈，但其实算法过程比较难做对，用动态规划更简单，但对于状态转移的过程比较难想到</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a>：最长等差数列的简单版本，给定的数组是严格递增或递减的，处理起来会简单很多</li>
<li><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>：关键在于有效数字只有可能是一位或者两位，因此对于任何一个数字，要么本身一位进行编码，要么和前一位组成两位数字进行编码</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a>：主要考察的是深搜回溯的方法，但是使用动态规划对字符串预处理可以在O(1)时间内判断回文子串</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">分割回文串 II</a>：dp[i] 表示以 s[i] 结尾的字符串的最小分割次数，状态转移时如果 s[i] 能与前面的某个位置 j 组成回文子串 s[j…i]，那么dp[i] &#x3D; dp[j] + 1，遍历所有满足条件的 j &lt; i ，dp[i]取这些值里面的最小值，判断回文子串 s[j…i] 时同样可以用分割回文串中的动态规划方法，所以本题进行了两次动态规划，较为复杂。</li>
<li><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/solution/liang-ge-zi-fu-chuan-de-shan-chu-cao-zuo-14uw/">两个字符串的删除操作</a>：转化成LCS问题可以很简单的解决，但还可以用更符合题意的状态定义$dp[i][j]$</li>
<li><a href="https://leetcode-cn.com/problems/counting-bits/">比特位计数</a>：比较简单</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（六）着色</title>
    <url>/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<h3 id="着色（Shading）"><a href="#着色（Shading）" class="headerlink" title="着色（Shading）"></a>着色（Shading）</h3><p>前几节我们介绍了三维中的各种变换，三维到二维的映射，以及如何在屏幕空间中渲染三维空间中我们所看到的物体，也就是光栅化。光栅化的过程实际上就是判断像素是否在三角形内，如果在就填上对应的颜色的过程。那么从这一节开始，我们将讨论“填上对应的颜色”这里的颜色从何而来。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-什么是着色？"><a href="#1-什么是着色？" class="headerlink" title="1 什么是着色？"></a>1 什么是着色？</h4><p>现实生活中我们之所以能看见东西，是因为光线和物体本身发生了某些”作用“，而我们看到的世界实际上是发生这个作用之后的世界，那对于计算机而言，我们给定了相机、模型以及场景，利用前几节的内容我们实际上就能显示出相机看到了什么，但显示出的内容和实际我们应该看到的内容有很大的区别，原因在于我们没有考虑光线和物体所发生的”作用“，当光线照到物体上时，我们所看到的物体的颜色，一定和实际物体的颜色是不同的，比如下面这张图，相信这也很好理解：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165537111.png" alt="image-20220309165537111"></p>
<p>立方体本身的颜色一定是一样的，但我们看到的每一个面颜色都不同，这就是光线的作用，因此我们要想画出来实际看到的场景，就要知道我们看到的模型的每一个部分是什么颜色的，而不是模型本身是什么颜色的，这也就是着色所做的工作。当然上面的图是很简单的情况，实际应用中我们渲染的场景可能非常复杂：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309165746676.png" alt="image-20220309165746676"></p>
<p>可以看到这个场景具有复杂的光照条件，包含了各种不同材质的物体，还包括透明的液体，还有右边杯子上倒映出的周围环境的镜像，这些都是我们眼睛看到的，而不是物体本身具有的，<strong>着色就是要根据物体本身具有的属性，以及环境的光照计算出物体上每一个点在我们的视角下，应该被看到的颜色。</strong></p>
<h4 id="2-Blinn-Phong着色模型"><a href="#2-Blinn-Phong着色模型" class="headerlink" title="2 Blinn-Phong着色模型"></a>2 Blinn-Phong着色模型</h4><p>通常来说光线与物体之间的”作用“可以描述为以下三种，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309170238290.png" alt="image-20220309170238290"></p>
<p>一种是我们看到的非常亮的反光，叫做<strong>高光（Specular highlights）</strong>；另一种是物体颜色上细微的渐变，也就是<strong>漫反射（Diffuse reflection）</strong>；最后是没有被光线直接照射到但也可以被看到的部分，因为有间接的光线照射到了这部分，也就是<strong>环境光或间接光照（Ambient lighting）</strong>。</p>
<blockquote>
<p>在展开介绍之前要先明确，我们计算着色永远是在进行局部的计算，因为物体上的每一部分都和光线有不同的角度，所以也就发生不同的反应，我们计算的这个局部的点称为<strong>着色点</strong>，这也是一个抽象的概念，着色点可以是一个点也可以是一个平面，平面可以理解为这个点抽象而成的无限小的平面，我们计算各种光照时，都是光线在与这个平面发生作用。</p>
</blockquote>
<p>计算着色其实就是计算上面三种光照，对于这三种光照的计算，输入都是一样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171357997.png" alt="image-20220309171357997"></p>
<p>输入包含我们观察的方向向量$\vec v$，着色点的法向量$\vec n$，光线的入射方向$\vec l$以及着色点表面的属性，也就是颜色等信息。需要说明的是这三个表示方向的向量只表示方向，因此都是单位向量。</p>
<h5 id="2-1-漫反射"><a href="#2-1-漫反射" class="headerlink" title="2.1 漫反射"></a>2.1 漫反射</h5><p>漫反射非常简单，就是光线射到物体表面时会朝各个方向均匀的发散：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309171931199.png" alt="image-20220309171931199"></p>
<p>也就是说，物体表面的颜色从各个方向看都是相同的，决定物体颜色深浅的，只有物体<strong>接收</strong>到光线之后，<strong>吸收</strong>了多少光，又<strong>反射</strong>出去了多少光，反射出去的这部分，也就是我们看到的颜色。</p>
<p>于是首先要考虑物体能<strong>接收</strong>到多少光。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172156026.png" alt="image-20220309172156026"></p>
<p>物体表面如果和光线入射方向垂直，那就接收到了几乎全部的光，而如果物体旋转一定的角度，就有一部分光到达不了物体表面，也就无法被接收，而到达物体表面的光，也与物体表面有一定的角度，能量也是无法被完全接收的，那如何描述这个关系呢，Lambert’s余弦定理给出了答案：<strong>物体表面单位面积的光照与平面法线和光线夹角的余弦成正比</strong>。这里的光线方向是从物体表面指向光源的方向，是光线入射方向的反方向。</p>
<p>那么光的强度又该如何描述呢，光可以理解为一种能量，所以在传播的过程中能量一定是有所损失的，所以光的强度与传播距离是成反比的，如果光源处强度为$I$，那么距离光源 $r$ 处的强度为$I&#x2F;r^2$.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309172942182.png" alt="image-20220309172942182"></p>
<p>于是我们就可以得出漫反射的计算公式：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309173151067.png" alt="image-20220309173151067"></p>
<p>$k_d$ 是漫反射系数，也就是着色点的颜色；平面法线和光线夹角的余弦也就是着色点的法向量$\vec n$和光线的入射方向$\vec l$的点乘，因而二者都是单位向量所以点乘就是余弦，$max(0, \vec n·\vec l)$的含义是有时夹角余弦为负，那我们认为这是无意义的，因为这相当于光线从平面下方射入，实际上就是看不到任何颜色，所以如果夹角余弦为负我们就取0.</p>
<p>可以看出漫反射计算中不包含视线方向 $\vec v$ ，正好对应开头说的，漫反射与观察方向无关，漫反射的颜色从任何方向看都是一样的。</p>
<p>下面的图展示了$k_d$ 逐渐增大对应的漫反射表现，也就是颜色逐渐变亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175149118.png" alt="image-20220309175149118"></p>
<h5 id="2-2-高光"><a href="#2-2-高光" class="headerlink" title="2.2 高光"></a>2.2 高光</h5><p>当我们的视线方向和光线的镜面反射方向比较接近时，就产生了高光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175403769.png" alt="image-20220309175403769"></p>
<p>所以我们只要计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦就可以，高光和这个夹角余弦成正比。</p>
<p>在布林冯模型中没有直接计算镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 的夹角余弦，而是进行了优化：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309175724874.png" alt="image-20220309175724874"></p>
<p>镜面反射方向 $\vec R$ 和观察方向 $\vec v$ 接近可以转化为着色点法向量和<strong>半程向量</strong>接近。所谓半程向量是指光线入射方向和观察方向的角平分线方向，这个向量非常容易计算，根据向量的平行四边形法则，半程向量就是光线入射方向向量和观察方向向量的和。</p>
<p>于是我们就得到了上面的高光计算公式，和漫反射非常类似，$k_s$ 是高光系数，也就是高光的颜色，一般就是白色，与漫反射唯一不同的是，高光计算公式中夹角余弦部分多了一个指数 $p$，这是因为余弦函数本身的容忍度太高，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180233721.png" alt="image-20220309180233721"></p>
<p>如果直接使用余弦函数，那么镜面反射方向和观察方向夹角45°甚至更大时，我们还会取到一个比较大的值，此时意味着我们还可以看到比较明显的高光，但实际上我们只有在镜面反射方向和观察方向夹角非常小时才能看到高光。可以看到随着余弦函数幂次的增大，我们能看到高光的夹角阈值在变小，当我们使用余弦函数的64次方时，只有在镜面反射方向和观察方向夹角大约20°范围内才能看到高光，当然这还是太大了，所以在布林冯模型中 $p$ 的取值一般在100~200左右。</p>
<p>下面的图每一行展示的是随着 $p$ 取值增大所看到的高光的效果，每一列代表的是高光系数 $k_s$ 增大带来的变化，就是高光部分的颜色越来越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309180800693.png" alt="image-20220309180800693"></p>
<h5 id="2-3-间接光照"><a href="#2-3-间接光照" class="headerlink" title="2.3 间接光照"></a>2.3 间接光照</h5><p>间接光照最为简单，间接光照就是从四面八方射向物体表面的各种光对物体颜色产生的影响的总和，与光线的入射方向、物体表面的法线方向和我们的观察方向都没有关系，所以间接光照就是一个常数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181612011.png" alt="image-20220309181612011"></p>
<h5 id="2-4-布林冯模型"><a href="#2-4-布林冯模型" class="headerlink" title="2.4 布林冯模型"></a>2.4 布林冯模型</h5><p>将上面的三个光照项加起来就得到了物体表面受光照影响的总和，这就是布林冯着色模型。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309181732816.png" alt="image-20220309181732816"></p>
<p>可以看到最左边间接光照就是一个固定的颜色（常数），漫反射表现的是物体表面颜色的变化，这个变化是由物体表面和光线方向不同引起的，高光是一些白色的亮光，只有物体上使得光线镜面反射方向和观察方向夹角比较小的部分才会显示出高光。这些项全部叠加起来也就是最终我们看到的物体的颜色了。</p>
<h4 id="3-着色频率"><a href="#3-着色频率" class="headerlink" title="3 着色频率"></a>3 着色频率</h4><p>到此为止我们了解了对一个着色点应该如何着色，那么对于一个物体，我们该以什么样的方式去对整个物体表面进行着色呢？有以下三种方式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182145738.png" alt="image-20220309182145738"></p>
<ul>
<li>最左边是对物体上的每一个片面（也就是组成物体的基本几何图形，可以是三角形，可以是矩形），进行一次着色，此时这一个片面就是一个着色点，所以这个片面内计算出的颜色是一致的，可以看出着色效果并不好</li>
<li>中间是对物体上的每一个片面的每一个顶点进行一次着色，此时每个片面的顶点是一个着色点，片面的颜色取决于计算出的这些顶点的颜色，可以用插值的方法得到每个片面的颜色</li>
<li>右边是对物体上每一个点进行一次着色，此时每一个点都是一个着色点，因此效果也最细腻</li>
</ul>
<p>上面三种着色方式代表着三种不同的着色频率，其中也包含很多具体的问题，接下来具体介绍这三种着色方式。</p>
<h5 id="3-1-Flat-shading"><a href="#3-1-Flat-shading" class="headerlink" title="3.1 Flat shading"></a>3.1 Flat shading</h5><p>Flat shading对物体每一个片面三角形进行着色，是最简单的着色方式，但是对于平滑表面着色效果不好。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182705236.png" alt="image-20220309182705236"></p>
<h5 id="3-2-Gouraud-shading"><a href="#3-2-Gouraud-shading" class="headerlink" title="3.2 Gouraud shading"></a>3.2 Gouraud shading</h5><p>Gouraud shading对物体上的每一个三角形的每一个顶点进行一次着色，计算出每个顶点的颜色后，对三个顶点颜色进行插值就可以得到三角形上每一个点的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309182821004.png" alt="image-20220309182821004"></p>
<p>具体如何插值后面会专门介绍，除此之外还存在一个问题，就是一个顶点怎么计算它的法向量？</p>
<p>我们首先考虑一个简单的二维情况，如果这个顶点是一个圆上的点，那么这个点的法线方向就是圆心和这个点连线的方向，如果这个点是圆某个内接多边形的顶点（圆上任何一个点都可以是内接多边形的顶点），那么法线方向就是与这个顶点相邻的两条边的法线的角平分线方向，也就是两条边的法向量的和。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309183734717.png" alt="image-20220309183734717"></p>
<p>推广到三维中，<strong>物体上一个点的法线方向就是与它相邻的所有平面法向量的加权和</strong>。加权是因为实际应用中三维物体不可能都是一个均匀球体，会是各种形状，所以每个相邻的平面也不一样大，自然对这个顶点法线方向的贡献也不同。</p>
<p>知道了如何计算点的法向量，也就知道如何进行Gouraud shading了。关于三角形颜色的插值，后面会统一介绍。</p>
<h5 id="3-3-Phong-shading"><a href="#3-3-Phong-shading" class="headerlink" title="3.3 Phong shading"></a>3.3 Phong shading</h5><p>Phong shading对模型上每一个点进行着色计算，因此每一个点都是一个单独的着色点。那么又出现一个问题，我们如何计算物体上每一个点的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184149978.png" alt="image-20220309184149978"></p>
<p>由于这些点大部分都不是片面三角形的顶点，所以上面的法线计算方法并不适用。但我们可以先计算出片面三角形顶点的法向量，再利用插值的方法得到三角形内每一个点的法向量，当然别忘了计算完成后对法向量进行归一化，法向量只指示方向，一定是单位向量。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309184601435.png" alt="image-20220309184601435"></p>
<p>和上面的颜色插值一样，这里又要用到三角形的插值，只不过这次插值的内容是法向量。接下来我们专门介绍三角形的插值方法——利用重心坐标。</p>
<h4 id="4-重心坐标（Barycentric-Coordinates）"><a href="#4-重心坐标（Barycentric-Coordinates）" class="headerlink" title="4 重心坐标（Barycentric Coordinates）"></a>4 重心坐标（Barycentric Coordinates）</h4><p>三角形插值是图形学中经常使用的操作，因为很多时候我们只知道三角形三个顶点对应的某些属性值，那么想要使得三角形内部每一个点的属性值平滑的变化，就需要利用已有值进行插值。于是引入三角形重心坐标的概念。</p>
<p>重心坐标实际上是一个坐标表示方法，对于空间中的三角形ABC，任意一个在三角形ABC平面上的点$(x,y)$，都可以表示为三角形三个顶点坐标的线性组合$\alpha A+\beta B+ \gamma C$，其中三个系数就是这个点在这个三角形下的重心坐标，重心坐标需要满足约束$\alpha + \beta + \gamma&#x3D;1$，如果不满足这个约束，表示出来的点就不在三角形ABC这个平面上；并且如果这个点在三角形内部，重心坐标三个数都非负。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309185358567.png" alt="image-20220309185358567"></p>
<p>有了重心坐标的定义，那对于三角形内部的任意一个点，怎么去得到它的重心坐标呢？</p>
<p>对于三角形内部任意一个点，将它和三个顶点相连，会形成三个子三角形，重心坐标可以根据三个子三角形面积求出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190117856.png" alt="image-20220309190117856"></p>
<p>每个顶点对应的系数等于该顶点<strong>对面</strong>的子三角形面积除以三角形的总面积，比如点 A 的系数 $\alpha$ 等于点 A 对面的子三角形，也就是和点 A 不相邻的子三角形$A_A$的面积除以三角形ABC的总面积。</p>
<p>显然三角形重心的重心坐标就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190751306.png" alt="image-20220309190751306"></p>
<p>给定三角形的三个顶点和三角形内任意一个点坐标，我们可以根据下面的式子求出该点的重心坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309190924381.png" alt="image-20220309190924381"></p>
<p>得到重心坐标后，再进行三角形内部的线性插值就非常容易了，因为线性插值就是把三角形内任意一个点的某项属性（属性可以是坐标、颜色、深度、法向量等等）表示为三角形三个顶点属性的线性组合，至于怎么组合，重心坐标就是“坐标”这个属性的组合系数，自然也可以用在其他任何属性上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309191134142.png" alt="image-20220309191134142"></p>
<p>需要注意的是，<strong>重心坐标不具有投影不变性</strong>，因为空间中的三角形投影到平面上，形状可能会变化，那么三角形内每个点的重心坐标自然会发生变化，因此计算和空间有关的属性的插值时，要先在三维空间中计算，再投影到二维空间。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h4><p>总之，着色就是计算模型上每一个点应该被我们看到的颜色，根据着色频率的不同，着色时又分为三种着色策略：</p>
<ul>
<li>Flat shading</li>
<li>Gouraud shading</li>
<li>Phong shading</li>
</ul>
<p>下面是这三种着色策略的对比，可以看出，当模型片面不够多时，Flat shading的效果较差，但随着模型复杂度的提升，Flat shading的效果并不差，并且由于不需要插值运算，当模型足够精细时，使用Flat shading是性价比更高的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/image-20220309192158594.png" alt="image-20220309192158594"></p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（五）深度缓冲</title>
    <url>/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h3 id="深度缓冲（Z-Buffer）"><a href="#深度缓冲（Z-Buffer）" class="headerlink" title="深度缓冲（Z-Buffer）"></a>深度缓冲（Z-Buffer）</h3><p>到上一篇文章为止，我们基本完成了把三维物体画在二维屏幕上的过程，但在这个过程中，还有一个非常重要的问题没有讨论，那就是在光栅化的时候我们之前的推导都没有考虑Z轴，也就是没有考虑三维物体离我们的远近，但是现实生活中我们看一个三维物体或者场景，由于物体离我们眼睛的距离不同，自然会产生遮挡现象。</p>
<p><em><span id="more"></span></em></p>
<p>比如一个立方体，在这样的视角下我们是看不到它的左平面、下平面和后平面的，但是在光栅化的过程中，我们依然会取这个立方体左平面上的三个点组成三角形并画在屏幕上，如果不考虑遮挡关系，那画出来的正方体显然和我们看到的就不一样了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308174826553.png" alt="image-20220308174826553"></p>
<p>那如何在光栅化过程中考虑这种遮挡关系，并把这种关系正确的画出来呢？这就是这一节要讨论的内容。</p>
<p>在开始之前，要先明确一个概念，这一节所说的 Z ，并不是物体的 Z 坐标，<strong>而是代表物体离我们的远近，也就是深度，这个深度永远是正数，而且数值越小离我们越近</strong>。因为之前说了相机指向 -Z 方向，所以如果是 Z 坐标的话，离我们越近的反而数值上越大，这不符合我们的直觉。因此需要重新给出这个深度的概念。</p>
<h4 id="1-画家算法"><a href="#1-画家算法" class="headerlink" title="1 画家算法"></a>1 画家算法</h4><p>画家算法指的是我们像画家画画一样，从远处往近处画，这样近处的画面自然会遮挡住远处的画面，光栅化的时候也可以这样，我们先对三角形的深度排序，然后从远往近画在屏幕上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175526241.png" alt="image-20220308175526241"></p>
<p>但是这样的算法无法解决下面这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308175553407.png" alt="image-20220308175553407"></p>
<p>三角形的遮挡关系往往没有那么简单，因此画家算法大多情况下并不适用。</p>
<h4 id="2-Z-Buffer"><a href="#2-Z-Buffer" class="headerlink" title="2 Z-Buffer"></a>2 Z-Buffer</h4><p>Z-Buffer的思想非常简单，那就是我们在渲染图形时，除了维护frame-buffer（显示在屏幕上的图）外，再维护一个Z-buffer（深度图），<strong>Z-buffer中存储屏幕上每一个像素当前的最小深度</strong>，在光栅化开始时，Z-buffer中每一个像素的深度都设为无穷大，之后渲染三角形的时候，每次都先判断当前渲染的三角形的深度和Z-buffer中当前像素的深度谁更小（谁离我们更近），如果三角形的深度更小，那么就把三角形的颜色存入frame-buffer中这个像素的位置，同时把Z-buffer中当前像素的最小深度更新一次，这样我们总能保证深度小的颜色遮挡深度大的颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180155386.png" alt="image-20220308180155386"></p>
<p>Z-buffer和frame-buffer总是同时渲染的，因此当我们生成一张图片的时候，也就生成了这张图片的深度图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180255018.png" alt="image-20220308180255018"></p>
<p>可以看到深度图中越远的地方像素值越大，越近的地方像素值越小。</p>
<p>Z-buffer的伪代码如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/image-20220308180341613.png" alt="image-20220308180341613"></p>
<p>相比于画家算法 O(nlogn) ，Z-buffer只需要 O(n) 的时间复杂度。</p>
<blockquote>
<p>为什么是O(n)？</p>
<p>假设每个三角形只覆盖常数个像素，那么Z-buffer做的就是对每一个三角形判断对应的深度，然后填充像素，因此只需要花费 O(1) 时间，那么有n个三角形，复杂度就是O(n).</p>
</blockquote>
<p>最后说一下Z-buffer的优势，就是与画三角形的顺序无关，只要维护对了深度信息，画出来的一定是正确是遮挡关系，并且对硬件没有特殊需求，容易实现。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（八）图形管线</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="图形管线（Graphics-Pipeline）"><a href="#图形管线（Graphics-Pipeline）" class="headerlink" title="图形管线（Graphics Pipeline）"></a>图形管线（Graphics Pipeline）</h3><p>这一节将对前面的所有内容做一个总结，因为图形管线就是由前面的所有内容组成的一个图形渲染流水线，空间中的点经过图形管线就被渲染到屏幕上成为图形。本节以概述形式介绍图形管线，随着学习的深入，会对图形管线有更深入的理解，到时候会对图形渲染管线进行全面详尽的总结。</p>
<p><em><span id="more"></span></em></p>
<p>图形管线是基于物体顺序渲染的一系列绘制操作的序列。相对于基于物体顺序渲染还有基于图像顺序渲染，会在之后会讲到。基于物体顺序渲染由于其极高的运行效率而统治了图形学的渲染方法，从早期人们提出了软件图形管线后，图形管线的流程思路又被硬件优化内置到显卡中成为硬件图形管线，这两个管线后来呈现出并行关系，负责不同的事务。</p>
<p>图形管线的主要流程如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/image-20220310201713743.png" alt="image-20220310201713743"></p>
<h4 id="1-顶点数据处理"><a href="#1-顶点数据处理" class="headerlink" title="1 顶点数据处理"></a>1 顶点数据处理</h4><p>输入图形管线的是三维空间中的顶点，这些输入的顶点数据不止有坐标，还包括纹理坐标、顶点法线和顶点颜色等各种属性，顶点数据处理就是对这些属性数据进行处理，首先把顶点连成空间中的一个个面，可以是三角形也可以是四边形，这里我们就用常用的三角形，空间中的三角形称为<strong>图元</strong>。</p>
<p>之后就是经过各种矩阵变换把三维映射到二维屏幕上，在变换的时候还会进行一步重要的操作，叫做视体裁剪，视体就是指透视投影近平面和远平面组成的四棱台。这需要回顾透视投影部分的内容。</p>
<p>透视投影有一个重要的性质就是它会将直线映射为直线，平面映射为平面，线段映射为线段，并且保留了所有点的排序正确，这保证了三角形正确映射为三角形。</p>
<p>但是经过透视投影矩阵，原本的 $z$ 将会被映射为 $z’&#x3D;n+f-nf&#x2F;z$。于是我们就会发现在这个映射中，正的 $z$ 值会被映射到负 $z$ 上，负的 $z$  值被映射到正 $z$  上，当我们要渲染的物体都在视体内时自然还能正确投影到屏幕上，但是一旦出现了跨越 $z&#x3D;0$ 的线段，线段就会有一部分被映射到正负无穷因而被撕裂。</p>
<p>详细来看其实是下面的图所导致的。下图所表示经过透视投影处理后的 $z$ 值情况，可以看到由于视体标准化的原因 $n+f$ 是真正意义上的 0 点，$z$ 值在 $n+f$ 的位置发生的翻转，这个翻转导致了图的下半部分的三角形 $c$ 点经过透视投影后出现在了另一个方向，这将会导致光栅化的时候绘制出错误三角形。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/q3tenh9i8t.png" alt="q3tenh9i8t"></p>
<p>观察上面的图我们还可以发现在视体中的部分(也就是z&#x3D;n到z&#x3D;f的区域)，经过透视投影后也会保持原来的顺序和位置，因而解决这个问题的方法就很直观了，在透视投影前就先将视体之外的面片裁剪掉，这就是视体裁剪。视体裁剪除了防止撕裂外还有一个显而易见的好处就是减少了后面进行投影变换时需要处理的顶点数量，而且减少掉的内容本来就在视体之外所以不会影响到最终的画面。</p>
<p>具体如何进行裁剪，我们可以根据视体的顶点坐标计算出六个平面的方程，然后将空间中的点带入视体面方程，但平面方程计算比较复杂，更多关于裁剪的内容可以查看本篇的参考内容。</p>
<h4 id="2-曲面细分"><a href="#2-曲面细分" class="headerlink" title="2 曲面细分"></a>2 曲面细分</h4><p>曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量，是渲染管线一个可选的阶段。它由外壳着色器(Hull Shader)、镶嵌器(Tessellator)和域着色器(Domain Shader)构成，其中外壳着色器和域着色器是可编程的，而镶嵌器是由硬件管理的。我们可以借助曲面细分的技术实现细节层次(Level-of-Detail)的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。</p>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3 光栅化"></a>3 光栅化</h4><p>经过前面的处理我们得到了许多图元，并且最后通过视口变换变换到了屏幕坐标系下，然后就是进行光栅化，光栅化阶段会把图元变成屏幕坐标系中的离散的片元，片元可以理解为像素，但它与像素的区别在于片元拥有比像素更多的信息，例如深度值，法线，纹理坐标等信息。因此片元只是尺度和像素相同，但片元还不能直接显示到屏幕，一个像素会有很多个候选片元，这些片元还要经过一系列计算才能决定哪些片元显示在屏幕上。</p>
<h4 id="4-片元处理"><a href="#4-片元处理" class="headerlink" title="4 片元处理"></a>4 片元处理</h4><p>片元处理阶段会对各个片元计算深度、颜色等属性信息，这里用到的就是三角形重心坐标插值，计算颜色还要用到纹理映射，因为片元相当于一个像素，所以这里的着色频率相当于是对每一个像素计算着色，也就是Phong Shading。有的图形管线也会在顶点处理时进行着色，也就是进行Gouraud Shading，但效果肯定不如逐片元着色好。</p>
<h4 id="5-混合测试"><a href="#5-混合测试" class="headerlink" title="5 混合测试"></a>5 混合测试</h4><p>经过片元处理我们就得到了所有片元的颜色，最后就是要选择哪些片元能够显示在屏幕上，这里要经过一系列的混合测试，比如深度测试，也就是要用到之前说过的Z-Buffer，选择深度小的片元进行显示，当然除了深度测试之外还有切测试、Alpha测试、模板测试等等。</p>
<h4 id="6-Shader"><a href="#6-Shader" class="headerlink" title="6 Shader"></a>6 Shader</h4><p>刚才说到过，在图形管线中我们可以选择在顶点处理阶段进行着色或者在片元处理阶段进行着色，而且我们还可以对着色进行专门的编程，控制GPU对对一个着色点执行什么样的着色操作，这就是Shader。</p>
<p>Shader（着色器）是指一组供计算机图形资源在执行渲染任务时使用的指令，用于计算图像的颜色或明暗。通俗地说，着色器告诉电脑如何用特有的一种方法去绘制物体。</p>
<p>关于Shader，后面会有专门的文章详细的讲解。</p>
<h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1685227">【笔记】《计算机图形学》(8)——图形管线 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://positiveczp.github.io/%E7%BB%86%E8%AF%B4%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html">细说图形渲染管线</a></li>
<li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/102758967">一篇文章彻底弄懂齐次裁剪 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（七）纹理映射</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h3 id="纹理映射（Texture-Mapping）"><a href="#纹理映射（Texture-Mapping）" class="headerlink" title="纹理映射（Texture Mapping）"></a>纹理映射（Texture Mapping）</h3><p>上一节介绍了着色模型和着色频率，回忆漫反射的计算，漫反射系数 $k_d$ 通常就是物体本身的颜色，但很多时候物体本身的颜色并没有那么简单，大多数情况下，物体上每一个部分的颜色都不同，物体表面具有一定的纹理，比如木质的地板，此时我们在渲染的时候也需要把这样的纹理渲染出来，这就是纹理映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310165904624.png" alt="image-20220310165904624"></p>
<p><em><span id="more"></span></em></p>
<h4 id="1-纹理映射"><a href="#1-纹理映射" class="headerlink" title="1 纹理映射"></a>1 纹理映射</h4><p>首先是一个非常简单的结论：每一个三维物体表面上的点，都可以对应一个二维平面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310170619028.png" alt="image-20220310170619028"></p>
<p>比如一个地球仪，我们把地球仪展开成一个平面，就是世界地图，相反，实际上纹理映射就是把世界地图“贴”到地球仪上。</p>
<p>因此对于三维物体表面的点，我们都可以把它映射到一个纹理空间中，这个纹理空间和屏幕空间一样，都是二维的，纹理空间的坐标用 $(u,v)$ 来表示，这样我们就把屏幕空间，三维空间和纹理空间联系到了一起，当然通过上图也可以看出来这三个坐标之间的关系：三维空间坐标是联系屏幕空间坐标和纹理空间坐标的桥梁，我们无法直接通过屏幕空间坐标得到对应的纹理空间坐标，因为他们之间不存在一一对应关系，屏幕上一个像素可能对应纹理空间的一个区域。这里不理解也没关系，后面我们就会遇到这种情况。</p>
<p>于是，最理想的情况下，三维物体上每个点都对应纹理空间的一个点，自然三维空间的三角形也就可以对应纹理图上的一个三角形，我们把这些对应的三角形的颜色都“复制”到三维图形表面的三角形上，也就相当于把一张纹理图“贴”到了模型上。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310171049609.png" alt="image-20220310171049609"></p>
<p>具体怎么做呢？我们对于每一个屏幕上的采样点，可以通过上一次说的三角形重心坐标插值的方法，得到这个采样点的纹理坐标$(u,v)$，然后我们根据纹理坐标直接到纹理图上查询，就可以得到纹理颜色，然后把纹理颜色作为漫反射系数 $k_d$ 去计算颜色就可以了。</p>
<h4 id="2-纹理过小"><a href="#2-纹理过小" class="headerlink" title="2 纹理过小"></a>2 纹理过小</h4><p>上面我们了解了纹理映射的过程，其实非常简单。但实际上也没有那么简单，我们先考虑一种情况，那就是如果纹理图很小，会发生什么？</p>
<p>比如我们要在屏幕上画一面 4K 的墙面，但是纹理图只有不到 1K 的分辨率，这个时候屏幕上的多个像素都会映射到纹理图上的同一个像素内，我们把纹理图上的像素称为纹素 <strong>Texel</strong>，如果我们使用最近邻的方式去获得纹理颜色，那么这些像素的颜色就都会是一样的，这相当于把原本低分辨率的图暴力的放大了，于是就会出现下面左边的图这样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>因此我们肯定不能用最近邻方法获取纹理颜色值，对于这种问题，自然想到插值，比如最简单的双线性插值。假如屏幕上的一个像素映射到纹理图上的坐标对应红色的点，周围黑色的点是纹素中心：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173834882.png" alt="image-20220310173834882"></p>
<p>双线性插值选取该点周围最近的四个纹素：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174007656.png" alt="image-20220310174007656"></p>
<p>计算在水平和垂直两个方向上的相对偏移系数，偏移系数都在0~1之间，我们假设两个纹素之间的距离是 1：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174055457.png" alt="image-20220310174055457"></p>
<p>然后先做一次水平插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174217122.png" alt="image-20220310174217122"></p>
<p>再做一次竖直插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310174310943.png" alt="image-20220310174310943"></p>
<p>一共做了两种线性插值，所以叫做双线性插值。然后将插值的颜色作为该点的纹理颜色返回，这样就可以使得屏幕上的像素过度的更柔和一些，下面中间的图就是双线性插值的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310173005265.png" alt="image-20220310173005265"></p>
<p>当然还可以使用更复杂的双cubic插值，会选取周围16个点做两次cubic插值，效果会更好，当然运算开销也更大，最右边的图把眼角处细微的锯齿都去掉了。</p>
<h4 id="3-纹理过大"><a href="#3-纹理过大" class="headerlink" title="3 纹理过大"></a>3 纹理过大</h4><p>讨论完了纹理图过小产生的问题，接下来考虑如果纹理图过大又会发生什么呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175039809.png" alt="image-20220310175039809"></p>
<p>可以看到，当纹理图的分辨率过大时，产生了锯齿和摩尔纹，也就是发生了走样。为什么会走样呢，回顾之前说的走样产生的原因，是因为采样频率跟不上信号变化的频率，当纹理图过大时，屏幕上一个像素对应到纹理图上可能是一片区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175322646.png" alt="image-20220310175322646"></p>
<p>这一片区域中每一个纹素颜色都可能不同，这相当于在一个像素内，信号（也就是颜色）发生了剧烈的变化，这也就是采样频率低于了信号的变化频率，也就发生了走样。此时如果我们用区域内的一个纹素值代表整个区域的颜色显然是不合理的。因此我们要进行纹理映射的反走样。</p>
<p>反走样之前也讲过，最简单的反走样就是增大采样频率，比如类似于MSAA的超采样，我们可以把一个像素分成好多个像素去映射到纹理图上，然后获取这些子像素的纹理颜色，最后加权整合成像素颜色。效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310175853537.png" alt="image-20220310175853537"></p>
<p>可以看到效果还不错，但为了得到这样的效果进行了512倍超采样，消耗太大了，如果纹理图更大呢？我们没有办法无穷尽的进行超采样，因此最好是换一种方法。</p>
<p>反走样是因为采样产生的，那我们可以不直接不采样，如果我们能直接获取到纹理图上某个区域的平均值，就不需要进行采样了。我们直接把像素对应的区域的平均值拿到就可以了。如何做到呢？</p>
<h5 id="3-1-Mipmap"><a href="#3-1-Mipmap" class="headerlink" title="3.1 Mipmap"></a>3.1 Mipmap</h5><p>Mipmap是一种非常<strong>快速的</strong>，<strong>空间开销很低的</strong>，<strong>近似的</strong>，区域查询方法，但<strong>只能查询方形区域</strong>。</p>
<p>Mipmap的思想非常简单，我们把一张图片每四个像素计算一个平均值，这样全图计算一次之后，图片尺寸就缩小了一半，这个图片中每个像素的值就是原图一个正方形区域四个像素的平均值，之后继续这样缩小下去，就得到了不同级别的原图的多个像素的平均值构成的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310180712996.png" alt="image-20220310180712996"></p>
<p>由于每次图片尺寸缩小一半，那么像素数就只有原来的四分之一，所有级别的图加起来所花费的额外存储空间也不过原图大小的三分之一（简单的等比数列求和）。</p>
<p>接下来就是如何去查询信息了。我们把屏幕空间中的一个点和它水平和垂直方向相邻的点都映射到纹理空间中，就得到了纹理空间中的三个点（也可以是四个，把对角线上相邻的点也映射过去就是四个点，具体看后续是否用得到）；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181400709.png" alt="image-20220310181400709"></p>
<p>然后我们计算映射后该点和其他两个点的距离，把这个距离取最大值作为以该点为中心的正方形区域的边长，这样就<strong>近似</strong>得到了屏幕上一个像素在纹理空间中对应的一片正方形区域。然后查询这片区域的平均值即可，查询的级别 $D&#x3D;log_2L$，D取整数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181820489.png" alt="image-20220310181820489"></p>
<p>下面是按照上面的算法，一个场景中每个像素要查询的Mipmap的级别可视化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310181932739.png" alt="image-20220310181932739"></p>
<p>可以发现Mipmap级别 D 取整数会造成屏幕上相邻像素查询的级别可能差别很大，最后渲染出来的图可能会有严重的割裂现象，因此我们希望查询的级别也能平滑过渡，我们希望可以查询 1.8 级的Mipmap，又是平滑过渡，因此又是插值。</p>
<p>我们可以去查询两个级别的Mipmap，在Mipmap内部使用双线性插值得到两个级别的平均值，然后再将这两个级别进行线性插值得到最终结果，也就是进行了三线性插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182407725.png" alt="image-20220310182407725"></p>
<p>使用三线性插值后，Mipmap级别可视化的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182449283.png" alt="image-20220310182449283"></p>
<p>过度非常平滑，达到了我们想要的效果。</p>
<p>最后看一下使用Mipmap渲染出来的图片是什么样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310182543245.png" alt="image-20220310182543245"></p>
<h5 id="3-2-各向异性过滤"><a href="#3-2-各向异性过滤" class="headerlink" title="3.2 各向异性过滤"></a>3.2 各向异性过滤</h5><p>可以看到Mipmap渲染的图形中，近处的锯齿消失了，但远处产生了过度模糊，这是因为Mipmap只能近似方形区域，而这张图上近处的像素映射到纹理空间中对应的区域非常小，因此无论这个区域是什么形状，近似成正方形都不会有太大的问题，但是远处的一个像素对应到纹理图上可能是很大一片区域，此时这个区域的形状就会对结果产生影响了，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183141960.png" alt="image-20220310183141960"></p>
<p>区域很大时，如果形状不是正方形而是一个矩形，那我们按照Mipmap的方法实际近似的区域其实是这个矩形的Bounding box，这与原来的矩形区域差别很大，所以Mipmap不能完美的解决走样问题。</p>
<p>因此现在游戏中使用的更多的是各向异性过滤技术。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183403325.png" alt="image-20220310183403325"></p>
<p>各向异性过滤是Mipmap的改进，它不仅每次等比例的缩小原图，还会长宽不等比例的去计算Mipmap，这样缩小的图上一个像素对应的就是原图上一个矩形区域内像素的平均值了，然后我们就可以支持矩形的查询了。但斜向的矩形查询仍然存在问题。</p>
<p>除此之外的反走样方法还有EWA过滤，如下图，是用多个圆形或者椭圆形去近似填充任意几何图形，但是需要多次查询，不过可以查询任意形状的区域。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310183733788.png" alt="image-20220310183733788"></p>
<h4 id="4-纹理的应用"><a href="#4-纹理的应用" class="headerlink" title="4 纹理的应用"></a>4 纹理的应用</h4><p>前面就是纹理映射的全部基本的内容，现在我们要把纹理推广开来。</p>
<p>纹理不是一张简单的图片。在现代GPU中，纹理就可以理解为<strong>一块可以支持快速范围查询的内存</strong>。而上面我们所说的纹理图，只不过是纹理的一种用法而已，纹理图其实就是把颜色存入这块内存，供我们随时查询，取用。当然我们也可以存别的东西，所以纹理可以有各种各样的用途。</p>
<h5 id="4-1-环境贴图"><a href="#4-1-环境贴图" class="headerlink" title="4.1 环境贴图"></a>4.1 环境贴图</h5><p>一些光面的物体还会反射环境中的景象，这怎么做到呢？也是利用纹理实现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184622644.png" alt="image-20220310184622644"></p>
<p>我们可以提前把整个环境的图存下来，渲染物体颜色的时候把环境作为一个纹理应用到物体上就可以了。</p>
<p>我们假设用一个球来存储环境贴图，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184801387.png" alt="image-20220310184801387"></p>
<p>那把这球的表面展开成平面，就得到了整个场景的环境贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310184850501.png" alt="image-20220310184850501"></p>
<p>但我们会发现这张帖图有一点问题，就是边缘会产生扭曲，因为球顶部的面积更小，所以造成了扭曲。因此人们想到用立方体存储不是更好吗？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185057776.png" alt="image-20220310185057776"></p>
<p>把球的每一个面“贴到”立方体的每一个面上，就可以用立方体存储整个环境，大概的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185159502.png" alt="image-20220310185159502"></p>
<h5 id="4-2-凹凸贴图"><a href="#4-2-凹凸贴图" class="headerlink" title="4.2 凹凸贴图"></a>4.2 凹凸贴图</h5><p>有时候我们希望渲染出物体表面凹凸不平的样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185306391.png" alt="image-20220310185306391"></p>
<p>这时我们可以用凹凸贴图来解决。想要造成凹凸的效果，其实就是在计算光照时，将顶点或者平面的法向量向上或者向下移动一定的距离，这样计算出的光照就有明显的明暗变化，在我们看起来也就产生了凹凸的效果，因此我们可以用纹理存储每一个顶点法向量的扰动量，然后再计算光照时取到这个扰动量施加到原本的法向量上去计算光照，就得到了凹凸的效果。具体怎么计算扰动后的法向量呢？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185709262.png" alt="image-20220310185709262"></p>
<p>我们先考虑简单的二维情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310185827357.png" alt="image-20220310185827357"></p>
<p>假设原本平面的法向量是$(0,1)$，我们可以计算出扰动后的点在曲线上的导数（切线），然后可以直接得到和切线垂直的方向，这就是扰动后的点的法线方向，最后别忘了归一化。</p>
<p>推广到三维空间中，我们每次计算都把当前点的法向量转换到以这个点为基准的局部坐标系下，这样当前点的法向量就是$(0,0,1)$，然后同样计算在两个方向上的导数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190221871.png" alt="image-20220310190221871"></p>
<p>于是扰动后的法线方向就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190327571.png" alt="image-20220310190327571"></p>
<p>最后再从局部坐标系转换回原本的坐标系即可。</p>
<h5 id="4-3-位移贴图"><a href="#4-3-位移贴图" class="headerlink" title="4.3 位移贴图"></a>4.3 位移贴图</h5><p>使用凹凸贴图可以渲染出凹凸的效果，但是其实只是在计算光照时改变了顶点的法向量，而顶点本身没有发生任何变化，所以我们看到的凹凸效果只是一个假象，很容易看出破绽：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310190611021.png" alt="image-20220310190611021"></p>
<p>凹凸贴图渲染出来的模型边缘还是平滑的。而位移贴图可以渲染出真正凹凸不平的效果。</p>
<p>位移贴图存储的是每个顶点的位移，也就是它真正改变了点在空间中的位置，这样自然模型的形状也就发生了变化，渲染的效果也会更真实。</p>
<p>那为什么不直接做一个这样的模型呢？显然这么复杂的模型如果直接在建模的时候就做好，要花费大量的精力，所以位移贴图要方便许多。</p>
<h5 id="4-4-三维噪声和固体纹理"><a href="#4-4-三维噪声和固体纹理" class="headerlink" title="4.4 三维噪声和固体纹理"></a>4.4 三维噪声和固体纹理</h5><p>有一些纹理比如瓷器上的纹路，是完全不规则并且独一无二的，这时候如果我们给每一个花瓶一个不同的贴图显然是不现实的，因此我们可以给定一个三维程序噪声函数，在计算颜色的时候利用这个噪声函数生成随机的纹路。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191026718.png" alt="image-20220310191026718"></p>
<p>有时候我们的模型内部也需要有一定的纹理，比如大理石切开之后的纹理，那我们可以把整个大理石的表面和内部的全部纹理信息都存下来，存储成一个三维的纹理，这样对应空间中每一个点都有不同的纹理。</p>
<h5 id="4-5-环境光遮蔽"><a href="#4-5-环境光遮蔽" class="headerlink" title="4.5 环境光遮蔽"></a>4.5 环境光遮蔽</h5><p>我们在计算shading的时候并不会考虑模型本身对模型光照的影响，比如下面这张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/image-20220310191426063.png" alt="image-20220310191426063"></p>
<p>模型本身可能会对光照有一定的遮挡，导致不同部分产生一些阴影，左边的图就是正常着色的结果，可以看到眼眉处没有阴影，显得不是很真实，因此我们可以预先计算模型本身对光照的影响，生成一张阴影纹理图，在之后着色的时候加到着色结果上，就有了更真实的渲染结果，这也是环境光遮蔽的原理。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十）阴影</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<h3 id="阴影（Shadows）"><a href="#阴影（Shadows）" class="headerlink" title="阴影（Shadows）"></a>阴影（Shadows）</h3><p>在开始下一部分之前，先回头解决光栅化中的一个问题，那就是如何在光栅化渲染过程中绘制阴影。之前在纹理映射部分讲到了环境光遮蔽的基本原理，就是利用了贴图提前计算环境光遮蔽，那么绘制阴影同样如此，这一节就来简单介绍阴影贴图或者叫阴影映射（Shadow mapping）。</p>
<p><em><span id="more"></span></em></p>
<p>阴影映射是一个在图像空间执行的算法，因此在计算阴影的时候无需知道场景的几何关系，计算成本低，但会产生走样现象，并且<strong>阴影映射只适用于点光源</strong>。</p>
<p>简单来说，阴影映射的核心思想就是：<strong>不在阴影中的点一定是既能被相机看到也能被光源看到的点</strong>。按照这个核心思想我们来看阴影映射的步骤。</p>
<h4 id="阴影映射过程"><a href="#阴影映射过程" class="headerlink" title="阴影映射过程"></a>阴影映射过程</h4><p>首先我们在光源处放一个虚拟相机，去看向整个场景，然后我们记录这个虚拟相机看到的整个场景的深度形成一张深度图，比如下面的图，没有被遮挡的物体的深度自然就是物体到光源的距离，而存在遮挡关系的物体肯定只能记录离光源最近的物体的距离。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171205820.png" alt="image-20220313171205820"></p>
<p>然后我们再用真正的相机看向整个场景，此时看到的每一个点我们都计算它到光源的距离，然后把这个点映射到用光源生成的深度图上，找到光源看到的这个点的深度，如果计算出来的深度和光源看到的深度是一致的，那就说明这个点没有被遮挡，也就是既能被相机看到也能被光源看到，那么这个点就不处在阴影中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171505847.png" alt="image-20220313171505847"></p>
<p>而如果计算出来的深度和光源看到的深度不一致，那显然这个点被遮挡了，相机能看到但光源看不到，这也就是阴影，于是我们把这个点涂上阴影的颜色，这样就完成了阴影映射，得到了场景中在点光源下物体的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313171937017.png" alt="image-20220313171937017"></p>
<p>我们用一个例子来看这个过程，下图是一个场景，左上角有一个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172040685.png" alt="image-20220313172040685"></p>
<p>首先从光源的视角看向整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172139630.png" alt="image-20220313172139630"></p>
<p>得到一张深度图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172152108.png" alt="image-20220313172152108"></p>
<p>然后再从相机的视角去计算哪些是阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313172230122.png" alt="image-20220313172230122"></p>
<p>最后就得到了场景阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313174252951.png" alt="image-20220313174252951"></p>
<h4 id="阴影映射的缺陷"><a href="#阴影映射的缺陷" class="headerlink" title="阴影映射的缺陷"></a>阴影映射的缺陷</h4><p>阴影映射可以得到场景的阴影关系，但存在很多问题。</p>
<ul>
<li><p>阴影映射的质量取决于阴影贴图的分辨率，分辨率越高自然阴影质量越好</p>
</li>
<li><p>由于深度都是浮点数，计算机中是无法判断两个浮点数完全相等的，因此会存在一定的误差，这也会影响阴影的效果</p>
</li>
<li><p>阴影映射只能得到“硬阴影”，因为我们的阴影映射是逐像素进行的，因此对于每一个像素只有被遮挡和没被遮挡两种情况，因此我们得到的阴影边界非常清晰，如下图：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313180907623.png" alt="image-20220313180907623"></p>
<p>但实际我们看到的阴影是存在<strong>半影（Penumbra）</strong>现象的，半影就是指能看到部分光源的地方，比如日全食的时候，我们在全影（Umbra）区完全看不到太阳，就产生了日全食，而在半影区我们可以看到一部分太阳，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181023004.png" alt="image-20220313181023004"></p>
<p>半影表现在阴影上就像下面的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/image-20220313181151360.png" alt="image-20220313181151360"></p>
<p>这样的阴影边界不那么清晰，是“软阴影”，显得更加真实。</p>
<p>对于这样的软阴影该如何渲染，我们从下一节开始讨论光线追踪后，就会了解。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十二）辐射度量学基础</title>
    <url>/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="辐射度量学（Radiometry）"><a href="#辐射度量学（Radiometry）" class="headerlink" title="辐射度量学（Radiometry）"></a>辐射度量学（Radiometry）</h3><p>上一节我们学习了 Whitted 风格光线追踪的基本原理和优化结构，Whitted 风格光线追踪是基于布林冯光照模型的渲染方式，回顾布林冯光照模型，其中有一个概念我们一直不清楚，那就是所有光照公式中的光照强度 $I$ 是如何定义的，光照强度到底是什么，是从哪里来的，又要用什么去衡量？并且上一节中我们也看到了，其实利用 Whitted 风格光线追踪渲染出来的图片并没有想象中那么真实，这是因为我们从头到尾都没有准确的对光照进行度量和描述，所有公式中的光都是抽象的，简化的结果。因此也无法解释上面的一系列问题。</p>
<p>从这一节开始我们将学习更为先进的路径追踪技术，路径追踪技术是基于辐射度量学的光线追踪算法，而<strong>辐射度量学是可以准确描述光线的空间属性的体系，可以保证在物理上绝对正确的情况下进行各种光照的计算。</strong></p>
<p><em><span id="more"></span></em></p>
<p>为了之后更好的学习，这一节首先介绍基础辐射度量学的各种概念和公式，由于许多概念没有太准确的中文翻译，所以这一节中的概念只能在保留英文原词的基础上尽可能的加以说明。</p>
<h4 id="1-Radiant-Energy-和-Flux（Power）"><a href="#1-Radiant-Energy-和-Flux（Power）" class="headerlink" title="1 Radiant Energy 和 Flux（Power）"></a>1 Radiant Energy 和 Flux（Power）</h4><p>Radiant Energy 简单来说就是指光线的能量，物理上能量的单位是焦耳（J），所以 Radiant Energy 的单位自然也是焦耳。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150152632.png" alt="image-20220318150152632"></p>
<p>Radiant Flux 物理上叫做辐射通量，也称为功率（Power），是指单位时间内，放射、反射、折射或者接收到的光的能量，物理上功率的单位一般是瓦特（W），光学中有一个专门的单位<strong>流明（lm）</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318150419583.png" alt="image-20220318150419583"></p>
<p>辐射通量还可以理解为一个光源放射出光线，在单位时间内通过一个平面的光线的数量，这样理解更符合”通量“这个概念，但辐射通量（功率）用我们生活上的经验来理解指的其实就是”亮度“，比如我们买灯泡，功率越大肯定就越亮，所以 Radiant Flux 描述的就是光的亮度，<strong>因此功率就代表光的强度。后文中提到的所有光的强度指的都是辐射通量，也就是功率。</strong></p>
<h4 id="2-Radiant-Intensity"><a href="#2-Radiant-Intensity" class="headerlink" title="2 Radiant Intensity"></a>2 Radiant Intensity</h4><p>之前我们一直不知道如何描述一个点光源向四面八方辐射出的光线的强度，因为我们不知道如何定义空间中任意一个方向。回顾平面中我们是如何定义任意一个方向的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151148501.png" alt="image-20220318151148501"></p>
<p>显然是用角度来定义的，一个单位圆就可以定义平面中任意一个方向，高中知识也告诉我们这个角度等于弧长除以半径，因为整个圆的周长是 $2\pi r$，所以角度最大就是 $2\pi$，单位是弧度（radians）。那这个概念能不能推广到空间中呢？当然可以。</p>
<p>空间中的一个单位球就可以定义任意一个方向，从圆心向球面投射出一块小的区域 A ，当这个区域足够小的时候这个锥体就指示了一个方向，我们用这个椎体的面积除以球的半径的平方就得到了类似于二维中的角度，我们把这个角度称为<strong>立体角（Solid Angle）</strong>，因为球的表面积是 $4\pi r^2$，所以立体角最大是 $4\pi$，单位是 sr（steradians）.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151731669.png" alt="image-20220318151731669"></p>
<p>Radiant Intensity 就是用来描述<strong>一个点光源放射出的单位立体角上的光的强度</strong>的物理量。<strong>所谓单位立体角，我们永远可以理解为它就是一个方向。</strong>这句话非常关键，对于后面其他概念的理解很有帮助。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318151022165.png" alt="image-20220318151022165"></p>
<p>根据上面的公式，Radiant Intensity 的单位是（lm &#x2F; sr），有一个专门的名字叫做 candela，candela 也是国际标准单位之一。</p>
<p>其中微分立体角 $d\omega$ 如何表述呢？可以利用微积分知识得到另一个表达式，考虑空间中的单位球体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318152452914.png" alt="image-20220318152452914"></p>
<p>实际上之前定义空间中任意一个方向我们更为熟悉的方式是用角度 $\theta$ 和 $\phi$ 来唯一确定球上任意一个半径方向，也就指示了空间中任意一个方向，其中 $\theta$ 是半径与 Z 轴的夹角， $\phi$ 是半径绕 Z 轴旋转的角度。那么考虑一个单位立体角，假设这个立体角是半径分别在 $\theta$ 和 $\phi$ 方向上移动 $d\theta$ 和 $d\phi$ 角度形成的，于是它对应球面上一个非常小的矩形 $dA$，我们要计算这个矩形的面积就要求出它的两个边长，矩形垂直的边长对应的就是以 $r$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\theta$ ，所以矩形的垂直边长就是 $r·d\theta$，同理矩形水平的边长对应的是以 $r·sin\theta$ 为半径的圆上的一段圆弧，圆弧对应的角度是 $d\phi$ ，所以矩形的水平边长就是 $r·sin\theta ·d\phi$，因此可以得到微分矩形的面积：<br>$$<br>\begin{split}<br>dA &amp;&#x3D; (r·d\theta)(r·sin\theta ·d\phi) \\<br>&amp;&#x3D; r^2 sin\theta \ d\theta \ d\phi<br>\end{split}<br>$$<br>于是微分立体角就是：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>之前说过，因为立体角表示的是整个球面上某一块的面积与半径平方的比值，所以立体角最大就是 $4\pi$，因此在球面上对所有立体角 $\omega$ 积分一定得到的是 $4\pi$，整个球面对 $\omega$ 积分实际上就是对 $\theta$ 在 $[0,\pi]$， $\phi$ 在 $[0,2\pi]$ 上积分，就是一个简单的二重积分：<br>$$<br>\begin{split}<br>\Omega &amp;&#x3D; \int_{S^2} d \omega \\<br>&amp;&#x3D;\int_{0}^{2\pi} \int_{0}^{\pi} sin\theta \ d\theta \ d\phi \\<br>&amp;&#x3D; 4\pi<br>\end{split}<br>$$<br>现在再回顾 Radiant Intensity 的定义，Radiant Intensity 描述的就是一个点光源朝四面八方辐射出去的光的通量（功率）。如果我们假设一个点光源向各个方向辐射出的强度是相同的，那么每个单位立体角上的强度就是一样的，假设为 $I$，则光源本身的强度 $\Phi$ 相当于每个单位立体角上的强度 $I$ 的积分：<br>$$<br>\begin{split}<br>\Phi &amp;&#x3D; \int_{S^2} I \ d\omega \<br>&amp;&#x3D; 4\pi I<br>\end{split}<br>$$<br>因此每个单位立体角上的强度 $I$ 就是：<br>$$<br>I &#x3D; \frac{\Phi}{4\pi} \ (candelas)<br>$$<br>比如一个 LED 灯泡的功率是 815 流明，那么它的 Radiant Intensity 就是：<br>$$<br>Intensity &#x3D; \frac{815 \ lm}{4\pi \ sr} &#x3D; 65 \ candelas<br>$$</p>
<h4 id="3-Irradiance"><a href="#3-Irradiance" class="headerlink" title="3 Irradiance"></a>3 Irradiance</h4><p>Intensity 是用来描述一个光源发出的光的强度的物理量，那自然要有一个物理量用来描述一个点接收的光有多少，Irradiance 表示<strong>单位面积入射的光的强度</strong>，单位是 $lm &#x2F; m^2$，也有一个专门的名字叫做 lux。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318160656284.png" alt="image-20220318160656284"></p>
<p>这里的单位面积指的是<strong>投影单位面积</strong>，我们规定只有光线和这个面垂直，才去计算 Irradiance，因此如果这个面和光线入射方向不垂直，那就把这个面投影到垂直的方向上再计算，实际上这也是之前布林冯光照模型中用到的 Lambert’s 余弦定理的原理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161132535.png" alt="image-20220318161132535"></p>
<p>因此一个表面和入射光的夹角越接近直角，它单位面积接收到的光的能量就越大。</p>
<p>利用 Irradiance 还可以解释布林冯光照模型中光的强度随距离衰减为什么是 $I&#x2F;r^2$。回顾当时的一张图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318161604597.png" alt="image-20220318161604597"></p>
<p>现在我们用辐射度量学的角度来理解这张图，如果光源的强度是 $\Phi$，假设光源向四面八方都是均匀辐射的，在光源处有一个单位球面把光源包起来，那么这个球面上每一处的 Irradiance 就是光源的强度除以球的表面积，单位球半径为1，因此：<br>$$<br>E &#x3D; \frac{\Phi}{4\pi}<br>$$<br>而距离光源半径为 $r$ 的球面上每一处的 Irradiance 就是：<br>$$<br>E’ &#x3D; \frac{\Phi}{4\pi r^2} &#x3D; \frac{E}{r^2}<br>$$<br>所以之前说的光的强度随距离衰减实际上是 Irradiance 在随着距离衰减。</p>
<h4 id="4-Radiance"><a href="#4-Radiance" class="headerlink" title="4 Radiance"></a>4 Radiance</h4><p>到目前为止，我们已经有了描述光源发出的光的强度的物理量 Intensity 和描述单位面积接收到的光的强度的物理量 Irradiance，接下来就是最重要的一个概念——Radiance，Radiance 是用来描述光线的物理量，而我们后续渲染时的所有计算都是基于光线的计算，所以说 Radiance 是最重要的一个概念。</p>
<p>Radiance 定义为<strong>单位立体角、单位投影面积上发射、反射、折射或入射的光的强度</strong>。单位是 $lm&#x2F;(sr·m^2)$，也有一个专门的名字叫做尼特（nit）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318162959095.png" alt="image-20220318162959095"></p>
<p>虽然已经有了心理准备，但这个概念还是太过抽象了。不过我们可以一点一点拆开来看。从上面的公式可以看到，实际上 Radiance 就是单位立体角、单位面积的光的强度。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163414923.png" alt="image-20220318163414923"></p>
<p>回顾 Radiant Intensity 的定义，Radiant Intensity 是单位立体角上的光的强度，那么 Radiance 不就是单位面积上的 Radiant Intensity 吗；同理，Irradiance 是单位面积上的光的强度，那么 Radiance 不也可以是单位立体角上的 Irradiance 吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318163639208.png" alt="image-20220318163639208"></p>
<p>现在我们在抽象上好像明白 Radiance 是什么了，接下来分别分析一下这两种说法对应的都是什么物理意义。</p>
<ul>
<li>Radiance 相当于单位面积上的 Radiant Intensity，Radiant Intensity 是指一个点光源放射出的单位立体角上的强度，所以Radiance就是<strong>一个光源单位面积上放射出的单位立体角的上的光的强度</strong>。之前说过，单位立体角我们永远可以理解为它就是一个方向，因此上面这句话就可以理解成<strong>一个光源单位面积上放射出的某个方向上的光的强度</strong>。这相当于我们不考虑整个光源向某个方向放射出的能量有多少，而是只考虑光源上的某一个单位平面向某个方向放射出的能量有多少，同样这里的单位面积一定是投影单位面积。因此从这个角度来说，<strong>Radiance 表示的是沿着某个立体角表示的方向 $\omega$ 离开单位平面 dA 的光的强度</strong>。这里的”离开“自然可以代表发射、反射、折射等等。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318164148266.png" alt="image-20220318164148266"></p>
<ul>
<li>Radiance 相当于单位立体角上的 Irradiance，Irradiance 表示单位面积入射的光的强度，单位立体角又表示方向，所以Radiance 就是单位面积在某个方向上入射的光的强度。也就是一个单位平面从四面八方都会接收到光，但 Radiance 只表示这个单位平面接收到的从某个方向 $\omega$ 入射来的光的强度。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318165844563.png" alt="image-20220318165844563"></p>
<p>下面的图有助于更进一步理解 Radiance 和 Irradiance 的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220318170234173.png" alt="image-20220318170234173"></p>
<p>Irradiance 是单位平面 $dA$ 从各个方向接收到的全部的光的强度，Radiance 是单位平面 $dA$ 从单位立体角 $d\omega$ 方向接收到的光的强度，因此对 Radiance 在半球面的各个方向 $d\omega$ 上积分，得到的就是各个方向接收到的光的强度的总和，也就是 Irradiance 。</p>
<p>这样一来我们就可以理解 Radiance 的物理含义了，同时也就明白为什么开头说 Radiance 是表示光线的物理量，因为它既有方向，又有大小。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十四）材质</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="材质（Materials）"><a href="#材质（Materials）" class="headerlink" title="材质（Materials）"></a>材质（Materials）</h3><p>这一节开始学习图形学中材质的相关内容。我们之所以能看到现实世界中不同的物体有不同的材质，本质上就是因为不同材质对光线的吸收、反射、折射的能力不同，而描述这种能力的函数就是我们上一节中简单了解过的双向反射分布函数（BRDF），上一节中也说过，BRDF 就是材质，因此这一节讨论的内容实际上就是 BRDF。</p>
<p><em><span id="more"></span></em></p>
<p>双向反射分布函数（BRDF）描述反射的性质，那自然也存在双向折射分布函数（BTDF），他们统称为 BSDF，但一般来说 BRDF 也可以广义上代表折射或其他，因此也并没有严格的区分，说到 BRDF 就可以代表各种材质。</p>
<h4 id="1-漫反射材质"><a href="#1-漫反射材质" class="headerlink" title="1 漫反射材质"></a>1 漫反射材质</h4><p>漫反射是最简单的一种反射，但也算是最常见的，光线朝四面八方反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100847526.png" alt="image-20220322100847526"></p>
<p>漫反射材质也是最简单的一种材质，是我们日常生活中经常见到的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322100939770.png" alt="image-20220322100939770"></p>
<p>它的 BRDF 也非常简单，回顾布林冯光照模型中对漫反射的描述，其中漫反射系数当时我们理解为一个颜色，并且漫反射系数取值在 [0, 1] 之间，描述有多少光被反射了出去，那实际上漫反射系数的功能不就和 BRDF 一样吗，现在我们用之前学过的知识来推导漫反射系数到底是什么。</p>
<p>我们先考虑一个最简单的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322101511437.png" alt="image-20220322101511437"></p>
<p>假设一个着色点的所有入射光，也就是各个方向入射的 Radiance 都是相等的，并且之前我们学过，漫反射与观察方向无关，也是均匀的向各个方向反射出去，也就是说各个方向出射的 Radiance 也是相等的。而 BRDF 是关于方向的函数，可漫反射又与方向无关，这说明漫反射的 BRDF 就是一个常数，只是一个系数用来描述入射进来的光有多少被反射出去。因此我们可以写出反射方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102049675.png" alt="image-20220322102049675"></p>
<p>因为入射的 Radiance 都是相等的，所以 $L_i(\omega_i)$ 与 $\omega_i$ 无关，就可以统一写成一个常数 $L_i$，而 BRDF 也是常数，因此反射方程就是一个在半球面上关于函数 $cos\theta$ 的积分，积分结果就是 $\pi$，因此我们可以得到：反射出去的光 $L_o$ 就等于 $\pi f_r$ 倍的入射光 $L_i$ ，那么假设现在这个表面完全不吸收光，有多少入射就全部反射出去，那也就是 $L_o&#x3D;L_i$ ，即  $\pi f_r&#x3D;1$，因此这种情况下，漫反射的 BRDF 就是：<br>$$<br>f_r &#x3D; \frac{1}{\pi}<br>$$<br> 当然实际情况是表面一定会吸收一定的能量，因此漫反射的 BRDF 为：<br>$$<br>f_r &#x3D; \frac{\rho}{\pi}, \ \rho \in [0,1]<br>$$<br>这样就描述了入射的光有多少被反射了出去，因此漫反射的 BRDF 的取值范围不是 $[0, 1]$，而是 $[0,\frac{1}{\pi}]$，当然 $\rho$ 也可以是一个三维向量，分别对应 [r, g, b] 分别反射多少。</p>
<h4 id="2-Glossy-反射材质"><a href="#2-Glossy-反射材质" class="headerlink" title="2 Glossy 反射材质"></a>2 Glossy 反射材质</h4><p>Glossy 反射我们也很熟悉了，之前经常提到，上一节中也解释了 Glossy 反射是因为表面相对较为粗糙，以至于入射光不能完美的沿着镜面反射方向反射，而是沿着镜面反射方向一定范围内的区域反射出去，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322102939224.png" alt="image-20220322102939224"></p>
<p>Glossy 材质的效果如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103228125.png" alt="image-20220322103228125"></p>
<h4 id="3-折射材质"><a href="#3-折射材质" class="headerlink" title="3 折射材质"></a>3 折射材质</h4><p>折射我们学过物理应该也很熟悉，类似水、玻璃之类的都是折射材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103310715.png" alt="image-20220322103310715"></p>
<p>折射材质的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103330971.png" alt="image-20220322103330971"></p>
<p>左边是空气到水面，右边是空气到玻璃。折射材质表面的反射可以看成是完美的镜面反射，那么如何描述一个完美的镜面反射呢，我们知道空间中可以靠一个方位角 $\phi$ 和一个俯仰角 $\theta$ 来确定一个方向，那么描述完美镜面反射其实也就是描述入射光和反射光方向的关系。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103540198.png" alt="image-20220322103540198"></p>
<p>对于俯仰角，两条光线的俯仰角要一样，那也就是两个方向向量的和的长度刚好是图中红线的二倍：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103659282.png" alt="image-20220322103659282"></p>
<p>这样就得到用入射方向表示的出射方向了，对于一个完美镜面反射，只要知道了入射方向向量我们就可以算出出射方向。</p>
<p>对于方位角，就简单很多，如下图，是上面的场景的俯视图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103833701.png" alt="image-20220322103833701"></p>
<p>显然，只要两个方向共线即可。</p>
<p>接下来讨论折射，学过物理我们知道折射与折射率有关，因此折射的俯仰角和方位角的关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322103957053.png" alt="image-20220322103957053"></p>
<p>俯仰角满足入射光线与法线夹角乘以入射材质的折射率等于出射光线与法线夹角乘以出射材质的折射率，方位角关系和反射一样，右边还给出了常见材质的折射率。</p>
<p>于是根据这样的关系，知道了入射方向与法线的夹角，就可以得到出射方向与发现的夹角了，我们还可以稍微进行一下变形：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104134927.png" alt="image-20220322104134927"></p>
<p>对于出射角 $\theta _t$ 来说，它的余弦必须是实数，而右边的根号可能会得到非实数，这样就没有意义，也就相当于折射不会发生，因此当根号下的数小于0 时，不会发生折射。而我们观察整个根号下的式子，要想小于0 ，就必须使得：<br>$$<br>(\frac{\eta_i}{\eta_t})^2(1-cos^2\theta_i) &gt; 1<br>$$<br>显然 $(1-cos^2\theta_i)$ 不可能大于 1 ，因此只有当 $\frac{\eta_i}{\eta_t} &gt; 1$ 时，不会发生折射，也就是入射材质的折射率大于出射材质的折射率时，折射可能不会发生，比如从水面向空气中传播的光线，就会有一部分不会发生折射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322104805300.png" alt="image-20220322104805300"></p>
<p>因此我们在水下看向水面永远只能看到一个锥形区域，而其它部分都是黑的。</p>
<h4 id="4-菲涅尔项"><a href="#4-菲涅尔项" class="headerlink" title="4 菲涅尔项"></a>4 菲涅尔项</h4><p>生活中我们有很多现象与菲涅尔项描述的问题有关，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105314627.png" alt="image-20220322105314627"></p>
<p>我们从不同的视角看这本书，看到的书在桌面上的反射是不同的，这是因为最左边的图，我们视线的入射角大，因此观察到的反射就弱，而右边我们视线的入射角小，观察到的反射就强：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105454152.png" alt="image-20220322105454152"></p>
<p>这就是菲涅尔项描述的东西。可以做一个简单的理解：<strong>菲涅尔效果就是在反射效果中，离你近的反射得更模糊，离你远的反射得更清晰。</strong></p>
<p>当然从科学上解释就相对比较复杂了，目前只要知道菲涅尔项描述的是光在两种不同折射率的介质中传播时的反射和折射就可以了。</p>
<p>下图展示的是折射率为 1.5 的绝缘体的入射角和反射率之间的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322105926927.png" alt="image-20220322105926927"></p>
<p>可以看到入射方向和法线夹角越大，相当于我们的观察角度越小，反射就越强。虚线代表极化后的光线的反射率，整体趋势是一样的。</p>
<p>下图是导体的反射率：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110109442.png" alt="image-20220322110109442"></p>
<p>这说明导体无论从什么视角看，都可以看到相对明显的反射，比如金属之类的材质。</p>
<p>菲涅尔项的数学公式如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110600896.png" alt="image-20220322110600896"></p>
<p>其中 $R_S$ 和 $R_P$ 是水平和垂直偏振光，也就是极化光的菲涅尔公式，我们在渲染中一般不考虑极化，因此取二者的平均即可。但是由于菲涅尔公式比较复杂，因此一般用 Schlick’s 近似来近似菲涅尔系数；</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322110925864.png" alt="image-20220322110925864"></p>
<p>$R_0$ 是初始反射率，可以看到与两种材质的折射率有关， Schlick’s 近似显然会随着入射方向和法线夹角增大使得反射率从 $R_0$ 变为 1，和我们上面看到的图是差不多的，因此可以近似地表示菲涅尔项。</p>
<p>总体来说菲涅尔项描述的就是有多少光会发生反射，于是剩余的光就发生折射，在之后的渲染中我们也是用菲涅尔系数来混和计算得到的反射颜色和折射颜色的。</p>
<p>利用菲涅尔项还可以解释金属为什么几乎不会产生漫反射，因为金属的折射率是复数，对于金属来说, 由于金属内部是可以自由运动的电子，菲涅尔项表示反射的部分光，那么剩余的部分则是折射进金属内部被自由电子转化为其他形式的能量，相当于直接被金属吸收了，不会在内部发生次表面散射再从表面其他位置出去，因此也就几乎没有漫反射，而菲涅尔项表示的反射部分是高光反射，金属的菲涅尔项的基础反射率一般都代表了高光反射的颜色，也就体现为金属的颜色，例如金子的金色和铝的银色等。而对于非金属材质，高光反射颜色比较单一，并且会发生次表面散射，因此大部分被我们看到的是漫反射颜色。</p>
<h4 id="5-微表面材质"><a href="#5-微表面材质" class="headerlink" title="5 微表面材质"></a>5 微表面材质</h4><p>微表面材质是现在应用极为广泛的材质，简单来说就是一个凹凸不平的表面在近处看可以看出凹凸的材质，但在远处看就只能看到一个光滑的镜面反射，这也符合我们生活中的物理事实，关键在于如何用 BRDF 来描述微表面材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120246445.png" alt="image-20220322120246445"></p>
<p>上面的图实际上已经体现了微表面材质的一个核心思想，就是凹凸不平的表面的每一个微表面的法线方向会有明显的不同，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322120412707.png" alt="image-20220322120412707"></p>
<p>对于一个相对平滑的表面，它的各个微表面的法线方向会集中在一个范围内，但是对于一个粗糙的表面，它的各个微表面的法线方向分布会较为分散，因此描述微表面的 BRDF 的一个关键就是法线分布。微表面的 BRDF 写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121119399.png" alt="image-20220322121119399"></p>
<p>其中 D 是法线分布函数，表示有多少微表面会被看到，只有微表面的法线方向在光线入射方向和观察方向的半程向量方向才会被看到，如下图 (a) ；G 是阴影项，因为微表面凹凸不平，那么当入射光线贴着表面入射时，表面上就会有一部分微表面被其他微表面遮挡住而产生阴影，类似于我们之前说的环境光遮蔽，G 就是用来描述法线方向是半程向量的微表面中有多少微表面会因为互相遮挡而不被看到； F 是菲涅尔项，表示这些微表面有多少光会被反射，如下图 (b) 和 (c)：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220410181553709.png" alt="image-20220410181553709"></p>
<p> G 就是用来描述物体表面本身的遮挡的。</p>
<p>微表面非常强大，下面是一些利用微表面材质渲染的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121530820.png" alt="image-20220322121530820"></p>
<p>可以看到表面镌刻、尼龙等细节表现得很好，而这些物体当我们离远看的时候自然不会有这样的细节，表现出的就是正常的镜面反射。</p>
<h4 id="6-各向同性和各向异性材质"><a href="#6-各向同性和各向异性材质" class="headerlink" title="6 各向同性和各向异性材质"></a>6 各向同性和各向异性材质</h4><p>我们生活中还有一些现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121710880.png" alt="image-20220322121710880"></p>
<p>铝合金锅底的这种放射的纹路，再比如电梯间的光会呈现出拉线的形状：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121740142.png" alt="image-20220322121740142"></p>
<p>仔细观察这些现象，是因为材质表面具有一定的方向性，比如上图中的电梯间的金属，明显是有竖直方向的磨砂纹路的，这样的材质就称为各向异性材质，而我们正常见到的材质被称为各向同性材质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322121927873.png" alt="image-20220322121927873"></p>
<p>可以看到各向同性材质的表面上每个点的法线方向分布是均匀的，而各向异性材质表面的法线分布是明显具有方向性的。</p>
<p>体现到 BRDF 上，各向同性材质的 BRDF 只与入射方向和出射方向的相对位置有关，也就是只要两个方向的相对位置不变，无论这两条线怎么旋转，BRDF 都是一样的；而各项异性材质的 BRDF 还与入射方向和出射方向的绝对位置有关，即使二者的相对位置不变，但是绝对位置发生变化，也会影响反射效果，即各向异性材质的 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122230386.png" alt="image-20220322122230386"></p>
<p>生活中还有很多各向异性材质，比如天鹅绒：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122318720.png" alt="image-20220322122318720"></p>
<p>再比如尼龙材质：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122347490.png" alt="image-20220322122347490"></p>
<p>还有刚才说到的金属锅、水壶之类的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122419199.png" alt="image-20220322122419199"></p>
<h4 id="7-总结-BRDF-的性质"><a href="#7-总结-BRDF-的性质" class="headerlink" title="7 总结 BRDF 的性质"></a>7 总结 BRDF 的性质</h4><p>我们见过了这么多 BRDF ，现在来总结一下 BRDF 的性质：</p>
<ul>
<li>首先是非负性，这是一定的，因为能量是守恒的，反射出去的能量只能变小或者不变，不可能反射出更多的能量：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122550593.png" alt="image-20220322122550593"></p>
<ul>
<li>线性，BRDF 可线性累加</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122608033.png" alt="image-20220322122608033"></p>
<ul>
<li>双向性， BRDF 的名字就叫双向反射分布函数，说明入射方向和出射方向可以对调，也满足同一个 BRDF</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122715819.png" alt="image-20220322122715819"></p>
<ul>
<li>能量守恒，同样是刚才说过的，反射出的能量不可能变多，最多也就是和入射的能量一样</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122757354.png" alt="image-20220322122757354"></p>
<h4 id="8-测量BRDF"><a href="#8-测量BRDF" class="headerlink" title="8 测量BRDF"></a>8 测量BRDF</h4><p>所谓测量 BRDF 是因为材质的反射性质很多时候由我们直接去定义一个函数一定是不够准确的，因此很多时候需要我们实际去测量某一种材质的 BRDF，然后再利用测量的准确值去帮助渲染。</p>
<p>要测量 BRDF 我们只需要知道入射方向、出射方向，和这两个方向上的 Radiance 就可以得到，这些值都可以借助仪器直接测量出来，因此我们只要固定光源，然后移动相机就可以得到一个入射方向上所有出射方向的 BRDF ，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132135050.png" alt="image-20220322132135050"></p>
<p>然后再把所有光源位置也都测一遍，就得到了整个材质的 BRDF，下图是一个测量 BRDF 的仪器：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132252977.png" alt="image-20220322132252977"></p>
<p>但是我们知道 BRDF 是四维的，因为它表示的是两个三维空间方向之间的关系，每一个三维空间方向可以用一个方位角和一个俯仰角表示，所以 BRDF 有四个维度，这对于测量来说，要测量的数据量会非常庞大，并且怎么样存储这些 BRDF 值也是一个巨大的挑战。</p>
<p>但我们上面刚刚学习过，各向同性 BRDF 满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322122908584.png" alt="image-20220322122908584"></p>
<p>因此，只要知道了两个方向的相对角度，就可以确定 BRDF，所以，原本四维的 BRDF 如果是各向同性的，就可以变为三维：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322131734351.png" alt="image-20220322131734351"></p>
<p>减少了一个维度，这会使 BRDF 的测量数据量大幅减少。至于如何存储又是另一个专门研究的领域，各种压缩算法，这里不再讨论。</p>
<p>MERL BRDF 数据库很早之前就测量了各种各向同性材质的 BRDF（可能现在还补充了大量各向异性材质），因此我们现在需要不同材质的 BRDF 可以直接利用这些测量好的数据，而无需考虑复杂的测量和存储方式是如何实现的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/image-20220322132659194.png" alt="image-20220322132659194"></p>
<h4 id="9-参考"><a href="#9-参考" class="headerlink" title="9 参考"></a>9 参考</h4><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/158025828">彻底看懂PBR&#x2F;BRDF方程</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/357190332">什么是菲涅尔</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十五）高级渲染和材质概述</title>
    <url>/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/</url>
    <content><![CDATA[<h3 id="高级渲染和材质概述"><a href="#高级渲染和材质概述" class="headerlink" title="高级渲染和材质概述"></a>高级渲染和材质概述</h3><p>这一节的内容涉及许多比较复杂的高级渲染方法和材质的知识，只做了解，增长见识，如果以后对哪方面需要深入学习可以方便查找。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-无偏方法和有偏方法"><a href="#1-无偏方法和有偏方法" class="headerlink" title="1 无偏方法和有偏方法"></a>1 无偏方法和有偏方法</h4><p>所谓无偏（Unbiased）方法是指利用无偏蒙特卡洛估计的光线传播方法，无偏是指无论采样点多与少，最终得到的估计的期望是正确的；那自然有偏（Biased）就是指估计的期望和真实值有偏差，但如果随着采样点数量增多，估计的期望最终会收敛到正确的期望，那么称这样的估计是有偏但一致（consistent）的。</p>
<h4 id="2-无偏光线传播方法"><a href="#2-无偏光线传播方法" class="headerlink" title="2 无偏光线传播方法"></a>2 无偏光线传播方法</h4><h5 id="2-1-双向路径追踪（Bidirectional-Path-Tracing）"><a href="#2-1-双向路径追踪（Bidirectional-Path-Tracing）" class="headerlink" title="2.1 双向路径追踪（Bidirectional Path Tracing）"></a>2.1 双向路径追踪（Bidirectional Path Tracing）</h5><p>路径追踪是从相机投射光线，BDPT 是既从相机又从光源投射出光线，称为半路径，对两条半路径进行追踪，最后将两条半路径的端点连接起来形成一条通路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152353955.png" alt="image-20220324152353955"></p>
<p>当然实现起来非常困难且速度极慢，但是这种方法能够产生一些传统路径追踪难以采样到的光路，所以能够很有效地降低噪声，对于光线在光源附近传播比较复杂的场景来说，效果会非常好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152449127.png" alt="image-20220324152449127"></p>
<h5 id="2-2-Metropolis-光线传播"><a href="#2-2-Metropolis-光线传播" class="headerlink" title="2.2 Metropolis 光线传播"></a>2.2 Metropolis 光线传播</h5><p>路径追踪中一个核心问题就是怎样去尽可能多的采样一些贡献大的路径，而 MLT 方法可以自适应的生成贡献大的路径。简单来说它会避开贡献小的路径，而在贡献大的路径附近做更多局部的探索，通过特殊的变异方法，生成一些新的路径，这些局部的路径的贡献往往也很高。与双向路径追踪相比，MLT  更加鲁棒，能处理各种复杂的场景。比如说整个场景只通过门缝透进来的间接光照亮，此时传统的路径追踪方法因为难以采样到透过门缝的这样的特殊路径而产生非常大的噪声。</p>
<p>MLT 是马尔科夫链蒙特卡洛估计（Markov Chain Monte Carlo）的应用，我们知道蒙特卡洛估计以不同的概率密度函数采样得到的结果是不同的，理论上来说概率密度函数分布和被积函数分布一致的时候，得到的估计值最准确，马尔科夫链可以通过一个样本在其附近推导出另外一些样本，并且尽量使这些样本的分布和被积函数分布相似。</p>
<p>MLT 可以通过一条已知光路推导出其附近的其他光路进行渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152843564.png" alt="image-20220324152843564"></p>
<p>这种方法对一些光线传播极其复杂的场景效果很好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324152927402.png" alt="image-20220324152927402"></p>
<p>缺点是无法确定什么时候会收敛，并且由于每个像素是独立计算的，每个像素的收敛时间也不同，因此有时渲染的结果会显得比较“脏”：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153048554.png" alt="image-20220324153048554"></p>
<h4 id="3-有偏光线传播方法"><a href="#3-有偏光线传播方法" class="headerlink" title="3 有偏光线传播方法"></a>3 有偏光线传播方法</h4><h5 id="3-1-光子映射（Photon-Mapping）"><a href="#3-1-光子映射（Photon-Mapping）" class="headerlink" title="3.1 光子映射（Photon Mapping）"></a>3.1 光子映射（Photon Mapping）</h5><p>光子映射非常适合渲染 caustics 情景，就是光线聚焦产生的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153218599.png" alt="image-20220324153218599"></p>
<p>再比如之前见过的水面在阳光下会有很明亮的纹路，这都是由于光线聚焦产生的。</p>
<p>光子映射首先 追踪从光源放射出的所有的光子，当光子打到漫反射表面的时候就停下，停留在当前位置，然后追踪从相机射出的光线，同样打到漫反射表面就停下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153431048.png" alt="image-20220324153431048"></p>
<p>这样对于每一个相机射出的光线所到达的位置，取其周围 N 个光源发出的光子，然后利用这些光子数量除以他们围成的面积，就可以得到当前位置的光子密度，光子密度越大的地方自然也就越亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153559255.png" alt="image-20220324153559255"></p>
<p>但是由于我们是用光子数量除以面积，但实际上面积应该是一个非常小的面积的时候，这样的除法才能代表密度，因此这只是对密度的近似，所以是一个有偏估计，但是当我们射出的光子足够多的时候，所取得 N 个光子所围成的面积也会足够小，这时得到的密度就是无限接近正确密度，因此这个方法是有偏但一致的。</p>
<p>体现到渲染结果上，如果 N 取得非常小，那结果噪声就会很大，因为偏差很大，如果 N 很大，得到的结果就会很模糊，这是因为方法本身是有偏的，有偏体现的图像上就是模糊：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153904111.png" alt="image-20220324153904111"></p>
<p>因此我们说：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324153945548.png" alt="image-20220324153945548"></p>
<h5 id="3-2-Vertex-Connection-and-Merging"><a href="#3-2-Vertex-Connection-and-Merging" class="headerlink" title="3.2 Vertex Connection and Merging"></a>3.2 Vertex Connection and Merging</h5><p>VCM 是一种应用非常广泛的光线传播算法，结合了双向路径跟踪和光子映射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154056618.png" alt="image-20220324154056618"></p>
<h5 id="3-3-实时辐射（Instant-Radiosity）"><a href="#3-3-实时辐射（Instant-Radiosity）" class="headerlink" title="3.3 实时辐射（Instant Radiosity）"></a>3.3 实时辐射（Instant Radiosity）</h5><p>IR 的核心思想非常简单，把每一个被光源间接照亮的点都当成新的光源。渲染其他点时考虑所有这些虚拟光源，这样相当于考虑了光线的多次弹射，因此只需要用计算直接光照的方法就可以得到间接光照的结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154257580.png" alt="image-20220324154257580"></p>
<p>这种方法效率高，效果也不错，但无法渲染 glossy 反射，并且有时边缘会莫名发光，这和采样时积分转换过程有关，这里不展开讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154348327.png" alt="image-20220324154348327"></p>
<h4 id="4-高级材质"><a href="#4-高级材质" class="headerlink" title="4 高级材质"></a>4 高级材质</h4><h5 id="4-1-散射介质"><a href="#4-1-散射介质" class="headerlink" title="4.1 散射介质"></a>4.1 散射介质</h5><p>散射介质（Participating Media）也叫参与介质，是指云、雾一类的会对光具有散射作用的介质。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154623569.png" alt="image-20220324154623569"></p>
<p>我们可以把他们当成空间中的颗粒，光线传播到每个颗粒上时，会有一部分被吸收，有一部分发生散射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154711282.png" alt="image-20220324154711282"></p>
<p>因此只要描述颗粒吸收光线和散射光线的性质就可以，吸收光线由散射介质的性质决定，比如乌云就会吸收大量光导致光线传播不出去，而散射性质由相位函数（Phase Function）来描述，相位函数描述一个颗粒散射的时候向各个方向会散射多少，有的是均匀散射，有的向前方散射多后方散射少：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324154909876.png" alt="image-20220324154909876"></p>
<p>渲染的时候我们可以假设光线向前传播一段距离就会发生一次散射，具体传播多远由介质性质决定，具体怎么散射由相位函数决定，然后最终到达光源，将光源和所有散射点链接，计算每个散射点的着色就可以形成云雾透过光线的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155103056.png" alt="image-20220324155103056"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155121487.png" alt="image-20220324155121487"></p>
<h5 id="4-2-毛发材质"><a href="#4-2-毛发材质" class="headerlink" title="4.2 毛发材质"></a>4.2 毛发材质</h5><p>毛发材质的渲染最早采用的是很简单的方式，将头发当作一根圆柱，光线打到圆柱上时，一部分会正常发生镜面反射，另一部分会呈锥形散射出去，将这两种计算叠加起来就得到头发的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155339434.png" alt="image-20220324155339434"></p>
<p>但是这样渲染出来的效果并不好，因为这和布林冯光照模型几乎一样，没有体现出头发的材质特性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155414673.png" alt="image-20220324155414673"></p>
<p>头发实际上是可以被光线穿过的，穿过头发的光线还会在头发内部发生反射再折射出去，因此人们把头发看作一个玻璃管：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155506941.png" alt="image-20220324155506941"></p>
<p>射到头发表面的光线，一部分发生反射，即为 R，另一部分折射进头发内部再从另外一面折射出去，即为 TT，还有一部分在头发内部反射再从这边的表面折射出去，即为 TRT，这三部分的总和构成最终渲染结果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155652739.png" alt="image-20220324155652739"></p>
<p>同时我们把头发外表面称作 cuticle，头发内部称作 cortex，头发内部是有色素的，因此也决定了光线在内部传播的性质。这个方法称为Marschner model，效果非常不错：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155821388.png" alt="image-20220324155821388"></p>
<p>但对于动物毛发，也是用这样的方法会得到不太好的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155848465.png" alt="image-20220324155848465"></p>
<p>这是由于动物毛发和人类毛发构造有些不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324155910248.png" alt="image-20220324155910248"></p>
<p>在头发中心还有一部分叫做髓质（Medulla），这部分非常复杂，光线进去之后会像在散射介质中一样发生复杂的散射，由于人类毛发髓质只占很小一部分，因此忽略掉也不会有太大影响，但是动物毛发中髓质占很大一部分，因此必须考虑光线在髓质中的散射。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160108209.png" alt="image-20220324160108209"></p>
<p>可以看到髓质对渲染结果的影响非常大，因此使用双圆柱来描述头发的结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160144068.png" alt="image-20220324160144068"></p>
<p>除了之前的 R 、T、TRT之外，双圆柱模型还考虑了光现在髓质中散射后的 TTs 和 TRTs：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160245669.png" alt="image-20220324160245669"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160325405.png" alt="image-20220324160325405"></p>
<p>这也是闫令琪老师的主要贡献之一，感兴趣可以找来论文细看。</p>
<h5 id="4-3-颗粒材质"><a href="#4-3-颗粒材质" class="headerlink" title="4.3 颗粒材质"></a>4.3 颗粒材质</h5><p>颗粒材质也非常复杂，可以定义在空间中，然后计算光线和每个小颗粒的作用。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160506385.png" alt="image-20220324160506385"></p>
<h5 id="4-4-半透明材质"><a href="#4-4-半透明材质" class="headerlink" title="4.4 半透明材质"></a>4.4 半透明材质</h5><p>半透明材质是因为光线打到物体表面后，在物体内部发生了多次散射，之后又从其表面的其他地方出去。光线在物体内部的散射称为次表面散射（Subsurface Scattering）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160705666.png" alt="image-20220324160705666"></p>
<p>按照这样的性质可以把 BRDF 稍作改进， BRDF 描述光线从一个方向入射会有多少从另一个方向射出，但是这两个方向都是从表面上同一个点出发的，次表面散射的 BRDF 称为 BSSRDF，描述的是光线从一个方向入射，会从表面的其他点沿着某个方向射出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324160907689.png" alt="image-20220324160907689"></p>
<p>因此这回渲染方程的积分除了要对所有方向积分外，还要对整个表面进行积分。</p>
<p>后来人们发现半透明就好像物体内部有一个光源一样，所以可以按照这种思路在物体内部放一个光源来模拟半透明的效果，但是还要在外部有另一个虚拟光源才能达到正确的半透明效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161102328.png" alt="image-20220324161102328"></p>
<p>次表面散射非常强大，因此应用非常广泛，比如人的皮肤，因为人的皮肤本身就是透光的，所以用 BSSRDF 会更加真实：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161143507.png" alt="image-20220324161143507"></p>
<p>再比如玉质物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161219954.png" alt="image-20220324161219954"></p>
<h5 id="4-5-布料材质"><a href="#4-5-布料材质" class="headerlink" title="4.5 布料材质"></a>4.5 布料材质</h5><p>布料是由一根根地线织成的，每根线又是由一股股纤维构成的，因此渲染布料可以像喧染头发一样对每根纤维进行渲染，但计算量自然非常庞大。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161605583.png" alt="image-20220324161605583"></p>
<p>因此可以把布料当成一个表面，根据织物针织的方法，定义不同的 BRDF：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161706245.png" alt="image-20220324161706245"></p>
<p>但对于天鹅绒这类布料，它的线是向外发散分布的，并不是按规律织起来的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161915668.png" alt="image-20220324161915668"></p>
<p>因此不适合当成一个表面去渲染，这时可以把它当成空间中的散射介质，像渲染云雾一样去渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324161825842.png" alt="image-20220324161825842"></p>
<p>当然效果最好的还是一开始说的渲染每一根纤维，只是计算量太大：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162002053.png" alt="image-20220324162002053"></p>
<h5 id="4-6-细节材质"><a href="#4-6-细节材质" class="headerlink" title="4.6 细节材质"></a>4.6 细节材质</h5><p>有时渲染的不真实不是因为渲染的不好，而是因为渲染出来的物体太过完美而显得不真实，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162108682.png" alt="image-20220324162108682"></p>
<p>而实际的车和鼠标的表面是这样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162127568.png" alt="image-20220324162127568"></p>
<p>另外当光线在非常细小的地方传播的时候就不得不考虑光的波动性，而不能只考虑光的几何特性，比如渲染出金属表面的颗粒效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162342490.png" alt="image-20220324162342490"></p>
<p>如何做出这些细节，这也是闫令琪老师的另一大贡献，更多可以看论文。</p>
<h5 id="4-7-程序化生成材质"><a href="#4-7-程序化生成材质" class="headerlink" title="4.7 程序化生成材质"></a>4.7 程序化生成材质</h5><p>这个我们之前在纹理映射部分提到过，对于一些没有规律的花纹，比如花瓶以及它内部的纹路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162506356.png" alt="image-20220324162506356"></p>
<p>我们如果把这些空间中的每个点的材质都存下来是不现实的，因此会定义一个空间中的噪声函数去生成这样的噪声，这就是程序化生成材质，应用也非常广泛，除了上面的花瓶纹路，再比如木质品：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162620934.png" alt="image-20220324162620934"></p>
<p>水面的波浪：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%9D%90%E8%B4%A8%E5%89%8D%E6%B2%BF/image-20220324162634485.png" alt="image-20220324162634485"></p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】优先队列和堆</title>
    <url>/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</url>
    <content><![CDATA[<p><strong>优先队列（Priority Queue）</strong>是计算机科学中的一类<strong>抽象数据类型</strong>。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。<strong>堆（Heap）</strong>是一种数据结构，是<strong>实现优先队列的一种方式</strong>。所以堆并不等同于优先队列。</p>
<p><em><span id="more"></span></em></p>
<p>优先队列还有其他的实现方式，比如数组和链表。但是，这些实现方式只能保证插入操作和删除操作中的一种操作可以在 <em>O(1)</em> 的时间复杂度内完成，而另外一个操作则需要在 <em>O(N)</em> 的时间复杂度内完成。堆能够使优先队列的插入操作在 <em>O(log N)</em> 的时间复杂度内完成，删除操作在 <em>O(log N)</em> 的时间复杂度内完成。</p>
<h3 id="1-堆的定义和基本操作"><a href="#1-堆的定义和基本操作" class="headerlink" title="1 堆的定义和基本操作"></a>1 堆的定义和基本操作</h3><p>堆是一种特殊的二叉树，满足以下两个条件：</p>
<ul>
<li>是完全二叉树，所谓完全二叉树是指叶子节点只能出现在最下层和次下层的二叉树，树中每一个结点的编号都和满二叉树一一对应</li>
<li>每一个节点的值都必须<strong>大于等于或者小于等于</strong>其孩子节点的值</li>
</ul>
<p>堆具有以下特点：</p>
<ul>
<li>可以在 <em>O(logN)</em> 的时间复杂度内向堆中插入元素；</li>
<li>可以在 <em>O(logN)</em> 的时间复杂度内在堆中删除元素；</li>
<li>可以在 <em>O(1)</em> 的时间复杂度内获取堆中最大或最小的元素；</li>
</ul>
<p>堆分为小顶堆和大顶堆两类：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1610956684-VBPCQt-image.png" alt="1610956684-VBPCQt-image"></p>
<p>堆的基本操作有插入（在堆中插入一个元素同时保持堆的性质不变）、删除（删除堆顶元素同时保持堆的性质不变）和获取堆顶元素。</p>
<p>在 C++ 中已经有内置方法实现了堆，所以一般来说并不需要我们去实现一个堆 。我们只需要掌握堆在 C++ 中的常用方法，使我们能灵活的运用堆去解决问题即可。</p>
<p>C++ STL 实现了对存储在数组或 vector 中的元素进行堆操作的函数，包括创建堆和堆的基本操作：</p>
<ul>
<li>创建堆：make_heap(<strong>_First, _Last, _Comp</strong>)，默认是大顶堆</li>
<li>在堆中添加元素：push_heap(<strong>_First,  _Last, _Comp</strong>)，该函数实际上是用来调整堆序的，要先在 vector 中 push_back 一个元素到尾部，然后再使用 push_heap，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max_heap.<span class="built_in">push_back</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">push_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>在堆中删除元素：pop_heap(<strong>_First, _Last, _Comp</strong>)，该函数是删除原本的堆顶元素，并将该元素放到 vector 末尾，用 vector 原来的末尾元素作为新的堆顶元素，因此该函数执行完毕后要取走原本的堆顶元素还要使用 vector.pop_back()，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出了堆顶元素（也叫删除堆顶元素），放到了底层容器的末尾，原来末尾的元素替代堆顶，end迭代器减1，重新siftdown了堆</span></span><br><span class="line"><span class="built_in">pop_heap</span>(max_heap.<span class="built_in">begin</span>(), max_heap.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//从底层容器（数组或vector）中删除了元素</span></span><br><span class="line">max_heap.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>堆排序：sort_heap(<strong>_First, _Last, _Comp</strong>)，既然每次 pop_heap 可以获得堆顶的元素（假如是大顶堆，每次都获得最大的元素，取出放到了底层容器的末尾），那么我们持续对整个 heap 做 pop_heap 操作，每次将操作的范围向前缩减一个元素（就是每次 end 迭代器减 1 ）。最终我们可以获得一个递增的序列。</li>
</ul>
<p>下面是基本使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it= v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">        cout&lt;&lt; *it &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; min=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立小顶堆</span></span><br><span class="line">    <span class="built_in">make_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//6 10 9 30 15 22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    min.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//该算法前提：必须在堆的条件下</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min); <span class="comment">//6 10 9 30 15 22 20  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆顶元素</span></span><br><span class="line">    <span class="built_in">pop_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22 6  不为小顶堆 这个pop_heap操作后，实际上是把堆顶元素放到了末尾</span></span><br><span class="line">    min.<span class="built_in">pop_back</span>();<span class="comment">//这才彻底在底层vector数据容器中删除</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//9 10 20 30 15 22  仍为小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序  保持greater，小顶堆，得到的是降序</span></span><br><span class="line">    <span class="built_in">sort_heap</span>(min.<span class="built_in">begin</span>(),min.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//试了用less，结果杂乱无章</span></span><br><span class="line">    <span class="built_in">printHeap</span>(min);<span class="comment">//30 22 20 15 10 9 注意结果是降序的哦!!!其实是调用了很多次pop_heap(...,greater..)，每一次都把小顶堆堆顶的元素往末尾放，每放一次end迭代器减1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把上面code里所有的第三个参数改为<code>less&lt;int&gt;()</code>，就是大顶堆和排序为升序。</p>
<p>C++ 中还有优先队列的实现，和普通队列的用法类似，只是在创建时略有不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认按照元素从大到小的顺序出队</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;   　　</span><br><span class="line"><span class="comment">//按照元素从小到大的顺序出队，第二个参数是容器类型</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q; </span><br><span class="line"><span class="comment">//自定义优先级</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;     </span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>     </span></span><br><span class="line"><span class="function">　　</span>&#123;        </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; q;</span><br><span class="line"><span class="comment">//结构体声明，重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;     </span><br><span class="line">　　<span class="type">int</span> x, y;     </span><br><span class="line">　　<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a, node b)     </span><br><span class="line">　　&#123;         </span><br><span class="line">　　　　<span class="keyword">return</span> a.x &gt; b.x;    <span class="comment">//结构体中，x小的优先级高     </span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br></pre></td></tr></table></figure>

<h3 id="2-堆的应用"><a href="#2-堆的应用" class="headerlink" title="2 堆的应用"></a>2 堆的应用</h3><h4 id="2-1-堆排序"><a href="#2-1-堆排序" class="headerlink" title="2.1 堆排序"></a>2.1 堆排序</h4><p>C++ 中已经提供了堆排序，我们也已经了解了堆排序的过程，之后会在专门的排序算法专题中再次学习堆排序。</p>
<h4 id="2-2-Top-K-问题"><a href="#2-2-Top-K-问题" class="headerlink" title="2.2 Top K 问题"></a>2.2 Top K 问题</h4><p>Top K 问题是最经典的用堆（优先队列）解决的问题。</p>
<h5 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></h5><blockquote>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
</blockquote>
<p>一种解法是创建小顶堆，然后取 k 次堆顶元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop_heap</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr.<span class="built_in">back</span>());</span><br><span class="line">            arr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法调用了 K 次删除操作，因此时间复杂度是 O(KlogN)。</p>
<p>另一种解法是创建大顶堆，向堆中添加元素，当堆中有 K 个元素时，每次添加元素前与堆顶元素对比，如果当前元素比堆顶元素大则舍弃，如果当前元素比堆顶元素小，则删除堆顶元素并将当前元素加入堆，这样遍历完整个数组后，堆中的元素就是最小的 k 个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">make_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; ans[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pop_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                    <span class="built_in">push_heap</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最坏情况下每一次都要替换堆顶元素，因此时间复杂度为 O(NlogK)。可以看出使用堆的实现会使代码显得非常繁琐，因此一般使用优先队列编码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)  <span class="keyword">return</span> ans;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然由于 STL 的 priority_queue 内部实际上也是使用堆实现的，因此效率不如我们直接调用堆函数高。但使用起来更方便，更符合 STL 一般容器的常规用法。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>找的最大元素用小顶堆，算法同上，这次我们只需要输出堆顶元素即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt;= q.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数据流中的第-K-大元素"><a href="#数据流中的第-K-大元素" class="headerlink" title="数据流中的第 K 大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">数据流中的第 K 大元素</a></h5><blockquote>
<p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>
<p>请实现 KthLargest 类：</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> 使用整数 k 和整数流 nums 初始化对象。</li>
<li><code>int add(int val)</code> 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</li>
</ul>
</blockquote>
<p>我们使用优先队列直接解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: nums) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的问题中我们都直接使用了 STL 提供的堆的实现，接下来借这道题，我们来自己手写一个堆的实现。</p>
<h5 id="自己实现一个堆"><a href="#自己实现一个堆" class="headerlink" title="自己实现一个堆"></a>自己实现一个堆</h5><p>首先根据之前学习的堆的基本知识我们知道，堆是一个完全二叉树，但是在编程语言中并不是用二叉树来实现堆的，而是用一个数组来实现。这是因为堆中父节点和子节点之间的编号是有一定的关系的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/1609834142-VnDgJC-%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt="1609834142-VnDgJC-幻灯片1"></p>
<p>从上图可以看出堆中父节点和子节点的编号的关系：</p>
<ul>
<li>已知一个节点编号 index ，它的父节点的编号为 ：</li>
</ul>
<p>$$<br>index_{parent} &#x3D; \lfloor \frac{index-1}{2} \rfloor<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的左孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{leftchild} &#x3D; 2 \times index + 1<br>$$</p>
<ul>
<li>已知一个节点编号 index ，它的右孩子节点的编号为 ：</li>
</ul>
<p>$$<br>index_{rightchild} &#x3D; 2\times index + 2<br>$$</p>
<p>有了这个关系我们可以轻松的在一个数组中找到给定节点的父节点和孩子节点，接下来考虑如何实现堆的基本操作：插入和删除元素。</p>
<ul>
<li>向堆中插入一个元素：我们只需要把该元素插入数组末尾，然后不停的向上调整该元素的位置直到符合堆的要求</li>
<li>在堆中删除一个元素：我们把当前堆顶和末尾元素交换，然后将新的堆顶元素向下调整位置直到符合堆的要求</li>
</ul>
<p>具体的过程可以看<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/solution/python-dong-hua-shou-xie-shi-xian-dui-by-ypz2/">手写堆实现动画</a>，更方便理解。</p>
<p>因此为了达成上面的操作，我们需要写两个调整元素位置的函数，以及其他基本功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="type">bool</span> greater = <span class="number">0</span>;   <span class="comment">//默认为大顶堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> greater = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;greater = greater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greater ? heap[i] &lt; heap[j] : heap[i] &gt; heap[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向下调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果有孩子节点</span></span><br><span class="line">        <span class="keyword">while</span>(index * <span class="number">2</span> + <span class="number">1</span> &lt; heap.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> largest = index;</span><br><span class="line">            <span class="type">int</span> leftchild = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rightchild = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(leftchild, largest)) largest = leftchild;</span><br><span class="line">            <span class="keyword">if</span>(rightchild &lt; heap.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">compare</span>(rightchild, largest)) largest = rightchild;</span><br><span class="line">            <span class="keyword">if</span>(largest == index) <span class="keyword">break</span>; <span class="comment">//如果当前根节点已经是当前子树最大或最小的节点则调整完毕</span></span><br><span class="line">            <span class="built_in">swap</span>(largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//向上调整节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">while</span>(index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(parent, index)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(index, parent);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="built_in">AdjustUp</span>(heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//删除元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, heap.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">前 K 个高频元素</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<p>哈希表统计频数即可，主要是学习C++优先队列如何自定义比较函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num, count] : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; q.<span class="built_in">top</span>().second)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> q.<span class="built_in">push</span>(<span class="built_in">pair</span>(num, count));</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是定义了一个结构体，在结构体中定义比较函数，构造优先队列时相当于传入函数对象。还可以用下面的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp);</span><br></pre></td></tr></table></figure>

<p>decltype 函数用于获取函数指针，传入的是函数的地址。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（一）实现基本工具类</title>
    <url>/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这部分我们将使用 C++ 从零开始实现一个光线追踪器。首先需要实现一些在简单的光线追踪器中要用到的基本工具类，包含三维向量类、光线类，以及一些之后可能频繁用到的工具函数。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-三维向量类"><a href="#1-三维向量类" class="headerlink" title="1 三维向量类"></a>1 三维向量类</h3><p>尽管在正规的光线追踪器中使用更多的是四维向量，比如齐次坐标和带有 A 通道的颜色，但是对于我们这个简化的光线追踪器来说，三维向量已经足够了，我们可以使用三维向量表示位置、方向、颜色等，为了区分这三种表示，我们给三维向量类 <code>vec3</code>起两个别名 <code>point3</code> 和 <code>color</code> 以方便之后代码的编写和阅读，但他们实质上没有任何区别，我们没有为了不同的表示构造一个专门的类，这意味着一个颜色和一个位置可以进行相加，这在正常的光线追踪工程实现中是不被允许的，但我们毕竟是简化版本，只要在使用的时候注意即可。</p>
<p>我们首先在该类中实现一些基本的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  实现三维向量类，用于存储位置、向量、颜色等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类及常用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> e[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec3</span>() : e&#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">vec3</span>(<span class="type">double</span> e0, <span class="type">double</span> e1, <span class="type">double</span> e2) : e&#123; e0, e1, e2 &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> e[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3 <span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">vec3</span>(-e[<span class="number">0</span>], -e[<span class="number">1</span>], -e[<span class="number">2</span>]); &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line">    <span class="type">double</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123; <span class="keyword">return</span> e[i]; &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">        e[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">        e[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">        e[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        e[<span class="number">0</span>] *= t;</span><br><span class="line">        e[<span class="number">1</span>] *= t;</span><br><span class="line">        e[<span class="number">2</span>] *= t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> <span class="type">double</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= <span class="number">1</span>/t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length_squared</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e[<span class="number">0</span>] * e[<span class="number">0</span>] + e[<span class="number">1</span>] * e[<span class="number">1</span>] + e[<span class="number">2</span>] * e[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">length_squared</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义vec3的别名，分别用于存储点和颜色，提升代码可读性</span></span><br><span class="line"><span class="keyword">using</span> point3 = vec3;</span><br><span class="line"><span class="keyword">using</span> color = vec3;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在工程实践中，文件开头的 <code>#pragma once</code> 是必须的，否则可能因为头文件重复包含导致编译错误，定义类时的判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC3_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC3_H</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也是必须的，同样是为了防止重复编译。</p>
<p>然后实现一些对向量操作的工具函数，大部分是运算符重载，以让我们可以按照之前的习惯操作三维向量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******一些工具函数*******/</span></span><br><span class="line"><span class="keyword">inline</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; v.e[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>+(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] + v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] + v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] + v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>-(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] - v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] - v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] - v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应元素相乘</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>], u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>], u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向量和标量运算</span></span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">double</span> t, <span class="type">const</span> vec3&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(t * v.e[<span class="number">0</span>], t * v.e[<span class="number">1</span>], t * v.e[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>*(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> vec3 <span class="keyword">operator</span>/(<span class="type">const</span> vec3&amp; v, <span class="type">double</span> t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / t) * v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.e[<span class="number">0</span>] * v.e[<span class="number">0</span>] + u.e[<span class="number">1</span>] * v.e[<span class="number">1</span>] + u.e[<span class="number">2</span>] * v.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叉乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(u.e[<span class="number">1</span>] * v.e[<span class="number">2</span>] - u.e[<span class="number">2</span>] * v.e[<span class="number">1</span>],</span><br><span class="line">        u.e[<span class="number">2</span>] * v.e[<span class="number">0</span>] - u.e[<span class="number">0</span>] * v.e[<span class="number">2</span>],</span><br><span class="line">        u.e[<span class="number">0</span>] * v.e[<span class="number">1</span>] - u.e[<span class="number">1</span>] * v.e[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单位化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">normalize</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v / v.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用于最后的图像输出，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 注意输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">x</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">y</span>());</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">255.999</span> * pixel_color.<span class="built_in">z</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-光线类"><a href="#2-光线类" class="headerlink" title="2 光线类"></a>2 光线类</h3><p>光线类是基于三维向量类的，我们按照图形学中射线的定义来实现一个光线类，给定空间中一个位置和一个方向就可以确定一条射线，再给定时间 t，就可以得到射线上任意一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现光线类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-图像输出"><a href="#3-图像输出" class="headerlink" title="3 图像输出"></a>3 图像输出</h3><p>我们所有渲染结果最终都要输出到一张图片中，我们可以选择任何输出格式，这里使用了非常方便的开源的图像工具 <a href="https://github.com/nothings/stb">stb_image </a>，将结果保存到数组中然后使用 <code>stbi_write_png</code> 函数保存为 PNG 格式图片。我们用一个生成渐变图片的例子来了解图像输出流程。</p>
<p>首先定义一个 <code>ray_color</code> 函数，根据给定的方向机型简单的线性插值，以混合两种不同的颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据归一化的方向的y坐标线性混合白色和蓝色，以得到自上而下的蓝白色渐变效果</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义相机所在位置为 (0, 0, 0)，屏幕（输出的图片）比例为 16 : 9，因此我们的视口比例也要和最终的图片比例一致，然后从屏幕左上角开始遍历，从相机向屏幕投射光线，根据该光线方向通过 <code>ray_color</code> 函数计算插值颜色显示到屏幕上。场景大致如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/fig-1.03-cam-geom.jpg" alt="fig-1.03-cam-geom"></p>
<p>下面实现主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;BlendColor.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename; </span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，可以刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/11/20220411-RayTracer-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/BlendColor.png" alt="BlendColor"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（七）景深效果</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>到目前为止，我们的简易光线追踪器就差不多了，接下来对相机进行一些改进，使得我们能在任何角度观察场景并且模拟镜头相机的景深效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-更强大的相机"><a href="#1-更强大的相机" class="headerlink" title="1 更强大的相机"></a>1 更强大的相机</h3><p>到目前为止我们的相机基本上还是固定的，我们希望能够让相机更强大一些。比如可以调节视场角大小以扩充我们的视野，以及能够移动相机，从不同的角度观察整个场景。</p>
<h4 id="1-1-自定义视场"><a href="#1-1-自定义视场" class="headerlink" title="1.1 自定义视场"></a>1.1 自定义视场</h4><p>对于视场角，一般使用垂直视场角，我们将视场角加到相机类的构造函数中，通过视场角和宽高比来计算视口尺寸，这是一个简单的几何计算：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.14-cam-view-geom.jpg" alt="fig-1.14-cam-view-geom"></p>
<p>我们假设视口平面在 z &#x3D; -1 处，于是视口的高度 h 即为：<br>$$<br>h &#x3D; tan(\frac{\theta}{2})<br>$$<br>由此我们可以修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">    <span class="built_in">camera</span>(<span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-自定义指向和位置"><a href="#1-2-自定义指向和位置" class="headerlink" title="1.2 自定义指向和位置"></a>1.2 自定义指向和位置</h4><p>接下来我们希望摄像机能在任何位置任何角度观察场景。首先回顾之前图形学中学习的如何固定一个相机位置和姿态，我们需要一个位置、观察方向，以及一个 up 向量，这个 up 向量指定了相机旋转的角度，然后我们要根据这些值来计算在这个对应的角度下视口平面是怎样的，这可以通过两次叉乘得到：</p>
<ul>
<li>up 向量和观察方向 w 叉乘得到视口平面 u 方向</li>
<li>u 方向和 w 方向叉乘得到视口平面 v 方向</li>
</ul>
<p>其中观察方向 w 可以通过给定的相机位置 lookfrom 和要观察的点 lookat 得到，我们沿着 -w 方向观察，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/fig-1.16-cam-view-up.jpg" alt="fig-1.16-cam-view-up"></p>
<p>于是我们可以继续修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(point3 lookfrom, point3 lookat, vec3 vup, <span class="type">double</span> vfov, <span class="type">double</span> aspect_ratio) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        <span class="keyword">auto</span> w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        <span class="keyword">auto</span> u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        horizontal = viewport_width * u;</span><br><span class="line">        vertical = viewport_height * v;</span><br><span class="line">        <span class="comment">// 视口平面左下角点</span></span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + s * horizontal + t * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;CameraView.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(point3(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>), point3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), vec3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">90</span>, aspect_ratio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.45</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraView.png" alt="CameraView"></p>
<p>调整视场角为 30 度，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/CameraViewTiny.png" alt="CameraViewTiny"></p>
<h3 id="2-散焦模糊"><a href="#2-散焦模糊" class="headerlink" title="2 散焦模糊"></a>2 散焦模糊</h3><p>之前我们投射光线都假设相机的镜头是一个只容纳一根光线的针孔，一根光线投射出去会打到场景中的一个点，但实际相机的镜头是一个透镜，透镜会将场景中多束光线汇聚到一个点上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/20200301194134436.png" alt="20200301194134436"></p>
<p>对于树的顶点P，其传入到成像屏幕的范围，从之前的一条光线，扩大到 L1 到 L2 两条光线之间的部分，尽管采样的光线变多了，但并不影响这一棵树的清晰成像，因为目前这棵树到相机的距离，刚好是新的屏幕到相机的距离，即焦点距离。焦点距离不等同于焦距，焦距是投影点到图像平面的距离。</p>
<p>但是如果我们的相机向前移动一点，原本能采样到树顶的像素颜色，变成了多条光线采样值的混合色，也就是树顶部下面一片区域的颜色，从而导致这个像素变模糊，越往前移动，越模糊，因为 L1 和 L2 的区间会扩大更多；而如果我们的相机向后移动一点，并延长光线L1 和 L2 至树的纵切平面，则会采样天空和树头顶的颜色的混合色，同样实现模糊。越往后，L1 和 L2 的区间将会扩大，从而越模糊。</p>
<p>因此，只要物体到相机的距离不等于焦点距离，就会出现模糊，光圈越大，采样射线的跨度越大，模糊效果越明显，这就是散焦模糊的原理。我们为了简单的模拟这一过程，可以将原本相机位置的一个点，变为相机所在位置为中心的一个圆盘内的点，然后从圆盘内的多个点出发，投射光线到场景中并采样求平均，就可以实现上述镜头景深的效果。</p>
<p>首先先增加一个生成单位圆盘内随机点的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成单位圆盘内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_unit_disk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="built_in">random_double</span>(<span class="number">-1</span>, <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist   <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改相机参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = (lookfrom - lookat).<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur.png" alt="DefoucsBlur"></p>
<p>减小光圈将会降低模糊：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> aperture = <span class="number">1.0</span>;</span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/DefoucsBlur1.0.png" alt="DefoucsBlur1.0"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（八）构建随机场景</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>到目前为止，最简单的光线追踪器就构建完成了，在开始进一步完善之前，我们先随机向场景中加入许多不同材质不同属性的球体，渲染第一张“完整的”光线追踪图片。</p>
<p><em><span id="more"></span></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.75</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.95</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;final.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">3.0</span> / <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">1200</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%9E%84%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9C%BA%E6%99%AF/FinalRender2.png" alt="FinalRender2"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（六）电介质</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>这一节开始实现诸如水、玻璃、钻石等透明材质，他们都是电介质（dielectric ），光线到达电介质会发生折射，因此首先要计算折射光线。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-折射光线"><a href="#1-折射光线" class="headerlink" title="1 折射光线"></a>1 折射光线</h3><p>之前在图形学中我们知道，Snell‘s law 描述了折射光线和入射光线之间存在关系：<br>$$<br>\eta·sin\theta &#x3D; \eta’·sin\theta’<br>$$<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/fig-1.13-refraction.jpg" alt="fig-1.13-refraction"></p>
<p>所以求解折射光线就是求解折射角 $\theta’$，$\theta’$ 是折射光线 $R’$ 和法线的夹角，我们可以把  $R’$ 分解为垂直于法线的分量和平行于法线的分量 ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220435357.png" alt="image-20220416220435357"></p>
<p>然后可以根据两个分量的计算公式得到折射光线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/image-20220416220421971.png" alt="image-20220416220421971"></p>
<p>其中 $cos\theta$ 可以通过归一化的入射光线和法线的点乘得到，因此垂直分量可以改写为：<br>$$<br>R’_{perp} &#x3D; \frac{\eta}{\eta’}(R + (-R·n) \ n)<br>$$<br>由此我们可以编写一个计算折射光线的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算折射光线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">refract</span><span class="params">(<span class="type">const</span> vec3&amp; R, <span class="type">const</span> vec3&amp; n, <span class="type">double</span> etai_over_etat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-R, n), <span class="number">1.0</span>);</span><br><span class="line">    vec3 r_out_perp = etai_over_etat * (R + cos_theta * n);</span><br><span class="line">    vec3 r_out_parallel = -<span class="built_in">sqrt</span>(<span class="built_in">fabs</span>(<span class="number">1.0</span> - r_out_perp.<span class="built_in">length_squared</span>())) * n;</span><br><span class="line">    <span class="keyword">return</span> r_out_perp + r_out_parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-电介质材质"><a href="#2-电介质材质" class="headerlink" title="2 电介质材质"></a>2 电介质材质</h3><p>有了折射光线计算，我们可以实现一个只计算折射光线的电介质材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        vec3 refracted = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, refracted);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景，将中间和左边的球体材质更换为电介质，设置折射率为1.5，模拟玻璃材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>

<p>得到的结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract.png" alt="Refract"></p>
<p>这看起来显然是不对的，因为我们现在只计算了折射光线，但是当介质折射率较大的时候，有可能存在无法发生折射的情况，也就是 $\theta’$ 无解，比如上面的玻璃，折射率为 1.5，那么：<br>$$<br>sin\theta’ &#x3D; \frac{1.5}{1}sin\theta<br>$$<br>可能出现 $sin\theta’$ 大于 1 的情况，此时不会发生折射，这个现象我们在图形学中也有学过。</p>
<p>因此我们需要在材质的散射函数中做一个判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (refraction_ratio * sin_theta &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 折射</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 反射</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是修改我们的电介质材质类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract)</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景中的材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/Refract1.png" alt="Refract1"></p>
<h3 id="3-加入菲涅尔项"><a href="#3-加入菲涅尔项" class="headerlink" title="3 加入菲涅尔项"></a>3 加入菲涅尔项</h3><p>现在为电介质材质加入菲涅尔项，使其随着观察角度变化发生更多的反射，依然使用 Schlick’s 近似计算菲涅尔项，修改后的最终材质类如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们现在实现的电介质材质类是简化后的版本，光线打到物体上要么发生反射，要么发生折射，我们并没有同时考虑折射光线和反射光线。</p>
<h3 id="4-空心玻璃球"><a href="#4-空心玻璃球" class="headerlink" title="4 空心玻璃球"></a>4 空心玻璃球</h3><p>对于玻璃球来说，如果使用负半径，几何形状不受影响，但表面法线指向内（可以回顾球体类中 <code>hit</code> 方法的实现）。这可以作为一个气泡来制作一个中空的玻璃球：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line"><span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">0.3</span>);</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">-0.4</span>, material_left));</span><br><span class="line">world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br></pre></td></tr></table></figure>

<p>我们向场景中左边球体内加了一个同心半径为负的球体，使它们构成了一个空心玻璃球，渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E7%94%B5%E4%BB%8B%E8%B4%A8/RefractHollow.png" alt="RefractHollow"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二）实现物体类</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/</url>
    <content><![CDATA[<p>有了基本工具类，现在我们可以回顾图形学中的知识，从最简单的渲染一个球体开始，逐渐熟悉光线追踪的实现。<br><em><span id="more"></span></em></p>
<h3 id="1-渲染一个球体"><a href="#1-渲染一个球体" class="headerlink" title="1 渲染一个球体"></a>1 渲染一个球体</h3><p>在光线追踪中如果投射出的光线碰到了物体，就计算该点的颜色作为像素值，那么我们从最简单的情形开始，渲染一个球体，我们在 z &#x3D; -1 处放置一个球体，然后计算投射出的每一条光线和该球体是否有交点，如果有的话我们将该像素设置为一个定值，这样就可以在屏幕上显示出这个球体了。</p>
<p>计算光线和空间中球体是否有交点我们在图形学中已经学过，非常简单，对于射线 $P(t)$ 和一个空间中球心在 $C$ ，半径为 $r$  的球体，如果射线上的点在球面上，则满足：<br>$$<br>(P(t)−C)⋅(P(t)−C)&#x3D;r^2<br>$$<br>将 $P(t) &#x3D; A + t \vec b$ 代入得：<br>$$<br>(A+t\vec b−C)⋅(A+t\vec b−C)&#x3D;r^2<br>$$<br>再展开即可得到关于 $t$ 的一元二次方程：<br>$$<br>t^2 \vec b⋅\vec b+2t\vec b⋅(A−C)+(A−C)⋅(A−C)−r^2&#x3D;0<br>$$<br>只需要判断这个一元二次方程有没有实数根即可。于是我们可以写出判断光线是否和球体相交的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">	<span class="keyword">return</span> (discriminant &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在之前的 <code>ray_color</code> 函数中加上判断光线是否和球体相交的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//放置在 z = -1 处的一个半径为0.5的球体</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r)) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">	<span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/Sphere.png" alt="Sphere"></p>
<p>需要注意的是，现在我们只考虑了是否有实数根，并没有考虑 t 的正负，这会导致即使把球体放到 z &#x3D; 1 处，也能得到和上图相同的结果，这相当于我们看到了在相机后面的物体，这个问题之后我们会解决。</p>
<h3 id="2-表面法线"><a href="#2-表面法线" class="headerlink" title="2 表面法线"></a>2 表面法线</h3><h4 id="2-1-可视化物体表面法线"><a href="#2-1-可视化物体表面法线" class="headerlink" title="2.1 可视化物体表面法线"></a>2.1 可视化物体表面法线</h4><p>我们计算光线与物体交点的光照时首先需要知道该交点的法线，对于一个球体来说，表面上任意一点的法线方向就是该点和球心连线的方向并从球心向外指。因此我们只要计算出投射的光线和球体的交点就可以得到该点的法向量，由于法向量是单位向量，每个分量范围都在 [-1, 1] ，因此我们可以将每个分量都映射到 [0, 1]，作为颜色值显示出来。</p>
<p>为此我们先修改刚才的 <code>hit_sphere</code> 使其返回交点的 t 值，由于我们的球体放在 z &#x3D; -1 处，所以两个交点都一定是正实数，我们返回较小的那个一根即可，即：<br>$$<br>t_{return} &#x3D; \frac{-b - \sqrt{b^2-4ac} }{2a}<br>$$<br>因为只能看到离我们最近的点，修改后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">2.0</span> * <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">	<span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">return</span> (-b - <span class="built_in">sqrt</span>(discriminant)) / (<span class="number">2.0</span> * a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//放置在 z = -1 处的一个半径为0.5的球体，计算交点法线作为颜色返回</span></span><br><span class="line">	<span class="keyword">auto</span> t = <span class="built_in">hit_sphere</span>(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>, r);</span><br><span class="line">	<span class="keyword">if</span> (t &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		vec3 normal = <span class="built_in">normalize</span>(r.<span class="built_in">at</span>(t) - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">		<span class="keyword">return</span> (normal + <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vec3 unit_dir = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="comment">// 归一化后y的范围是[-1,1]，将其映射到[0,1]作为混合系数</span></span><br><span class="line">	t = <span class="number">0.5</span> * (unit_dir.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/SphereNormal.png" alt="SphereNormal"></p>
<h4 id="2-2-代码优化"><a href="#2-2-代码优化" class="headerlink" title="2.2 代码优化"></a>2.2 代码优化</h4><p>上面的 <code>hit_sphere</code> 函数有一些可以优化的地方，首先两个相同向量的点乘，可以通过我们在 <code>vec3</code> 类中定义的 <code>length_squared()</code> 方法得到，另外考虑方程的求根公式：<br>$$<br>\frac{-b \pm \sqrt{b^2-4ac} }{2a}<br>$$<br>如果把 b 替换成 2h，可以得到：<br>$$<br>\frac{-2h \pm \sqrt{(2h)^2-4ac} }{2a}<br>$$<br>展开整理得：<br>$$<br>\frac{-h \pm \sqrt{h^2-ac} }{a}<br>$$<br>于是我们只需要计算 b 的一半即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断光线是否与球体相交</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">hit_sphere</span><span class="params">(<span class="type">const</span> point3&amp; center, <span class="type">double</span> radius, ray&amp; r)</span> </span>&#123;</span><br><span class="line">	vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">	<span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">	<span class="keyword">auto</span> h = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="built_in">dot</span>(oc, oc) - radius * radius;</span><br><span class="line">	<span class="keyword">auto</span> discriminant = h * h - a * c;</span><br><span class="line">	<span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">return</span> (-h - <span class="built_in">sqrt</span>(discriminant)) / a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多个物体"><a href="#3-多个物体" class="headerlink" title="3 多个物体"></a>3 多个物体</h3><h4 id="3-1-实现物体类"><a href="#3-1-实现物体类" class="headerlink" title="3.1 实现物体类"></a>3.1 实现物体类</h4><p>在实际场景中我们不可能只有一个物体，并且物体也不可能只是球体，还可能有有各种各样的模型，因此为了能让所有模型都可以放置到场景中并计算我们投射光线和物体的交点，我们可以先定义一个可计算交点的抽象物体类 <code>hittable</code>，这个类定义一个纯虚函数 <code>hit</code> 用来判断物体和光线的交点，然后再以该抽象类为基类，实现各种物体类即可，这样一来，不同的物体的 <code>hit</code> 函数有可以有不同的实现了。</p>
<p><code>hit</code> 函数也和我们上面写的稍有不同，除了要接收一根光线作为参数外，还要有一个限定范围 $t_{min}$ 和 $t_{max}$，只有当交点的 t 在这个范围内才会与物体相交，这部分也在之前的图形学中也有学过，同时这个范围也可以用于后面计算多个物体中最近的交点。</p>
<p>此外，光线可能和物体有多个交点，我们需要取在限定范围内的离我们最近的交点，把该交点及其法线等属性记录下来，因此还要定义一个存储交点属性的结构体。</p>
<p>最后还需要考虑一个问题，交点是物体的正面还是背面？这对我们渲染来说非常重要，尤其是一些双面不同的物体。这可以通过光线和法线的点乘来判断，如果光线和交点的法线反向，这说明交点在物体的正面，因为法线都是从物体中心指向表面的；相反如果光线和交点的法线同向，这说明交点在物体的背面。同向和反向实际上是两个向量的夹角，因此点乘即可。如果交点在物体背面，那么计算光照时用到的法线应该是这个点表面法线的反方向，所以要对原法线取反。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/fig-1.06-normal-sides.jpg" alt="fig-1.06-normal-sides"></p>
<p>现在我们可以开始实现上面的思路了，首先是抽象类和结构体的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"><span class="comment">// utilities.h 包含了常用的工具函数并整合了常用头文件，避免循环嵌套，我们在后面会实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来实现一个球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重载虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-实现物体列表类"><a href="#3-2-实现物体列表类" class="headerlink" title="3.2 实现物体列表类"></a>3.2 实现物体列表类</h4><p>现在我们已经有了可以与光线相交的物体的基类 <code>hittable</code>，可以在其基础上实现各种物体类，接下来我们要定义一个类来存储多个物体，代码比较容易理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	物体列表类hittable_list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_LIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_LIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_list</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">hittable_list</span>(shared_ptr&lt;hittable&gt; object) &#123; <span class="built_in">add</span>(object); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; objects.<span class="built_in">clear</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(shared_ptr&lt;hittable&gt; object)</span> </span>&#123; objects.<span class="built_in">push_back</span>(object); &#125;</span><br><span class="line">    <span class="comment">// 一个物体列表的hit函数用于得到光线和这个列表中所有物体最近的一个交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record temp_rec;</span><br><span class="line">    <span class="type">bool</span> hit_anything = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录当前的最近的t</span></span><br><span class="line">    <span class="keyword">auto</span> closest_so_far = t_max;</span><br><span class="line">    <span class="comment">// 遍历每一个物体</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">hit</span>(r, t_min, closest_so_far, temp_rec)) &#123;</span><br><span class="line">            hit_anything = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 更新最近的t</span></span><br><span class="line">            closest_so_far = temp_rec.t;</span><br><span class="line">            rec = temp_rec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_anything;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-关于智能指针"><a href="#3-3-关于智能指针" class="headerlink" title="3.3 关于智能指针"></a>3.3 关于智能指针</h4><p>上面的物体列表类中使用了智能指针，在之后的代码中我们也会经常使用，智能指针能帮助我们自动管理内存，防止内存泄漏，一般来说初始化一个智能指针可以使用如下形式的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line">shared_ptr&lt;vec3&gt;   vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line">shared_ptr&lt;sphere&gt; sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>auto 支持对智能指针类型的自动推导，因此我们写起来会更方便：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> double_ptr = <span class="built_in">make_shared</span>&lt;<span class="type">double</span>&gt;(<span class="number">0.37</span>);</span><br><span class="line"><span class="keyword">auto</span> vec3_ptr   = <span class="built_in">make_shared</span>&lt;vec3&gt;(<span class="number">1.414214</span>, <span class="number">2.718281</span>, <span class="number">1.618034</span>);</span><br><span class="line"><span class="keyword">auto</span> sphere_ptr = <span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>声明后就可以像正常指针一样使用了。更多关于智能指针的内容可以查看 C++ 与 STL 部分的笔记。</p>
<h3 id="4-常用常量和工具函数"><a href="#4-常用常量和工具函数" class="headerlink" title="4 常用常量和工具函数"></a>4 常用常量和工具函数</h3><p>接下来需要定义一些常用的常量以及角度转弧度等工具函数，并将一些类的头文件整合起来，使代码组织更整洁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	常用常量及工具函数</span></span><br><span class="line"><span class="comment">	整合包含其他头文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UTILITIES_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTILITIES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::shared_ptr;</span><br><span class="line"><span class="keyword">using</span> std::make_shared;</span><br><span class="line"><span class="keyword">using</span> std::sqrt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> infinity = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415926535897932385</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">degrees_to_radians</span><span class="params">(<span class="type">double</span> degrees)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> degrees * pi / <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用头文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ray.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> UTILITIES_H</span></span><br></pre></td></tr></table></figure>

<h3 id="5-再次可视化法线"><a href="#5-再次可视化法线" class="headerlink" title="5 再次可视化法线"></a>5 再次可视化法线</h3><p>使用上面实现的一系列代码，再次实现一个可视化法线的效果，首先修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">	hit_record rec;</span><br><span class="line">	<span class="comment">// 计算和世界中的物体的交点的法线</span></span><br><span class="line">	<span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.5</span> * (rec.normal + <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">	<span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;WorldSphereNormal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******相机属性*******/</span></span><br><span class="line">    <span class="comment">// 视口高度设为两个单位</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">    <span class="comment">// 视口宽度根据屏幕宽高比计算</span></span><br><span class="line">    <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">    <span class="comment">// 原点到视口平面距离为1个单位</span></span><br><span class="line">    <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 相机原点</span></span><br><span class="line">    <span class="keyword">auto</span> origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口宽的一半</span></span><br><span class="line">    <span class="keyword">auto</span> horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 视口高的一半</span></span><br><span class="line">    <span class="keyword">auto</span> vertical = <span class="built_in">vec3</span>(<span class="number">0</span>, viewport_height, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 相当于将(0,0,0)移动到视口平面的左下角，也就是得到左下角的点的位置</span></span><br><span class="line">    <span class="keyword">auto</span> lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******场景属性*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="comment">// x方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> u = <span class="built_in">double</span>(i) / (image_width - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// y方向偏移</span></span><br><span class="line">            <span class="keyword">auto</span> v = <span class="built_in">double</span>(j) / (image_height - <span class="number">1</span>);</span><br><span class="line">            <span class="function">ray <span class="title">r</span><span class="params">(origin, lower_left_corner + u * horizontal + v * vertical - origin)</span></span>;</span><br><span class="line">            color pixel_color = <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/WorldSphereNormal.png" alt="WorldSphereNormal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（九）运动模糊</title>
    <url>/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/</url>
    <content><![CDATA[<p>从这一节开始我们将进一步完善之前的光线追踪器，加入更多真正的光线追踪器中用到的算法和功能。首先我们将为场景中的物体加入运动，并且实现运动模糊效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-运动模糊实现原理"><a href="#1-运动模糊实现原理" class="headerlink" title="1 运动模糊实现原理"></a>1 运动模糊实现原理</h3><p>在实际拍照的时候，运动模糊是由于在快门时间内，物体的位置发生了变化，使得一个像素融合了物体在不同位置的颜色，从而产生模糊的效果。快门时间是指从快门开启到快门关闭的这段时间。因此我们也可以加入快门时间这一概念，在投射光线的时候，随机在快门时间内投射一条光线，并且保证场景内的物体在该时间下在它应该在的位置即可。这样就可以让一个像素融合物体在多个位置的颜色，产生运动模糊效果。</p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>根据以上原理，我们首先要为每一条光线加上一个时间属性，说明这条光线是在什么时刻被投射出的，然后就可以根据这个时刻找到该时刻场景中物体的位置，再去计算交点等后续步骤。修改 <code>ray.h</code> 如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    光线类ray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec3.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ray</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">ray</span>(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; direction, <span class="type">double</span> time = <span class="number">0.0</span>) :</span><br><span class="line">        <span class="built_in">orig</span>(origin), <span class="built_in">dir</span>(direction), <span class="built_in">tm</span>(time) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">origin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> orig; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">direction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> dir; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">time</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> tm; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">at</span><span class="params">(<span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orig + t * dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 orig;</span><br><span class="line">    vec3 dir;</span><br><span class="line">    <span class="type">double</span> tm;    <span class="comment">// 光线被投射出的时刻</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改相机类，使它能够在给定快门时间内随机投射光线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>(</span><br><span class="line">        point3 lookfrom,</span><br><span class="line">        point3 lookat,</span><br><span class="line">        vec3   vup,</span><br><span class="line">        <span class="type">double</span> vfov,</span><br><span class="line">        <span class="type">double</span> aspect_ratio,</span><br><span class="line">        <span class="type">double</span> aperture,    <span class="comment">// 光圈大小，光圈为0就是之前的针孔相机</span></span><br><span class="line">        <span class="type">double</span> focus_dist,  <span class="comment">// 焦点距离，在焦点距离处的物体不会发生散焦模糊</span></span><br><span class="line">        <span class="type">double</span> _time0 = <span class="number">0</span>,  <span class="comment">// 快门开启时间</span></span><br><span class="line">        <span class="type">double</span> _time1 = <span class="number">0</span>   <span class="comment">// 快门关闭时间</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 通过视场角和宽高比计算视口大小，视场角是垂直方向的，单位是角度</span></span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">degrees_to_radians</span>(vfov);</span><br><span class="line">        <span class="keyword">auto</span> h = <span class="built_in">tan</span>(theta / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span> * h;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="comment">// 计算视口平面的三个坐标轴</span></span><br><span class="line">        w = <span class="built_in">normalize</span>(lookfrom - lookat);</span><br><span class="line">        u = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(vup, w));</span><br><span class="line">        v = <span class="built_in">cross</span>(w, u);</span><br><span class="line">        <span class="comment">// 相机位置</span></span><br><span class="line">        origin = lookfrom;</span><br><span class="line">        <span class="comment">// 视口</span></span><br><span class="line">        horizontal = focus_dist * viewport_width * u;</span><br><span class="line">        vertical = focus_dist * viewport_height * v;</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - focus_dist * w;</span><br><span class="line">        <span class="comment">// 镜头半径等于光圈大小的一半</span></span><br><span class="line">        lens_radius = aperture / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 快门时间</span></span><br><span class="line">        time0 = _time0;</span><br><span class="line">        time1 = _time1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> s, <span class="type">double</span> t)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 圆盘内随机取一点作为偏移</span></span><br><span class="line">        vec3 rd = lens_radius * <span class="built_in">random_in_unit_disk</span>();</span><br><span class="line">        vec3 offset = u * rd.<span class="built_in">x</span>() + v * rd.<span class="built_in">y</span>();</span><br><span class="line">        <span class="comment">// 从偏离远镜头的位置投射光线，模拟散焦，并在快门时间内随机选择一个时刻作为该光线投射出的时刻</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(</span><br><span class="line">            origin + offset,</span><br><span class="line">            lower_left_corner + s * horizontal + t * vertical - origin - offset, </span><br><span class="line">            <span class="built_in">random_double</span>(time0, time1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">    vec3 u, v, w;</span><br><span class="line">    <span class="type">double</span> lens_radius;</span><br><span class="line">    <span class="type">double</span> time0;</span><br><span class="line">    <span class="type">double</span> time1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后还要记得修改材质类中构造散射光线的地方，散射光线的时刻和入射光线一致：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line"></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后修改场景中的物体类，使其能够随时间移动，目前我们只有球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">    支持移动，time0时球心在center0，time1时球心在enter1，线性移动</span></span><br><span class="line"><span class="comment">    不移动的球体可以将初始位置和结束位置设为相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(</span><br><span class="line">        point3 cen0, point3 cen1, <span class="type">double</span> _time0, <span class="type">double</span> _time1, <span class="type">double</span> r, shared_ptr&lt;material&gt; m)</span><br><span class="line">        : <span class="built_in">center0</span>(cen0), <span class="built_in">center1</span>(cen1), <span class="built_in">time0</span>(_time0), <span class="built_in">time1</span>(_time1), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center0, center1;</span><br><span class="line">    <span class="type">double</span> time0, time1;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到物体在某一时刻的球心位置</span></span><br><span class="line"><span class="function">point3 <span class="title">sphere::center</span><span class="params">(<span class="type">double</span> time)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time1 - time0 == <span class="number">0</span>) <span class="keyword">return</span> center0;</span><br><span class="line">    <span class="keyword">return</span> center0 + ((time - time0) / (time1 - time0)) * (center1 - center0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - <span class="built_in">center</span>(r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - <span class="built_in">center</span>(r.<span class="built_in">time</span>())) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>修改主函数，还是用随机构建的场景，但是球体的初始化要用新的方法，同时为了渲染快一些，我们还是用之前的 16 : 9 的 400 * 225 的分辨率，每个像素采样 100 根光线：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>,  <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\The Next Week\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MotionBlur.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">45</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    <span class="function">point3 <span class="title">lookfrom</span><span class="params">(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">lookat</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> aperture = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, <span class="number">20</span>, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    <span class="keyword">auto</span> world = <span class="built_in">random_scene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/MotionBlur.png" alt="MotionBlur"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十）实现BVH</title>
    <url>/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/</url>
    <content><![CDATA[<p>这一节我们开始考虑对光线追踪器的性能做一点优化，以应对之后更加复杂的场景。之前在渲染随机场景的时候我们的代码运行的非常慢，根据目前代码的实现过程以及之前学的图形学知识可以分析出，影响速度的一个重要瓶颈是计算光线和物体交点的部分，因为每根光线都要和场景 world 中的所有物体去计算交点，然后判断哪个离我们最近，当物体非常多的时候自然效率会很低。因此这一节我们运用图形学中学过的<strong>层次包围盒（BVH）</strong>去优化我们的代码。关于 BVH 的理论知识可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-轴对齐包围盒（AABB）"><a href="#1-轴对齐包围盒（AABB）" class="headerlink" title="1 轴对齐包围盒（AABB）"></a>1 轴对齐包围盒（AABB）</h3><p>构建 BVH 首先需要我们实现一个轴对齐包围盒类，并实现光线和 AABB 的交点计算。在图形学中我们学过计算光线和 AABB 三对平面的交点只需要用一个维度的坐标计算即可，因此我们只需要存储三对平面的坐标，这里的坐标是指一个数字，因为 AABB 是轴对齐的，因此一对平面可以表示为：<br>$$<br>x &#x3D; x_0 ,\ x&#x3D;x_1<br>$$<br>的形式，所以只需要用六个数字就可以表示一个轴对齐包围盒。</p>
<p>于是我们计算出光线和三对平面的交点 tmin 和 tmax ，然后用三对 tmin 和 tmax 判断光线是否和 AABB 有交点。判断方法也在图形学中有学过，这里不再赘述。</p>
<p>需要注意的是在实现中因为我们是用单独一个维度坐标计算的，那就有可能出现分母为 0 的情况，好消息是只要光线的起点不在两对平面之间，即使分母为 0 ，那么得到的 tmin 和 tmax 就会是同样为正无穷或者负无穷，因为计算机中 0 只是一个很小的有符号浮点数。所以我们可以使 tmin 永远为二者中较小的，tmax 永远为二者中较大的，就可以得到正确的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    轴对齐包围盒类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AABB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AABB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">aabb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 minslab;</span><br><span class="line">    point3 maxslab;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">aabb</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">aabb</span>(<span class="type">const</span> point3&amp; m1, <span class="type">const</span> point3&amp; m2) &#123; minslab = m1; maxslab = m2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> minslab; &#125;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> maxslab; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t0 = <span class="built_in">fmin</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            <span class="keyword">auto</span> t1 = <span class="built_in">fmax</span>((minslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i],</span><br><span class="line">                          (maxslab[i] - r.<span class="built_in">origin</span>()[i]) / r.<span class="built_in">direction</span>()[i]);</span><br><span class="line">            tmin = <span class="built_in">fmax</span>(tmin, t0);</span><br><span class="line">            tmax = <span class="built_in">fmin</span>(tmax, t1);</span><br><span class="line">            <span class="keyword">if</span> (tmax &lt;= tmin) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>一个更稳定的 <code>hit</code> 函数的实现方式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(<span class="type">const</span> ray&amp; r, <span class="type">double</span> tmin, <span class="type">double</span> tmax)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> invD = <span class="number">1.0f</span> / r.<span class="built_in">direction</span>()[i];</span><br><span class="line">        <span class="keyword">auto</span> t0 = (<span class="built_in">min</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">auto</span> t1 = (<span class="built_in">max</span>()[i] - r.<span class="built_in">origin</span>()[i]) * invD;</span><br><span class="line">        <span class="keyword">if</span> (invD &lt; <span class="number">0.0f</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(t0, t1);</span><br><span class="line">        tmin = t0 &gt; tmin ? t0 : tmin;</span><br><span class="line">        tmax = t1 &lt; tmax ? t1 : tmax;</span><br><span class="line">        <span class="keyword">if</span> (tmax &lt;= tmin)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的图形学中推导光线和 AABB 有交点的时候，得出的条件是 <code>tmax &gt; tmin</code> 且 <code>tmax &gt;= 0</code>，但是在上面的代码中我们并没有考虑是否满足 <code>tmax &gt;= 0</code>，这是因为这里的 <code>hit</code> 函数的 <code>tmin</code> 和 <code>tmax</code> 是作为参数给定的，我们在传入参数的时候就会保证得到的交点的 t 值一定是大于 0 的。</p>
<h3 id="2-计算-BoundingBox"><a href="#2-计算-BoundingBox" class="headerlink" title="2 计算 BoundingBox"></a>2 计算 BoundingBox</h3><p>现在需要为物体类 <code>hittable</code> 添加一个计算物体 BoundingBox 的方法，并在不同的物体中有不同的实现，该函数返回 bool 类型，因为不是所有物体都能有 BoundingBox ，比如一个无限大的平面。此外对于移动的物体，需要 BoundingBox 能够覆盖所有时刻物体所在的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    抽象类hittable，所有物体都继承该类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HITTABLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HITTABLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aabb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后实现球体的 <code>bounding_box</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::bounding_box</span><span class="params">(<span class="type">double</span> _time0, <span class="type">double</span> _time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">aabb <span class="title">box0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time0) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    <span class="function">aabb <span class="title">box1</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) - vec3(radius, radius, radius),</span></span></span><br><span class="line"><span class="params"><span class="function">        center(_time1) + vec3(radius, radius, radius))</span></span>;</span><br><span class="line">    output_box = <span class="built_in">surrounding_box</span>(box0, box1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>surrounding_box</code> 函数在 <code>aabb.h</code> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个包围盒形成一个大的包围盒</span></span><br><span class="line"><span class="function">aabb <span class="title">surrounding_box</span><span class="params">(aabb box0, aabb box1)</span> </span>&#123;</span><br><span class="line">    <span class="function">point3 <span class="title">small</span><span class="params">(fmin(box0.min().x(), box1.min().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().y(), box1.min().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmin(box0.min().z(), box1.min().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">big</span><span class="params">(fmax(box0.max().x(), box1.max().x()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().y(), box1.max().y()),</span></span></span><br><span class="line"><span class="params"><span class="function">        fmax(box0.max().z(), box1.max().z()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">aabb</span>(small, big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现物体列表 <code>hittable_list</code> 的包围盒计算，思路是计算每个物体的包围盒，然后利用 <code>surrounding_box</code> 函数合并这些包围盒形成整个场景的包围盒：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hittable_list::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (objects.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    aabb temp_box;</span><br><span class="line">    <span class="type">bool</span> first_box = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!object-&gt;<span class="built_in">bounding_box</span>(time0, time1, temp_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        output_box = first_box ? temp_box : <span class="built_in">surrounding_box</span>(output_box, temp_box);</span><br><span class="line">        first_box = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现-BVH-树"><a href="#3-实现-BVH-树" class="headerlink" title="3 实现 BVH 树"></a>3 实现 BVH 树</h3><p>在图形学中我们学过，BVH 树的中间节点只存储包围盒，叶子节点存储物体，因此我们可以实现一个 BVH 节点类，每个 BVH 节点的孩子节点可以是另外的 BVH 节点或者是场景中的物体，同时每个 BVH 节点也需要计算和光线的交点，因此我们可以让 BVH 节点类也继承于 <code>hittable</code> 基类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BVH类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BVH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BVH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bvh_node</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bvh_node</span>();</span><br><span class="line">    <span class="comment">// 可以通过hittable_list来构建BVH</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(<span class="type">const</span> hittable_list&amp; list, <span class="type">double</span> time0, <span class="type">double</span> time1)</span><br><span class="line">        : <span class="built_in">bvh_node</span>(list.objects, <span class="number">0</span>, list.objects.<span class="built_in">size</span>(), time0, time1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造BVH树</span></span><br><span class="line">    <span class="built_in">bvh_node</span>(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">        <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 孩子节点可以是其他的BVH节点也可以是物体</span></span><br><span class="line">    shared_ptr&lt;hittable&gt; left;</span><br><span class="line">    shared_ptr&lt;hittable&gt; right;</span><br><span class="line">    aabb box;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!box.<span class="built_in">hit</span>(r, t_min, t_max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hit_left = left-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">    <span class="comment">// 如果和左子树中有交点，要更新t_max，使得最终的交点是最近的交点</span></span><br><span class="line">    <span class="type">bool</span> hit_right = right-&gt;<span class="built_in">hit</span>(r, t_min, hit_left ? rec.t : t_max, rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit_left || hit_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bvh_node::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    output_box = box;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比较复杂的是构建 BVH 树，我们在构造函数中构造整个 BVH 树，对于给定的物体列表，我们将其按照某一方向（x，y，z随机选择）排序，然后一分为二，一部分放到左子树，一部分放到右子树，因此这是一个类似于二分的递归过程。当物体列表中只有两个物体的时候，左右子树各放一个物体，当只有一个物体的时候，我们把这个物体复制一份，同时放到左右子树中，这样可以保证整个 BVH 树是一个完全二叉树，并且所有非叶子节点都一定有两个孩子节点，可以方便我们之后的处理，不需要判断孩子节点是否存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bvh_node::<span class="built_in">bvh_node</span>(</span><br><span class="line">    <span class="type">const</span> std::vector&lt;shared_ptr&lt;hittable&gt;&gt;&amp; src_objects,</span><br><span class="line">    <span class="type">size_t</span> start, <span class="type">size_t</span> end, <span class="type">double</span> time0, <span class="type">double</span> time1</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 不要修改原来的物体列表</span></span><br><span class="line">    <span class="keyword">auto</span> objects = src_objects;</span><br><span class="line">    <span class="comment">// 随机选择一个划分方向，并传递相应的比较函数指针</span></span><br><span class="line">    <span class="type">int</span> axis = <span class="built_in">random_int</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> comparator = (axis == <span class="number">0</span>) ? box_x_compare</span><br><span class="line">                    : (axis == <span class="number">1</span>) ? box_y_compare</span><br><span class="line">                    : box_z_compare;</span><br><span class="line">    <span class="comment">// 区间内的物体数量</span></span><br><span class="line">    <span class="type">size_t</span> object_span = end - start;</span><br><span class="line">    <span class="comment">// 只有一个物体，同时放到两个孩子节点</span></span><br><span class="line">    <span class="keyword">if</span> (object_span == <span class="number">1</span>) &#123;</span><br><span class="line">        left = right = objects[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个物体，左右孩子结点各一个</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (object_span == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comparator</span>(objects[start], objects[start + <span class="number">1</span>])) &#123;</span><br><span class="line">            left = objects[start];</span><br><span class="line">            right = objects[start + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = objects[start + <span class="number">1</span>];</span><br><span class="line">            right = objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多个物体递归的进行划分</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先按照指定的维度进行排序</span></span><br><span class="line">        std::<span class="built_in">sort</span>(objects.<span class="built_in">begin</span>() + start, objects.<span class="built_in">begin</span>() + end, comparator);</span><br><span class="line">        <span class="comment">// 二分</span></span><br><span class="line">        <span class="keyword">auto</span> mid = start + object_span / <span class="number">2</span>;</span><br><span class="line">        left = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, start, mid, time0, time1);</span><br><span class="line">        right = <span class="built_in">make_shared</span>&lt;bvh_node&gt;(objects, mid, end, time0, time1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的box由左右两个子树的box的合并而来</span></span><br><span class="line">    aabb box_left, box_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_left)</span><br><span class="line">        || !right-&gt;<span class="built_in">bounding_box</span>(time0, time1, box_right)</span><br><span class="line">        )</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    box = <span class="built_in">surrounding_box</span>(box_left, box_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面用到了 <code>random_int</code> 函数，在 <code>utilities.h</code> 中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成[min,max]之间的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">random_int</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">random_double</span>(min, max + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及自定义的比较函数，我们根据不同的方向，按照物体或者 BVH 节点的包围盒位置从小到大排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">box_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b, <span class="type">int</span> axis)</span> </span>&#123;</span><br><span class="line">    aabb box_a;</span><br><span class="line">    aabb box_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!a-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_a) || !b-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">0</span>, box_b))</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No bounding box in bvh_node constructor.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> box_a.<span class="built_in">min</span>().e[axis] &lt; box_b.<span class="built_in">min</span>().e[axis];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_x_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_y_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box_z_compare</span><span class="params">(<span class="type">const</span> shared_ptr&lt;hittable&gt; a, <span class="type">const</span> shared_ptr&lt;hittable&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">box_compare</span>(a, b, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（三）相机类和反走样</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/</url>
    <content><![CDATA[<p>上一节渲染的球体边缘可以明显看到锯齿，为了得到更好的效果我们需要实现一个简单的反走样算法，并且实现一个相机类，以便于管理虚拟摄像机和之后的各种场景采样任务。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-生成随机数的工具函数"><a href="#1-生成随机数的工具函数" class="headerlink" title="1 生成随机数的工具函数"></a>1 生成随机数的工具函数</h3><p>首先我们要向 <code>utilities.h</code> 中添加两个生成随机数的函数，用于在像素内部随机采样，一个生成 [0 ,1] 之间的随机数，另一个可以定制随机数范围，在 C++ 11 中可以不使用传统的 <code>rand()</code> 实现，可以使用 <code>&lt;random&gt;</code> 中提供的方法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 生成[0,1]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0~1之间的均匀分布</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// random_device用于生成均匀整数，用来给mt19937播种，类似于之前的srand()</span></span><br><span class="line">    <span class="function"><span class="type">static</span> std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="comment">// 生成符合分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">distribution</span>(generator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成[min,max]之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">random_double</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min + (max - min) * <span class="built_in">random_double</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-实现相机类"><a href="#2-实现相机类" class="headerlink" title="2 实现相机类"></a>2 实现相机类</h3><p>现在我们实现一个相机类来管理虚拟摄像机以及场景中的各种采样任务，我们先使用之前的轴对齐摄像机作为默认构造方法，来实现一个简单的相机类，只需要把之前主函数中的设置相机的代码拿过来组织一下即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相机类camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camera</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">camera</span>() &#123;</span><br><span class="line">        <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_height = <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> viewport_width = aspect_ratio * viewport_height;</span><br><span class="line">        <span class="keyword">auto</span> focal_length = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        origin = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="built_in">vec3</span>(viewport_width, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        vertical = <span class="built_in">vec3</span>(<span class="number">0.0</span>, viewport_height, <span class="number">0.0</span>);</span><br><span class="line">        lower_left_corner = origin - horizontal / <span class="number">2</span> - vertical / <span class="number">2</span> - <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, focal_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">get_ray</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ray</span>(origin, lower_left_corner + u * horizontal + v * vertical - origin);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    point3 origin;</span><br><span class="line">    point3 lower_left_corner;</span><br><span class="line">    vec3 horizontal;</span><br><span class="line">    vec3 vertical;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-反走样"><a href="#3-反走样" class="headerlink" title="3 反走样"></a>3 反走样</h3><p>光线追踪中最简单的反走样就是在一个像素内部投射出多条光线，将他们的得到的颜色混合起来作为该像素的颜色。</p>
<p>在实现时，我们可以将多根光线的颜色先全部累加到像素中，然后在 <code>write_color</code> 函数中将该像素颜色除以采样数量即可。在此之前我们先在 <code>utilities.h</code> 中添加一个截断函数，用于将给定值截取在指定范围内，同时修改 <code>write_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的数字截取到[min,max]范围内</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">clamp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min) <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max) <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    r *= scale;</span><br><span class="line">    g *= scale;</span><br><span class="line">    b *= scale;</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-测试反走样效果"><a href="#4-测试反走样效果" class="headerlink" title="4 测试反走样效果"></a>4 测试反走样效果</h3><p>接下来修改主函数，测试一下反走样实现效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Antialiasing.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="comment">// 向场景中添加两个球体</span></span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/Antialiasing.png" alt="Antialiasing"></p>
<p>没有反走样的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%9B%B8%E6%9C%BA%E7%B1%BB%E5%92%8C%E5%8F%8D%E8%B5%B0%E6%A0%B7/WorldSphereNormal.png" alt="WorldSphereNormal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十一）纹理</title>
    <url>/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>我们之前实现了物体和材质，但还缺少让物体变得更丰富的纹理，因此这一节我们实现一个纹理类。纹理可以是图片，也可以是程序生成的噪声，我们之前场景中所有的物体都是纯色的，实际上纯色也可以认为是一种纹理。因此我们可以定义一个纹理抽象类，然后在此基础上实现各种不同的纹理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-实现纯色纹理"><a href="#1-实现纯色纹理" class="headerlink" title="1 实现纯色纹理"></a>1 实现纯色纹理</h3><p>纯色纹理的实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">texture</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯色纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solid_color</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">solid_color</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">solid_color</span>(color c) : <span class="built_in">color_value</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solid_color</span>(<span class="type">double</span> red, <span class="type">double</span> green, <span class="type">double</span> blue)</span><br><span class="line">        : <span class="built_in">solid_color</span>(<span class="built_in">color</span>(red, green, blue)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    color color_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来要更新 <code>hit_record</code> ，存储交点的纹理坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">double</span> u;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">double</span> v;           <span class="comment">//纹理坐标</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-计算纹理坐标"><a href="#2-计算纹理坐标" class="headerlink" title="2 计算纹理坐标"></a>2 计算纹理坐标</h3><p>对于球体来说，计算纹理坐标其实就是把球面上每一个点映射到纹理平面 uv 上。最简单的表示一个球面上的点的方法是用方位角 $\phi$ 和俯仰角 $\theta$，由于 uv 平面的范围是 [0, 1]，所以映射关系为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200148322.png" alt="image-20220418200148322"></p>
<p>给定方位角和俯仰角，可以计算球心在原点的单位球面上的一点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/image-20220418200253256.png" alt="image-20220418200253256"></p>
<p>于是我们可以通过光线和球面的交点坐标解出方位角和俯仰角然后映射为纹理坐标。根据以上公式可以看出俯仰角 $\theta &#x3D; arccos(-y)$，方位角 $\phi &#x3D; arctan(-z &#x2F; x)$，反三角函数计算可以直接使用 <code>&lt;cmath&gt;</code> 提供的函数 <code>acos</code> 和 <code>atan2</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(z, -x);</span><br></pre></td></tr></table></figure>

<p>但是 <code>atan2</code> 返回的值的范围是 $[-\pi, \pi]$ ，并且是从 0 到 $\pi$，再从 $-\pi$ 到 0，这样映射的话，纹理坐标 u 就会是从 0 到 1&#x2F;2，再从 -1&#x2F;2 到 0，是不对的，但是可以利用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">atan2</span>(a, b) == <span class="built_in">atan2</span>(-a, -b) + pi;</span><br></pre></td></tr></table></figure>

<p> 这个公式返回的是从 0 到 $2\pi$ 的连续值，就可以映射为正确的纹理坐标了。因此可以通过：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">theta = <span class="built_in">acos</span>(-y)</span><br><span class="line">phi = <span class="built_in">atan2</span>(-z, x) + pi;</span><br></pre></td></tr></table></figure>

<p>得到正确的方位角和俯仰角，然后映射得到纹理坐标。在球体类中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算给定球面上的点p的纹理坐标，p是圆心在原点的单位球面上的坐标，一般用归一化的法线</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_sphere_uv</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">double</span>&amp; u, <span class="type">double</span>&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">        u = phi / (<span class="number">2</span> * pi);</span><br><span class="line">        v = theta / pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时更新球体的 <code>hit</code> 函数，将纹理坐标记录到 <code>hit_record</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="built_in">get_sphere_uv</span>(outward_normal, rec.u, rec.v);</span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-为材质类添加纹理"><a href="#3-为材质类添加纹理" class="headerlink" title="3 为材质类添加纹理"></a>3 为材质类添加纹理</h3><p>现在我们可以为所有的材质增加纹理，代替之前的颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-格子纹理"><a href="#4-格子纹理" class="headerlink" title="4 格子纹理"></a>4 格子纹理</h3><p>我们利用两种纹理交替形成一个格子纹理，这是一种经典的生成格子纹理的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格子纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">checker_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">checker_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(shared_ptr&lt;texture&gt; _even, shared_ptr&lt;texture&gt; _odd)</span><br><span class="line">        : <span class="built_in">even</span>(_even), <span class="built_in">odd</span>(_odd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checker_texture</span>(color c1, color c2)</span><br><span class="line">        : <span class="built_in">even</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c1)), <span class="built_in">odd</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> sines = <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">x</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">y</span>()) * <span class="built_in">sin</span>(<span class="number">10</span> * p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="keyword">if</span> (sines &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> odd-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> even-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; odd;</span><br><span class="line">    shared_ptr&lt;texture&gt; even;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5 测试效果"></a>5 测试效果</h3><p>我们把随机场景中的地面的球体改为格子纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/CheckerTexture.png" alt="CheckerTexture"></p>
<h3 id="6-新的场景"><a href="#6-新的场景" class="headerlink" title="6 新的场景"></a>6 新的场景</h3><p>接下来我们构建一个新的场景，由于之后我们可能还会有其他场景，为了便于管理，我们新建一个 <code>sence.h</code> 来存放各种场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机构建场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">random_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list world;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line">    <span class="keyword">auto</span> ground_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, ground_material));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">-11</span>; a &lt; <span class="number">11</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-11</span>; b &lt; <span class="number">11</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> choose_mat = <span class="built_in">random_double</span>();</span><br><span class="line">            <span class="function">point3 <span class="title">center</span><span class="params">(a + <span class="number">0.9</span> * random_double(), <span class="number">0.2</span>, b + <span class="number">0.9</span> * random_double())</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((center - <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">0.2</span>, <span class="number">0</span>)).<span class="built_in">length</span>() &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                shared_ptr&lt;material&gt; sphere_material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.8</span>) &#123;</span><br><span class="line">                    <span class="comment">// diffuse</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>() * <span class="built_in">random_vec</span>();</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(albedo);</span><br><span class="line">                    <span class="comment">// 移动的小球</span></span><br><span class="line">                    <span class="keyword">auto</span> center2 = center + <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center2, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (choose_mat &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">                    <span class="comment">// metal</span></span><br><span class="line">                    <span class="keyword">auto</span> albedo = <span class="built_in">random_vec</span>(<span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">auto</span> fuzz = <span class="built_in">random_double</span>(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;metal&gt;(albedo, fuzz);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// glass</span></span><br><span class="line">                    sphere_material = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">                    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">                        center, center, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.2</span>, sphere_material));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material1 = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material2 = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.4</span>, <span class="number">0.2</span>, <span class="number">0.1</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> material3 = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.5</span>), <span class="number">0.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, material3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> world;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个球体场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> checker = <span class="built_in">make_shared</span>&lt;checker_texture&gt;(<span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>), <span class="built_in">color</span>(<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>), <span class="number">10</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(checker)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******创建相机*******/</span></span><br><span class="line"><span class="function">vec3 <span class="title">vup</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dist_to_focus = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">camera <span class="title">cam</span><span class="params">(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E7%BA%B9%E7%90%86/TwoSphere.png" alt="TwoSphere"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十三）图片纹理</title>
    <url>/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>之前我们实现了纯色和噪声纹理，但它们都是程序生成的纹理，这一节我们通过读入图片，实现图片纹理映射。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-图片纹理类"><a href="#1-图片纹理类" class="headerlink" title="1 图片纹理类"></a>1 图片纹理类</h3><p>要实现图片纹理类，我们先要读入一张图片，这可以用到一开始存图使用的轻量而强大的 <code>stb_image</code> 库，然后我们要找到纹理坐标和图片坐标的映射关系，非常简单，对于一张 M * N 的图片上的像素 (i, j)，它的纹理坐标是：<br>$$<br>u &#x3D; \frac{i}{M-1},\ v &#x3D; \frac{j}{N-1}<br>$$<br>于是可以实现一个图片纹理类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 纹理类，包含各种纹理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;perlin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 图片纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">image_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> bytes_per_pixel = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>()</span><br><span class="line">        : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">bytes_per_scanline</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">image_texture</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">        <span class="keyword">auto</span> components_per_pixel = bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        data = <span class="built_in">stbi_load</span>(</span><br><span class="line">            filename, &amp;width, &amp;height, &amp;components_per_pixel, components_per_pixel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;ERROR: Could not load texture image file &#x27;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">            width = height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_per_scanline = bytes_per_pixel * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">image_texture</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> vec3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有图片的话返回一个固定的颜色，便于debug</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入的纹理坐标截断在[0,1]区间</span></span><br><span class="line">        u = <span class="built_in">clamp</span>(u, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 由于图片是从上到下存储的，相当于原点在左上角，而纹理坐标原点在左下角，因此纵坐标要翻转一下</span></span><br><span class="line">        v = <span class="number">1.0</span> - <span class="built_in">clamp</span>(v, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">        <span class="comment">// 纹理坐标映射到图片坐标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(u * width);</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(v * height);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= width)  i = width - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= height) j = height - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们返回的颜色都在[0,1]之间，因此要除以255</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> color_scale = <span class="number">1.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> pixel = data + j * bytes_per_scanline + i * bytes_per_pixel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(color_scale * pixel[<span class="number">0</span>], color_scale * pixel[<span class="number">1</span>], color_scale * pixel[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="type">int</span> bytes_per_scanline;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-测试效果"><a href="#2-测试效果" class="headerlink" title="2 测试效果"></a>2 测试效果</h3><p>新建一个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 地球</span></span><br><span class="line"><span class="function">hittable_list <span class="title">earth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string TexturePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> earth_texture = <span class="built_in">make_shared</span>&lt;image_texture&gt;(TexturePath.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">auto</span> earth_surface = <span class="built_in">make_shared</span>&lt;lambertian&gt;(earth_texture);</span><br><span class="line">    <span class="keyword">auto</span> globe = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, earth_surface);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hittable_list</span>(globe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并对应修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> sence = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        world = <span class="built_in">earth</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/21/20220421-RayTracer-%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86/Earth.png" alt="Earth"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十四）光源</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>之前的场景中一直缺少一个重要的元素，那就是光源，这一节我们来实现光源，这样我们之后就可以随意控制场景中的光照了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-自发光材质"><a href="#1-自发光材质" class="headerlink" title="1 自发光材质"></a>1 自发光材质</h3><p>光源可以认为是会自发光的材质，并且其他光线到达其表面也不会发生散射，这样的材质实现非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自发光材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到上面还重载了另一个虚函数 <code>emitted</code>，因此要在 <code>material</code> 抽象类中加入 <code>emitted</code> 的声明，但因为我们不需要所有派生类都实现这个方法，因此不必定义为纯虚函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，产生散射光线并给定光线衰减系数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自发光虚函数，不必所有派生类都进行实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-为场景添加背景颜色"><a href="#2-为场景添加背景颜色" class="headerlink" title="2 为场景添加背景颜色"></a>2 为场景添加背景颜色</h3><p>为了之后测试光源，我们需要一个全黑的背景，这样所有的光线就都来自于光源了，为此我们在 <code>ray_color</code> 函数中增加一个背景颜色的参数，并作相应的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">	hit_record rec;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">	<span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">	<span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">	<span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">		<span class="keyword">return</span> background;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">	ray scattered;</span><br><span class="line">	color attenuation;</span><br><span class="line">	color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">	<span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">	<span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">		<span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主函数中增加背景颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"></span><br><span class="line">point3 lookfrom;</span><br><span class="line">point3 lookat;</span><br><span class="line"><span class="keyword">auto</span> vfov = <span class="number">40.0</span>;</span><br><span class="line"><span class="keyword">auto</span> aperture = <span class="number">0.0</span>;</span><br><span class="line"><span class="function">color <span class="title">background</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ...</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.70</span>, <span class="number">0.80</span>, <span class="number">1.00</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    pixel_color += <span class="built_in">ray_color</span>(r, background, world, min_bounce, RR);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>为了方便，我们把之前的场景的背景统一设置为了天空的蓝白色。</p>
<h3 id="3-矩形物体"><a href="#3-矩形物体" class="headerlink" title="3 矩形物体"></a>3 矩形物体</h3><p>接下来我们实现另一类物体——矩形，矩形在我们之后的场景中非常重要，它既可以作为面光源，也可以组合成立方体等等。为了实现矩形物体类，我们首先要考虑的就是它的 <code>hit</code> 函数，这里为了实现方便，我们实现的矩形是一个轴对齐矩形。</p>
<p>对于一个三维空间中存在于 xy 平面内的矩形，可以直接用它的 z 坐标来描述它的位置，比如 z &#x3D; k，又因为它是轴对齐矩形，因此可以用四条线 x &#x3D; x0, x &#x3D; x1, y &#x3D; y0, y &#x3D; y1 来定义这个矩形，这和之前的轴对齐包围盒非常相似，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/fig-2.05-ray-rect.jpg" alt="fig-2.05-ray-rect"></p>
<p>于是求光线和矩形的交点可以类似于图形学中求光线和三角形的交点，分为两步，先求光线和 z &#x3D; k 平面的交点，然后判断该交点是否在矩形内部。光线和 z &#x3D; k 平面的交点非常容易求得，对于光线 $P(t) &#x3D; A + tb$，可以直接用它的 z 坐标和 z &#x3D; k 联立：<br>$$<br>P_z(t) &#x3D; A_z + tb_z &#x3D; k<br>$$<br>于是可以求得与 z &#x3D; k 平面相交的 t：<br>$$<br>t &#x3D; \frac{k-A_z}{b_z}<br>$$<br>然后将该 t 带入光线的其他两个维度的坐标方程就可以得到 x 和 y 的坐标：<br>$$<br>x &#x3D; A_x + tb_x,\ y &#x3D; A_y+tb_y<br>$$<br>如果光线和矩形有交点，那么必须满足：<br>$$<br>x_0 &lt; x &lt; x_1 \ 且\ y_0 &lt; y &lt; y_1<br>$$<br>有了 <code>hit</code> 函数，接下来考虑一个矩形物体的包围盒，由于我们的轴对齐矩形是没有 z 方向的厚度的，这在 BVH 随机维度划分的时候会出问题，因此我们为矩形物体包围盒的 z 方向填充一个很小的长度。</p>
<p>一个 xy 平面的轴对齐矩形物体类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 轴对齐矩形类aarect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AARECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AARECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xy_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xy_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xy_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// z 方向填充一个很小的长度，防止 BVH 划分出问题</span></span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, y0, k - <span class="number">0.0001</span>), <span class="built_in">point3</span>(x1, y1, k + <span class="number">0.0001</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, y0, y1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xy_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">z</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-测试光源"><a href="#4-测试光源" class="headerlink" title="4 测试光源"></a>4 测试光源</h3><p>现在我们来创建一个包含一个面光源的简单场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单光照场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">simple_light</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> difflight = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>, difflight));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我们给定的光源的颜色是大于 (1, 1, 1) 的，这是为了保证光源足够亮，以照亮其他物体。</p>
<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sence.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            world = <span class="built_in">simple_light</span>();</span><br><span class="line">            samples_per_pixel = <span class="number">400</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">26</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">20.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight.png" alt="SimpleLight"></p>
<p>我们也可以使用球体作为光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/SimpleLight2.png" alt="SimpleLight2"></p>
<h3 id="5-其他轴对齐矩形"><a href="#5-其他轴对齐矩形" class="headerlink" title="5 其他轴对齐矩形"></a>5 其他轴对齐矩形</h3><p>现在我们增加其他两个平面的轴对齐矩形的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">xz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xz_rect</span>(<span class="type">double</span> _x0, <span class="type">double</span> _x1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">x0</span>(_x0), <span class="built_in">x1</span>(_x1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(x0, k - <span class="number">0.0001</span>, z0), <span class="built_in">point3</span>(x1, k + <span class="number">0.0001</span>, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> x0, x1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">y</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> x = r.<span class="built_in">origin</span>().<span class="built_in">x</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (x - x0) / (x1 - x0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">yz_rect</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">yz_rect</span>(<span class="type">double</span> _y0, <span class="type">double</span> _y1, <span class="type">double</span> _z0, <span class="type">double</span> _z1, <span class="type">double</span> _k,</span><br><span class="line">        shared_ptr&lt;material&gt; mat)</span><br><span class="line">        : <span class="built_in">y0</span>(_y0), <span class="built_in">y1</span>(_y1), <span class="built_in">z0</span>(_z0), <span class="built_in">z1</span>(_z1), <span class="built_in">k</span>(_k), <span class="built_in">mp</span>(mat) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(<span class="built_in">point3</span>(k - <span class="number">0.0001</span>, y0, z0), <span class="built_in">point3</span>(k + <span class="number">0.0001</span>, y1, z1));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;material&gt; mp;</span><br><span class="line">    <span class="type">double</span> y0, y1, z0, z1, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">yz_rect::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = (k - r.<span class="built_in">origin</span>().<span class="built_in">x</span>()) / r.<span class="built_in">direction</span>().<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">if</span> (t &lt; t_min || t &gt; t_max)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> y = r.<span class="built_in">origin</span>().<span class="built_in">y</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = r.<span class="built_in">origin</span>().<span class="built_in">z</span>() + t * r.<span class="built_in">direction</span>().<span class="built_in">z</span>();</span><br><span class="line">    <span class="keyword">if</span> (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    rec.u = (y - y0) / (y1 - y0);</span><br><span class="line">    rec.v = (z - z0) / (z1 - z0);</span><br><span class="line">    rec.t = t;</span><br><span class="line">    <span class="keyword">auto</span> outward_normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    rec.mat_ptr = mp;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-创建-Cornell-Box"><a href="#6-创建-Cornell-Box" class="headerlink" title="6 创建 Cornell Box"></a>6 创建 Cornell Box</h3><p>有了矩形物体，我们可以创建一个著名的 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            world = <span class="built_in">cornell_box</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%85%89%E6%BA%90/CornellBox.png" alt="CornellBox"></p>
<p>由于光源太小，导致图片中噪声非常大。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十六）参与介质</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>之前在图形学中我们学过参与介质（participating media）的实现原理，比如烟雾，这一节我们来实现一个恒定密度的参与介质。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-恒定密度介质"><a href="#1-恒定密度介质" class="headerlink" title="1 恒定密度介质"></a>1 恒定密度介质</h3><p>因为我们之前所有的实现都是基于“表面”的，而参与介质是基于“体积”的，这二者之间还是有很大的不同的，但是一个简单的办法是可以把整个参与介质看作是由表面构成的，但这个表面可以在物体内部，只要在一定范围内的点都算作该物体的表面，所以都可以和光线发生作用。</p>
<p>我们在图形学中学过，光线穿过烟雾会在其内部发生各种散射，我们可以用一个概率模型来描述这种过程，如果一个烟雾的密度越大，那么光线在其中发生散射的几率也就越大，如果光线越稀薄，光线就越有可能直接穿过介质而不发生散射，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/fig-2.08-ray-vol.jpg" alt="fig-2.08-ray-vol"></p>
<p>我们认为光线在烟雾中走过 $\Delta L$ 距离发生散射的几率是：<br>$$<br>probability &#x3D; C·\Delta L<br>$$<br>其中 $C$ 与介质的密度成正比，于是对于一个随机数就可以用上面的式子计算得到概率，并把这个概率认为是散射发生的距离。如果散射发生的距离大于光线在介质中传播的距离，说明光线没有击中介质，而是直接穿过。</p>
<p>因此一个恒定密度的介质只需要一个密度和边界就可以描述，边界使用另一个物体来确定，相当于该物体形状的烟雾，一个恒定密度的介质类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 恒定密度的参与介质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTANT_MEDIUM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constant_medium</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, shared_ptr&lt;texture&gt; a)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(a))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">constant_medium</span>(shared_ptr&lt;hittable&gt; b, <span class="type">double</span> d, color c)</span><br><span class="line">        : <span class="built_in">boundary</span>(b),</span><br><span class="line">        <span class="built_in">neg_inv_density</span>(<span class="number">-1</span> / d),</span><br><span class="line">        <span class="built_in">phase_function</span>(<span class="built_in">make_shared</span>&lt;isotropic&gt;(c))</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boundary-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; boundary;          <span class="comment">// 边界</span></span><br><span class="line">    shared_ptr&lt;material&gt; phase_function;    <span class="comment">// 各向同性材质，保证光线向各个方向等概率均匀散射</span></span><br><span class="line">    <span class="type">double</span> neg_inv_density;                 <span class="comment">// 密度的负倒数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">constant_medium::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于debug</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableDebug = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> debugging = enableDebug &amp;&amp; <span class="built_in">random_double</span>() &lt; <span class="number">0.00001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求光线和边界的两个交点</span></span><br><span class="line">    hit_record rec1, rec2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, -infinity, infinity, rec1))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!boundary-&gt;<span class="built_in">hit</span>(r, rec1.t + <span class="number">0.0001</span>, infinity, rec2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) std::cerr &lt;&lt; <span class="string">&quot;\nt_min=&quot;</span> &lt;&lt; rec1.t &lt;&lt; <span class="string">&quot;, t_max=&quot;</span> &lt;&lt; rec2.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; t_min) rec1.t = t_min;</span><br><span class="line">    <span class="keyword">if</span> (rec2.t &gt; t_max) rec2.t = t_max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &gt;= rec2.t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rec1.t &lt; <span class="number">0</span>)</span><br><span class="line">        rec1.t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线在介质中的距离</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ray_length = r.<span class="built_in">direction</span>().<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> distance_inside_boundary = (rec2.t - rec1.t) * ray_length;</span><br><span class="line">    <span class="comment">// 光线发生散射的距离，两个相乘的数都是小于1的负数，所以密度越大值越小</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> hit_distance = neg_inv_density * <span class="built_in">log</span>(<span class="built_in">random_double</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生散射的距离大于光线在介质中的距离则没有发生散射，直接穿过介质</span></span><br><span class="line">    <span class="keyword">if</span> (hit_distance &gt; distance_inside_boundary)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 散射发生的位置</span></span><br><span class="line">    rec.t = rec1.t + hit_distance / ray_length;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugging) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;hit_distance = &quot;</span> &lt;&lt; hit_distance &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.t = &quot;</span> &lt;&lt; rec.t &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;rec.p = &quot;</span> &lt;&lt; rec.p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法线方向这些属性可以随便设置</span></span><br><span class="line">    rec.normal = <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rec.front_face = <span class="literal">true</span>;</span><br><span class="line">    rec.mat_ptr = phase_function;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面的实现中我们默认光线一旦出了介质就不会再在介质中弹射了，因此只适用于凸多边形物体，不适用于凹多边形物体。其中控制光线向各个方向等概率散射的材质在 <code>material.h</code> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 各向同性材质</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">isotropic</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">isotropic</span>(color c) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line">    <span class="built_in">isotropic</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 光线向各个方向等概率均匀散射</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">random_in_unit_sphere</span>(), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-用烟雾渲染-Cornell-Box"><a href="#2-用烟雾渲染-Cornell-Box" class="headerlink" title="2 用烟雾渲染 Cornell Box"></a>2 用烟雾渲染 Cornell Box</h3><p>我们使用上面实现的介质新建一个 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 烟雾Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_smoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">113</span>, <span class="number">443</span>, <span class="number">127</span>, <span class="number">432</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box1, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(box2, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            world = <span class="built_in">cornell_smoke</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">600</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">200</span>;</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/CornellBoxSmoke.png" alt="CornellBoxSmoke"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十七）新特性最终场景</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>现在我们新建一个非常复杂的场景来测试到目前为止光线追踪器的全部特性，生成我们的第二张光线追踪“大片”。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-创建新场景"><a href="#1-创建新场景" class="headerlink" title="1 创建新场景"></a>1 创建新场景</h3><p>创建一个包含所有特性的场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新特性最终场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">final_scene</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高低起伏的盒子组成地面</span></span><br><span class="line">    hittable_list boxes1;</span><br><span class="line">    <span class="keyword">auto</span> ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.48</span>, <span class="number">0.83</span>, <span class="number">0.53</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> boxes_per_side = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boxes_per_side; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; boxes_per_side; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> w = <span class="number">100.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x0 = <span class="number">-1000.0</span> + i * w;</span><br><span class="line">            <span class="keyword">auto</span> z0 = <span class="number">-1000.0</span> + j * w;</span><br><span class="line">            <span class="keyword">auto</span> y0 = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">auto</span> x1 = x0 + w;</span><br><span class="line">            <span class="keyword">auto</span> y1 = <span class="built_in">random_double</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">            <span class="keyword">auto</span> z1 = z0 + w;</span><br><span class="line"></span><br><span class="line">            boxes1.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(x0, y0, z0), <span class="built_in">point3</span>(x1, y1, z1), ground));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hittable_list objects;</span><br><span class="line">    <span class="comment">// 构建地面的BVH树</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes1, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 光源</span></span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">123</span>, <span class="number">423</span>, <span class="number">147</span>, <span class="number">412</span>, <span class="number">554</span>, light));</span><br><span class="line">    <span class="comment">// 移动的球体</span></span><br><span class="line">    <span class="keyword">auto</span> center1 = <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">auto</span> center2 = center1 + <span class="built_in">vec3</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> moving_sphere_material = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.1</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(center1, center2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, moving_sphere_material));</span><br><span class="line">    <span class="comment">// 透明球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="built_in">point3</span>(<span class="number">260</span>, <span class="number">150</span>, <span class="number">45</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>)));</span><br><span class="line">    <span class="comment">// 金属球体</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.9</span>), <span class="number">1.0</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与介质</span></span><br><span class="line">    <span class="keyword">auto</span> boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="built_in">point3</span>(<span class="number">360</span>, <span class="number">150</span>, <span class="number">145</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">70</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(boundary);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">0.01</span>, <span class="built_in">color</span>(<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.9</span>)));</span><br><span class="line">    boundary = <span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">5000</span>, <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;constant_medium&gt;(boundary, <span class="number">.0001</span>, <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地球</span></span><br><span class="line">    <span class="keyword">auto</span> emat = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">make_shared</span>&lt;image_texture&gt;(</span><br><span class="line">        <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Project\\Textures\\earthmap.jpg&quot;</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="built_in">point3</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">400</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, emat));</span><br><span class="line">    <span class="comment">// 噪声纹理</span></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="built_in">point3</span>(<span class="number">220</span>, <span class="number">280</span>, <span class="number">300</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一堆小球</span></span><br><span class="line">    hittable_list boxes2;</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="type">int</span> ns = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ns; j++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> center = <span class="built_in">random_vec</span>(<span class="number">0</span>, <span class="number">165</span>);</span><br><span class="line">        boxes2.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">            center, center, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, white));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旋转平移一堆小球</span></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;translate&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;rotate_y&gt;(</span><br><span class="line">            <span class="built_in">make_shared</span>&lt;bvh_node&gt;(boxes2, <span class="number">0.0</span>, <span class="number">1.0</span>), <span class="number">15</span>),</span><br><span class="line">        <span class="built_in">vec3</span>(<span class="number">-100</span>, <span class="number">270</span>, <span class="number">395</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-渲染效果"><a href="#2-渲染效果" class="headerlink" title="2 渲染效果"></a>2 渲染效果</h3><p>修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            world = <span class="built_in">final_scene</span>();</span><br><span class="line">            aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">            image_width = <span class="number">800</span>;</span><br><span class="line">            samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">            min_bounce = <span class="number">95</span>;</span><br><span class="line">            background = <span class="built_in">color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            lookfrom = <span class="built_in">point3</span>(<span class="number">478</span>, <span class="number">278</span>, <span class="number">-600</span>);</span><br><span class="line">            lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">            vfov = <span class="number">40.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E7%BB%88%E5%9C%BA%E6%99%AF/FinalSence.png" alt="FinalSence"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十五）立方体和变换</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>上一节中我们实现了光源和矩形物体，并初步创建了一个 Cornell Box 场景，但场景中还缺少两个立方体，并且立方体和墙面之间存在一定的旋转角度，因此这一节我们需要实现一个立方体物体类，并且支持旋转和平移。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-轴对齐立方体"><a href="#1-轴对齐立方体" class="headerlink" title="1 轴对齐立方体"></a>1 轴对齐立方体</h3><p>先使用轴对齐矩形实现一个轴对齐立方体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aarect.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = <span class="built_in">aabb</span>(box_min, box_max);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 box_min;</span><br><span class="line">    point3 box_max;</span><br><span class="line">    hittable_list sides;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">box::<span class="built_in">box</span>(<span class="type">const</span> point3&amp; p0, <span class="type">const</span> point3&amp; p1, shared_ptr&lt;material&gt; ptr) &#123;</span><br><span class="line">    box_min = p0;</span><br><span class="line">    box_max = p1;</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p1.<span class="built_in">z</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">y</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(p0.<span class="built_in">x</span>(), p1.<span class="built_in">x</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">y</span>(), ptr));</span><br><span class="line"></span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p1.<span class="built_in">x</span>(), ptr));</span><br><span class="line">    sides.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(p0.<span class="built_in">y</span>(), p1.<span class="built_in">y</span>(), p0.<span class="built_in">z</span>(), p1.<span class="built_in">z</span>(), p0.<span class="built_in">x</span>(), ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">box::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sides.<span class="built_in">hit</span>(r, t_min, t_max, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后将 box 添加到 Cornell Box 场景中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>), <span class="built_in">point3</span>(<span class="number">295</span>, <span class="number">165</span>, <span class="number">230</span>), white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>), <span class="built_in">point3</span>(<span class="number">430</span>, <span class="number">330</span>, <span class="number">460</span>), white));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxComplete.png" alt="CornellBoxComplete"></p>
<h3 id="2-Instances"><a href="#2-Instances" class="headerlink" title="2 Instances"></a>2 Instances</h3><p>接下来我们要实现立方体的旋转，更一般地，我们不止要让立方体旋转，而是要让场景中的所有物体都能够运动，运动包括平移和旋转。在光线追踪器中，这些都是通过 Instances 来实现的，Instances 可以认为是一个几何变换器，可以将传入的物体按照给定的参数和方式进行变换，因此我们要实现这些几何变换的 Instances 类。</p>
<h4 id="2-1-平移"><a href="#2-1-平移" class="headerlink" title="2.1 平移"></a>2.1 平移</h4><p>首先是平移变换类，在光线追踪器中实现物体平移不是通过真的把物体移动到某个位置，因为物体一旦被放入场景再去变换位置就需要费很大的功夫，所以实现物体平移是通过向反方向移动光线来实现的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/fig-2.06-ray-box.jpg" alt="fig-2.06-ray-box"></p>
<p>要把粉色的正方形沿 x 轴向右移动两个单位，我们可以通过把光线沿 x 轴向左移动两个单位来实现。</p>
<p>注意和之前实现的移动的球体做区分，这里的移动不是在一段时间内的运动，而是改变场景中物体的摆放方式。</p>
<p>平移变换类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平移变换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">translate</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">translate</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> vec3&amp; displacement)</span><br><span class="line">        : <span class="built_in">ptr</span>(p), <span class="built_in">offset</span>(displacement) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    vec3 offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 光线向反方向平移</span></span><br><span class="line">    <span class="function">ray <span class="title">moved_r</span><span class="params">(r.origin() - offset, r.direction(), r.time())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算交点，这里计算出的交点是相对坐标，物体还在原本的地方</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(moved_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把物体和光线的交点加上偏移，得到平移后的物体和光线的交点在世界空间的绝对坐标</span></span><br><span class="line">    <span class="comment">// 这才相当于把物体移动了</span></span><br><span class="line">    rec.p += offset;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(moved_r, rec.normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">translate::bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    output_box = <span class="built_in">aabb</span>(</span><br><span class="line">        output_box.<span class="built_in">min</span>() + offset,</span><br><span class="line">        output_box.<span class="built_in">max</span>() + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-旋转"><a href="#2-2-旋转" class="headerlink" title="2.2 旋转"></a>2.2 旋转</h4><p>旋转的思路和平移一样，也是先反方向旋转光线，得到交点后对交点再进行正向旋转，不同的是旋转后交点法线也要相应变换，在 Shader 学习中我们知道对法线变换要用变换矩阵的逆转置矩阵，旋转矩阵是正交矩阵，逆转置矩阵就是其本身。</p>
<p>绕 y 轴旋转的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绕y轴旋转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rotate_y</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        output_box = bbox;</span><br><span class="line">        <span class="keyword">return</span> hasbox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">    <span class="type">double</span> sin_theta;</span><br><span class="line">    <span class="type">double</span> cos_theta;</span><br><span class="line">    <span class="type">bool</span> hasbox;</span><br><span class="line">    aabb bbox;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，计算旋转后的bounding box及其他的基本成员</span></span><br><span class="line">rotate_y::<span class="built_in">rotate_y</span>(shared_ptr&lt;hittable&gt; p, <span class="type">double</span> angle) : <span class="built_in">ptr</span>(p) &#123;</span><br><span class="line">    <span class="keyword">auto</span> radians = <span class="built_in">degrees_to_radians</span>(angle);</span><br><span class="line">    sin_theta = <span class="built_in">sin</span>(radians);</span><br><span class="line">    cos_theta = <span class="built_in">cos</span>(radians);</span><br><span class="line">    hasbox = ptr-&gt;<span class="built_in">bounding_box</span>(<span class="number">0</span>, <span class="number">1</span>, bbox);</span><br><span class="line"></span><br><span class="line">    <span class="function">point3 <span class="title">min</span><span class="params">(infinity, infinity, infinity)</span></span>;</span><br><span class="line">    <span class="function">point3 <span class="title">max</span><span class="params">(-infinity, -infinity, -infinity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历bounding box的每个顶点，并进行变换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = i * bbox.<span class="built_in">max</span>().<span class="built_in">x</span>() + (<span class="number">1</span> - i) * bbox.<span class="built_in">min</span>().<span class="built_in">x</span>();</span><br><span class="line">                <span class="keyword">auto</span> y = j * bbox.<span class="built_in">max</span>().<span class="built_in">y</span>() + (<span class="number">1</span> - j) * bbox.<span class="built_in">min</span>().<span class="built_in">y</span>();</span><br><span class="line">                <span class="keyword">auto</span> z = k * bbox.<span class="built_in">max</span>().<span class="built_in">z</span>() + (<span class="number">1</span> - k) * bbox.<span class="built_in">min</span>().<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> newx = cos_theta * x + sin_theta * z;</span><br><span class="line">                <span class="keyword">auto</span> newz = -sin_theta * x + cos_theta * z;</span><br><span class="line"></span><br><span class="line">                <span class="function">vec3 <span class="title">tester</span><span class="params">(newx, y, newz)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line">                    min[c] = <span class="built_in">fmin</span>(min[c], tester[c]);</span><br><span class="line">                    max[c] = <span class="built_in">fmax</span>(max[c], tester[c]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bbox = <span class="built_in">aabb</span>(min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rotate_y::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> origin = r.<span class="built_in">origin</span>();</span><br><span class="line">    <span class="keyword">auto</span> direction = r.<span class="built_in">direction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线向反方向旋转</span></span><br><span class="line">    origin[<span class="number">0</span>] = cos_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    origin[<span class="number">2</span>] = sin_theta * r.<span class="built_in">origin</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">origin</span>()[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 因为光线方向实际上是两个点的差，所以也可以直接应用变换矩阵</span></span><br><span class="line">    direction[<span class="number">0</span>] = cos_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] - sin_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line">    direction[<span class="number">2</span>] = sin_theta * r.<span class="built_in">direction</span>()[<span class="number">0</span>] + cos_theta * r.<span class="built_in">direction</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">ray <span class="title">rotated_r</span><span class="params">(origin, direction, r.time())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到的交点同样是相对的坐标</span></span><br><span class="line">    <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(rotated_r, t_min, t_max, rec))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> p = rec.p;</span><br><span class="line">    <span class="keyword">auto</span> normal = rec.normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将交点进行旋转</span></span><br><span class="line">    p[<span class="number">0</span>] = cos_theta * rec.p[<span class="number">0</span>] + sin_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">2</span>] = -sin_theta * rec.p[<span class="number">0</span>] + cos_theta * rec.p[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 法线也要旋转，法线变换应该用原变换矩阵的逆转置矩阵，旋转矩阵正交因此逆转置矩阵就是原矩阵</span></span><br><span class="line">    normal[<span class="number">0</span>] = cos_theta * rec.normal[<span class="number">0</span>] + sin_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line">    normal[<span class="number">2</span>] = -sin_theta * rec.normal[<span class="number">0</span>] + cos_theta * rec.normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    rec.p = p;</span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(rotated_r, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-完整的-Cornell-Box"><a href="#3-完整的-Cornell-Box" class="headerlink" title="3 完整的 Cornell Box"></a>3 完整的 Cornell Box</h3><p>利用实现的立方体和几何变换类，来得到完整的 Cornell Box 场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> red = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.65</span>, <span class="number">.05</span>, <span class="number">.05</span>));</span><br><span class="line">    <span class="keyword">auto</span> white = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.73</span>, <span class="number">.73</span>, <span class="number">.73</span>));</span><br><span class="line">    <span class="keyword">auto</span> green = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">.12</span>, <span class="number">.45</span>, <span class="number">.15</span>));</span><br><span class="line">    <span class="keyword">auto</span> light = <span class="built_in">make_shared</span>&lt;diffuse_light&gt;(<span class="built_in">color</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, green));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;yz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, red));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xy_rect&gt;(<span class="number">0</span>, <span class="number">555</span>, <span class="number">0</span>, <span class="number">555</span>, <span class="number">555</span>, white));</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), white);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;hittable&gt; box2 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">165</span>, <span class="number">165</span>), white);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box2, <span class="number">-18</span>);</span><br><span class="line">    box2 = <span class="built_in">make_shared</span>&lt;translate&gt;(box2, <span class="built_in">vec3</span>(<span class="number">130</span>, <span class="number">0</span>, <span class="number">65</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/22/20220422-RayTracer-%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E5%8F%98%E6%8D%A2/CornellBoxFinal.png" alt="CornellBoxFinal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十九）随机方向</title>
    <url>/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>上一节我们实现了基于蒙特卡洛积分的渲染方程并了解了重要性采样在光线追踪中的作用。这一节我们根据不同的概率密度来直接生成随机方向。经过上一节的推导，我们知道了之前实现的散射函数中的随机方向对应的概率密度是什么，但是没有显式的用概率密度去直接产生随机方向，而是用一个均匀分布（单位球面上随机取点）加上一个法线偏移达到这样的效果。这一节我们来实现直接生成给定概率密度的随机方向。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-相对于-Z-轴的随机方向"><a href="#1-相对于-Z-轴的随机方向" class="headerlink" title="1 相对于 Z 轴的随机方向"></a>1 相对于 Z 轴的随机方向</h3><p>我们先实现相对于 Z 轴的随机方向，也就是假设所有着色点的法线都是 Z 轴，之后再将他们转换到真实法线方向上。</p>
<p>在之前的推导中我们知道，球面上的随机方向的概率密度是和俯仰角 $\theta$ 有关的，对于给定的随机方向概率密度 $p(direction)&#x3D;f(\theta)$，方位角和俯仰角的一维概率密度函数为：<br>$$<br>p(\phi) &#x3D; \frac{1}{2\pi},\ p(\theta) &#x3D; 2\pi f(\theta)sin\theta<br>$$<br>对于两个均匀生成的随机数 $r_1$ 、$r_2$，有：<br>$$<br>r_1 &#x3D; \int_0^\phi \frac{1}{2\pi} dt<br>$$<br>可以求得：<br>$$<br>\phi &#x3D; 2\pi r_1<br>$$<br>同理：<br>$$<br>r_2 &#x3D; \int_0^\theta2\pi f(t)sin(t)dt<br>$$<br>之前推到过， lambertian 材质的散射光线的概率密度函数为：<br>$$<br>p(direction)&#x3D;f(\theta)&#x3D;\frac{cos\theta}{\pi}<br>$$<br>代入上式中得：<br>$$<br>r_2 &#x3D; \int_0^\theta2\pi \frac{cost}{\pi}sin(t)dt&#x3D;1-cos^2\theta<br>$$<br>于是可以求得：<br>$$<br>cos\theta &#x3D; \sqrt{1-r_2}<br>$$<br>极坐标和直角坐标的转换公式为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/image-20220424111850258.png" alt="image-20220424111850258"></p>
<p>将解出来的 $\phi$ 和 $\theta$ 带入得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/image-20220424111709272.png" alt="image-20220424111709272"></p>
<p>于是我们可以实现该函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_cosine_direction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">	<span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">	<span class="comment">// 方向是单位向量，所以z坐标就是cos(theta)</span></span><br><span class="line">	<span class="keyword">auto</span> z = <span class="built_in">sqrt</span>(<span class="number">1</span> - r2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">	<span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line">	<span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(r2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用这个方法生成其他概率分布的随机方向，只要替换推导过程中的 $f(\theta)$ 即可，比如均匀半球分布 $\frac{1}{2\pi}$，均匀球面分布 $\frac{1}{4\pi}$ 等。</p>
<h3 id="2-相对于法线的随机方向"><a href="#2-相对于法线的随机方向" class="headerlink" title="2 相对于法线的随机方向"></a>2 相对于法线的随机方向</h3><p>接下来我们将上面生成的围绕 z 轴的随机方向转换为围绕着色点法线的随机方向。这实际上就是一个坐标系转化的过程，回顾最简单的线性代数知识，向量 (x, y, z) 表示的是三个方向上的标准正交基的和，标准正交基就是一个坐标系的三个坐标轴，由于向量只有方向，没有位置，因此用这三个数组合任意的标准正交基都可以得到这个标准正交基下的一个向量，所以我们只要求出法线所在的坐标系下的三个标准正交基，再用 (x, y, z) 组合，就可以得到法线坐标系下的随机方向了。</p>
<p>得到法线坐标系的标准正交基很简单，类似于之前相机类中实现的方法，我们可以随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，二者叉乘得到一个向量 $\vec t$，再用 $\vec t$ 和法线 $\vec n$ 叉乘得到向量 $\vec s$，则 $\vec n$ 、 $\vec s$ 、 $\vec t$  就构成一组标准正交基。</p>
<p>至于随机选一个不平行于法线 $\vec n$ 的向量 $\vec a$，我们可以直接给定  $\vec a$ 就是 (1, 0, 0)，为了保证不和法线平行，当法线接近 (1, 0, 0) 的时候，  $\vec a$ 就改为 (0, 1, 0)。</p>
<p>标准正交基的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 标准正交基Orthonormal basis类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">onb</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">onb</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> vec3 <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> axis[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">u</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">v</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function">vec3 <span class="title">w</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> axis[<span class="number">2</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * <span class="built_in">u</span>() + b * <span class="built_in">v</span>() + c * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">local</span><span class="params">(<span class="type">const</span> vec3&amp; a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">x</span>() * <span class="built_in">u</span>() + a.<span class="built_in">y</span>() * <span class="built_in">v</span>() + a.<span class="built_in">z</span>() * <span class="built_in">w</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vec3 axis[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onb::build_from_w</span><span class="params">(<span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    axis[<span class="number">2</span>] = <span class="built_in">normalize</span>(n);</span><br><span class="line">    vec3 a = (<span class="built_in">fabs</span>(<span class="built_in">w</span>().<span class="built_in">x</span>()) &gt; <span class="number">0.9</span>) ? <span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>) : <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    axis[<span class="number">1</span>] = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(<span class="built_in">w</span>(), a));</span><br><span class="line">    axis[<span class="number">0</span>] = <span class="built_in">cross</span>(<span class="built_in">w</span>(), <span class="built_in">v</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在我们可以修改 lambertian 材质的散射函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建法线空间的标准正交基</span></span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(rec.normal);</span><br><span class="line">        <span class="comment">// 得到法线空间下概率分布为cos(theta)/pi的随机方向</span></span><br><span class="line">        <span class="keyword">auto</span> direction = uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度，即cos(theta)/pi</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(uvw.<span class="built_in">w</span>(), scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%9A%8F%E6%9C%BA%E6%96%B9%E5%90%91/CornellBox3.png" alt="CornellBox3"></p>
<p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，下一节我们将直接对光源进行采样。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十八）重要性采样</title>
    <url>/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<p>到目前为止我们已经实现了一个完整的光线追踪器，但距离真正的光线追踪其还差极为艰难的一步，也就是我们之前在渲染 Cornell Box 的时候提到的，画面噪声很大是因为光源太小，由于我们对散射光线的随机采样是使用最基本的采样方式，所以当光源很小的时候，光线打到光源的概率就很小，也就导致了噪声过大。从这一节开始我们就来解决这个问题。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-再谈渲染方程"><a href="#1-再谈渲染方程" class="headerlink" title="1 再谈渲染方程"></a>1 再谈渲染方程</h3><p>首先我们来回顾图形学中学过的渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320143225898.png" alt="image-20220320143225898"></p>
<p>实际上在前面的光线追踪器中我们已经实现了这个渲染方程，但是只实现了一个特殊情况，现在我们来深入分析一下我们是如何实现的。</p>
<p>我们是在 <code>ray_color</code> 函数中实现这个渲染方程的，渲染方程中的入射光线和出射光线的强度在我们的代码中其实就是 <code>ray_color</code> 函数计算的颜色。</p>
<p><code>ray_color</code> 函数的<code>r_in</code> 参数最开始传入的是我们从像素中投射出的视线，也就是观察方向，我们根据观察方向通过材质的散射函数随机采样出一条对于我们来说真正的入射光线，然后递归的计算这个入射光线的颜色，并返回 <code>albedo * ray_color</code>，其中反射率 <code>albedo</code> 就是出射光线和入射光线的比值，乘以入射光线颜色，自然就得到了出射光线的颜色，也就是我们最终观察到的颜色。整个过程不断递归，每次传入 <code>ray_color</code> 函数的入射光线实际上是上一次计算的入射光线，是本次计算的出射光线。</p>
<p>但是我们发现在 <code>ray_color</code> 函数中并没有体现出 BRDF 的存在。这是由于我们实现的是一个特殊情况。</p>
<p>首先我们对渲染方程中的 BRDF 项做一些变形。我们知道 BRDF 可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/image-20220320141430022.png" alt="image-20220320141430022"></p>
<p>从公式上看，BRDF 计算的是从每个散射方向 $\omega_r$ 出射的光的能量，和从每个入射方向 $\omega_i$ 上入射的光被着色点吸收的全部能量（在法线方向上投影的能量）的比值。<strong>双向反射分布函数的意义在于既描述了光线能量的反射比率，也描述了光线散射方向的分布。</strong></p>
<p>如果一个材质会发生散射，那么就会存在一个散射光线的分布，这个分布是关于方向的，我们称之为散射光线的概率密度函数 $s(direction)$，根据上面的 BRDF 公式，我们可以把 BRDF 改写为：<br>$$<br>BRDF &#x3D; \frac{albedo·s(direction)}{cos\theta}<br>$$<br>其中反射率是出射光线和入射光线的比值，描述光线的能量反射比率，散射光线的概率密度函数描述了光线散射方向的概率分布，这和上面的 BRDF 表达式是一致的。</p>
<p>接下来将这个 BRDF 表达式带入渲染方程中，其中夹角余弦可以写成表面法线和入射光线的点乘。于是我们可以得到：<br>$$<br>color_{out} &#x3D; color_{emit} + \int_{\Omega^+}albedo·s(direction)·color_{in}<br>$$<br>这和我们代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一致的，只是代码中缺少了散射光线的概率密度函数 $s(direction)$。这是为什么呢？</p>
<p>在我们实现的材质中，以漫反射 lambertian 材质为例，它的计算散射方向的方法是：使用表面法线偏移着色点 p 作为单位球的球心，在该单位球面上均匀采样一点并连接该点和点 p ，形成的向量即为散射方向。这样计算出的散射方向并不是在以点 p 为球心的半球上均匀分布的，所以概率密度并不是的 $\frac{1}{2\pi}$，而是与散射光线和法线的夹角余弦 $cos\theta$ 成正比的，我们可以推导出这个概率密度函数。</p>
<blockquote>
<p><strong>为什么概率密度和 $cos\theta$ 成正比？</strong></p>
<p>可以这样理解，首先概率密度函数的积分是概率，对于 cos 函数，从 0 到 $\pi&#x2F;4$ 的积分和从 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 的积分显然是不同的，这说明我们取到的散射方向和法线的夹角在 0 到 $\pi&#x2F;4$ 的概率比在 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 的概率更大。</p>
<p>在我们的代码中， lambertian 材质的散射光线方向是法线方向加上一个单位球面上随机生成的方向，也就是说，最终得到的散射光线方向是两个向量的和。如果单位球面上随机生成的方向和法线的夹角刚好是 45 度，那么他和法线的和向量与法线的夹角一定小于 45 度，如果想要和向量的夹角为 45 度，那么随机生成的向量夹角就要大于 45 度。这说明我们在一个单位球面上均匀的取随机点作为一个向量与法线相加得到散射方向，大部分的点得到的散射方向会在 0 到 $\pi&#x2F;4$ 范围内，只有一小部分才会使最终的散射方向在 $\pi&#x2F;4$ 到 $\pi&#x2F;2$ 范围内，因此也就对应了不均匀的概率。</p>
</blockquote>
<p>接下来我们推导这个概率密度函数是什么。首先我们知道，方向表示为单位立体角 $d\omega$，单位立体角是球面上的一块面积 $dA$ 和半径平方的比值，在图形学中我们推导过：<br>$$<br>d\omega &#x3D; \frac{dA}{r^2} &#x3D; \frac{r^2sin\theta \ d\theta \ d\phi}{r^2} &#x3D; sin\theta \ d\theta \ d\phi<br>$$<br>于是对于半球面上的均匀采样，有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}pdf·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>而单位半球面的积分就是半球的表面积 $2\pi$，于是半球面上的均匀分布就是：<br>$$<br>pdf(x) &#x3D; \frac{1}{2\pi}<br>$$<br>同理，我们现在要求的概率密度函数和 $cos\theta$ 成正比，于是可以表示为：<br>$$<br>pdf(x) &#x3D; C·cos\theta<br>$$<br>带入上面的积分有：<br>$$<br>\int_0^{2\pi}\int_0^{\pi&#x2F;2}C·cos\theta·sin\theta \ d\theta \ d\phi &#x3D; 1<br>$$<br>半球面上对 $cos\theta$ 积分结果为 $\pi$，因此：<br>$$<br>C·\pi &#x3D; 1<br>$$<br>于是可以得到我们实现的 lambertian 材质的散射光线的概率密度函数为：<br>$$<br>s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>接下来继续回顾图形学中的知识，我们求解渲染方程使用的是蒙特卡洛积分的方法，也就是按照某个概率分布 $p(x)$ 对被积变量进行随机采样，于是原积分可以通过如下方式计算：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>那么现在的渲染方程就可以通过蒙特卡洛积分计算：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum \frac{albedo·s(direction)·color_{in}}{p(direction)}<br>$$<br>如果我们选择对光线随机采样的概率密度和散射光线本身的概率密度分布一致，即：<br>$$<br>p(direction) &#x3D; s(direction) &#x3D; \frac{cos\theta}{\pi}<br>$$<br>显然渲染方程变为：<br>$$<br>color_{out} &#x3D; color_{emit} + \sum albedo·color_{in}<br>$$<br>也就是我们现在代码中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emitted + attenuation * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在我们之前的实现中，<strong>隐式的把对光线随机采样的概率密度设置为了永远和散射光线的概率密度一样</strong>，无论是漫反射材质还是金属材质又或者是其他材质，我们不关注他们散射光线的概率密度什么，反正我们采样的概率密度和它们一致，所以渲染方程永远可以表示为上面那样。</p>
<p>那么这样做为什么可以得到正确的结果呢？之前我们在图形学中也提到过，随机采样的概率分布越接近该变量原本的概率分布，蒙特卡洛积分收敛的也就越好，这会在之后展开讨论。</p>
<p>现在为了实现更一般的渲染方程，我们需要改写现在的代码。</p>
<p>首先修改材质抽象类，为散射光线的计算加入采样光线的 pdf：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 带有采样pdf的散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; albedo, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 lambertian 材质的散射函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 散射光线时刻和入射光线一样</span></span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        pdf = <span class="built_in">dot</span>(rec.normal, scattered.<span class="built_in">direction</span>()) / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到和之前一样的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox.png" alt="CornellBox"></p>
<p>如果我们把采样光线改为在半球上均匀采样，此时采样光线的 pdf 就是 $\frac{1}{2\pi}$ ，于是我们只要修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered, <span class="type">double</span>&amp; pdf</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//auto scatter_direction = rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 改为半球均匀采样 </span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, <span class="built_in">normalize</span>(scatter_direction), r_in.<span class="built_in">time</span>());</span><br><span class="line">        attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        <span class="comment">//pdf = dot(rec.normal, scattered.direction()) / pi;</span></span><br><span class="line">        pdf = <span class="number">0.5</span> / pi;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/CornellBox2.png" alt="CornellBox2"></p>
<p>使用什么样的采样 pdf 完全取决于我们的选择，但是使用什么样的 pdf 效果好刚才已经给出了答案，随机采样的 pdf 形状越接近函数原本的形状，蒙特卡洛估计收敛的效果就会越好。下面我们来推导这是为什么。</p>
<h3 id="2-重要性采样"><a href="#2-重要性采样" class="headerlink" title="2 重要性采样"></a>2 重要性采样</h3><p>要了解重要性采样的原理就要先深入理解蒙特卡洛积分，首先我们来分析为什么蒙特卡洛积分可以得到原积分的估计值。根据蒙特卡洛积分的计算方法：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>首先我们把积分变量看做了一个随机变量 X，然后构造了一个随机采样的分布 p(X)，利用这个分布我们可以构造一个新的随机变量：<br>$$<br>Y &#x3D; \frac{f(X)}{p(X)}<br>$$<br>概率论告诉我们的如果一个随机变量 X 的期望是 E(X)，那么随机变量 f(X) 的期望就是 E(f(X))，于是蒙特卡洛积分 $F_N$ 的期望就是：<br>$$<br>E[F_N] &#x3D; E[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>也就是：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^NE[Y_i]<br>$$<br>连续型随机变量的期望就是对概率密度函数的积分，所以：<br>$$<br>E[Y_i] &#x3D; \int_a^b \frac{f(x)}{p(x)}p(x)dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>带入上式得：<br>$$<br>E[F_N] &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^N\int_a^b{f(x)}dx &#x3D; \int_a^b{f(x)}dx<br>$$<br>以上证明过程表明，若我们根据公式来构造一个新的随机变量 $F_N$ ，则 $F_N$ 的期望就是原积分的结果，随着 N 的增加，$F_N$ 就越逼近理论上的积分值，即蒙特卡洛积分是原积分的一个无偏估计。</p>
<p>接下来我们看蒙特卡洛估计的方差：<br>$$<br>\sigma^2[F_N] &#x3D; \sigma^2[\frac{1}{N}\sum_{i&#x3D;1}^N\frac{f(X_i)}{p(X_i)}]<br>$$<br>即：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}\sum_{i&#x3D;1}^N\sigma^2[Y_i]<br>$$<br>于是可以得到：<br>$$<br>\sigma^2[F_N] &#x3D; \frac{1}{N^2}N\sigma^2[Y]&#x3D;\frac{1}{N}\sigma^2[Y]<br>$$<br>所以蒙特卡洛积分的标准差就是：<br>$$<br>\sigma[F_N] &#x3D; \frac{1}{\sqrt{n}}\sigma[Y]<br>$$<br>这个结果告诉我们，估计值的不稳定来源于随机变量 Y 的取值不稳定。换句话说，如果随机变量：<br>$$<br>Y_i &#x3D; \frac{f(X_i)}{p(X_i)}<br>$$<br>因不同 $X_i$ 的取值变化地越剧烈，就会造成 Y 的方差较大，也就导致估计值的收敛速度越慢。这证明了，<strong>如果 p(x) 的形状越接近 f(x)，则有益于最终结果的收敛</strong>。</p>
<p><strong>上述思想就是“重要性采样”的方法，即对积分值有重要贡献，即 f(x) 较大的被积函数区间，我们以较大概率生成处于这个区间附近的随机变量，就可以快速逼近理论值。</strong> </p>
<p>应用到光线追踪中，光源方向的光线对最终渲染方程积分结果的贡献更大，如果使用我们现在的均匀随机采样，由于光源很小，得到光源方向的光线的概率就很小，自然对最终结果的估计就会产生较大的偏差，体现在画面上就是有很大的噪声。于是为了消除噪声，我们应该使用重要性采样，生成更多光源方向的光线。</p>
<p>当然，如果我们采样更多的随机光线到光源，会导致积分结果过大，也就是画面过亮，而产生不正确的效果，因此我们需要降低这些样本的权重，在蒙特卡洛积分的公式中，除以概率密度函数就是为了解决这个问题，概率密度大的样本取到的相对概率大，除以这个概率可以削弱该样本的权重，以抵消这种不均衡。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十一）混合概率密度</title>
    <url>/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<p>现在我们有了光线在平面随机散射的 pdf 和直接对光源采样的 pdf，接下来我们可以混合这两种 pdf 得到混合概率密度，使用概率密度的好处之一正是 pdf 支持线性组合。</p>
<p><em><span id="more"></span></em></p>
<p>因为我们要混和多种 pdf，最好的方法就是新建一个类去管理他们：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 概率密度函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PDF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pdf</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">pdf</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们将之前的随机散射的 pdf 作为派生类实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法线周围随机散射的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cosine_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cosine_pdf</span>(<span class="type">const</span> vec3&amp; w) &#123; uvw.<span class="built_in">build_from_w</span>(w); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(<span class="built_in">normalize</span>(direction), uvw.<span class="built_in">w</span>());</span><br><span class="line">        <span class="keyword">return</span> (cosine &lt;= <span class="number">0</span>) ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_cosine_direction</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    onb uvw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后实现一个向场景中某个物体的方向采样光线的 pdf 类，这样我们可以不只向光源方向采样，还可以支持场景中的其他物体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向场景中某个物体方向采样的pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hittable_pdf</span>(shared_ptr&lt;hittable&gt; p, <span class="type">const</span> point3&amp; origin) : <span class="built_in">ptr</span>(p), <span class="built_in">o</span>(origin) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">pdf_value</span>(o, direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 o;</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们新调用了 <code>hittable</code> 类中的两个方法 <code>value</code> 和 <code>random</code>，因此要在抽象类中声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，在派生类中实现</span></span><br><span class="line">    <span class="comment">// 计算光线与物体的交点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算物体的包围盒</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚函数，不要求所有派生类都实现</span></span><br><span class="line">    <span class="comment">// 计算对该物体方向采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成对该物体方向采样的随机光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 xz 平面物体类中实现这两个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xz平面矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xz_rect</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********作为光源平面用到的方法*********/</span></span><br><span class="line">    <span class="comment">// 计算随机采样的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; origin, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(origin, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 光源平面面积</span></span><br><span class="line">        <span class="keyword">auto</span> area = (x1 - x0) * (z1 - z0);</span><br><span class="line">        <span class="comment">// 光源采样点到着色点的距离平方</span></span><br><span class="line">        <span class="keyword">auto</span> distance_squared = rec.t * rec.t * v.<span class="built_in">length_squared</span>();</span><br><span class="line">        <span class="comment">// 光线和光源平面法线cos</span></span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">fabs</span>(<span class="built_in">dot</span>(v, rec.normal) / v.<span class="built_in">length</span>());</span><br><span class="line">        <span class="comment">// 概率密度</span></span><br><span class="line">        <span class="keyword">return</span> distance_squared / (cosine * area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机采样一点，作为随机采样的方向</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; origin)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> random_point = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(x0, x1), k, <span class="built_in">random_double</span>(z0, z1));</span><br><span class="line">        <span class="keyword">return</span> random_point - origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后开始实现混合 pdf 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混合pdf</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mixture_pdf</span> : <span class="keyword">public</span> pdf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mixture_pdf</span>(shared_ptr&lt;pdf&gt; p0, shared_ptr&lt;pdf&gt; p1) &#123;</span><br><span class="line">        p[<span class="number">0</span>] = p0;</span><br><span class="line">        p[<span class="number">1</span>] = p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">value</span><span class="params">(<span class="type">const</span> vec3&amp; direction)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * p[<span class="number">0</span>]-&gt;<span class="built_in">value</span>(direction) + <span class="number">0.5</span> * p[<span class="number">1</span>]-&gt;<span class="built_in">value</span>(direction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> vec3 <span class="title">generate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &lt; <span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">0</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p[<span class="number">1</span>]-&gt;<span class="built_in">generate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;pdf&gt; p[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们这里只是简单的把两个 pdf 平均起来。</p>
<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf_val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf_val))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混合 pdf</span></span><br><span class="line">    <span class="keyword">auto</span> p0 = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="keyword">auto</span> p1 = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">    <span class="function">mixture_pdf <span class="title">mixed_pdf</span><span class="params">(p0, p1)</span></span>;</span><br><span class="line">    <span class="comment">// 使用混合pdf采样光线</span></span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, mixed_pdf.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    pdf_val = mixed_pdf.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line">shared_ptr&lt;hittable&gt; lights;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sence = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">switch</span> (sence) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">        world = <span class="built_in">cornell_box</span>();</span><br><span class="line">        lights = <span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;());</span><br><span class="line">        aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">        image_width = <span class="number">600</span>;</span><br><span class="line">        samples_per_pixel = <span class="number">10000</span>;</span><br><span class="line">        min_bounce = <span class="number">95</span>;</span><br><span class="line">        background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">40.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E6%B7%B7%E5%90%88%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6/CornellBoxFinal.png" alt="CornellBoxFinal"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十）直接对光源采样</title>
    <url>/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<p>到目前为止我们实际上没有对之前的实现有什么实质性的更改，只是换了一种实现方式，所以得到的效果自然也是差不多的。但是改变实现方式是为了能够实现重要性采样，这一节我们将直接对光源进行采样。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-对光源采样的-PDF"><a href="#1-对光源采样的-PDF" class="headerlink" title="1 对光源采样的 PDF"></a>1 对光源采样的 PDF</h3><p>对光源直接采样就是把渲染方程中的对 $\omega$ 的积分改为对光源面积 $A$ 的积分，因此要做一个积分变量的替换，图形学中我们用立体角公式已经推导过 $d\omega$ 和 $dA$ 的关系：<br>$$<br>d\omega &#x3D; \frac{dA·cos\theta’}{||x - p||^2}<br>$$<br>回顾我们之前改写的蒙特卡洛计算渲染方程：<br>$$<br>color_{out} &#x3D; \frac{albedo·s(direction)·color_{in}}{p(direction)}<br>$$<br>我们只需要解出对光源采样的 $p(direction)$ 即可。因为无论对 $\omega$ 采样还是对光源 $A$ 采样，得到的方向的概率应该都是一样的，所以：<br>$$<br>p(direction)·d\omega &#x3D; \frac{1}{A}·dA<br>$$<br>其中 $\frac{1}{A}$ 是对光源面积 $A$ 均匀采样的概率密度，把上面 $d\omega$ 和 $dA$ 的关系式带入即可得到：<br>$$<br>p(direction) &#x3D; \frac{||x-p||^2}{cos\theta’·A}<br>$$<br>也就是对光源采样的概率密度函数。这实际上和我们图形学中推导的，通过积分变量替换改写渲染方程，再用对光源采样的 $pdf&#x3D;\frac{1}{A}$ 进行蒙特卡洛积分计算是完全一样的，只是这里我们把整个积分替换的系数和对光源采样的 pdf 统一写成了对方向 $\omega$ 在光源方向上采样的 pdf。</p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>有了上面的公式我们可以改写 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    ray scattered;</span><br><span class="line">    color albedo;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(rec.u, rec.v, rec.p);</span><br><span class="line">    <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">    <span class="type">double</span> pdf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, albedo, scattered, pdf))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光源平面随机采样一点</span></span><br><span class="line">    <span class="keyword">auto</span> on_light = <span class="built_in">point3</span>(<span class="built_in">random_double</span>(<span class="number">213</span>, <span class="number">343</span>), <span class="number">554</span>, <span class="built_in">random_double</span>(<span class="number">227</span>, <span class="number">332</span>));</span><br><span class="line">    <span class="comment">// 光源到着色点p的方向</span></span><br><span class="line">    <span class="keyword">auto</span> to_light = on_light - rec.p;</span><br><span class="line">    <span class="comment">// 得到距离用于之后计算pdf</span></span><br><span class="line">    <span class="keyword">auto</span> distance_squared = to_light.<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="comment">// 方向归一化用于得到cos(theta&#x27;)</span></span><br><span class="line">    to_light = <span class="built_in">normalize</span>(to_light);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(to_light, rec.normal) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="keyword">auto</span> light_cosine = <span class="built_in">fabs</span>(to_light.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">if</span> (light_cosine &lt; <span class="number">0.000001</span>)</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line">    <span class="comment">// 光源面积</span></span><br><span class="line">    <span class="type">double</span> light_area = (<span class="number">343</span> - <span class="number">213</span>) * (<span class="number">332</span> - <span class="number">227</span>);</span><br><span class="line">    <span class="comment">// 计算直接对光源采样的pdf</span></span><br><span class="line">    pdf = distance_squared / (light_cosine * light_area);</span><br><span class="line">    scattered = <span class="built_in">ray</span>(rec.p, to_light, r.<span class="built_in">time</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">// Cornell Box 场景</span></span><br><span class="line">world = <span class="built_in">cornell_box</span>();</span><br><span class="line">aspect_ratio = <span class="number">1.0</span>;</span><br><span class="line">image_width = <span class="number">600</span>;</span><br><span class="line">samples_per_pixel = <span class="number">10</span>;</span><br><span class="line">min_bounce = <span class="number">45</span>;</span><br><span class="line">background = <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">lookfrom = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">-800</span>);</span><br><span class="line">lookat = <span class="built_in">point3</span>(<span class="number">278</span>, <span class="number">278</span>, <span class="number">0</span>);</span><br><span class="line">vfov = <span class="number">40.0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每个像素只采样 10 根光线，得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/CornellBoxLight.png" alt="CornellBoxLight"></p>
<p>比之前每个像素采样 100 根光线的噪声还要小很多。</p>
<h3 id="3-单向光源"><a href="#3-单向光源" class="headerlink" title="3 单向光源"></a>3 单向光源</h3><p>可以看到上面的结果中，噪声主要集中在光源附近，这是因为光源是双面的，光源和天花板之间有一个很小的缝隙，为了解决这个问题我们可以让光源只向下发光，修改光源材质的 <code>emitted</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自发光材质，用作光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">diffuse_light</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">diffuse_light</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">emit</span>(a) &#123;&#125;</span><br><span class="line">    <span class="built_in">diffuse_light</span>(color c) : <span class="built_in">emit</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(c)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有正面发光</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rec.front_face)</span><br><span class="line">            <span class="keyword">return</span> emit-&gt;<span class="built_in">value</span>(u, v, p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; emit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后实现一个翻转类，使得我们能够翻转光源法线，使它的法线全部指向 -y 方向：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转光源法线，使其只有正面发光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flip_face</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">flip_face</span>(shared_ptr&lt;hittable&gt; p) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ptr-&gt;<span class="built_in">hit</span>(r, t_min, t_max, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        rec.front_face = !rec.front_face;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">bounding_box</span><span class="params">(<span class="type">double</span> time0, <span class="type">double</span> time1, aabb&amp; output_box)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">bounding_box</span>(time0, time1, output_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;hittable&gt; ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在场景中调用翻转：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;flip_face&gt;(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, light)));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> color&amp; background, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    ...</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + albedo * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, depth - <span class="number">1</span>, RR) / pdf / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/26/20220426-RayTracer-%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%89%E6%BA%90%E9%87%87%E6%A0%B7/CornellBoxLightFlip.png" alt="CornellBoxLightFlip"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（二十二）最后一步</title>
    <url>/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>到此为止关于漫反射材质的全部内容就都完成了，现在只剩最后一步——用我们新的实现方式修改金属和电介质材质，使得新的光线追踪器支持镜面反射和折射。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-统一管理散射光线"><a href="#1-统一管理散射光线" class="headerlink" title="1 统一管理散射光线"></a>1 统一管理散射光线</h3><p>对于镜面反射和折射，如果用新的渲染方程会出现 pdf 值为 0 的情况，因此我们使用之前隐式的渲染方程，也就是采样 pdf 和光线散射 pdf 一致。为此我们首先需要新增一个结构体来统一管理散射光线，然后根据散射光线的类型选择对应的渲染方程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统一管理散射光线</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">scatter_record</span> &#123;</span><br><span class="line">    ray specular_ray;           <span class="comment">// 散射光线</span></span><br><span class="line">    <span class="type">bool</span> is_specular;           <span class="comment">// 是否是镜面反射，金属或者电介质为true</span></span><br><span class="line">    color attenuation;          <span class="comment">// 反射率</span></span><br><span class="line">    shared_ptr&lt;pdf&gt; pdf_ptr;    <span class="comment">// 散射光线pdf，如果是金属或者电介质就是空指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改材质抽象类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 散射函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 计算材质散射光线的pdf</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自发光，可选</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">emitted</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来用新的结构体和方法改写之前实现的 Lambertian 材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类，在单位球面上采样得到散射方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(<span class="built_in">make_shared</span>&lt;solid_color&gt;(a)) &#123;&#125;</span><br><span class="line">    <span class="built_in">lambertian</span>(shared_ptr&lt;texture&gt; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样散射光线</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">false</span>;</span><br><span class="line">        srec.attenuation = albedo-&gt;<span class="built_in">value</span>(rec.u, rec.v, rec.p);</span><br><span class="line">        <span class="comment">// 采样光线的概率密度</span></span><br><span class="line">        srec.pdf_ptr = <span class="built_in">make_shared</span>&lt;cosine_pdf&gt;(rec.normal);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 材质本身散射光线的概率密度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">scattering_pdf</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, <span class="type">const</span> ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cosine = <span class="built_in">dot</span>(rec.normal, <span class="built_in">normalize</span>(scattered.<span class="built_in">direction</span>()));</span><br><span class="line">        <span class="keyword">return</span> cosine &lt; <span class="number">0</span> ? <span class="number">0</span> : cosine / pi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;texture&gt; albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******创建场景*******/</span></span><br><span class="line">hittable_list world;</span><br><span class="line"><span class="keyword">auto</span> lights = <span class="built_in">make_shared</span>&lt;hittable_list&gt;();</span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;xz_rect&gt;(<span class="number">213</span>, <span class="number">343</span>, <span class="number">227</span>, <span class="number">332</span>, <span class="number">554</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line"><span class="comment">// 对透光的玻璃也进行额外采样</span></span><br><span class="line">lights-&gt;<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="built_in">shared_ptr</span>&lt;material&gt;()));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-金属和电介质"><a href="#2-金属和电介质" class="headerlink" title="2 金属和电介质"></a>2 金属和电介质</h3><p>有了统一管理散射光线的方法，我们可以修改之前的金属材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        srec.attenuation = albedo;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时修改电介质材质类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电介质材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dielectric</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">dielectric</span>(<span class="type">double</span> index_of_refraction) : <span class="built_in">ir</span>(index_of_refraction) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, scatter_record&amp; srec</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        srec.is_specular = <span class="literal">true</span>;</span><br><span class="line">        srec.pdf_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 电介质不吸收任何光，全部被折射或者反射，所以衰减系数恒为1</span></span><br><span class="line">        srec.attenuation = <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">        <span class="comment">// 如果是正面，则是从空气进入介质，反之从介质折射出去</span></span><br><span class="line">        <span class="type">double</span> refraction_ratio = rec.front_face ? (<span class="number">1.0</span> / ir) : ir;</span><br><span class="line">        <span class="comment">// 入射光线记得单位化，折射函数传入的参数都是单位向量</span></span><br><span class="line">        vec3 unit_direction = <span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="comment">// 计算是否发生折射</span></span><br><span class="line">        <span class="type">double</span> cos_theta = <span class="built_in">fmin</span>(<span class="built_in">dot</span>(-unit_direction, rec.normal), <span class="number">1.0</span>);</span><br><span class="line">        <span class="type">double</span> sin_theta = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - cos_theta * cos_theta);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> cannot_refract = refraction_ratio * sin_theta &gt; <span class="number">1.0</span>;</span><br><span class="line">        vec3 direction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cannot_refract || <span class="built_in">reflectance</span>(cos_theta, refraction_ratio) &gt; <span class="built_in">random_double</span>())</span><br><span class="line">            direction = <span class="built_in">reflect</span>(unit_direction, rec.normal);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            direction = <span class="built_in">refract</span>(unit_direction, rec.normal, refraction_ratio);</span><br><span class="line">        </span><br><span class="line">        srec.specular_ray = <span class="built_in">ray</span>(rec.p, direction, r_in.<span class="built_in">time</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> ir;  <span class="comment">//介质折射率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">reflectance</span><span class="params">(<span class="type">double</span> cosine, <span class="type">double</span> ref_idx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Schlick&#x27;s近似计算菲涅尔项</span></span><br><span class="line">        <span class="keyword">auto</span> r0 = (<span class="number">1</span> - ref_idx) / (<span class="number">1</span> + ref_idx);</span><br><span class="line">        r0 = r0 * r0;</span><br><span class="line">        <span class="keyword">return</span> r0 + (<span class="number">1</span> - r0) * <span class="built_in">pow</span>((<span class="number">1</span> - cosine), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pdf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ray&amp; r, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> color&amp; background, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> hittable&amp; world, </span></span></span><br><span class="line"><span class="params"><span class="function">    shared_ptr&lt;hittable&gt;&amp; lights, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> depth, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> RR)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果光线没有打到任何物体，返回背景颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (!world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">        <span class="keyword">return</span> background;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 根据物体材质得到光线传播方向、反射率及自发光颜色</span></span><br><span class="line">    scatter_record srec;</span><br><span class="line">    color emitted = rec.mat_ptr-&gt;<span class="built_in">emitted</span>(r, rec, rec.u, rec.v, rec.p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于光源，不会发生散射，返回光源颜色</span></span><br><span class="line">    <span class="keyword">if</span> (!rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, srec))</span><br><span class="line">        <span class="keyword">return</span> emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是高光反射或折射，采用之前的渲染方程，隐式的使采样pdf和散射pdf保持一致</span></span><br><span class="line">    <span class="keyword">if</span> (srec.is_specular) &#123;</span><br><span class="line">        <span class="keyword">return</span> srec.attenuation</span><br><span class="line">            * <span class="built_in">ray_color</span>(srec.specular_ray, background, world, lights, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对光源采样的pdf</span></span><br><span class="line">    <span class="keyword">auto</span> light_ptr = <span class="built_in">make_shared</span>&lt;hittable_pdf&gt;(lights, rec.p);</span><br><span class="line">    <span class="comment">// 混合pdf</span></span><br><span class="line">    <span class="function">mixture_pdf <span class="title">p</span><span class="params">(light_ptr, srec.pdf_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样光线</span></span><br><span class="line">    ray scattered = <span class="built_in">ray</span>(rec.p, p.<span class="built_in">generate</span>(), r.<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 采样光线的pdf值</span></span><br><span class="line">    <span class="keyword">auto</span> pdf_val = p.<span class="built_in">value</span>(scattered.<span class="built_in">direction</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染方程</span></span><br><span class="line">    <span class="keyword">return</span> emitted</span><br><span class="line">        + srec.attenuation * rec.mat_ptr-&gt;<span class="built_in">scattering_pdf</span>(r, rec, scattered)</span><br><span class="line">        * <span class="built_in">ray_color</span>(scattered, background, world, lights, depth - <span class="number">1</span>, RR) / pdf_val / RR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cornell Box场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">cornell_box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;material&gt; aluminum = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.88</span>), <span class="number">0.0</span>);</span><br><span class="line">    shared_ptr&lt;hittable&gt; box1 = <span class="built_in">make_shared</span>&lt;box&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">165</span>, <span class="number">330</span>, <span class="number">165</span>), aluminum);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;rotate_y&gt;(box1, <span class="number">15</span>);</span><br><span class="line">    box1 = <span class="built_in">make_shared</span>&lt;translate&gt;(box1, <span class="built_in">vec3</span>(<span class="number">265</span>, <span class="number">0</span>, <span class="number">295</span>));</span><br><span class="line">    objects.<span class="built_in">add</span>(box1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> glass = <span class="built_in">make_shared</span>&lt;dielectric&gt;(<span class="number">1.5</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="built_in">point3</span>(<span class="number">190</span>, <span class="number">90</span>, <span class="number">190</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">90</span>, glass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-对球体和物体列表采样"><a href="#3-对球体和物体列表采样" class="headerlink" title="3 对球体和物体列表采样"></a>3 对球体和物体列表采样</h3><p>上面的主函数中我们对透明玻璃球也进行了额外采样，因此类似于之前光源所在的 zx 平面，现在我们需要实现球体和物体列表的 <code>pdf_value</code> 函数和 <code>random</code> 函数，对球体采样的具体推导过程可以查看《RayTracingTheRestOfYourLife》第 12.3 节，这里直接给出代码，首先修改球体类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        hit_record rec;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;<span class="built_in">hit</span>(<span class="built_in">ray</span>(o, v), <span class="number">0.001</span>, infinity, rec))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cos_theta_max = <span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / (center0 - o).<span class="built_in">length_squared</span>());</span><br><span class="line">        <span class="keyword">auto</span> solid_angle = <span class="number">2</span> * pi * (<span class="number">1</span> - cos_theta_max);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> / solid_angle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">random</span><span class="params">(<span class="type">const</span> point3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        vec3 direction = center0 - o;</span><br><span class="line">        <span class="keyword">auto</span> distance_squared = direction.<span class="built_in">length_squared</span>();</span><br><span class="line">        onb uvw;</span><br><span class="line">        uvw.<span class="built_in">build_from_w</span>(direction);</span><br><span class="line">        <span class="keyword">return</span> uvw.<span class="built_in">local</span>(<span class="built_in">random_to_sphere</span>(radius, distance_squared));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>工具函数新增：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在球体外对球体随机采样</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_to_sphere</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> distance_squared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r1 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> r2 = <span class="built_in">random_double</span>();</span><br><span class="line">    <span class="keyword">auto</span> z = <span class="number">1</span> + r2 * (<span class="built_in">sqrt</span>(<span class="number">1</span> - radius * radius / distance_squared) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="number">2</span> * pi * r1;</span><br><span class="line">    <span class="keyword">auto</span> x = <span class="built_in">cos</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line">    <span class="keyword">auto</span> y = <span class="built_in">sin</span>(phi) * <span class="built_in">sqrt</span>(<span class="number">1</span> - z * z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是物体列表 <code>hittable_list</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hittable_list</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">hittable_list::pdf_value</span><span class="params">(<span class="type">const</span> point3&amp; o, <span class="type">const</span> vec3&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> weight = <span class="number">1.0</span> / objects.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> sum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; object : objects)</span><br><span class="line">            sum += weight * object-&gt;<span class="built_in">pdf_value</span>(o, v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vec3 <span class="title">hittable_list::random</span><span class="params">(<span class="type">const</span> vec3&amp; o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> int_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(objects.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> objects[<span class="built_in">random_int</span>(<span class="number">0</span>, int_size - <span class="number">1</span>)]-&gt;<span class="built_in">random</span>(o);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-最后一步"><a href="#4-最后一步" class="headerlink" title="4 最后一步"></a>4 最后一步</h3><p>最后一步我们来处理掉之前图片中有时会出现的黑点或者异常像素，这是因为一些不好的采样计算出了很大的或者 NaN 的颜色，使得整个像素受损，因此我们可以在写颜色的时候处理这种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向数组中写入一个颜色，用到了指针的引用传递</span></span><br><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常像素值</span></span><br><span class="line">    <span class="keyword">if</span> (r != r) r = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g != g) g = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b != b) b = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/27/20220427-RayTracer-%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5/CornellBoxConv.png" alt="CornellBoxConv"></p>
<h3 id="完结撒花！"><a href="#完结撒花！" class="headerlink" title="完结撒花！"></a>完结撒花！</h3>]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎】（一）游戏引擎架构</title>
    <url>/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>游戏引擎是一个庞大的软件系统，也是最接近操作系统的大型软件，因此会涉及非常复杂的架构设计、资源管理和和代码实现。这一节我们简要学习一个游戏引擎必备的几个重要模块及其功能，了解游戏引擎的宏观分层架构。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-游戏引擎分层架构"><a href="#1-游戏引擎分层架构" class="headerlink" title="1 游戏引擎分层架构"></a>1 游戏引擎分层架构</h3><p>现代游戏引擎的架构极为复杂，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155123811.png" alt="image-20220428155123811"></p>
<p>但大致可分为以下几个层次：</p>
<ul>
<li>工具层：工具层是面向游戏开发者，能够让游戏开发者使用引擎制作游戏的接口，包括一些系列可视化的编辑器，比如角色编辑器、纹理编辑器、动画编辑器等等。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428155356486.png" alt="image-20220428155356486"></p>
<ul>
<li>功能层：功能层包含一个游戏需要的各种功能，包括物理碰撞、动画、渲染、音效、逻辑脚本等等，是能够让一款游戏充满可玩性的核心驱动。</li>
<li>资源层：资源层负责管理游戏引擎中的各种资源，比如纹理、模型、音频、视频、脚本等，资源层需要将这些资源合理的、有层次的组织起来，并管理他们的生命周期，在合适的时间加载某些资源，在另外一些时候释放某些资源。</li>
<li>核心层：核心层包含上面几层在实现的过程中需要频繁使用的一些工具函数，比如数学、数据结构、常用的算法等，核心层是游戏引擎中所有上层结构的支撑，由于游戏引擎对效率的要求很高，所以有时并不能直接使用 C++ STL 提供的一些容器或者算法，而需要根据需求编写更高效的数据结构实现和算法函数供上层调用，因此核心层也是对代码质量要求最高的一层。</li>
<li>平台层：平台层是最容易被忽略的一层，但也是非常重要的一层，平台层负责处理不同平台的差异，包括软件平台和硬件平台，比如不同的操作系统、不同的 CPU&#x2F;GPU 架构、不同的游戏输入设备等等，保证游戏能够在所有平台完美运行。</li>
<li>第三方库：第三方库一方面用于实现一些基本功能，比如 GUI、图像处理等，另外也可以将功能层中某些模块直接用第三方库来实现，比如一些专门做物理、动画的第三方插件，直接集成到引擎中既方便开发，得到的效果也更好。</li>
</ul>
<p>游戏引擎架构当然没有这么简单，但是大致总结起来可以认为就是由这几部分组成的，分层架构的设计要求必须由上层调用下层功能，这样既便于开发，也便于管理。接下来我们对其中的重要模块稍作深入了解。</p>
<h3 id="2-资源层"><a href="#2-资源层" class="headerlink" title="2 资源层"></a>2 资源层</h3><p>游戏开发中需要利用各种资源来达到目的，而各类资源有不同的格式，即使是同一类资源，它们的格式也不尽相同，比如不同的 3D 建模软件导出的模型就存在各种各样的格式差异，资源层需要将这些不同的资源，统一转化为游戏引擎使用的格式，转换后的资源被称为 Asset，从资源到 Asset 的过程可以认为是对资源文件的提纯过程，这个过程会去掉那些游戏引擎不需要的信息，比如 3D 模型中的编辑信息，而只保留游戏引擎中需要的信息，并组织成统一的格式。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428161522013.png" alt="image-20220428161522013"></p>
<p>除此之外，资源层还要对海量的资源进行合理的管理，包括每个资源的唯一标识（GUID）、不同资源之间的关系、资源的生命周期等等。高效的管理资源是一个游戏稳定运行的基础，比如在游戏场景切换的时候就需要卸载大量资源再加载大量资源，如果资源管理做的不好，轻则加载时间长，影响游戏体验，重则出现卡顿，甚至崩溃。</p>
<h3 id="3-功能层"><a href="#3-功能层" class="headerlink" title="3 功能层"></a>3 功能层</h3><p>从某种程度上说，功能层是游戏引擎最核心的部分，因为它实现了一个游戏之所以能称之为游戏的全部重要功能，包括渲染、物理、动画、音效、网络、游戏性等等。因此功能层也是构建游戏世界的核心。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162147284.png" alt="image-20220428162147284"></p>
<p>游戏世界是依靠 Tick 来驱动的，类似于秒针走动一下，我们的世界就会发生一次改变。在游戏世界中，“秒针”每次走动，我们的计算机就会将所有的功能全部运行一遍，来计算这一秒游戏世界中发生的事情，因此在游戏引擎的代码中，入口就是 Tick：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428162301962.png" alt="image-20220428162301962"></p>
<p>Tick 一般分为逻辑 Tick 和渲染 Tick，逻辑 Tick 负责计算相机、运动、动画、物理等功能，相当于在构建整个游戏世界；渲染 Tick 则负责将游戏在世界呈现在玩家面前，包括剔除、渲染、后处理等等。因此在每一个 Tick 中，都是先计算逻辑 Tick，再计算渲染 Tick。</p>
<p>功能层的许多功能可以在游戏中实现，也可以在游戏引擎中实现，这完全取决于需求，对于一些通用的商业引擎，它们可能会用于制作各种类型的游戏，因此功能层提供的功能要尽可能的丰富，而对于一些专用的引擎，比如寒霜、RED ENGINE等，它们被用于制作特定类型的游戏，因此就会在功能层对特定的功能进行实现，而抛弃一些不需要的功能。</p>
<h3 id="4-核心层"><a href="#4-核心层" class="headerlink" title="4 核心层"></a>4 核心层</h3><p>核心层为上层实现提供核心驱动，在核心层会实现包括数学计算、数据结构、内存管理、线程管理在内的基本代码，这部分要保证绝对的安全、稳定、高效。因此对编码要求也极高，一般核心层的代码不会轻易修改。</p>
<p>数学计算包括一些基本运算、向量、矩阵、四元数、随机数等的实现，游戏中许多计算可能并不要求结果的绝对精确，而是更需要计算的高效性，结果允许存在一定误差，因此在实现上就和 C++ 提供的数学库完全不同了。</p>
<p>数据结构也是同样，STL 提供的各种数据结构和容器实现有时候可能在内存、效率上达不到游戏中的要求，比如 C++11 中的 vector 在扩容时就可能造成大量的空间碎片，因此我们需要实现更高效、内存管理更严格的数据结构和容器供上层使用。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/image-20220428163516740.png" alt="image-20220428163516740"></p>
<h3 id="5-平台层"><a href="#5-平台层" class="headerlink" title="5 平台层"></a>5 平台层</h3><p>平台层需要处理不同软硬件平台的差异，使得游戏和引擎能够在不同平台上运行。平台之间的差异说起来简单，但是实际情况却非常复杂，比如图形 API 之间的差异，DirectX 11、OpenGL、Vulkan 等图形接口就有相当大的差异，即便是同为微软的 DirectX 11 和 DirectX 12 也有着完全不同的实现框架，并且不同的显卡架构也完全不同，因此需要一个统一的渲染接口将这些差异统一起来，使得上层使用者只需要关注功能实现，而不需要关注底层接口和硬件之间的差异。</p>
<p>除此之外，平台差异还包括核心处理器架构的差异，PS、XBox、PC 等平台的核心处理架构设计是完全不同的，需要对这样的差异进行处理；另外还有游戏输入设备之间的差异，键鼠、手柄、方向盘、感应器等等，需要一个统一的接口处理这些设备的输入，使它们能得到相同的响应效果。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>总而言之，游戏引擎架构极为复杂，但概括来说就是由分层架构搭建而成，并且只允许上层功能调用下层功能，不允许下层功能调用上层功能。越底层的功能越稳定，越上层的功能越灵活。</p>
<p>游戏世界依靠 Tick 驱动，每一个 Tick 都计算一次逻辑功能和渲染功能，这样整个游戏世界就能够构建起来、运行起来并且呈现在玩家面前了。</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL】序列式容器</title>
    <url>/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>容器（Containers）是 STL 六大组件中最被人熟知和常用的一个神器，根据组织方式大概分为序列式容器和关联式容器两大类。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-STL-容器概览"><a href="#1-STL-容器概览" class="headerlink" title="1 STL 容器概览"></a>1 STL 容器概览</h3><p>STL 提供的容器如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430153405060.png" alt="image-20220430153405060"></p>
<p>其中内缩表达基层与衍生层的关系，这里所谓的衍生，并非派生 (inheritance) 关系，而是内含 (containment) 关系。例如 heap 内含一个 vector，priority_queue 内含一个 heap 、stack 和 queue 都含一个 deque，set&#x2F;map&#x2F;multiset&#x2F;multimap 都内含一个 RB-tree，hast_x 都内含一个 hashtable。</p>
<h3 id="2-序列式容器"><a href="#2-序列式容器" class="headerlink" title="2 序列式容器"></a>2 序列式容器</h3><p>所谓序列式容器，其中的元素都可序（ordered），但未必有序（sorted），C++ 本身内建了一个序列式容器array，STL 另外提供了vector、list、deque、stack、queue、priority-queue 等序列式容器。其中 stack 和 queue 由于只是 deque 改头换面而来，技术上被归为一种配接器 (adapter)。接下来了解各序列式容器的具体实现。</p>
<h3 id="3-vector"><a href="#3-vector" class="headerlink" title="3 vector"></a>3 vector</h3><p>vector 采用的数据结构非常简单：线性连续空间。它以两个迭代器 start 和 finish 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 end_of_storage 指向整块连续空间（含备用空间）的尾端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;             <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">    iterator finish;            <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">    iterator end_of_storage;    <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了降低空间配置时的速度成本， vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量 (capacity) 的观念。换句话说，一个 vector 的容量永远大于或等于其大小。一旦容量等于大小，下次再有新增元素，整个 vector 就得进行动态增加容量。</p>
<p>所谓动态增加容量，并不是在原来空间之后接续新空间（因为无法保证原空间之后尚有可供分配的空间），而是以原来大小的的两倍另外分配一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430154445332.png" alt="image-20220430154445332"></p>
<p>当我们以 <code>push_back()</code> 将新元素插入于 vector 尾端时，该函数首先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新配置、移动数据、释放原空间）。</p>
<h3 id="4-list"><a href="#4-list" class="headerlink" title="4 list"></a>4 list</h3><p>相对于 vector 的连续线性空间，list 就显得复杂许多，它的好处就是插入或删除一个元素，就配置或删除一个元素空间。对于任何位置的元素的插入或删除，list 永远是常数时间。</p>
<p>List 不仅是一个双向链表，而且是一个双向循环链表，只需一个指针就可遍历整个链表。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430155828333.png" alt="image-20220430155828333"></p>
<p>对于迭代器，只能通过 <code>++</code> 或 <code>--</code> 操作将迭代器移动到后继&#x2F;前驱节点元素处，而不能对迭代器进行 +n 或 -n 的操作。因此 List 的迭代器是双向迭代器。在 List 中增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其它迭代器都不会失效。</p>
<h3 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h3><p>vector 是单向开口的连续线性空间，deque 则是一种双向开口的线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，虽然 vector 也支持从头端插入元素，不过效率奇差。deque 容器类与 vector 类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。</p>
<p>deque 与 vector 最大差异：</p>
<ul>
<li>deque 允许常数时间内对头部进行元素的插入或移除操作。</li>
<li>deque 没有所谓的容量观念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并拼接起来。</li>
</ul>
<p>deque 由一段一段连续空间组成，一旦有必要在 deque 的前端或尾端增加新空间，便配置一段连续空间，串接在整个 deque 的前端或尾端。deque 的最大任务，便是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价是复杂的迭代器结构。</p>
<p>deque 采用一块所谓的 map（不是 STL 的 map 容器）作为主控。这里所谓 map 是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是 deque 的储存空间主体。 SGI STL 允许我们指定缓冲区大小，默认值 0 表示将使用 512 bytes 缓冲区。deque 最初状态（无任何元素）保有一个缓冲区，因此，clear() 完成之后回到初始状态，也一样会保留一个缓冲区。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430160922218.png" alt="image-20220430160922218"></p>
<p>由于以上结构，deque 的迭代器实现也较为复杂，deque 的迭代器首先必须指出分段连续空间在哪里，其次它必须能够判断自己是否已经处在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃下一个缓冲区，为了能够正常跳跃，deque 必须随时掌握管控中心（map）。下图展示了 deque 的中控器、迭代器和缓冲区的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430161351783.png" alt="image-20220430161351783"></p>
<p>假设一个 deque 存储 20 个元素，每个缓冲区可以存储 8 个元素，则它的迭代器关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220430161627317.png" alt="image-20220430161627317"></p>
<p>迭代器 start 内的 cur 指针指向第一块缓冲区的第一个元素，迭代器 finish 内的 cur 指针指向最后一块缓冲区的最后一个元素（的下一位置）。</p>
<p>下面来分析 deque 常用操作对迭代器的影响：</p>
<ul>
<li>在队前或队后插入元素时（push_back()和push_front()），由于可能缓冲区的空间不够，需要增加 map 中控器，而中控器的个数如果也不够，就需要新开辟更大的空间来容纳中控器，所以可能会使迭代器失效；但指针、引用仍有效，因为缓冲区已有的元素没有重新分配内存。</li>
<li>在队列其他位置插入元素时，由于会造成缓冲区的一些元素的移动，所以肯定会造成迭代器的失效；并且指针、引用都会失效。</li>
<li>删除队头或队尾的元素时，由于只是对当前的元素进行操作，所以其他元素的迭代器不会受到影响，所以一定不会失效，而且指针和引用也都不会失效。</li>
<li>删除其他位置的元素时，也会造成元素的移动，所以其他元素的迭代器、指针和引用都会失效。</li>
</ul>
<h3 id="5-stack"><a href="#5-stack" class="headerlink" title="5 stack"></a>5 stack</h3><p>stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口。stack 允许增加元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其他方法可以存取 stack 的其他元素，换言之，stack 不允许有遍历行为，因此 stack 没有迭代器。stack 默认以 deque 为底层容器。stack 是对 deque 的又一层封装，因此 stack 并不是容器，而被称作配接器。</p>
<p>除了 deque 外，stack 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p>
<h3 id="6-queue"><a href="#6-queue" class="headerlink" title="6 queue"></a>6 queue</h3><p>queue 是一种先进先出（First In First Out，FIFO）的数据结构，它有两个出口，允许增加元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何其他方法可以存取 queue 的其他元素，换言之，queue不允许有遍历行为，因此 queue 没有迭代器。queue 默认以 deque 为底层容器。</p>
<p>除了 deque 外，queue 也可以使用 list 作为底层容器，因为二者都是双端开头的容器。</p>
<h3 id="7-heap"><a href="#7-heap" class="headerlink" title="7 heap"></a>7 heap</h3><p>heap 使用 vector 作为底层容器，关于 heap 的算法可在专题<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/06/20220406-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/">【数据结构】优先队列和堆</a>中找到。STL 默认建立大顶堆。</p>
<h3 id="8-priority-queue"><a href="#8-priority-queue" class="headerlink" title="8 priority_queue"></a>8 priority_queue</h3><p>priority_queue 底层使用 heap 实现。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL】迭代器</title>
    <url>/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>STL的中心思想是：将数据容器和算法分隔开，彼此独立设计，最后再用黏合剂将它们撮合在一起。容器和算法的泛型化，可以用 C++ 的 class template 和 function template 来实现，而迭代器（Iterator）就是二者的黏合剂了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-迭代器的实现"><a href="#1-迭代器的实现" class="headerlink" title="1 迭代器的实现"></a>1 迭代器的实现</h3><p>迭代器是一种智能指针，它将指针进行了一层封装，既包含了原生指针的灵活和强大，也加上很多重要的特性，使其能发挥更大的作用以及能更好的使用。指针最常见也最为重要的行为就是内容提领 (dereference) 和成员访问 (member access)，迭代器对指针的一些基本操作如*、-&gt;、++、&#x3D;&#x3D;、!&#x3D;、&#x3D;进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构。</p>
<p>迭代器的“智能”体现在，针对不同的数据容器能够使用统一的方法、函数进行操作，以达到相同的目的。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++();  </span><br><span class="line"></span><br><span class="line">    ...  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    T *m_ptr;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>对于不同的数据容器，以上 Iterator 类中的成员函数 operator++ 的实现会各不相同，例如，对于数组的可能实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于数组的实现  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;   </span><br><span class="line">   ++m_ptr;   </span><br><span class="line">   retrun *<span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于链表，它会有一个类似于 next 的成员函数用于获取下一个结点，其可能实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++()  </span><br><span class="line">&#123;  </span><br><span class="line">   m_ptr = m_ptr-&gt;<span class="built_in">next</span>();<span class="comment">//next()用于获取链表的下一个节点   </span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>iterator 的实现首先要对其所指向的对象的实现细节有非常丰富的了解，所以 iterator 为了不暴露所指向对象的信息，干脆就将 iterator 的实现由各个容器的设计者来实现好了。STL 将迭代器的实现交给了容器，每种容器都会以嵌套的方式在内部定义专属的迭代器。各种迭代器的接口相同，内部实现却不相同，这也直接体现了泛型编程的概念。</p>
<h3 id="2-迭代器的类别"><a href="#2-迭代器的类别" class="headerlink" title="2 迭代器的类别"></a>2 迭代器的类别</h3><p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p>
<p>常用的迭代器按功能强弱分为：</p>
<ul>
<li>输入迭代器：只读</li>
<li>输出迭代器：只写</li>
<li>正向迭代器：正向遍历迭代器，假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</li>
<li>双向迭代器：双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code> 都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</li>
<li>随机访问迭代器：随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：<ul>
<li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li>
<li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
</li>
</ul>
<p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p>
<p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<p>下表是不同容器的迭代器功能类型：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器功能</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向</td>
</tr>
<tr>
<td>set &#x2F; multiset</td>
<td>双向</td>
</tr>
<tr>
<td>map &#x2F; multimap</td>
<td>双向</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>priority_queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<p>在以上功能的基础上，迭代器根据定义方式还分为：</p>
<ul>
<li>正向迭代器：容器类名::iterator </li>
<li>常量正向迭代器：容器类名::const_iterator</li>
<li>反向迭代器：容器类名::reverse_iterator</li>
<li>常量反向迭代器：容器类名::const_reverse_iterator</li>
</ul>
<p>反向迭代器和正向迭代器的区别在于：对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</p>
<h3 id="3-迭代器辅助函数"><a href="#3-迭代器辅助函数" class="headerlink" title="3 迭代器辅助函数"></a>3 迭代器辅助函数</h3><p>STL 中有用于操作迭代器的三个函数模板，它们是：</p>
<ul>
<li><code>advance(p, n)</code>：使迭代器 p 向前或向后移动 n 个元素。</li>
<li><code>distance(p, q)</code>：计算两个迭代器之间的距离，即迭代器 p 经过多少次 <code>++</code> 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li>
<li><code>iter_swap(p, q)</code>：用于交换两个迭代器 p、q 指向的值。</li>
</ul>
<p>要使用上述模板，需要包含头文件 <code>&lt;algorithm&gt;</code>。</p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL】关联式容器</title>
    <url>/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>标准的 STL 关联式容器分为 set(集合) &#x2F; map(映射表)两大类，以及这两大类的衍生体 multiset（多键集合）和 multimap（多键映射表）。这些容器的底层机制均以 RB-tree（红黑树）或hash table（哈希表）完成。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h3><p>红黑树是 C++ STL 唯一实现的树状结构，是所有关联式容器的底层容器，关于红黑树的理论知识可以查看<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20220303-%E4%BA%8C%E5%8F%89%E6%A0%91/">【数据结构】二叉树</a>第三部分。</p>
<h4 id="1-1-红黑树节点"><a href="#1-1-红黑树节点" class="headerlink" title="1.1 红黑树节点"></a>1.1 红黑树节点</h4><p>STL 中红黑树的的节点设计采用了结构和数值分离的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_Color_type _Color_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node_base* _Base_ptr;</span><br><span class="line"></span><br><span class="line">    _Color_type _M_color;    <span class="comment">//颜色</span></span><br><span class="line">    _Base_ptr _M_parent;     <span class="comment">//父节点，红黑树很多操作都需要知道父节点</span></span><br><span class="line">    _Base_ptr _M_left;       <span class="comment">//左孩子</span></span><br><span class="line">    _Base_ptr _M_right;      <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉搜索树获取最大值最小值</span></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_minimum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_left != <span class="number">0</span>) __x = __x-&gt;_M_left;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> _Base_ptr _S_maximum(_Base_ptr __x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (__x-&gt;_M_right != <span class="number">0</span>) __x = __x-&gt;_M_right;</span><br><span class="line">      <span class="keyword">return</span> __x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树节点，包括结构和节点值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_node</span> : <span class="keyword">public</span> _Rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line">    _Value _M_value_field;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-红黑树迭代器"><a href="#1-2-红黑树迭代器" class="headerlink" title="1.2 红黑树迭代器"></a>1.2 红黑树迭代器</h4><p>为了更大的弹性， SGI 将 RB-tree 迭代器也实现为两层，下图所示的便是双层节点结构和双层迭代器结构之间的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/image-20220503111534187.png" alt="image-20220503111534187"></p>
<p>RB-tree 迭代器属于双向迭代器，不具备随机定位能力，其提领操作和成员访间操作与 list 十分近似，较为特殊的是其前进和后退操作。参见源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node_base::_Base_ptr _Base_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">  _Base_ptr _M_node;</span><br><span class="line">  <span class="comment">// 迭代器前进操作</span></span><br><span class="line">  <span class="type">void</span> _M_increment()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_right != <span class="number">0</span>) &#123;</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">      <span class="keyword">while</span> (_M_node-&gt;_M_left != <span class="number">0</span>)</span><br><span class="line">        _M_node = _M_node-&gt;_M_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_right) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_M_node-&gt;_M_right != __y)</span><br><span class="line">        _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//迭代器后退操作</span></span><br><span class="line">  <span class="type">void</span> _M_decrement()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_node-&gt;_M_color == _S_rb_tree_red &amp;&amp;</span><br><span class="line">        _M_node-&gt;_M_parent-&gt;_M_parent == _M_node)</span><br><span class="line">      _M_node = _M_node-&gt;_M_right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_M_node-&gt;_M_left != <span class="number">0</span>) &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_left;</span><br><span class="line">      <span class="keyword">while</span> (__y-&gt;_M_right != <span class="number">0</span>)</span><br><span class="line">        __y = __y-&gt;_M_right;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Base_ptr __y = _M_node-&gt;_M_parent;</span><br><span class="line">      <span class="keyword">while</span> (_M_node == __y-&gt;_M_left) &#123;</span><br><span class="line">        _M_node = __y;</span><br><span class="line">        __y = __y-&gt;_M_parent;</span><br><span class="line">      &#125;</span><br><span class="line">      _M_node = __y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级迭代器，继承于一级</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Value</span>, <span class="keyword">class</span> <span class="title class_">_Ref</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Rb_tree_iterator</span> : <span class="keyword">public</span> _Rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Value&amp;, _Value*&gt;             </span><br><span class="line">    iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, <span class="type">const</span> _Value&amp;, <span class="type">const</span> _Value*&gt; </span><br><span class="line">    const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_iterator&lt;_Value, _Ref, _Ptr&gt;                   </span><br><span class="line">    _Self;</span><br><span class="line">  <span class="keyword">typedef</span> _Rb_tree_node&lt;_Value&gt;* _Link_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  _Rb_tree_iterator() &#123;&#125;</span><br><span class="line">  _Rb_tree_iterator(_Link_type __x) &#123; _M_node = __x; &#125;</span><br><span class="line">  _Rb_tree_iterator(<span class="type">const</span> iterator&amp; __it) &#123; _M_node = __it._M_node; &#125;</span><br><span class="line">  <span class="comment">//迭代器解引用，返回指向值</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> _Link_type(_M_node)-&gt;_M_value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  <span class="comment">//返回迭代器数值域指针</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//迭代器++操作，调用底层迭代器_M_increment()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; _M_increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_increment();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//迭代器--操作，调用底层迭代器_M_decrement()</span></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; _M_decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    _M_decrement();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他双目运算定义</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node == __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _Rb_tree_base_iterator&amp; __x,</span><br><span class="line">                       <span class="type">const</span> _Rb_tree_base_iterator&amp; __y) &#123;</span><br><span class="line">  <span class="keyword">return</span> __x._M_node != __y._M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="comment">//RB树迭代器是双向迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> _Rb_tree_base_iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-set-amp-map"><a href="#2-set-amp-map" class="headerlink" title="2 set &amp; map"></a>2 set &amp; map</h3><p>set 的所有元素都会根据元素的键值自动排序。set 的元素不像 map 那样可以同时拥有 key 和 value，set 元素的 key 就是 value，value 就是 key，set不允许有两个相同的元素。</p>
<p>map 的所有元素都会根据元素的键值自动排序。map 的所有元素都是 pair，同时拥有 key 和 value。pair 的第一元素为 key，第二元素为 value。map不允许有两个相同的键值。如果通过map的迭代器改变元素的键值，这样是不行的，因为 map 元素的键值关系到 map 元素的排列规则。任意改变 map 元素键值都会破坏 map 组织。如果修改元素的实值，这是可以的，因为 map 元素的实值不影响 map 元素的排列规则。</p>
<h3 id="3-multiset-amp-multimap"><a href="#3-multiset-amp-multimap" class="headerlink" title="3 multiset &amp; multimap"></a>3 multiset &amp; multimap</h3><p>multiset 和 multimap 的特性以及用法和 set 与 map 完全相同，唯一的差别在于它们允许键值重复，因此它的插入操作采用的是底层机制 RB-tree 的<code>insert_equal()</code> 而非 <code>insert_unique()</code>。</p>
<h3 id="4-hash-table"><a href="#4-hash-table" class="headerlink" title="4 hash table"></a>4 hash table</h3><p>hash table 是 STL 实现的另一种底层数据结构。之前的二叉搜索树具有对数平均时间表现，但这样的表现构造在一个假设上：输入数据有足够的随机性。hashtable 这种结构在插入、删除、查找具有“常数平均时间”，而且这种表现是以统计为基础，不需依赖元素的随机性。</p>
<p>hash table 底层数据结构为分离连接法的 hash 表，如下所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/772134-20160714231649779-234679385.png" alt="772134-20160714231649779-234679385"></p>
<p>hash table 中的 buckets 使用的是vector数据结构，当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射（常见的为取模），找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就返回；否则的话就将该元素插入到该链表的头部。当然，如果是 multi 版本的话，是可以插入重复元素的，此时插入过程为：当插入一个元素时，先利用 hash 函数，对元素的 key 进行映射，找到该插入哪个 bucket 内，然后遍历该 bucket 指向的链表，如果有相同的元素，就将新节点插入到该相同元素的后面；如果没有相同的元素，产生新节点，插入到链表头部。</p>
<p>对应的查询过程也是同理。此外，当调用成员函数 clear() 后，buckets vector 并未释放空间，仍保留原来大小，只是删除了 buckets 所连接的链表。</p>
<h3 id="5-hash-set-amp-hash-map"><a href="#5-hash-set-amp-hash-map" class="headerlink" title="5 hash_set &amp; hash_map"></a>5 hash_set &amp; hash_map</h3><p>hash_set 和 hash_map 以 hashtable 为底层结构，由于 RB-tree 有自动排序功能而 hash table 没有，反映出来的结果就是，set 和 map的元素有自动排序功能而hash_set 和 hash_map 没有。</p>
<h3 id="6-hash-multiset-amp-hash-multimap"><a href="#6-hash-multiset-amp-hash-multimap" class="headerlink" title="6 hash_multiset &amp; hash_multimap"></a>6 hash_multiset &amp; hash_multimap</h3><p>hash_multiset 和 hash_multimap 的特性与 multiset 和 multimap 完全相同，唯一的差别在于它们的底层机制是 hash table，因此，hash_multiset 和 hash_multimap 的元素是不会自动排序的。</p>
<h3 id="7-unordered-set-amp-unordered-map"><a href="#7-unordered-set-amp-unordered-map" class="headerlink" title="7 unordered_set &amp; unordered_map"></a>7 unordered_set &amp; unordered_map</h3><p>unordered_set 和 unordered_map 是 C++11 标准新增的容器，底层同样使用 hash table 实现，但一般来说效率比 hash_set 和 hash_map 更高，原因在于二者 rehash 实现不同。因此 hash_set 和 hash_map 基本已弃用。</p>
<h3 id="8-红黑树和-hash-table-对比"><a href="#8-红黑树和-hash-table-对比" class="headerlink" title="8 红黑树和 hash table 对比"></a>8 红黑树和 hash table 对比</h3><p>虽然大多数情况下 hash table 实现的 map 都会比红黑树实现的 map 查找快，但不是绝对的，因为冲突过多的话，可能耗费时间比 map 还要多。</p>
<p>另外，hash table 的实现决定了其使用的空间会比实际数据空间大。红黑树初始化时，节点只需要一个，后续的插入只是插入新的节点，但是哈希表初始化时就不是那么简单了，哈希表初始化时需要申请一个数组，数组的每个元素都指向一条链表，所以初始化时需要申请很多内存，相比于红黑树，的确更耗时。</p>
<p>相对于红黑树，hash table的优点很明显：插入，查找，删除复杂度为常数时间，大规模查询时，性能差距更为明显。</p>
<p>但相比于hash table，平衡树也是有优点的:</p>
<ul>
<li>首先，尽管我们都说 hash 查找插入删除复杂度是常数时间，但这仅仅是个统计上的概念，最差情况下，也是会达到 O(n)，而红黑树最差的情况下也是 O(logn)；</li>
<li>其次，hash table 实际上是空间换时间的做法，空间越小，操作的时间复杂度越大，操作时间越不稳定，而平衡树则稳定很多；</li>
<li>还有一个就是序，红黑树是查找树，因此中序遍历的结果就是排好序的。这就使得其在范围查找方面性能优秀，而 hash 却需要遍历全部数据，之后统计才能得出范围查找的结果。另外，如果你知道一个元素在树中的位置，和它大小相近的元素也在它周围，这就使得获取相近元素的时间很少。另外，我们知道，中序遍历的时间复杂度也只是 O(n)，这个性质非常有用。</li>
</ul>
<p>map 和 unordered_map 的使用场景基本上就是根据上述各自的特性决定了：</p>
<ul>
<li>map 一般就是用在数据量小于1000或者对内存使用要求比较高的情况下。因为 hash table 需要申请的空间比较大，而红黑树则是新增一个节点就申请一个节点的空间。</li>
<li>如果数据量大的话并且需要频繁查找的话，就可以使用 hash table 实现的 map 了。这个时候内存已经不是主要的问题所在，而是查找时间了，这种情况下 hash table 的查找速度是常数而红黑树是 O(logN)，对于后者，1024个数据最坏情况下要10次比较，在频繁查找的情况下这种时间耗费是很大的。</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（一）关于对象</title>
    <url>/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>《深度探索 C++ 对象模型》第一章重点梳理。主要内容包括：</p>
<ul>
<li>C++ 封装对象的布局成本</li>
<li>C++ 对象模型，详述 C++ 如何组织类对象及其成员</li>
<li>C++ 继承简述，简述 C++ 三种继承关系和三种继承方式，关于继承布局模型会在之后的章节详述</li>
<li>C++ 支持多态的三种方式</li>
<li>指针类型和多态的实现原理</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-C-封装对象的布局成本"><a href="#1-C-封装对象的布局成本" class="headerlink" title="1 C++ 封装对象的布局成本"></a>1 C++ 封装对象的布局成本</h3><p>C++ 将数据和对数据的操作封装为一个类，相比于 C 语言不封装，<strong>并没有增加成本</strong>。因为类的数据成员直接内含在每一个实例化的对象中，而方法成员虽然含在类的声明中，但却不出现在每一个对象中，每一个非内联（non-inline）的成员函数只产生一个函数实体，而内联函数自然在使用的地方产生函数实体，因此不会有任何空间或执行的不良效应。</p>
<p>C++ 在布局以及存取时间上的主要额外负担是由 virtual 引起的，包括：</p>
<ul>
<li>virtual function 机制：用以支持一个高效的“执行期绑定”（runtime binding）</li>
<li>virtual base class：用以实现“多次出现在继承体系中的 base class，只存在一个被共享的实体”</li>
</ul>
<p>后面将会对这两种情况进行解释。</p>
<h3 id="2-C-对象模型"><a href="#2-C-对象模型" class="headerlink" title="2 C++ 对象模型"></a>2 C++ 对象模型</h3><p>C++ 对象模型按照以下方式组织类对象及其成员：</p>
<ul>
<li>非静态成员变量（non-static data member）存放于类对象内部</li>
<li>静态成员变量（static data member）存放于所有类对象之外</li>
<li>静态和非静态的成员函数（member function）存放于所有类对象之外</li>
<li>虚函数（virtual function）通过<strong>虚函数表（virtual table）</strong>管理：每一个类产生出一堆指向虚函数的指针，放在表格之中构成虚函数表，接下来每一个类对象拥有一个指向虚函数表的指针，称为 <strong>vptr</strong>，vptr 的设定（set）和重置（reset）都由类的构造函数、析构函数、拷贝构造等完成。并且每一个类所关联的 type_info 对象（用来支持 runtime type identification，简称 RTTI）也经由虚函数表指出，通常放在虚函数表的第一位。</li>
</ul>
<blockquote>
<p><strong>什么是 RTTI ？</strong></p>
<p>RTTI 即运行阶段类型识别（Runtime Type Identification），旨在为程序在运行阶段确定对象类型提供一种标准方式。</p>
<p>RTTI 可以在只有一个指向基类的指针或引用时，确定所指对象的准确类型。C++ 有两种支持 RTTI 的运算：</p>
<ul>
<li>dynamic_cast 运算符，如果可能的话，dynamic_cast 运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则该运算符返回空指针。</li>
<li>typeid 运算符，返回一个指出对象类型的 type_info 对象的引用，其中存储了有关对象类型的信息，比如类名等。</li>
</ul>
<p>需要注意的是，只能将 RTTI 用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才会将派生类对象的地址赋给基类指针（多态），即 <strong>RTTI 只适用于包含虚函数的类（实现多态）</strong>。</p>
</blockquote>
<p>以下面的类为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其对象模型如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505095707450.png" alt="image-20220505095707450"></p>
<p>C++ 这样构建对象模型的主要优点在于空间和存取时间效率高，但缺点在于如果程序代码本身没有更改，但所用到的类对象的非静态成员变量有所修改，那么代码就需要重新编译。</p>
<p>另一种没有应用在 C++ 中的对象模型——双表格模型可以解决这个问题，双表格模型把所有成员变量放在数据表格中，把所有指向函数的指针放在函数表格中，每一个类对象只包含指向这两个表格的指针。这样虽然更灵活，但也因此付出了空间和执行效率两方面的代价。</p>
<h3 id="3-C-继承简述"><a href="#3-C-继承简述" class="headerlink" title="3 C++ 继承简述"></a>3 C++ 继承简述</h3><p>C++ 支持单一继承、多重继承和虚拟继承：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单一继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library_Materials</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> : <span class="keyword">public</span> Library_Materials &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rental_Book</span> : <span class="keyword">public</span> Book &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iostream</span> : <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">istream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ostream</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> ios &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么需要虚拟继承？</strong></p>
<p>虚拟继承是为了防止多重继承中，一个派生类继承自两个相同的基类的情况。</p>
<p>如上面的例子，类 iostream 继承自类 istream 和类 ostream，这两个类都继承自基类 ios，如果不使用虚拟继承，则类 iostream 中会出现两个基类 ios 的对象，而在虚拟继承中，无论基类在继承链中被派生多少次，都只产生一个实体（称为子对象，subobject），即在类 iostream 中，istream 对象和 ostream 对象共享一个 ios 基类对象，从而避免了重复继承的情况。</p>
</blockquote>
<p>之后的章节中我们会具体讨论这些继承情况分别对应的继承模型，即派生对象和基类对象的组织关系和内存管理。</p>
<p>顺便讨论一下类成员的三种访问级别和三种继承方式。众所周知 C++ 类成员可以拥有三种访问级别：</p>
<ul>
<li>public：可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问</li>
<li>protected：可以被该类中的函数、子类的函数、其友元函数访问，但不能被该类的对象访问</li>
<li>private：只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问</li>
</ul>
<p>在类继承中，也包含三种继承方式，不同的继承方式会导致类中成员的访问级别变化：</p>
<ul>
<li>public 继承：父类中的成员属性不发生改变</li>
<li>protected 继承：父类的 protected 和 public 成员在子类中变为 protected，private 成员不变</li>
<li>private 继承：父类的所有成员在子类中变为 private</li>
</ul>
<h3 id="4-C-支持多态的三种方式"><a href="#4-C-支持多态的三种方式" class="headerlink" title="4 C++ 支持多态的三种方式"></a>4 C++ 支持多态的三种方式</h3><p>C++ 通过以下三种方式支持多态：</p>
<ul>
<li>隐式转换：将派生类指针转化为一个指向其基类的指针：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shape *ps = <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>虚函数机制：基类中定义虚函数（纯虚函数），派生类进行重载，在运行时决定调用哪个函数对象：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps-&gt;<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>dynamic_cast 和 type_id 运算符，在上面的虚拟继承提到过，用来将指向基类的指针转化为指向派生类对象的指针，或者获取对象的 type_info</li>
</ul>
<h3 id="5-指针类型和多态原理"><a href="#5-指针类型和多态原理" class="headerlink" title="5 指针类型和多态原理"></a>5 指针类型和多态原理</h3><p>指向类的指针和指向其他变量类型（比如 int, string）的指针有什么不同？</p>
<p>以内存需求的观点来说，没有什么不同，它们都需要有足够的内存来放置一个机器地址，指向不同类型的指针之间的差异既不在其声明方法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的 object 类型不同。也就是说，”指针类型”会告诉编译器如何解释某个特定地址中的内存内容及其大小。</p>
<p>例如下面的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么指向类 ZooAnimal 的对象的指针将会包含：</p>
<ul>
<li>指向 int 类型的指针，在 32 位计算机上，int 占 4 字节</li>
<li>指向 string 类型的指针，占 8 字节（4 字节的字符指针和 4 字节的表示字符串长度的整数）</li>
<li>指向虚函数表的指针，占 4 字节</li>
</ul>
<p>因此类 ZooAnimal 的对象一共占用 16 字节，如果 ZooAnimal 对象存放在内存地址 1000，那么一个指向 ZooAnimal 对象的指针将会知道它需要涵盖内存的内存范围是 1000~1015.</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505112402307.png" alt="image-20220505112402307"></p>
<p>如果不告诉编译器这个指针指向什么类型，比如泛型指针 void*，那么编译器将不知道指针涵盖的地址范围，也就不能通过指针访问到正确的内存内容。</p>
<p>现在我们定义一个 Bear 类继承自 ZooAnimal 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Dances</span> &#123; ... &#125;;	<span class="comment">//枚举类型默认使用int方式存储，占用4字节</span></span><br><span class="line">    </span><br><span class="line">    Dances dances_known;</span><br><span class="line">    <span class="type">int</span> cell_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么指向 Bear 对象的指针覆盖的内存大小是其基类子对象的大小（16字节）加上该对象成员变量的大小（4 + 4 字节）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505112658895.png" alt="image-20220505112658895"></p>
<p>假设 Bear 对象存放在内存地址 1000 处，那么指向基类 ZooAnimal 的指针 pz 和指向派生类 Bear 的指针 pb 都指向内存地址 1000，区别在于 pz 指针涵盖的内存范围只包含基类成员的 16 字节，而 pb 指针涵盖的内存范围包含整个 Bear 对象。</p>
<p>除了 ZooAnimal 对象中出现的成员，我们不能使用 pz 来处理 Bear 对象的任何成员，除非使用 virtual 机制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以，虽然 pz 指向一个 bear 对象的地址</span></span><br><span class="line">pz-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以，经过显式转换</span></span><br><span class="line">((Bear*)pz)-&gt;cell_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的方式是使用 RTTI，dynamic_cast返回一个指定派生类的指针，如果无法转换则返回空指针</span></span><br><span class="line"><span class="keyword">if</span>(Bear* pb2 = <span class="built_in">dynamic_cast</span>&lt;Bear*&gt;(pz))</span><br><span class="line">    pb2-&gt;cell_block;</span><br></pre></td></tr></table></figure>

<p>现在来看这种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear b;</span><br><span class="line">ZooAnimal za = b;</span><br><span class="line"><span class="comment">// 这将会调用 ZooAnimal 的 rotate 方法而不是 Bear 的</span></span><br><span class="line">za.<span class="built_in">rotate</span>();</span><br></pre></td></tr></table></figure>

<p>为什么 za 调用的是 ZooAnimal 的 rotate 方法？这是由于当一个基类对象直接被初始化为一个派生类对象时，会发生切割（sliced），以塞入较小的基类内存中，而无法体现出任何派生类的痕迹。这时多态就“失效”了，实际上这是由于多态不能够发挥在“直接存取对象”这件事情上，<strong>因为多态机制是依靠指针（pointer）或引用（reference）完成的</strong>。</p>
<p>举例来说明，比如有下面的类继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505150626835.png" alt="image-20220505150626835"></p>
<p>然后我们使用下面一组定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ZooAnimal za;</span><br><span class="line">    ZooAnimal *pza;</span><br><span class="line">    </span><br><span class="line">    Bear b;</span><br><span class="line">    Panda *pp = <span class="keyword">new</span> Panda;</span><br><span class="line">    </span><br><span class="line">    pza = &amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这组定义可能的内存布局如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/image-20220505150739142.png" alt="image-20220505150739142"></p>
<p>将对象 za 或者 b 的地址，或者指针 pp 的内容（也是个地址）赋给指针 pza，是完全没有问题的，后续还可以通过各种转换得到想要的不同派生类的对象，也就实现了多态。一个指针或者引用之所以支持多态，就是因为他们并不会引发内存配置的资源量的改变，会受到改变的只是它们所指向的内存的“大小和解释方式”而已。</p>
<p>但如果直接对对象进行操作，就会改变内存中的资源需求量，比如之前的例子，把整个 Bear 对象指定给 za，就会溢出它所配置得到的内存，自然也就无法得到正确的结果。</p>
<p>总之，多态是一种强大的机制，允许你继一个抽象的 public 接口之后，封装相关的类型。需要付出的代价就是额外的间接性——不论是在“内存的获得”或是在“类型的决断”上。C++ 通过 class 的 pointers 和 references 来支待多态，这种程序设计风格就称为“面向对象”。</p>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（三）关于数据成员</title>
    <url>/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第三章重点梳理。主要内容包括：</p>
<ul>
<li>C++ 字节对齐和类大小计算</li>
<li>数据成员的布局、虚函数表和虚基类表的布局</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-C-字节对齐"><a href="#1-C-字节对齐" class="headerlink" title="1 C++ 字节对齐"></a>1 C++ 字节对齐</h3><p>关于 C++ 字节对齐这篇文章讲得非常细致：<a href="https://blog.csdn.net/sweetfather/article/details/78487563">C++ 字节对齐的总结(原因和作用)</a></p>
<p>这里只做简要总结：</p>
<ul>
<li><p>字节对齐的原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是，如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个 int 型数据存放在偶地址开始的地方，那么一个读周期就可以读出这 32 位数据，而如果存放在奇地址开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32 位数据，显然在读取效率上下降很多</p>
</li>
<li><p>可以使用 <code>pragma pack(n)</code> 指定以 n 字节方式对齐，不指定则按默认方式对齐</p>
</li>
<li><p>字节对齐是要看变量所在偏移地址是否为变量字节数（或指定对齐字节数 n，取二者较小值）的整数倍</p>
</li>
<li><p>对于结构成员，要按照结构成员中对齐长度最大的一个对齐</p>
</li>
<li><p>对齐后还要看结构或类的总大小是否为其中最长变量（或指定对齐字节数 n，取二者较小值）的整数倍</p>
</li>
</ul>
<p>按照以上规则可以保证对齐后整个结构或类对象所占空间最小，并保证读取效率。</p>
<h3 id="2-C-类大小计算"><a href="#2-C-类大小计算" class="headerlink" title="2 C++ 类大小计算"></a>2 C++ 类大小计算</h3><p>关于 C++ 类的大小计算这篇文章讲的非常全面：<a href="https://www.cnblogs.com/fengyaoyao/p/10262312.html">C++类的大小计算汇总</a></p>
<p>这里只做简要总结：</p>
<p>C++ 中的类由于涉及虚函数、静态成员、虚拟继承、多继承、空类等情况，类对象的大小较为复杂，但总结起来遵循以下几个原则：</p>
<ul>
<li>类的大小是指类对象实体的大小，类大小的计算遵循字节对齐原则</li>
<li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员，均对类的大小无影响；静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区</li>
<li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响</li>
<li>虚继承对类的大小有影响，是因为虚基表指针带来的影响</li>
<li>空类的大小为 1，因为 C++ 要为某一个实体分配内存就要求这个实体必须有大小，不能为大小为 0 的实体分配内存，所以 C++ 会为空类指定 1 个字节作为其大小，防止 sizeof 为 0，含有虚函数，虚继承，多继承是特殊情况</li>
</ul>
<h4 id="2-1-关于空类"><a href="#2-1-关于空类" class="headerlink" title="2.1 关于空类"></a>2.1 关于空类</h4><p>C++ 空类大小为 1，这之中有两种情况需要注意：</p>
<ul>
<li>如果一个派生类继承自空类，且派生类有自己的数据成员，则基类子对象的一个字节不会加入到派生类中，因为派生类有自己的数据成员意味着有大小，可以分配内存，所以不需要空类的 1 个字节</li>
<li>一个类包含一个空类对象成员，这时空类的一个字节是要被计算进去的，因为空类对象必须有自己大小</li>
</ul>
<h4 id="2-2-关于虚函数"><a href="#2-2-关于虚函数" class="headerlink" title="2.2 关于虚函数"></a>2.2 关于虚函数</h4><p>虚函数是通过一张虚函数表来实现的。编译器必需要<strong>保证虚函数表的指针存在于对象实例中最前面的位置</strong>（这是为了保证正确取到虚函数的偏移量）。</p>
<p>每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就会为这个类创建一个虚函数表保存该类所有虚函数的地址，其实这个虚函数表的作用就是保存自己类中所有虚函数的地址，可以把虚函数表形象地看成一个函数指针数组，这个数组的每个元素存放的就是虚函数的地址。在每个带有虚函数的类中，编译器秘密地置入一指针，称为 vptr，指向这个对象的虚函数表。 当构造该派生类对象时，其成员 vptr 被初始化指向该派生类的虚函数表。所以可以认为<strong>虚函数表是该类的所有对象共有的</strong>，在定义该类时被初始化；而 <strong>vptr 则是每个类对象都有独立一份的</strong>，且在该类对象被构造时被初始化。</p>
<p>含有虚函数的时候，类的大小计算要注意以下几点：</p>
<ul>
<li>由于指针大小为 8 字节，因此含有虚函数的任何类的大小都是原本大小加上 8 字节</li>
<li>当继承的基类含有虚函数时，在派生类中不对基类的虚函数进行覆盖，同时派生类中还拥有自己的虚函数。此时派生类的虚函数表中首先存放基类虚函数地址，再存放派生类虚函数地址，所有虚函数地址顺序与声明顺序一致。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102541174.png" alt="image-20220507102541174"></p>
<ul>
<li>如果派生类中对基类的虚函数进行了覆盖，同时派生类中还拥有自己的虚函数。此时虚函数表中原本存放基类虚函数的位置会被覆盖为派生类重写的虚函数地址，其他顺序不变。因此无论是基类还是派生类，其大小也还是原本大小加 8 字节</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102558864.png" alt="image-20220507102558864"></p>
<ul>
<li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数无重载，此时派生类虚函数被放在第一个积累虚函数表后面，派生类的大小就是原本大小加上基类数量 * 8 字节</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102738036.png" alt="image-20220507102738036"></p>
<ul>
<li>当一个派生类继承自多个含有虚函数的基类，并对基类虚函数有重载，情况和上述一致，这时任意一个基类指针指向派生类对象都可以调用派生类重载的基类虚函数</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507102832628.png" alt="image-20220507102832628"></p>
<p>上面文章中的一个例子，在 Visual C++ 中的运行结果和文章中不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>    </span><br><span class="line">&#123;    </span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>    </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch1; </span><br><span class="line">    <span class="type">char</span> ch2; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> d;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> e;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>&#123;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>&#123;  &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;    <span class="comment">//result=1 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;    <span class="comment">//result=16     </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;C=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl;    <span class="comment">//result=16 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;D=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(D)&lt;&lt;endl;    <span class="comment">//result=24 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;E=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(E)&lt;&lt;endl;    <span class="comment">//result=40 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里关于类 E 的大小，有必要再详细分析一下：类 E 包含一个类 B 子对象 16字节，一个类 C 子对象 16 字节，以及自身的 int 4 字节，现在一共是 36字节，但因为要跟成员中最大变量虚函数表指针 8 字节对齐，最终补齐到 40 字节。</p>
<blockquote>
<p>可以在 VS 中输出类的布局，打开 vs项目属性-&gt;配置属性-&gt; c&#x2F;c++ -&gt;命令行，在其它选项中添加如下命令：</p>
<ul>
<li><code>/d1 reportAllClassLayout</code> 是查看所有类的布局</li>
<li><code>/d1 reportSingleClassLayoutXX</code> 是查看名为XX的类的布局</li>
</ul>
<p>配置之后重新编译项目，会在编译输出中打印类布局。</p>
</blockquote>
<p>上面例子中，类 E 的布局打印出来如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507113905627.png" alt="image-20220507113905627"></p>
<p>和我们的分析一致，同时还可以看到类 E 的两个虚函数表的布局：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507113943452.png" alt="image-20220507113943452"></p>
<p>其中 <code>E::$vftable@B@</code> 是基类 B 的虚函数表，存放的是被 E 重载后的函数 func0 的指针， <code>E::$vftable@C@</code> 是基类 C 的虚函数表，存放的是 C 的函数 func 和被 E 重载的函数 func1 的指针。</p>
<h4 id="2-3-关于虚继承"><a href="#2-3-关于虚继承" class="headerlink" title="2.3 关于虚继承"></a>2.3 关于虚继承</h4><p>Visual C++ 中虚继承的情况比较简单，只是多了一个指向虚基类表的指针 vbptr，而真正的指向虚基类的指针存放在虚基类表中。</p>
<h3 id="3-数据成员的布局"><a href="#3-数据成员的布局" class="headerlink" title="3 数据成员的布局"></a>3 数据成员的布局</h3><p>最后通过一个例子总结 C++ 数据成员布局，通过下面这个例子可以清晰的认识 C++ 类数据成员布局、虚函数表和虚基类表的布局：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class X is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Y is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Y) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class Z is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Z) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of class A is &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中包含了虚继承、多重继承、虚函数的情况，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size of class X is 4</span><br><span class="line">size of class Y is 24</span><br><span class="line">size of class Z is 32</span><br><span class="line">size of class A is 56</span><br></pre></td></tr></table></figure>

<p>我们打印类 A 的布局：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507115635356.png" alt="image-20220507115635356"></p>
<p>可以看到类 A 的布局：</p>
<ul>
<li>首先是基类 Y 的子对象，Y 包含一个虚函数，同时有一个虚基类，所以 Y 的内存中就是两个指针，一个是虚函数表指针 vfptr，一个是虚基类表指针 vbptr，共 16 字节；</li>
<li>然后是基类 Z 的子对象，Z 同样包含 vfptr 和 vbptr，以及一个 int 成员，字节对齐后一共是 24 字节，此时类 A 总共偏移 40 字节</li>
<li>然后是类 A 自己的数据成员，char 类型一个字节，类 A 总共偏移 41 字节，最终要和类中最长成员 8 字节对齐，因此对齐到 48 字节</li>
<li>类 A 的全部成员都存放完后，最后存放虚基类成员，int 占 4 字节，此时类 A 总共 52 字节，但输出是 56 字节，实际又做了一次 8 字节对齐，因为打印出的内存布局把类 A 和虚基类子对象作为两个独立的部分，所以打印 48 + 4 &#x3D; 52 字节，但实际还要做一次 8 字节对齐，所以 sizeof 输出 56 字节</li>
</ul>
<p>然后是类 A 的虚函数表：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507120353989.png" alt="image-20220507120353989"></p>
<p>虚函数表的第一项表示派生类对象指针相对于虚函数表指针的偏移，这里派生类 A 相对于基类 Y 的虚函数表指针的偏移是 0 字节，相对于基类 Z 的虚函数表指针的偏移是 -16 字节。</p>
<p>最后是类 A 的虚基类表：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507120419152.png" alt="image-20220507120419152"></p>
<p>虚基类表原理与虚函数表类似，表的第一项表示派生类对象指针相对于虚基类表指针的偏移，这里是 -8 字节，因为虚基类表指针前面还有一个虚函数表指针占用了 8 个字节，所以派生类 Y 对象的指针相对于其虚基类表指针的偏移量是 -8，派生类 Z 对象的指针相对于其虚基类表指针的偏移也是 -8，注意这里的派生类不再是指 A 了，而是指虚基类的派生类，所以就是 Y 和 Z；虚基类表从第二项开始，表示各个虚基类地址相对于虚基类表指针的偏移。这里虚基类 X 相对于 Y 的虚基类表指针偏移了 40 个字节，因此虚基类 X 相对于派生类 Y 的地址总共偏移了 48 字节，对于派生类 Z 也同样如此，总共偏移了 24 + 8 &#x3D; 32 个字节，从上面的内存布局可以清晰地看出这一点。</p>
<p>可以看到，Y 和 Z 的虚基类表都指向同一个虚基类 X 的子对象，正如之前所说的，虚基类无论在继承链中被继承多少次，都只产生一个实体，即虚基类子对象，但是“不同的派生类中虚基类子对象的位置不同”这句话，一方面是指虚基类子对象相对于派生类的起始地址偏移量不同，并不是存在多个虚基类子对象；另一方面，随着类的派生，虚基类子对象的位置确实可能变化，但所有派生类的虚基类表中都指向那同一个虚基类子对象。</p>
<p>最后总结一下，C++ 中数据成员布局与编译器有关，但总体原理一致，Visual C++ 中数据成员布局顺序为：</p>
<ul>
<li>基类子对象<ul>
<li>虚函数表指针 vfptr</li>
<li>虚基类表指针 vbptr</li>
<li>基类成员</li>
</ul>
</li>
<li>数据成员</li>
<li>虚基类成员</li>
</ul>
<blockquote>
<p>注：有的编译器不存在虚基类表指针 vbptr，而是把虚基类的偏移放在虚函数表中，这样只需要一个虚函数表指针</p>
</blockquote>
<p>最最后附上一个简单的问题：为什么不把派生类的成员填到基类子对象由于字节对齐而填充的空白内存中，而是要保留基类子对象的空白内存？</p>
<p>直接借用书中的图解释：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/image-20220507164044837.png" alt="image-20220507164044837"></p>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（四）关于函数成员</title>
    <url>/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第四章重点梳理。主要内容包括：</p>
<ul>
<li>调用不同成员函数的背后工作</li>
<li>虚函数详解</li>
<li>内联函数的背后工作</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-调用不同成员函数的背后工作"><a href="#1-调用不同成员函数的背后工作" class="headerlink" title="1 调用不同成员函数的背后工作"></a>1 调用不同成员函数的背后工作</h3><p>C++ 类中包括三种成员函数：非静态成员函数、静态成员函数和虚函数。这三种成员函数被调用时，编译器会进行不同的背后工作。</p>
<h4 id="1-1-非静态成员函数"><a href="#1-1-非静态成员函数" class="headerlink" title="1.1 非静态成员函数"></a>1.1 非静态成员函数</h4><p>C+＋的设计准则之一就是：非静态成员函数必须至少和一般的非成员函数有相同的效率。所以 C++ 的做法就是在非静态成员函数被调用时，编译器将其转化为一般的非成员函数，并传入一个对象的指针。</p>
<p>假设有一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x * _x + _y * _y +  _z * _z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是转化步骤：</p>
<ol>
<li>改写函数的 signature（函数原型）以安插一个额外的参数到成员函数中，作为对对象成员的存取管道，该额外参数即为 this 指针，如果成员函数是 const，则传入参数也为 const</li>
<li>将对每一个成员变量的存取操作改为经由 this 指针的存取操作</li>
<li>将成员函数重写为一个外部非成员函数，并对函数名进行编码，使其有一个独一无二的内部名称</li>
</ol>
<p>转化后的的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">(<span class="type">const</span> Point3d* <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(</span><br><span class="line">        <span class="keyword">this</span>-&gt;_x * <span class="keyword">this</span>-&gt;_x + </span><br><span class="line">        <span class="keyword">this</span>-&gt;_y * <span class="keyword">this</span>-&gt;_y +  </span><br><span class="line">        <span class="keyword">this</span>-&gt;_z * <span class="keyword">this</span>-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对函数的调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">magnitude</span>();</span><br></pre></td></tr></table></figure>

<p>也被转化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">magnitude_7Point3dFv</span>(ptr);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-静态成员函数"><a href="#1-2-静态成员函数" class="headerlink" title="1.2 静态成员函数"></a>1.2 静态成员函数</h4><p>静态成员函数类似于非静态成员函数，编译器同样将其转化为一般的外部非成员函数，唯一的区别在于，传入的参数不是 this 指针，而是一个被强制转化后的指针，编译器将 0 强制转化为对象指针传入函数，所以一个静态成员函数转化后是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">float</span> <span class="title">magnitude_7Point3dFv</span><span class="params">((Point3d*) <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也正因为这样的转化，决定了我们所熟悉的静态成员函数的特性：</p>
<ul>
<li>无需经由类对象调用，通过类名即可调用，因为无需传入具体的对象指针，0 指针只作为一个执行静态成员函数的绑定对象指针，除此之外没有任何功能</li>
<li>不能够直接存取类中的非静态成员，因为指针是 0，实际不指向任何对象实体</li>
<li>不能声明为 const，virtual 等</li>
</ul>
<h4 id="1-3-虚拟成员函数"><a href="#1-3-虚拟成员函数" class="headerlink" title="1.3 虚拟成员函数"></a>1.3 虚拟成员函数</h4><p>虚成员函数在调用时被转化为经由 vptr 指向的虚函数表中的索引值调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d* ptr = <span class="keyword">new</span> <span class="built_in">Point3d</span>();</span><br><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>]) (ptr);</span><br></pre></td></tr></table></figure>

<p>其中传入的 ptr 也是 this 指针，1 是该函数在虚函数表中的索引。</p>
<h3 id="2-虚函数详解"><a href="#2-虚函数详解" class="headerlink" title="2 虚函数详解"></a>2 虚函数详解</h3><p>之前我们已经了解了虚函数的一般模型：每一个类有一个虚函数表，其中存放该类中所有有作用的虚函数地址，然后每个对象内含一个成员变量 vptr，指向虚函数表。这一节中我们根据不同继承情况，深入了解该模型内部原理。</p>
<h4 id="2-1-单一继承"><a href="#2-1-单一继承" class="headerlink" title="2.1 单一继承"></a>2.1 单一继承</h4><p>任何情况下，一个 class 只会有一个 virtual table 。每一个 table 内含其对应的 class object 中所有 active virtual functions 函数实体的地址。这些 active virtual functions 包括：</p>
<ul>
<li>这个 class 所定义的函数实体。它会改写 (overriding) 一个可能存在的 base class virtual function 实体</li>
<li>继承自 base class 的函数实体。这是在 derived class 决定不改写 base class virtual function 时才会出现的情况</li>
<li>一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序</li>
</ul>
<p>单一继承情况下的虚函数表布局如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509102615749.png" alt="image-20220509102615749"></p>
<p>可以看到 Point2d 继承自 Point 类，重写的函数会覆盖基类虚函数，比如析构函数，以及在 Point2d 中实现的纯虚函数等，而没有重写的函数则直接复制基类虚函数表中该函数的地址，比如 Point::z() 函数。</p>
<p>回顾上一节提到的虚函数在编译时的转化，假设现在有如下调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>

<p>则会被编译器转化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>]) (ptr);</span><br></pre></td></tr></table></figure>

<p>于是这样的形式就可以提供给程序足够的信息，使其在执行期知道调用哪一个函数实体，因为：</p>
<ul>
<li>虽然不知道 ptr 指向的具体对象类型，但是我们知道经由 ptr 可以访问到该对象的 vptr，从而访问到类的虚函数表</li>
<li>虽然不知道哪一个函数实体 z() 会被调用，但是所有类的 z() 函数实体地址都放在虚函数表中下标为 4 的地方</li>
</ul>
<p>这正是指针和虚函数所支持的多态的内部原理之一。在一个单一继承体系中，这样的机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，就没有这么简单了。</p>
<h4 id="2-2-多重继承"><a href="#2-2-多重继承" class="headerlink" title="2.2 多重继承"></a>2.2 多重继承</h4><p>在多重继承之下，一个 derived class 内含 n 个虚函数表，n 表示上一层基类数目，其中第一个基类子对象指向的表为主要表格，其他的为次要表格，第一个基类的虚函数和派生类自己的虚函数都放在主要表格中。针对每一个虚函数表，派生类对象中都有对应的 vptr，当我们将一个派生类对象指定给第一个基类或者派生类的指针时，处理的是主要表格，其他情况处理的是次要表格。</p>
<p>多重继承情况下，虚函数表布局如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509105025788.png" alt="image-20220509105025788"></p>
<p>上图中的 * 表示需要调整 this 指针，当我们将派生类对象指定给第二个或之后的基类指针时，会存在一些需要调整 this 指针以支持正确的虚函数的情况，一般来说有以下三种情况（对应上面三个星号）：</p>
<ol>
<li>第一种情况：通过指向第二个基类的指针调用派生类的虚函数：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base2 *ptr = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>

<p>上面的代码中 ptr 首先会被编译器调整至指向基类对象中的第二个基类子对象，编译器的调整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *ptr = temp ? temp + <span class="built_in">sizeof</span>(Base1) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这样才能保证后续正确地访问或调用与第二个基类有关的成员和方法。但接下来的 <code>delete ptr</code> 需要调用析构函数，此时需要将 ptr 再向后调整至指向派生类对象起始地址，才能正确执行析构函数删除整个派生类对象。</p>
<ol start="2">
<li>第二种情况：通过一个指向派生类的指针，调用第二个基类中一个继承而来的虚函数，在这种情况派生类指针需要调整至指向第二个基类子对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived *pder = <span class="keyword">new</span> Derived;</span><br><span class="line">pder-&gt;<span class="built_in">mumble</span>();</span><br><span class="line"><span class="comment">//pedr必须向前调整sizeof(Base1)个字节以指向第二个基类子对象</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三种情况发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化，可能是 base type，也可能是 publicly derived type。这一点可以通过上图中的 clone() 函数说明，clone() 函数的派生版本返回一个派生类对象，默默地改写了两个基类函数实体，当我们通过第二个基类指针调用 clone() 函数时，需要调整 this 指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">// 返回值必须调整以指向第二个基类子对象</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure>

<p>当进行 <code>pb1-&gt;clone()</code> 时，pb1 会被调整指向派生类对象的起始地址，于是会调用 clone() 函数的派生版本，它会传回一个新的派生类对象，当该对象被指定给第二个基类的指针时，需要调整以指向第二个基类子对象。</p>
<h4 id="2-3-虚拟继承"><a href="#2-3-虚拟继承" class="headerlink" title="2.3 虚拟继承"></a>2.3 虚拟继承</h4><p>虚拟继承的情况非常复杂，即使只有唯一的一个虚基类，他们的关系也不会像单一继承情况那样简单，因为虚基类和派生类不再相符，两者之间同样需要进行 this 指针转化。</p>
<p>当一个 virtual base class 从另一个 virtual base class 派生而来，并且两者都支持 virtual functions 和 nonstatic data members 时，编译器对于 virtual base class 的支持简直就像进了迷宫一样。总之一个建议是，<strong>不要在虚基类中声明非静态成员变量</strong>。</p>
<h3 id="3-内联函数的背后工作"><a href="#3-内联函数的背后工作" class="headerlink" title="3 内联函数的背后工作"></a>3 内联函数的背后工作</h3><p>下表对比了不同类型成员函数的执行效率：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/image-20220509112026194.png" alt="image-20220509112026194"></p>
<p>可以看到内联函数的效率占据绝对优势。在以往的学习中我们被告知，inline 函数将会在被调用的时候在调用处产生函数实体，这个操作称为扩展，即把内联函数代码扩展到调用处替换函数调用代码。</p>
<p>但实际上不是所有声明为 inline 的函数都能成为内联函数，inline 只是一种请求，只有这个请求被接受才会在函数调用处扩展 inline 代码。那么编译器如何决定是否接受这个请求呢？</p>
<p>编译器有一套复杂的算法来决定是否将函数认定为 inline，通常是计算 assignments、function calls、virtual function calls 等操作的次数。每个操作（表达式）种类有一个权值，而 inline 函数的复杂度就以这些操作的总和来决定。当其执行成本比一般的函数调用及返回机制所带来的负荷低，就被认定为 inline。</p>
<p>一般而言，处理一个 inline 函数包括以下两个阶段：</p>
<ul>
<li>分析函数定义，以决定是否认定为 inline，如果函数因其复杂度，或因其建构问题，被判断为不可成为 inline，则它会被转为一个 static 函数，并在被编译模块内产生对应的函数定义。</li>
<li>真正的 inline 函数扩展操作是在调用的那个地方进行，这会带来参数的求值操作以及临时性对象的管理问题，接下来具体讨论。</li>
</ul>
<h4 id="3-1-有副作用的参数"><a href="#3-1-有副作用的参数" class="headerlink" title="3.1 有副作用的参数"></a>3.1 有副作用的参数</h4><p>inline 函数是如何被扩展的？下面一个例子可以说明问题，假设有如下内联函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是三个调用操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**（1）**/</span>minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line"><span class="comment">/**（3）**/</span>minval = <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">bar</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上三个调用会被扩展为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**（1）**/</span>minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line"><span class="comment">/**（2）**/</span>minval = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**（3）**/</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">bar</span>() + <span class="number">1</span>;</span><br><span class="line">minval = t1 &lt; t2 ? t1 : t2;</span><br></pre></td></tr></table></figure>

<p>第（3）个调用把函数调用作为参数传入 inline 函数，这可能导致实际参数的多次求值操作，因此被认为是有副作用的参数，所以在扩展时使用了临时变量。而传入常量则会直接执行表达式，并将内联函数扩展为赋值操作。</p>
<h4 id="3-2-局部变量"><a href="#3-2-局部变量" class="headerlink" title="3.2 局部变量"></a>3.2 局部变量</h4><p>如果我们修改 inline 函数，引入局部变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> minval = i &lt; j ? i : j</span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> minval;</span><br><span class="line"><span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">minval = <span class="built_in">min</span>(val1, val2);</span><br></pre></td></tr></table></figure>

<p>则会被扩展为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> min_lv_minval = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">minval = min_lv_minval</span><br></pre></td></tr></table></figure>

<p>inline 函数中的局部变量会被保留，并产生一个拥有唯一编码名字的临时变量。如果 inline 函数在同一个 scope 中被调用多次，那么每次都会产生一组名字不同的临时变量。</p>
<p>inline 函数中的局部变量，再加上有副作用的参数，可能会导致大量临时性对象的产生。特别是它被调用多次的时候，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">minval = <span class="built_in">min</span>(val1, val2) + <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">foo</span>() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>会被扩展为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为局部变量产生的临时变量</span></span><br><span class="line"><span class="type">int</span> min_lv_minval_00;</span><br><span class="line"><span class="type">int</span> min_lv_minval_01;</span><br><span class="line"><span class="comment">// 为副作用参数产生的临时变量</span></span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line">t1 = <span class="built_in">foo</span>();</span><br><span class="line">t2 = <span class="built_in">foo</span>() + <span class="number">1</span>;</span><br><span class="line">min_lv_minval_00 = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">min_lv_minval_01 = t1 &lt; t2 ? t1 : t2;</span><br><span class="line">minval = min_lv_minval_00 + min_lv_minval_01;</span><br></pre></td></tr></table></figure>

<p>内联函数对于封装提供了一种必要的支持，可以有效存取封装于 class 中的 nonpublic 数据。它同时也是 C 程序中大量使用的<code>#define</code> （前置处理宏）的一个安全代替品，特别是如果宏中的参数有副作用的话。然而一个 inline 函数如果被调用太多次的话，会产生大量的扩展码，使程序的大小暴涨，并且由于参数带有副作用或者 inline 函数中有局部变量，会产生大量临时对象，编译器无法将它们移除。此外，inline 中再有 inline，可能会使一个表面上看起来简单的 inline 因其连锁复杂度而没办法扩展开来。对于既要安全又要效率的程序， inline 函数提供了一个强而有力的工具。然而，与 non-inline 函数比起来，它们需要更加小心地处理。</p>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（五）对象复制和析构</title>
    <url>/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第五章重点梳理。主要内容包括：</p>
<ul>
<li>关于对象复制操作（Copy Assignment Operator）</li>
<li>关于对象析构（Destruction）</li>
<li>几点类的设计原则</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-关于-Copy-Assignment-Operator"><a href="#1-关于-Copy-Assignment-Operator" class="headerlink" title="1 关于 Copy Assignment Operator"></a>1 关于 Copy Assignment Operator</h3><p>Copy Assignment Operator 是指类中对 <code>operator=</code> 的重载，用来将一个对象指定给另一个对象。如果我们希望不允许将该类的对象指定给另一个对象，只需要将 <code>operator=</code> 设定为 private，并且不提供函数体即可。</p>
<p>当然大部分情况下，类的设计者可以选择不显式提供 copy assignment operator，使用默认的逐成员复制（类似于拷贝构造函数），因为这样既方便，效率又高。copy assignment operator 和拷贝构造函数一样，只在有用（nontrivial）的时候会真正被编译器产生或合成出来，而其他情况下由于保持有 bitwise copy semantics，不需要以函数调用的形式进行复制，也就无须合成。在四种情况下 copy assignment operator 会被视为 nontrivial 而被合成出来：</p>
<ul>
<li>当 class 中包含一个对象成员而后者的类声明有一个 copy assignment operator 时，因为需要调用对象成员的 copy assignment operator</li>
<li>当 class 继承自一个 base class 而后者存在有一个 copy assignment operator 时，因为需要调用基类的 copy assignment operator</li>
<li>当 class 声明了一个或多个 virtual functions 时，因为我们一定不能直接拷贝等号右边对象的 vptr，因为等号左边可能是基类对象，而右边是派生类对象</li>
<li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时（不论虚基类有没有 copy assignment operator）</li>
</ul>
<h3 id="2-关于析构（Destruction）"><a href="#2-关于析构（Destruction）" class="headerlink" title="2 关于析构（Destruction）"></a>2 关于析构（Destruction）</h3><p>如果 class 没有显式定义析构函数，那么只有在 class 内包含的 member object（或是 class 自己的 base class）拥有析构函数时，编译器才会自动合成一个析构函数，否则，析构函数会被视为不需要，也就不需被合成（当然更不需要被调用）。析构函数的扩展和执行顺序类似于之前构造函数的执行顺序，并且与构造函数的顺序完全相反：</p>
<ol>
<li>构造函数本身首先被执行</li>
<li>如果有对象成员，且其有析构函数，按照它们声明顺序的相反顺序调用它们的析构函数</li>
<li>如果有 vptr，则重设 vptr，指向适当的基类的虚函数表</li>
<li>如果有任何直接的（上一层） nonvirtual base classes 拥有 destructor，它们会以其声明顺序的相反顺序被调用</li>
<li>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个类是继承链最尾端 (most-derived) 的类，那么它们会以其原来的构造顺序的相反顺序被调用</li>
</ol>
<p>对于如下类继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/image-20220509161840825.png" alt="image-20220509161840825"></p>
<p>那么一个 PVertex 对象的构造过程是：首先构造一个 Point 对象，然后变成一个 Vertex 和一个 Point3d 对象，然后变成一个 Vertex3d 对象，最后变成一个 PVertex 对象；而一个 PVertex 对象的析构过程正相反：依次变成一个 Vertex3d 对象、一个 Vertex 对象、 一个 Point3d 对象，最后成为一个 Point 对象。</p>
<p>所以对象的构造是一个逐步进化的过程，从构建一个最基础的对象开始，一步步构建成一个目标对象，而对象的析构则是相反的逐步退化的过程。</p>
<h3 id="3-几点类的设计原则"><a href="#3-几点类的设计原则" class="headerlink" title="3 几点类的设计原则"></a>3 几点类的设计原则</h3><ul>
<li><p><strong>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。</strong>或许你可以通过其派生类来初始化它的数据成员（假如 non-static data member 为 publish 或 protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的 data member 应当被初始化，且只在其构造函数或其 member function 中初始化。</p>
</li>
<li><p><strong>只在有必要的时候才使用虚函数，不要滥用虚函数</strong>。虚函数意味着不小的成本，编译器很可能给你的类带来一连串的膨胀效应：</p>
<ul>
<li>每一个对象要多负担一个 vptr</li>
<li>给每一个构造函数（不论是显式的还是编译器合成的），插入一些代码来初始化 vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前</li>
<li>生成或合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对 vptr 的初始化代码</li>
<li>如果类原本具有 bitwise copy 语意，将失去该语义，然后是上面所述，更大的对象、没有那么高效的构造函数、没有那么高效的复制操作</li>
</ul>
</li>
<li><p><strong>不能决定一个虚函数是否需要 const ，那么就不要 const。</strong></p>
</li>
<li><p><strong>不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义，但还是必须实现该纯虚析构函数，否则所有的派生类都将遇到链接错误。这是因为，每一个派生类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显式的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义，所以当编译器看到一个其基类的析构函数声明，就去调用它的实体，而不管它有没有被定义。</p>
</li>
<li><p><strong>决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个基类的构造函数含有对虚函数的调用，当其派生类的构造函数调用基类的构造函数时，其中调用的虚函数是基类中的实体，而不是派生类中的实体。这是由 vptr 初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因为构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象，析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（六）关于执行期</title>
    <url>/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第六章重点梳理。主要内容包括：</p>
<ul>
<li>执行期对象的构造与析构</li>
<li>详解 new 和 delete</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-对象的构造与析构"><a href="#1-对象的构造与析构" class="headerlink" title="1 对象的构造与析构"></a>1 对象的构造与析构</h3><p>一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    Point point; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// point.Point::Point() 一般被安插在这儿      </span></span><br><span class="line">    </span><br><span class="line">    ...      </span><br><span class="line">             </span><br><span class="line">    <span class="comment">// point.Point::~Point() 一般被安插在这儿 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方</strong>，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。</p>
<h4 id="1-1-全局对象（Global-Objects）"><a href="#1-1-全局对象（Global-Objects）" class="headerlink" title="1.1 全局对象（Global Objects）"></a>1.1 全局对象（Global Objects）</h4><p>一个全局对象，C++ 保证它在 <code>main()</code> 第一次使用它之前将其构造，而在 <code>main()</code> 结束之前，将之析构掉。C++ 程序中所有的 global objects 都被放置在程序的 data segment (数据段) 中，如果明确指定给它一个值， object 将以该值为初值。否则 object 所配置到的内存内容为 0.</p>
<p>虽然全局对象在编译期被即被置为 0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是静态初始化。所谓静态初始化，是因为全局变量被放在 data segment，data segment 是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为 0，存储在数据段，而等到程序激活时，就可以通过构造函数对在数据段的全局对象进行初始化了.</p>
<blockquote>
<p>以下引用自原书：</p>
<p>静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置于 try 块中，我们知道一个没有得到 catch 的异常默认的调用 <code>terminate()</code> 函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…</p>
<p>Lippman 甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。</p>
</blockquote>
<h4 id="1-2-局部静态对象（Local-Static-Objects）"><a href="#1-2-局部静态对象（Local-Static-Objects）" class="headerlink" title="1.2 局部静态对象（Local Static Objects）"></a>1.2 局部静态对象（Local Static Objects）</h4><p>下面一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Matrix&amp;  <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> Matrix mat_identity;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>static</code> 语意保证了 mat_identity 对象在整个程序周期都存在，而不会在函数 <code>identity()</code>退出时被析构，所以：</p>
<ul>
<li>mat_identity 的构造函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li>
<li>mat_identity 的析构函数只能被施行一次，虽然 <code>identity()</code> 可以被调用多次</li>
</ul>
<p>那么 mat_identity 的构造函数和析构函数到底在什么时候被调用？答案是：mat_identity 的构造函数只有在  <code>identity()</code> 第一次被调用时才被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。</p>
<h4 id="1-3-对象数组（Array-of-Objects）"><a href="#1-3-对象数组（Array-of-Objects）" class="headerlink" title="1.3 对象数组（Array of Objects）"></a>1.3 对象数组（Array of Objects）</h4><p>对于定义的一个对象数组，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>实际上背后做的工作是：</p>
<ol>
<li>分配充足的内存以存储 10 个 Point 对象；</li>
<li>为每个 Point 对象调用它们的默认构造函数（如果有的话，且不论是合成的还是显式定义的）。编译器一般以一个或多个函数来完成这个任务。当数组的生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。而关于具体细节，不必要死扣了，每个编译器肯定都有些许差别。</li>
</ol>
<h3 id="2-new-和-delete"><a href="#2-new-和-delete" class="headerlink" title="2 new 和 delete"></a>2 new 和 delete</h3><p>C++ 中一个经常容易混淆的问题是关于：operator new、new expression 和 placement operator new。这一节来详细讨论这三者的区别和联系。</p>
<h4 id="2-1-operator-new-和-new-expression"><a href="#2-1-operator-new-和-new-expression" class="headerlink" title="2.1 operator new 和 new expression"></a>2.1 operator new 和 new expression</h4><p>首先要明确，operator new 是一个运算符，和 +、-、*、% 等一样，是可以被重载的，而 new expression 不可以被重载，new expression 是对 operator new 的又一层封装。</p>
<p>C 语言中 <code>malloc</code> 函数我们非常熟悉，函数原型为 <code>void* malloc(size_t size)</code> ，参数 size 为要分配的字节数，返回值是 void*，通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址，失败会返回 NULL，但是申请成功后并不进行初始化，每个数据都是随机值。</p>
<p>operator new 是对 malloc 的封装，因此功能和 malloc 完全一样，只有一点细微的不同，operator new 在内存申请失败时会抛出异常，除此之外完全相同，也就是说，operator new 只用于分配内存。</p>
<p>而当我们使用非常熟悉的 new expression，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point3d *p = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure>

<p>实际上包含了两个步骤：</p>
<ul>
<li>调用 operator new 分配内存</li>
<li>调用合适的构造函数初始化这块内存，如果不是自定义的类，那么初始化就是简单的赋值操作</li>
</ul>
<p>由此可见， new expression 是对 operator new 的又一层封装。</p>
<p>我们当然也可以直接使用 operator new，比如只想分配内存的时候，完全可以替代 C 语言中的 <code>malloc</code> 操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T* newelements = <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line"><span class="comment">// 等同于T* pa = (T*)malloc(sizeof(T));</span></span><br><span class="line"><span class="comment">// static_cast表示明确的显式转换，可以告诉编译器和阅读程序的人这样的转换是故意为之</span></span><br></pre></td></tr></table></figure>

<p>STL 中重载有两个版本的 operator new，分别为单个对象和数组对象服务，单个对象版本提供给分配单个对象的 <code>new</code> 表达式调用，数组版提供给分配数组的 <code>new[]</code> 表达式调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;     <span class="comment">// allocate an object</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// allocate an array</span></span><br></pre></td></tr></table></figure>

<p>我们可以分别重载这两个版本，来自定义单个对象或对象数组的内存分配方式。当我们自己在重载 operator new 时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个 <code>void*</code> 类型和第一个参数的类型必须为 <code>size_t</code>。</p>
<p>同样的，operator delete 和 delete expression 的关系和上述 operator new 和 new expression 的关系完全一样，delete expression 会先调用析构函数，再调用 operator delete 释放内存。operator delete 的功能和 C 中的 <code>free</code> 完全一样，是对 <code>free</code> 的封装。</p>
<p>需要注意的是，在类中重载的 operator new 和 operator delete 必须是静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个 this 指针来存取对象成员。另外，new expression 默认调用的是单参数的 operator new，即上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p>
<h4 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h4><p>有下面两种关于 delete expression 的情况，第一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// p为什么能delete两次，而程序运行的时候还不报错。</span></span><br></pre></td></tr></table></figure>

<p>第二种情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> ;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">5</span>;     <span class="comment">//delete后为什么还可以对*p进行再赋值？</span></span><br></pre></td></tr></table></figure>

<p>在回答这两个问题之前，我们先想想 <code>delete p</code>  这一语句意味着什么？p 指向一个地址，以该地址为起始地址保存有一个 <code>int</code> 变量（虽然该变量并没有进行初始化，因此默认为 0），<code>delete p </code> 之后 p 所指向的地址空间被释放，也就是说这个 int 变量的生命结束，但是 p 仍是一个合法的指针，它仍指向原来的地址，而且该地址仍代表着一个合法的程序空间。与 <code>delete</code> 之前唯一不同的是，你已经丧失了那块程序空间的所有权。但你依然可以通过指针对这块空间进行操作，因为你还保留有这块空间的“钥匙” p。</p>
<p>此时通过指针 p 对这块空间进行操作虽然从语法上来说是合法的，但是暗藏着很大的逻辑错误。不论是对一块已经释放的内存再度 <code>delete</code>，还是再度给它赋值，都暗含着很大的危险，因为当你 <code>delete</code> 后，就代表着将这块内存归还，而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度 <code>delete</code> 还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，完全取决于编译器够不够“聪明”。</p>
<p>上述情况下的指针 p 被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。避免野指针的一个好方法是，当一个指针变为野指针的时候，马上赋值为 <code>NULL</code>，其缘由在于，你可以很容易的判断一个指针是否为 <code>NULL</code>，却难以抉择其是否为野指针。而且，<code>delete </code> 一个空指针，不会做任何操作，因此总是安全的。</p>
<h4 id="2-3-placement-operator-new-和-placement-new-expression"><a href="#2-3-placement-operator-new-和-placement-new-expression" class="headerlink" title="2.3 placement operator new 和 placement new expression"></a>2.3 placement operator new 和 placement new expression</h4><p>placement new expression 的功能是对已经存在的空间进行初始化，即用来在指定地址上构造对象，因此它并不分配内存，仅仅是对指定地址调用构造函数。</p>
<p>而 placement operator new 是对 operator new 的重载，它的功能就是返回给定的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 p 指针指向的内存已经存在，不需要再分配内存，因此只要返回这个指针即可。</p>
<p>placement new expression 先调用 placement operator new 返回指针 p，然后调用构造函数初始化这个指针指向的内存，这样也就完成了对已经存在的空间进行初始化的工作。</p>
<p>需要注意的是，通过 placement new expression 构建的一个对象，如果你使用 delete 来删除对象，那么其内存也会被回收，如果想保留内存而只析构对象，好的办法是显式调用其析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* pa = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="keyword">operator</span> <span class="built_in">new</span> (<span class="built_in">sizeof</span>(A));</span><br><span class="line">	<span class="comment">// 使用 placement new expression 初始化内存</span></span><br><span class="line">	<span class="built_in">new</span>(pa) <span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// 显式调用析构函数析构对象</span></span><br><span class="line">	pa-&gt;~<span class="built_in">A</span>();</span><br><span class="line">    <span class="comment">// 此时内存还在，手动使用delete释放内存，如果直接使用delete则其自动先调用析构，再释放内存</span></span><br><span class="line">	<span class="keyword">delete</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上并没有 placement new expression 这么一说，上面的说法只是为了便于理解，从头到尾都只有一个 new expression，并且 new expression 永远都只进行以下两个步骤：</p>
<ul>
<li>调用一个合适参数的 operator new 来分配内存，可以是普通的 operator new，也可以是 operator new[]，还可以是 placement  operator new</li>
<li>调用一个合适参数的构造函数初始化 operator new 分配的内存</li>
</ul>
<h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><p>operator new、new expression 和 placement operator new 三者的关系现在非常明了，总结如下：</p>
<ul>
<li>operator new 相当于 malloc 分配内存，区别在于申请失败时抛出异常而不是返回空指针</li>
<li>placement operator new 将给定的指针直接返回，相当于返回一块已经存在的内存</li>
<li>new expression 首先调用合适的 operator new 分配内存（可能是新分配的，也可能是已经存在的），然后调用构造函数初始化这块内存</li>
<li>operator delete 相当于 free 释放内存</li>
<li>delete expression 首先调用析构函数，然后调用 operator delete 释放内存</li>
</ul>
<h4 id="2-5-内存池"><a href="#2-5-内存池" class="headerlink" title="2.5 内存池"></a>2.5 内存池</h4><p>关于内存池技术有必要的话可以再做深入学习，这里只做简单了解即可。</p>
<p>利用默认的内存管理操作符 new 和 delete 在堆上分配和释放内存会有一些额外的开销。</p>
<p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。</p>
<p>可见，如果程序频繁地使用 new 和 delete 在堆上分配和释放内存，会导致性能的损失。并且会使系统中出现大量的内存碎片，降低内存的利用率。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。</p>
<p>C++ 引入了内存池（Memory Pool）来提高内存管理和运行效率。内存池是一种高效的内存分配方式，其工作原理是先向系统一次性申请比较大的空间，当我们每次去申请空间时就直接使用内存池里的空间，而省略了申请和释放的两个动作开销，也减少了系统内存碎片，从而提高了系统效率。</p>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（七）模板和RTTI</title>
    <url>/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第七章重点梳理。主要内容包括：</p>
<ul>
<li>模板（Template）</li>
<li>执行期类型识别（Runtime Type Identification，RTTI）</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-模板（Template）"><a href="#1-模板（Template）" class="headerlink" title="1 模板（Template）"></a>1 模板（Template）</h3><h4 id="1-1-模板的实例化"><a href="#1-1-模板的实例化" class="headerlink" title="1.1 模板的实例化"></a>1.1 模板的实例化</h4><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++ 标准才要求实例化他们。其原因，有两点：</p>
<ul>
<li>空间和时间效率的考虑，如果模板类中有 100 个成员函数，对某个特定类型只有 2 个函数会被使用，针对另一个特定类型只会使用 3 个，那么如果将剩余的 195 个函数实例化将浪费大量的时间和空间。</li>
<li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li>
</ul>
<h4 id="1-2-模板的名称决议"><a href="#1-2-模板的名称决议" class="headerlink" title="1.2 模板的名称决议"></a>1.2 模板的名称决议</h4><p>对于一个模板类来说，需要明确两个范围：一个是定义模板的范围（scope of the template definition），另一个是实例化模板的范围（scope of the template instantiation）。</p>
<p>下面来举例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeRules</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        _member = <span class="built_in">foo</span>( _val );  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>( _member );  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _val;  </span><br><span class="line">    type _member;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope of the template instantiation  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;  </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ScopeRules&lt; <span class="type">int</span> &gt; sr0;  </span><br><span class="line"><span class="comment">/*(1)*/</span>sr0.<span class="built_in">invariant</span>();</span><br><span class="line"><span class="comment">/*(2)*/</span>sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></table></figure>

<p>对于上面的语句（1），将会调用哪一个 <code>foo()</code> 函数呢？答案是 <code>double foo ( double )</code>，这是一个完全反直觉的答案，原因在于 <code>invariant()</code> 函数调用了一个外部函数 <code>foo()</code> ，但传入的参数是模板类中固定类型的成员 <code>_val</code>，无论模板被实例化为什么类型，其中的 <code>_val</code> 都是 int 型，也就是说它完全与实例化模板的参数的类型无关，此时对于外部函数名称的决议会在定义模板的范围内进行，在上面的例子中，定义模板的范围内只有一个 <code>foo()</code> 函数的声明，所以即使 <code>_val</code> 是 int 型，也会调用 double 作为参数的 <code>foo()</code> 函数。</p>
<p>而对于语句（2），会调用 <code>int foo( int )</code>，因为 <code>type_dependent()</code> 函数将与实例化模板的参数类型有关的成员作为参数传给了外部函数，此时就无法在定义模板类的范围内决议使用哪个 <code>foo()</code> 函数，所以要推迟到模板被实例化之后再决议，因此会在实例化模板的范围内寻找合适的函数，上面的例子中，实例化模板的范围中有两个声明的 <code>foo()</code> 函数，所以会选择和模板类型匹配的 <code>foo(int)</code> 函数进行调用。</p>
<p>总结一下，在模板中，一个非成员名称的决议在于它适不适合在当前决议，当它完全与实例化模板的参数类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，于是将被推迟到实例化这个模板的时候才决议。</p>
<h3 id="2-执行期类型识别（Runtime-Type-Identification）"><a href="#2-执行期类型识别（Runtime-Type-Identification）" class="headerlink" title="2 执行期类型识别（Runtime Type Identification）"></a>2 执行期类型识别（Runtime Type Identification）</h3><p>在一开始学习多态的时候就已经了解过 RTTI，这里最后进行总结：</p>
<ol>
<li>RTTI  只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI 的，这是因为 RTTI 的实现是通过 vptr 来获取存储在虚函数表中的 <code>type_info*</code> ，事实上为非多态类提供 RTTI 也没有多大意义</li>
<li>对指针进行 <code>dynamic_cast</code> 失败会返回 NULL，而对引用的话，失败会抛出 <code>bad_cast exception</code>，这是由于指针可以被赋值为 0，以表示 no object，但是引用不行</li>
<li><code>typeid</code> 可以返回 <code>const type_info&amp;</code>，用以获取类型信息。虽然第一点指出 RTTI 只支持多态类，但 <code>typeid</code> 和 <code>type_info</code> 同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的 <code>type_info</code> 对象是静态取得（所以不能叫“执行期类型识别”），而多态类的是在执行期获得。</li>
</ol>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】GPU管线</title>
    <url>/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中 GPU 渲染管线和可编程着色器的相关知识进行概括总结。主要内容包括：</p>
<ul>
<li>GPU 管线概述</li>
<li>可编程着色模型</li>
<li>思维导图</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-GPU-管线"><a href="#1-GPU-管线" class="headerlink" title="1 GPU 管线"></a>1 GPU 管线</h3><p>GPU 管线和上一节概念上的图形渲染管线不完全相同，现代 GPU 实现了图形渲染管线中的几何和光栅化阶段。其被分为一些不同程度的可配置性和可编程性的硬件阶段，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513100149647.png" alt="image-20220513100149647"></p>
<p>其中，不同颜色代表了不同程度的自定义属性：</p>
<ul>
<li>绿色的阶段都是完全可编程的</li>
<li>黄色的阶段可配置，但不可编程</li>
<li>蓝色的阶段完全固定</li>
</ul>
<p>GPU 实现的渲染管线和概念上的图形渲染管线的功能阶段在结构上略有不同。以下是对  GPU 渲染管线的一个流程概览：</p>
<ul>
<li><strong>顶点着色器（The Vertex Shader）</strong>是完全可编程的阶段，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改、创建、忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置等。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。</li>
<li><strong>几何着色器（The Geometry Shader）</strong>位于顶点着色器之后，允许 GPU 高效地创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片元着色器。</li>
<li><strong>裁剪（Clipping）</strong>属于可配置的功能阶段，在此阶段可选运行的裁剪方式，以及添加自定义的裁剪面。</li>
<li><strong>屏幕映射（Screen Mapping）</strong>、<strong>三角形设置（Triangle Setup）</strong>和<strong>三角形遍历（Triangle Traversal）</strong>阶段是固定功能阶段。</li>
<li><strong>像素着色器（Pixel Shader，Direct3D 中的叫法）</strong>常常又称为片段着色器，<strong>片元着色器（Fragment Shader，OpenGL 中的叫法）</strong>，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。</li>
<li><strong>合并阶段（The Merger Stage）</strong>处于完全可编程和固定功能之间，尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改（Color Modifying），Z 缓冲（Z-buffer），混合（Blend），模板（Stencil）和相关缓存的处理。</li>
</ul>
<h3 id="2-可编程着色模型"><a href="#2-可编程着色模型" class="headerlink" title="2 可编程着色模型"></a>2 可编程着色模型</h3><p>早期的着色模型可以用汇编语言直接编程，但 DX10 之后，汇编就只在调试输出阶段可见，改用高级着色语言。目前的着色语言都是 C-like 的着色语言，比如 HLSL，CG 和 GLSL，其被编译成独立于机器的汇编语言，也称为中间语言（IL）。这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言。这样的安排可以兼容不同的硬件实现。这些汇编语言可以被看做是定义一个作为着色语言编译器的虚拟机。这个虚拟机是一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。<strong>着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。</strong></p>
<p>Shader 程序可以在程序加载或运行时离线编译。和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。一个编译过的  Shader 作为字符串或者文本来存储，并通过驱动程序传递给  GPU。</p>
<h4 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h4><p>顶点着色器是完全可编程的阶段，是专门处理传入的顶点信息的着色器，顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作。顶点着色器一般不处理附加信息，也就是说，顶点着色器提供了修改，创建，或者忽略与每个多边形顶点相关的值的方式，例如其颜色，法线，纹理坐标和位置。通常，<strong>顶点着色器程序将顶点从模型空间（Model Space）变换到齐次裁剪空间（Homogeneous Clip Space）</strong>，并且，一个顶点着色器至少且必须输出此变换位置。</p>
<p>顶点着色器既不能创建也不能消除顶点，并且由一个顶点生成的结果不能传递到另一个顶点。由于每个顶点都被独立处理，所以  GPU 上的任何数量的着色器处理器都可以并行地应用到传入的顶点流上。</p>
<p>顶点着色器的输出可以以许多不同的方式来使用，通常是随后用于每个实例三角形的生成和光栅化，然后各个像素片段被发送到像素着色器，以便继续处理。而在 Shader Model 4.0 中，数据也可以发送到几何着色器（Geometry Shader）或输出流（Streamed Output）或同时发动到像素着色器和几何着色器两者中。</p>
<h4 id="2-2-几何着色器"><a href="#2-2-几何着色器" class="headerlink" title="2.2 几何着色器"></a>2.2 几何着色器</h4><p>几何着色器的输入是单个对象及对象相关的顶点，而对象通常是网格中的三角形，线段或简单的点。另外，扩展的图元可以由几何着色器定义和处理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513102855674.png" alt="image-20220513102855674"></p>
<p>上图所示，几何着色器程序的输入是一个单独的类型：点，线段，三角形。两个最右边的图元，包括与线和三角形对象相邻的顶点也可被使用。</p>
<p>几何着色器需要图元作为输入，在处理过程中他可以将这个图元整个丢弃或者输出一个或更多的图元（也就是说它可以产生比它得到的更多或更少的顶点），这个能力被叫做几何增长（growing geometry）。几何着色器可以改变新传递进来的图元的拓扑结构，且几何着色器可以接收任何拓扑类型的图元，但是只能输出点、折线（line strip）和三角形条（triangle strips）。</p>
<p>当我们未添加几何着色器时，默认的行为是将输入的三角形直接输出。我们添加了几何着色器之后，可以在几何着色器中修改输出的图形，我们可以输出我们想要输出的任何图形。</p>
<blockquote>
<p>GPU 管线的标准使用方式是发送数据到顶点着色器，然后对所得到的三角形进行光栅化处理，并在像素着色器中处理它们。数据总是通过管线传递，无法访问中间结果。流输出的想法在  Shader Model 4.0 中被引入。在顶点着色器（以及可选的几何着色器中）处理顶点之后，除了将数据发送到光栅化阶段之外，也可以输出到流，也就是一个有序数组中进行处理。事实上，可以完全关掉光栅化，然后管线纯粹作为非图形流处理器来使用。以这种方式处理的数据可以通过管线回传，从而允许迭代处理。这种操作特别适用于模拟流动的水或其他粒子特效。</p>
</blockquote>
<h4 id="2-3-像素着色器"><a href="#2-3-像素着色器" class="headerlink" title="2.3 像素着色器"></a>2.3 像素着色器</h4><p>像素着色器(Pixel Shader，Direct3D 中的叫法)，常常又称为片元着色器(Fragment Shader, OpenGL 中的叫法)，用于进行逐像素计算颜色的操作，让复杂的着色方程在每一个像素上执行。像素着色器是光栅化阶段的主要步骤之一。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。</p>
<p>像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片元着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片元着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。</p>
<p>可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在 Shader Model 4.0 中，共有 16 个向量（每个向量含 4 个值）可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出 32 个向量到像素着色器中。</p>
<h4 id="2-4-合并阶段"><a href="#2-4-合并阶段" class="headerlink" title="2.4 合并阶段"></a>2.4 合并阶段</h4><p>作为光栅化阶段名义上的最后一个阶段，合并阶段（The Merging Stage）是将像素着色器中生成的各个片段的深度和颜色与帧缓冲结合在一起的地方。这个阶段也就是进行模板缓冲（Stencil-Buffer）和 Z 缓冲（Z-buffer）操作的地方。最常用于透明处理（Transparency）和合成操作（Compositing）的颜色混合（Color Blending）操作也是在这个阶段进行的。虽然合并阶段不可编程，但却是高度可配置的。在合并阶段可以设置颜色混合来执行大量不同的操作。最常见的是涉及颜色和 Alpha 值的乘法，加法，和减法的组合。其他操作也是可能的，比如最大值，最小值以及按位逻辑运算。</p>
<h4 id="2-5-特效"><a href="#2-5-特效" class="headerlink" title="2.5 特效"></a>2.5 特效</h4><p>GPU 渲染管线中的可编程阶段有顶点、几何和像素着色器三个部分，他们需要相互结合在一起使用。正因如此，不同的团队研发出了不同的特效语言，例如 HLSL FX，CgFX，以及 COLLADA FX，来将他们更好的结合在一起。</p>
<p>一个效果文件通常会包含所有执行一种特定图形算法的所有相关信息，而且通常定义一些可被应用程序赋值的全局参数。例如，一个单独的  effect file 可能定义渲染塑料材质需要的  vs（顶点着色器）和  ps（像素着色器），它可能暴露一些参数例如塑料颜色和粗糙度，这样渲染每个模型的时候可以改变效果而仅仅使用同一个特效文件。一个效果文件中能存储很多 techniques。这些 techniques 通常是一个<br>相同特效的变体。</p>
<p>下图展示了一些特效文件带来的材质和后处理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104314983.png" alt="image-20220513104314983"></p>
<h3 id="3-思维导图"><a href="#3-思维导图" class="headerlink" title="3 思维导图"></a>3 思维导图</h3><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/image-20220513104353817.png" alt="image-20220513104353817"></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】程序噪声总结</title>
    <url>/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>上一篇提到过，程序纹理基本上都是通过噪声纹理来实现的，不同的噪声纹理适合制作不同的效果，如云雾、水波、大理石、能量波等。这一节对常见的程序噪声算法进行总结，主要包括：</p>
<ul>
<li>Value Noise</li>
<li>Gradient Noise（Perlin Noise、Simplex Noise）</li>
<li>Voronoi Noise 和 Worley Noise</li>
<li>Fractal Brownian Motion</li>
<li>Curl Noise</li>
<li>White Noise</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-噪声概述"><a href="#1-噪声概述" class="headerlink" title="1 噪声概述"></a>1 噪声概述</h3><p>对于图形学而言，噪声通常会用作程序化效果生成（如地形、水面、云层等），其最开始在图形学中引进，是为了代替贴图给物件添加纹理以解决电脑内存不足的问题（不过噪声的计算通常比贴图采样要慢一点，因此现在通常是直接使用噪声贴图来代替 shader 的随机数计算），但是并不是所有的噪声都是有用的，只有那些数据具有一定的连贯性的噪声才算是有用的噪声，而如果噪声不连贯的话，在进行贴图采样后，得到的结果就会呈现一种混乱的状态，这种对于程序化生成而言并没有什么作用，因此图形学中的一个理想的噪声应该具备如下几个特性：</p>
<ul>
<li>伪随机（不变性）：所谓的噪声只是看起来随机而已，实际上，需要保证在同样的输入下，肯定能够得到同样的输出，否则可能出现渲染的结果随着时间或者观察位置而变化，这就不够物理了，而且结果不可控也跟实际需要不符合。</li>
<li>只返回一个 float 值，不管输入是几维的，只返回一个 float。</li>
<li>噪声通常是带限的（band-limited），噪声频率过高通常会导致锯齿（镜头旋转等情况下常见），因此通常其频率范围都是有限的，不过对于一些平缓（大尺寸）变化的情形需要一些低频噪声，而对于一些细节变化则需要一些高频噪声。</li>
<li>噪声需要具有一定的连续性，比如某些情况下需要计算噪声的导数，甚至需要计算高阶微分，因此对于噪声的连续性有一定的要求。</li>
<li>四方连续，为了保证 tiling 时不会出现肉眼可辩的缝隙，需要保证上下左右四个方向都是连续的（如果使用了大量 tiling 可能会导致重复纹样，而解决重复的做法就是将 tiling 尺寸设得足够大，虽然可能会引入其他问题，但是这个问题可以通过其他方式来规避）。</li>
</ul>
<h3 id="2-Value-Noise"><a href="#2-Value-Noise" class="headerlink" title="2 Value Noise"></a>2 Value Noise</h3><p>Value Noise 是最简单的一类噪声，其实现算法非常简单，以 2D 为例，我们在一个规整的 2D 网格上的每个顶点（如下图中的每个红色小圆点）放置一个随机数（通常范围在 [0, 1] 之间），之后使用线性插值填充每个小方格，得到的结果就是 Value Noise。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-442ada94477d7682.png" alt="19200103-442ada94477d7682"></p>
<h3 id="3-Gradient-Noise"><a href="#3-Gradient-Noise" class="headerlink" title="3 Gradient Noise"></a>3 Gradient Noise</h3><p>Value Noise 是通过对周边顶点的随机 Value 进行插值来得到噪声贴图的，而 Gradient Noise 的实现原理与 Value Noise 类似，不同的是，这里是通过对周边顶点的 Gradient（梯度，可以理解为某个点的速度，常用向量来表示）进行插值来输出噪声贴图。</p>
<p>对梯度进行插值，这里有一个问题需要解决，那就是对向量的插值，得到的结果肯定还是向量，而前面说过，噪声的输出结果应该是一个浮点数，那么要怎么实现这二者的转换呢？这里的做法是将当前像素点到对应顶点的连线作为一个向量，与这个顶点的梯度进行点乘，就得到了对应的浮点数，之后再对这个浮点数应用与 Value Noise 一样的插值算法，就能得到对应的噪声结果了。</p>
<p>根据插值顶点选取算法的不同，这里又有不同的细分，Perlin Noise 与前面的 Value Noise 类似，都是选取周边四个顶点（如果是 3D 的，就是周边 8 个顶点，以此类推）的数据进行插值，而 Simplex Noise 则不同，选取的是等边三个顶点的数据（如果是 3D，选取的就是正四面体的四个顶点进行插值），下面来看这两种噪声的实现细节。</p>
<h4 id="3-1-Perlin-Noise"><a href="#3-1-Perlin-Noise" class="headerlink" title="3.1 Perlin Noise"></a>3.1 Perlin Noise</h4><p>Perlin Noise 非常常见，关于 Perlin  Noise 可以查看之前在光线追踪中的实现：<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>。</p>
<h4 id="3-2-Simplex-Noise"><a href="#3-2-Simplex-Noise" class="headerlink" title="3.2 Simplex Noise"></a>3.2 Simplex Noise</h4><p>实际上，Simplex 噪声跟 Perlin 噪声都是 Ken Perlin 发明的，后者是对前者的优化替代，Simplex 实际上是一种算法，既可以用于实现 Value Noise，同样也可以用于实现 Gradient Noise，不过由于 Gradient Noise 的应用范围更广，因此这里我们就直接跳过 Value Noise 部分，只介绍用于实现 Gradient Noise 的部分。</p>
<p>Simplex Noise 与 Perlin Noise 的区别在于其插值时所选取的周边顶点的算法不同，具体而言，是选取此像素所从属的 grid 中的正三角形（等边三角形）的三个顶点（即将 Perlin Noise 中的插值正方形沿着对角线一分为二，选取当前像素所在的那个正三角形的三个顶点，对应到 3D 空间，Perlin 使用的是立方体的 8 个顶点，而 Simplex 使用的则是连接相邻三个面的对角线组成的四面体转换后的正立方体的四个顶点）作为插值的数据源。</p>
<p>相对 Perlin Noise，Simplex 的实现更为简洁，其成本也更低。与前面计算某个像素对应的噪声值需要通过对周边顶点数据进行插值不同，Simplex 采用的是衰减函数，比如根据某个顶点到此像素的距离来计算此顶点数据对于此像素的贡献，之后将周边顶点的贡献进行累加就得到了最终的输出结果。</p>
<p>前面说到，Simplex 噪声来自于正三角形（正四面体）的数据衰减，那么这个正三角形是怎么来的呢？我们知道，一个 2D 平面，既可以使用正方形进行无缝平铺，这种 tiling 方式对应的就是前面 Value &#x2F; Perlin Noise 的计算基础，同时也可以使用正三角形进行平铺，而这对应的则是 Simplex 噪声的实现基础，这里的一个问题就是这二者是如何转换的，毕竟我们平常使用的基本上都是 grid，也就是正方形的平铺方式。这个转换过程可以参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/9cfb678fbd95">图形学中常见噪声生成算法综述</a>中的 2.2 节</li>
<li><a href="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise - Wikipedia</a></li>
</ul>
<h3 id="4-Voronoi-Noise-和-Worley-Noise"><a href="#4-Voronoi-Noise-和-Worley-Noise" class="headerlink" title="4 Voronoi Noise 和 Worley Noise"></a>4 Voronoi Noise 和 Worley Noise</h3><p>Voronoi Noise 与 Worley Noise 在形态上十分相似，在图形学中的应用也基本一致，比如同样用于进行云层创建，水底焦散现象模拟等，那同样的噪声为什么会有两个名字呢？实际上图形学中最开始使用的是 Voronoi 噪声，只是这种噪声的实现算法消耗比较高，后面 Steven Worley 对齐进行了改进，提出了以其名字命名的 Worley 噪声。下面我们一起来看一下这两种噪声的实现算法。</p>
<p>Voronoi 噪声是通过在空间中生成随机分布的多个特征点，之后对于每个需要计算的像素，对所有的特征点进行遍历，找到距离其最近的特征点，以其对应的特征值作为此像素的值进行输出。下图展示了 Voronoi 噪声的生成过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-6ee079fe186022e5.gif" alt="19200103-6ee079fe186022e5"></p>
<p>Voronoi 噪声的思路很简单，但是由于需要对每个特征点进行遍历，整个算法的复杂度就变得很高了，为了降低计算的消耗，Worley 噪声就应运而生了。</p>
<p>Worley 噪声是通过将空间（2D &#x2F; 3D）划分成一个个的 cell（正方形 &#x2F; 立方体），在每个 cell 中的随机位置随机生成一个特征点，之后对于每个待计算的像素，搜寻周边的 cell，找到距离其最近的噪点，之后以距离此噪点的距离作为当前像素的噪声结果，就得到了对应的 Worley 噪声。相对于 Voronoi 噪声，Worley 算法的改进点在于将搜寻范围从所有特征点限定在了周边的若干个 cell 之中，理论上最正确的搜索范围是周边 25 个 cell，但实际上如果噪声函数选取得当，使用九宫格进行搜索也能得到正确的结果。下图展示了 Worley 噪声的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-e8fe35196eb9ddd9.png" alt="19200103-e8fe35196eb9ddd9"></p>
<p>如果将搜索范围换成 9 个 cell，会发现结果会存在异常，这是因为在某些随机函数作用下，九宫格搜索会漏掉一些正确解导致：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-bdec0bdd9617cdd0.png" alt="19200103-bdec0bdd9617cdd0"></p>
<h3 id="5-Fractal-Brownian-Motion"><a href="#5-Fractal-Brownian-Motion" class="headerlink" title="5 Fractal Brownian Motion"></a>5 Fractal Brownian Motion</h3><p>有时候单一频率的噪声不足以满足需求，会需要使用多级噪声累加的结果来实现程序化生成，这种方式我们称之为分形布朗运动（Fractal Brownian Motion，简称 FBM），也称为 Turbulence，简单来说就是将多个不同频率的噪声按照不同的振幅进行混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/">【RayTracer】（十二）Perlin 噪声</a>中有 Turbulence 应用于 Perlin Noise 的代码实现。还可以将 FBM 应用于 Worley 噪声，得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a89ea620cfe2aad9.png" alt="19200103-a89ea620cfe2aad9"></p>
<h3 id="6-Curl-Noise"><a href="#6-Curl-Noise" class="headerlink" title="6 Curl Noise"></a>6 Curl Noise</h3><p>Curl 噪声在图形学中有着广泛的应用，比如可以用于对粒子位置进行调制，使之产生卷曲的效果；比如可以对烟雾水流效果进行调制，生成湍流扰动效果等。相对于其他的流体模拟算法，Curl Noise 的生成算法算是十分简单的，但是应用起来效果却并没有减色多少。</p>
<p>Curl 噪声中的 Curl 可以看成是跟加减乘除号同等的一种运算符号，其输入数据是一个向量，经过 curl 运算之后，就得到了一个 divergence free（无散度）的向量场，这里先介绍下什么是向量的 divergence，即散度：<br>$$<br>div\ \vec a &#x3D; \nabla · \vec a &#x3D; \frac{\partial a_x}{\partial x} + \frac{\partial a_y}{\partial y} + \frac{\partial a_z}{\partial z}<br>$$<br>散度指的是向量三个分量在对应坐标轴方向上的偏微分之和，从物理上来说，指的是一个向量场在某个给定的位置散开或者说收敛的程度，日常生活中常见的流体比如水流，空气，烟雾等都是 divergence-free（无散）的。curl 噪声从物理上来说，可以用来表征用于对向量进行转向的力的大小。</p>
<p>下面我们来介绍一下 Curl 噪声的实现算法，对一个潜在的 3D 向量场 $\Psi$ 而言，令：<br>$$<br>\vec \Psi &#x3D; (\Psi_1, \Psi_2, \Psi_3)<br>$$<br>由此我们可以计算出其 Curl Velocity 算子：<br>$$<br>\vec v(x,y,z) &#x3D; (\frac{\partial \Psi_3}{\partial y} - \frac{\partial \Psi_2}{\partial z},<br>\frac{\partial \Psi_1}{\partial z} - \frac{\partial \Psi_3}{\partial x},<br>\frac{\partial \Psi_2}{\partial x} - \frac{\partial \Psi_1}{\partial y})<br>$$<br>2D 情况较为简单：<br>$$<br>\vec v(x,y) &#x3D; (\frac{\partial \Psi}{\partial y},-\frac{\partial \Psi}{\partial x})<br>$$<br>根据流体力学可知，上述速度场都是无散的，即：<br>$$<br>\nabla·\vec v &#x3D; 0<br>$$<br>具体来说，假设我们以二维 Perlin 噪声作为向量场，那么最终的 Curl 噪声就可以用如下公式表示：<br>$$<br>\vec v(x,y) &#x3D; (\frac{PerlinNoise(x,y)}{\partial y},-\frac{PerlinNoise(x,y)}{\partial x})<br>$$<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vec2 <span class="title">curlNoise</span><span class="params">(vec2 uv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> eps = <span class="number">0.00001</span>;</span><br><span class="line">    <span class="type">float</span> x = uv.x;</span><br><span class="line">    <span class="type">float</span> y = uv.y;</span><br><span class="line">    <span class="comment">//Find rate of change in X direction</span></span><br><span class="line">    <span class="type">int</span> firstOctave = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> accumOctaves = <span class="number">3</span>;</span><br><span class="line">    <span class="type">bool</span> revertPerlin = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">float</span> n1 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y + eps), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n2 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x, y - eps), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> a = (n1 - n2)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find rate of change in Y direction</span></span><br><span class="line">    <span class="type">float</span> n3 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x + eps, y), revertPerlin).x;</span><br><span class="line">    <span class="type">float</span> n4 = <span class="built_in">perlin2DNoise</span>(<span class="built_in">vec2</span>(x - eps, y), revertPerlin).x;</span><br><span class="line">    <span class="comment">//Average to find approximate derivative</span></span><br><span class="line">    <span class="type">float</span> b = (n3 - n4)/(<span class="number">2.0</span> * eps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Curl</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec2</span>(a, -b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-d8bc4eb896a6a039.png" alt="19200103-d8bc4eb896a6a039"></p>
<p>将之用速度向量来表示，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-a5f536670231116e.png" alt="19200103-a5f536670231116e"></p>
<p>其中灰色部分表示的是原始的 Perlin 噪声，而白色箭头表示的则是 Curl 噪声向量的方向与大小。</p>
<p>提高噪声频率得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-ef43d7f381fca207.png" alt="19200103-ef43d7f381fca207"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-7b5e9e3939c7b8ce.png" alt="19200103-7b5e9e3939c7b8ce"></p>
<h3 id="7-White-Noise"><a href="#7-White-Noise" class="headerlink" title="7 White Noise"></a>7 White Noise</h3><p>白噪声（White Noise）是一种在各个频率上的强度都十分均匀的噪声，这种噪声并不平滑，而自然界的各种纹理实际上都是连续的，因此通常不适合用于贴图生成。</p>
<p>实际上，所谓的白噪声并不是特指的某一种噪声，而是一种信号的统计模型。在离散采样中，白噪声具有如下特点：</p>
<ul>
<li>各个采样点之间完全没有数值上的联系</li>
<li>信号的均值为0，方差有限。</li>
</ul>
<p>实现白噪声最简单的算法就是直接使用一个随机数作为返回值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%A8%8B%E5%BA%8F%E5%99%AA%E5%A3%B0%E6%80%BB%E7%BB%93/19200103-c17c41b69b51b075.png" alt="19200103-c17c41b69b51b075"></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】模板测试和深度测试</title>
    <url>/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>之前学习渲染管线的时候，没有对混合阶段的各种测试展开细说，本篇将详细介绍模板测试和深度测试有关的知识，主要内容包括：</p>
<ul>
<li>渲染管线终极版</li>
<li>模板测试</li>
<li>深度测试</li>
<li>Early-Z 和 Z-Prepass</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-渲染管线终极版"><a href="#1-渲染管线终极版" class="headerlink" title="1 渲染管线终极版"></a>1 渲染管线终极版</h3><p>之前的学习中我们已经对渲染管线有了一个整体流程上的认识，但具体细节和阶段内部的顺序并没有过多关注，在学习模板测试和深度测试有关的内容之前，有必要为之前的渲染管线加上一些“细节”，以便于后续的理解。</p>
<p>下图展示了整个渲染管线的流程，包含了各阶段内部和操作内部的顺序以及流程细节，可以作为最终版放在脑中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/RenderPipeline.png" alt="RenderPipeline"></p>
<p>图中：</p>
<ul>
<li>绿色的阶段都是完全可编程的</li>
<li>蓝色的阶段可配置，但不可编程</li>
<li>黄色的阶段完全固定</li>
<li>虚线为可选阶段</li>
</ul>
<h3 id="2-模板测试（Stencil-Test）"><a href="#2-模板测试（Stencil-Test）" class="headerlink" title="2 模板测试（Stencil Test）"></a>2 模板测试（Stencil Test）</h3><p>模板测试简单来说就是根据模板缓冲区的数值决定该像素的颜色值，最简单的比如只有模板缓冲为 1 的像素才显示，为 0 则不显示，类似于一个 mask 操作，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/X911U-WnXlnLJg_9klfTcg.png" alt="X911U-WnXlnLJg_9klfTcg"></p>
<p>模板缓冲区与颜色缓冲区和深度缓冲区类似，模板缓冲区可以为屏幕上的每个像素点保存一个无符号整数值（通常是 8 位整数）。这个值的具体意义视程序的具体应用而定。在渲染的过程中，可以用这个值与一个预先设定的参考值相比较，根据比较的结果来决定是否更新相应的像素点的颜色值。这个比较的过程被称为模板测试。模板测试发生在透明度测试（alpha test）之后，深度测试（depth test）之前。如果模板测试通过，则相应的像素点更新，否则不更新。</p>
<p>模板测试可以定义不同的比较方式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160835251.png" alt="image-20220513160835251"></p>
<p>还可以定义更新缓冲值的方式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513160947277.png" alt="image-20220513160947277"></p>
<p>总的来说模板测试就是对当前模板缓冲值（stencil Buffer Value）和模板参考值（reference Value）使用特定的比较操作进行比较来决定是否渲染该像素，模板测试后可以根据测试结果，按照特定方式更新模板缓冲区的值。</p>
<p>模板测试可以与其他测试或图形算法结合实现许多效果，比如：描边、多边形填充、反射区域控制等。</p>
<h3 id="3-深度测试（Z-Test）"><a href="#3-深度测试（Z-Test）" class="headerlink" title="3 深度测试（Z Test）"></a>3 深度测试（Z Test）</h3><p>深度测试发生在模板测试之后，透明度混合之前。所谓深度测试，就是针对当前对象在屏幕上（更准确的说是frame buffer）对应的像素点，将对象自身的深度值与当前该像素点缓存的深度值进行比较，如果通过了，本对象在该像素点才会将颜色写入颜色缓冲区，否则否则不会写入颜色缓冲。</p>
<p><strong>深度缓冲（Z-Buffer）</strong>就像颜色缓冲（储存所有的片段颜色）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24 或 32 位 float 的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。一般来说，深度缓冲区中存储的深度值为 0 到 1 范围的浮点值，且为非线性。深度值在各个空间的变化如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220513171312423.png" alt="image-20220513171312423"></p>
<p><strong>深度写入（Z-Write）</strong>包括两种状态：ZWrite On 与 ZWrite Off。当我们开启深度写入的时候，通过深度测试则将新的深度值写入深度缓存；反之，如果关闭深度写入，那么深度就不会写入深度缓冲区。</p>
<p>深度测试对深度缓冲区和颜色缓冲区的写入情况有以下四种：</p>
<ul>
<li>深度测试通过，深度写入开启：写入深度缓冲区，写入颜色缓冲区；</li>
<li>深度测试通过，深度写入关闭：不写深度缓冲区，写入颜色缓冲区；</li>
<li>深度测试失败，深度写入开启：不写深度缓冲区，不写颜色缓冲区；</li>
<li>深度测试失败，深度写入关闭：不写深度缓冲区，不写颜色缓冲区；</li>
</ul>
<p>一般来说，深度测试可以自定义比较方式，默认为小于等于，即深度小于等于缓冲区中的深度时则通过测试，并且深度写入默认开启。深度测试的流程图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/f9z_wixRyJvq5jVawaFuPA.png" alt="f9z_wixRyJvq5jVawaFuPA"></p>
<p>深度测试不仅可以解决遮挡问题，还可以应用于很多效果，比如：阴影贴图、透明渲染、粒子渲染、切边效果、X光等。</p>
<h3 id="4-Early-Z-和-Z-Prepass"><a href="#4-Early-Z-和-Z-Prepass" class="headerlink" title="4 Early-Z 和 Z-Prepass"></a>4 Early-Z 和 Z-Prepass</h3><h4 id="4-1-Early-Z"><a href="#4-1-Early-Z" class="headerlink" title="4.1 Early-Z"></a>4.1 Early-Z</h4><p>在正常的渲染管线中，深度测试在所有测试完成后才进行，片元着色器计算的所有片元经过深度测试后会有一大部分被舍弃，这相当于进行了很多无用的计算，而实际上在进入片元着色器之前我们就已经知道了所有顶点的深度，因此完全可以提前进行深度测试，将深度大的片元提前舍弃，不去计算，这样就可以节省很多的计算量，这就是 Early-Z 的思想。上面的渲染管线图中给出了 Early-Z 在整个管线中的位置。</p>
<p>但是有一些情况下，Early-Z 会失效或使用 Early-Z 会造成错误：</p>
<ul>
<li>开启了透明度测试（Alpha Test ），这时如果提前进行深度测试，可能导致透明物体后的片元没有通过深度测试而渲染不出来</li>
<li>进行手动剔除（discard）操作，这时提前通过深度测试筛选出来的片元也可能会被手动剔除而造成错误</li>
<li>片元着色器中手动修改 GPU 插值得到的深度，这时提前通过深度剔除片元很大可能会造成错误</li>
<li>开启了透明度混合（Alpha Blend），开启透明度混合一般会关闭深度写入，所以 Early-Z 不生效</li>
<li>关闭深度测试时 Early-Z 自然也不生效</li>
</ul>
<p>Early-Z 进行的操作和原本逐像素处理阶段的 Z-Test（为了 Early-Z 区别，这个阶段也会被称为 Late-Z）操作完全一样，现代的 GPU 已经都开始包含这样的硬件设计。但是 Early-Z 有以下两个主要的缺点：</p>
<ul>
<li>一旦进行了手动写入深度值、开启 alpha test 或者丢弃像素等上述操作，那么 GPU 就会关闭 Early-Z 直到下次清空 Z-Buffer 后才会重新开启（不过现在的 GPU 也在逐渐优化，使其更智能的开关 Early-Z）。之所以 GPU  会选择关闭 Early-Z 是因为上述那些操作可能会在片元着色器与 Late-Z 阶段之间修改深度缓存中的深度值，导致提前的 Early-Z 结果不正确。我们也可以在 fragment shader 中使用 <code>layout(early_fragment_tests)</code> 来强制打开 Early-Z。</li>
<li>Early-Z 的优化效果并不稳定，最理想条件下所有绘制顺序都是由近及远，那么 Early-Z 可以完全避免过度绘制。但是相反的状态下，由远及近绘制物体， Early-Z 则会起不到任何效果。所以有些时候为了完全发挥 Early-Z 的功效，我们会在每帧绘制时对场景的物体按照到摄像机的距离由远及近进行排序。这个操作会在 CPU 端进行，当场景复杂到一定程度，频繁的排序将会占用 CPU 的大量计算资源。</li>
</ul>
<h4 id="4-2-Z-Prepass"><a href="#4-2-Z-Prepass" class="headerlink" title="4.2 Z-Prepass"></a>4.2 Z-Prepass</h4><p>Z-Prepass 是一种软件技术。它主要是配合 Early-Z 使用，来减少上面提到的 Early-Z 的第二个缺点——效果不稳定。Z-Prepass 的做法是将场景做两个 pass 的绘制。第一个 pass 仅写入深度，不做任何复杂的片元计算，不输出任何颜色。第二个 pass <strong>关闭深度写入</strong>，并将<strong>深度比较函数设为“相等”</strong>。</p>
<p>本节一开始就提到， Early-Z 的出现是因为经过大量运算的片元，很大概率会在之后被丢弃掉。那么对于第一个 pass 由于只写入深度，不在片元做任何计算，所以即便之后会被丢弃，也并不可惜。也就是说无论场景中的物体以怎样的顺序绘制，我们都可以以很小的代价提前绘制好当前场景的深度缓存。那么在第二个 pass 时，Early-Z 就可以用这个深度缓存中的值和当前深度值进行比较，只绘制深度相等的片元，任何其他的片元都可以直接丢弃，因此第二个 pass 要把深度比较函数设为“相等”。同时当前的深度缓存已经是完全正确的结果了，因此第二个 pass 也不需要对深度缓存做任何更新，便可以关闭深度写入。</p>
<p>Z-Prepass 必须配合 Early-Z 才能发挥效果，如果没有 Early-Z 的话，第二个 pass 的深度测试依旧在片元着色器之后，因此所有片元都会在片元阶段进行复杂计算。Z-Prepass 的思想和延迟渲染管线（defered render pipeline，之后会专门总结）有些相似，差别在于：</p>
<ul>
<li>第一，Z-Prepass 的第一个 pass 只计算深度，并且结果直接存储在深度缓存。而延迟渲染会同时计算更多其他的屏幕空间数据，并将这些数据存储在额外的 frame buffer 中，需要更大的缓存（也就是G-Buffer）。</li>
<li>第二，Z-Prepass 的第二个 pass 依旧需要对全场景的各个物体进行绘制（至少顶点阶段是如此），而延迟渲染的第二个 pass 类似于后处理，本质上只绘制了一个屏幕大小的矩形。</li>
</ul>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】图形渲染和视觉处理</title>
    <url>/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中与图形渲染基础和视觉处理相关的知识进行概括总结。主要内容包括：</p>
<ul>
<li>光照与材质</li>
<li>着色</li>
<li>抗锯齿总结</li>
<li>透明渲染</li>
<li>伽马校正</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-光照与材质"><a href="#1-光照与材质" class="headerlink" title="1 光照与材质"></a>1 光照与材质</h3><h4 id="1-1-光源特性"><a href="#1-1-光源特性" class="headerlink" title="1.1 光源特性"></a>1.1 光源特性</h4><p>光被不同地模拟为几何光线，电磁波或光子（具有一些波特性的量子粒子）。无论如何处理，光都是电磁辐射能，即通过空间传播的电磁能。光源发光，而不是散射或吸收光。根据渲染目的，光源可以以许多不同的方式来表示。光源可以分为三种不同类型：<strong>平行光源、点光源和聚光灯。</strong></p>
<h4 id="1-2-光的散射与吸收"><a href="#1-2-光的散射与吸收" class="headerlink" title="1.2 光的散射与吸收"></a>1.2 光的散射与吸收</h4><p><strong>从根本上来说，所有的光物质相互作用都是两种现象的结果：散射（scattering）和吸收（absorption）。</strong></p>
<p>散射（scattering）发生在当光线遇到任何种类的光学不连续性（optical discontinuity）时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。散射不会改变光量，它只是使其改变方向。光的散射（scattering）一般又分为反射（reflection）和折射（refraction）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110002009.png" alt="image-20220513110002009"></p>
<p>吸收（absorption）发生在物质内部，其会导致一些光转变成另一种能量并消失。吸收会减少光量，但不会影响其方向。</p>
<h4 id="1-3-镜面反射和漫反射"><a href="#1-3-镜面反射和漫反射" class="headerlink" title="1.3 镜面反射和漫反射"></a>1.3 镜面反射和漫反射</h4><p><strong>镜面反射光表示在表面反射的光。而漫反射光表示经历透射（transmission），吸收（absorption）和散射（scattering）的光。</strong></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110116016.png" alt="image-20220513110116016"></p>
<h4 id="1-4-颜色"><a href="#1-4-颜色" class="headerlink" title="1.4 颜色"></a>1.4 颜色</h4><p>入射光（Incoming illumination）通过表面辉度（irradiance）来度量。而出射光（outgoing light）通过出射率（exitance）来度量。<strong>出射率除以辉度可以作为材质的衡量特性。对于不发光的表面，该比率为 0 到 1 之间。出射率和辉度的比率对于不同的光颜色是不同的，所以其表示为 RGB 矢量，也就是我们通常说的颜色。</strong></p>
<h4 id="1-5-表面与散射分布"><a href="#1-5-表面与散射分布" class="headerlink" title="1.5 表面与散射分布"></a>1.5 表面与散射分布</h4><p>镜面反射项的方向分布取决于表面粗糙度（roughness，其反义词是 smoothness，光滑度）。反射光线对于更平滑的表面更加紧密，并且对于较粗糙的表面更加分散。我们可以看到下图中的这种依赖关系，它显示了不同粗糙度的两个表面的反射效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513110421641.png" alt="image-20220513110421641"></p>
<h3 id="2-着色"><a href="#2-着色" class="headerlink" title="2 着色"></a>2 着色</h3><p>可以查看以前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a></p>
<h3 id="3-抗锯齿方法总结"><a href="#3-抗锯齿方法总结" class="headerlink" title="3 抗锯齿方法总结"></a>3 抗锯齿方法总结</h3><p>抗锯齿，也称反走样。它是一种消除显示器输出的画面中图物边缘出现凹凸锯齿的技术，那些凹凸的锯齿通常因为高分辨率的信号以低分辨率表示或无法准确运算出 3D 图形坐标定位时所导致的走样（aliasing）而产生的，抗锯齿技术能有效地解决这些问题。</p>
<p>关于抗锯齿的原理可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/">【计算机图形学】（四）反走样</a>，下面将常见的抗锯齿类型进行总结介绍，也包括  RTR 中没有讲到的，最近几年新提出的常见抗锯齿类型。</p>
<h4 id="3-1-超级采样抗锯齿（SSAA）"><a href="#3-1-超级采样抗锯齿（SSAA）" class="headerlink" title="3.1 超级采样抗锯齿（SSAA）"></a>3.1 超级采样抗锯齿（SSAA）</h4><p>超级采样抗锯齿（Super-Sampling Anti-Aliasing，简称  SSAA）是比较早期的抗锯齿方法，比较消耗资源，但简单直接。这种抗锯齿方法先把图像映射到缓存并把它放大，再用超级采样把放大后的图像像素进行采样，一般选取 2 个或 4 个邻近像素，把这些采样混合起来后，生成的最终像素，这样每个像素拥有邻近像素的特征，像素与像素之间的过渡色彩，就变得近似，使得图形的边缘色彩过渡趋于平滑。再把最终像素还原回原来大小的图像，并保存到帧缓存也就是显存中，替代原图像存储起来，最后输出到显示器，显示出一帧画面。这样就等于把一幅模糊的大图，通过细腻化后再缩小成清晰的小图。比如在 1024x768 分辨率上开启 2xSSAA，GPU 会先渲染 2048x1536 图像，再“塞进”1024x768 的屏幕中，将画面精细度提升一倍，毫无疑问会改善边缘锯齿情况。超级采样抗锯齿中使用的采样法一般有两种：</p>
<ul>
<li>OGSS，顺序栅格超级采样（Ordered Grid Super-Sampling，简称  OGSS），采样时选取  2 个邻近像素</li>
<li>RGSS，旋转栅格超级采样（Rotated Grid Super-Sampling，简称  RGSS），采样时选取  4 个邻近像素</li>
</ul>
<p>另外，作为概念上最简单的一种超采样方法，全场景抗锯齿（Full-Scene Antialiasing, FSAA）以较高的分辨率对场景进行绘制，然后对相邻的采样样本进行平均，从而生成一幅新的图像。</p>
<h4 id="3-2-多重采样抗锯齿（MSAA）"><a href="#3-2-多重采样抗锯齿（MSAA）" class="headerlink" title="3.2 多重采样抗锯齿（MSAA）"></a>3.2 多重采样抗锯齿（MSAA）</h4><p>多重采样抗锯齿（Multi Sampling Anti-Aliasing，简称  MSAA），是一种特殊的 SSAA，MSAA 首先来自于 OpenGL。具体是 MSAA 只对  Z 缓存（Z-Buffer）和模板缓存 (Stencil Buffer) 中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。这样的话，相比 SSAA 对画面中所有数据进行处理，MSAA 对资源的消耗需求大大减弱，不过在画质上可能稍有不如  SSAA。</p>
<h4 id="3-3-高分辨率抗锯齿（HRAA）"><a href="#3-3-高分辨率抗锯齿（HRAA）" class="headerlink" title="3.3 高分辨率抗锯齿（HRAA）"></a>3.3 高分辨率抗锯齿（HRAA）</h4><p>高分辨率抗锯齿方法(High Resolution Anti-Aliasing，简称 HRAA)，也称 Quincunx 方法，出自 NVIDIA 公司。“Quincunx”意思是 5 个物体的排列方式，其中 4 个在正方形角上，第五个在正方形中心，也就是梅花形。此方法中，采样模式是五点梅花状，其中四个样本在像素单元的角上，最后一个在中心。</p>
<h4 id="3-4-可编程过滤抗锯齿（CFAA）"><a href="#3-4-可编程过滤抗锯齿（CFAA）" class="headerlink" title="3.4 可编程过滤抗锯齿（CFAA）"></a>3.4 可编程过滤抗锯齿（CFAA）</h4><p>可编程过滤抗锯齿（Custom Filter Anti-Aliasing，简称 CFAA）简单地说就是扩大取样面积的 MSAA，比方说之前的 MSAA 是严格选取物体边缘像素进行缩放的，而 CFAA 则可以通过驱动和谐灵活地选择对影响锯齿效果较大的像素进行缩放，以较少的性能牺牲换取平滑效果。显卡资源占用也比较小。</p>
<h4 id="3-5-形态抗锯齿（MLAA）"><a href="#3-5-形态抗锯齿（MLAA）" class="headerlink" title="3.5 形态抗锯齿（MLAA）"></a>3.5 形态抗锯齿（MLAA）</h4><p>形态抗锯齿（Morphological Anti-Aliasing，简称 MLAA），是 AMD 推出的完全基于 CPU 处理的抗锯齿解决方案。与 MSAA 不同， MLAA 将跨越边缘像素的前景和背景色进行混合，用第 2 种颜色来填充该像素，从而更有效地改进图像边缘的变现效果。</p>
<h4 id="3-6-快速近似抗锯齿（FXAA）"><a href="#3-6-快速近似抗锯齿（FXAA）" class="headerlink" title="3.6 快速近似抗锯齿（FXAA）"></a>3.6 快速近似抗锯齿（FXAA）</h4><p>快速近似抗锯齿 (Fast Approximate Anti-Aliasing，简称 FXAA)  ，是传统 MSAA (多重采样抗锯齿) 效果的一种高性能近似。是最简单的、高效率的抗锯齿方式，FXAA 对图形边缘进行后处理。先进行边缘检测，然后通过提取边缘像素周围的颜色信息，通过混合颜色信息来消除高对比所产生的锯齿，其实就是对图像边缘进行柔化。</p>
<h4 id="3-7-时间性抗锯齿（TAA）"><a href="#3-7-时间性抗锯齿（TAA）" class="headerlink" title="3.7 时间性抗锯齿（TAA）"></a>3.7 时间性抗锯齿（TAA）</h4><p>时间性抗锯齿（Temporal Anti-Aliasing，简称 TAA），将 MSAA、时间滤波以及后期处理相结合，用于呈现更高的视觉保真度。与 CG 电影中所采用的技术类似，TXAA 集 MSAA 的强大功能与复杂的解析滤镜于一身，可呈现出更加平滑的图像效果。此外，TXAA 还能够对帧之间的整个场景进行抖动采样，以减少闪烁情形，闪烁情形在技术上又称作时间性锯齿。</p>
<p>Temporal AA 严格来说不是在光栅化时进行处理，而是以后处理的方式进行反走样，这也是目前比较主流的方式。Temporal AA 是近年来商业引擎最流行的几种反走样算法之一。</p>
<p>简单来说，Temporal AA 是基于历史帧缓冲，从历史帧中采样，在像素范围内进行加权抖动。相机抖动是 TAA 能够反走样最本质原因。相机随时间抖动过程中，引入了额外的子像素信息，对子像素的融合，使我们在时域上获得超采样的效果。具体来说，对于每一帧游戏画面，相机抖动 0.x~1 像素。那么在时域上，我们可以得到当前像素的多个子像素信息。时域上进行加权融合后，得到当前像素的最终颜色。</p>
<h4 id="3-8-多帧采样抗锯齿（MFAA）"><a href="#3-8-多帧采样抗锯齿（MFAA）" class="headerlink" title="3.8 多帧采样抗锯齿（MFAA）"></a>3.8 多帧采样抗锯齿（MFAA）</h4><p>多帧采样抗锯齿（Multi-Frame Sampled Anti-Aliasing，MFAA）是 NVIDIA 公司根据 MSAA 改进出的一种抗锯齿技术。可以将 MFAA 理解为 MSAA 的优化版，能够在得到几乎相同效果的同时提升性能上的表现。MFAA 与 MSAA 最大的差别就在于在同样开启 4 倍效果的时候 MSAA 是真正的针对每个边缘像素周围的 4 个像素进行采样，MFAA 则是仅仅只是采用交错的方式采样边缘某个像素周围的两个像素。</p>
<h4 id="3-9-深度学习超采样（DLSS）"><a href="#3-9-深度学习超采样（DLSS）" class="headerlink" title="3.9 深度学习超采样（DLSS）"></a>3.9 深度学习超采样（DLSS）</h4><p>利用神经网络的重建能力进行图像处理。DLSS 背后使用的技术是 Recurrent CNN，递归神经网络与卷积神经网络的一种结合。因此他能结合时域上的信息保证时域稳定性，即像素具有帧间连贯性，不会出现过多闪烁、跳变现象。其次，结合神经网络的强大图形重建能力，DLSS 能够分别对几何边缘以及着色进行重建。</p>
<h4 id="3-10-图示抗锯齿"><a href="#3-10-图示抗锯齿" class="headerlink" title="3.10 图示抗锯齿"></a>3.10 图示抗锯齿</h4><p>下图展示了不同采样方法的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/image-20220513113600088.png" alt="image-20220513113600088"></p>
<h3 id="4-透明渲染"><a href="#4-透明渲染" class="headerlink" title="4 透明渲染"></a>4 透明渲染</h3><h4 id="4-1-透明渲染算法"><a href="#4-1-透明渲染算法" class="headerlink" title="4.1 透明渲染算法"></a>4.1 透明渲染算法</h4><p>透明渲染是是图形学里面的常见问题之一，可以从《Real-Time Rendering》中总结出如下两个算法：</p>
<ul>
<li>Screen-Door Transparency 方法。基本思想是用棋盘格填充模式来绘制透明多边形，也就是说，以每隔一个像素绘制一点方式的来绘制一个多边形，这样会使在其后面的物体部分可见，通常情况下，屏幕上的像素比较紧凑，以至于棋盘格的这种绘制方式并不会露馅。同样的想法也用于剪切纹理的抗锯齿边缘，但是在子像素级别中的，这是一种称为 alpha 覆盖（alpha to coverage）的特征。screen-door transparency 方法的优点就是简单，可以在任何时间任何顺序绘制透明物体，并不需要特殊的硬件支持（只要支持填充模式）。缺点是透明度效果仅在 50% 时最好，且屏幕的每个区域中只能绘制一个透明物体。</li>
<li>Alpha 混合（Alpha Blending）方法。这个方法比较常见，其实就是按照 Alpha 混合向量的值来混合源像素和目标像素。当在屏幕上绘制某个物体时，与每个像素相关联的值有 RGB 颜色和 Z 缓冲深度值，以及另外一个成分 alpha 分量，这个 alpha 值也可以根据需要生成并存储，它描述的是给定像素的对象片段的不透明度的值。alpha 为 1.0 表示对象不透明，完全覆盖像素所在区域; 0.0 表示像素完全透明。为了使对象透明，在现有场景的上方，以小于 1 的透明度进行绘制即可。每个像素将从渲染管线接收到一个  RGBA 结果，并将这个值和原始像素颜色相混合。</li>
</ul>
<h4 id="4-2-透明排序"><a href="#4-2-透明排序" class="headerlink" title="4.2 透明排序"></a>4.2 透明排序</h4><p>要将透明对象正确地渲染到场景中，通常需要对物体进行排序。下面分别介绍两种比较基本的透明排序方法（画家算法和深度缓冲）和两种高级别的透明排序算法（加权平均值算法和深度剥离）。</p>
<h5 id="4-2-1-画家算法和深度缓冲"><a href="#4-2-1-画家算法和深度缓冲" class="headerlink" title="4.2.1  画家算法和深度缓冲"></a>4.2.1  画家算法和深度缓冲</h5><p>可查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/08/20220308-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/">【计算机图形学】（五）深度缓冲</a></p>
<h5 id="4-2-2-加权平均值算法（Weighted-Average）"><a href="#4-2-2-加权平均值算法（Weighted-Average）" class="headerlink" title="4.2.2 加权平均值算法（Weighted Average）"></a>4.2.2 加权平均值算法（Weighted Average）</h5><p>使用简单的透明混合公式来实现无序透明渲染的算法，它通过扩展透明混合公式，来实现无序透明物件的渲染，从而得到一定程度上逼真的结果。</p>
<p>NVIDIA 公司的 Louis Bavoil 在此基础上提出了新的算法，使用物体的不透明度作为加权值的加权平均值算法。此算法的主要思想如下：</p>
<p>对于某个位置的像素点，如果所有的不透明物件是相同的颜色，那么渲染的结果与它们的渲染顺序无关。那么，对于不相同颜色值的情况，如果我们用某一个颜色来替换这些颜色，比如这些颜色的平均值。对于这种情况，我们使用各个颜色的不透明度作为权重来计算出它们的加权平均值作为最终颜色替换这些颜色，这样渲染就与顺序无关。</p>
<p>此算法的优点很明显，效率高，速度快，只需要对物体进行一次的渲染，然后加上一次全屏的后处理。但是缺点也是同样的明显，透明结果只是一个近似值，而不是确切的正确结果。然而，它的效果仍然远远好过不做任何处理的简单透明混合，而且高效性也使得它有一定的应用空间。</p>
<h5 id="4-2-3-深度剥离算法（Depth-Peeling）"><a href="#4-2-3-深度剥离算法（Depth-Peeling）" class="headerlink" title="4.2.3 深度剥离算法（Depth Peeling）"></a>4.2.3 深度剥离算法（Depth Peeling）</h5><p>深度剥离是一种对深度值进行排序的技术。它的原理比较直观，标准的深度检测使场景中的 Z 值最小的点输出到屏幕上，就是离我们最近的顶点。但还有离我们第二近的顶点，第三近的顶点存在。要想显示它们，可以用多遍渲染的方法。深度剥离的每次渲染都需要一个深度缓冲，一个 Shadow Map 纹理和一个颜色缓冲，算法流程如下：</p>
<ul>
<li>首先使用深度缓冲正常渲染，就可以得到离我们最近的顶点及其深度值，同时将所有深度值拷贝到 Shadow Map 纹理中</li>
<li>第二次渲染打开深度纹理的比较功能，使得深度值比较大的颜色通过测试，这样就把所有深度值小于前一次渲染的顶点全部剥离掉，剩下的顶点都是比上一次渲染离我们更远的顶点，再加上深度缓冲本身的取最小深度的功能，就可以得到比上一次渲染离我们更远的顶点中离我们最近的顶点的颜色</li>
<li>重复第二步操作，就把所有顶点颜色按照深度一层一层剥离出来，最后按照从后往前的顺序进行渲染，这样就可以得到正确的结果了。</li>
</ul>
<p>这种方法与渲染物体的顺序无关，并且得到的结果保证正确，但缺点也很明显，需要剥离 N 次才能完成，就需要 N 个 Pass，N 是深度复杂度，因此性能是严重的瓶颈，另外如何确定 N 也是个问题。</p>
<h3 id="5-伽马校正"><a href="#5-伽马校正" class="headerlink" title="5 伽马校正"></a>5 伽马校正</h3><p>查看之前笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/">【RayTracer】（四）漫反射材质</a>中的第三部分。</p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】BRDF总结</title>
    <url>/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中 BRDF 相关知识进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>BRDF 前置知识：数学、辐射度量学</li>
<li>BRDF 的定义、理解和性质</li>
<li>BRDF 模型分类</li>
<li>基于物理的 BRDF</li>
<li>BRDF 引申</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-BRDF-前置知识"><a href="#1-BRDF-前置知识" class="headerlink" title="1 BRDF 前置知识"></a>1 BRDF 前置知识</h3><p>BRDF 需要的前置数学和辐射度量学的相关内容，可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/18/20220318-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/">【计算机图形学】（十二）辐射度量学基础</a>，这里不再赘述。</p>
<h3 id="2-BRDF-的定义、理解和性质"><a href="#2-BRDF-的定义、理解和性质" class="headerlink" title="2 BRDF 的定义、理解和性质"></a>2 BRDF 的定义、理解和性质</h3><h4 id="2-1-BRDF-的定义"><a href="#2-1-BRDF-的定义" class="headerlink" title="2.1 BRDF 的定义"></a>2.1 BRDF 的定义</h4><p>BRDF 的定义可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a>第一部分。为了更进一步加深理解，这里再进行一个总结。</p>
<p>可以将给一个表面着色的过程，理解为给定入射的光线数量和方向，计算出指定方向的出射光亮度（radiance）。在计算机图形学领域，BRDF（Bidirectional Reflectance Distribution Function，译作双向反射分布函数）是一个用来描述表面如何反射光线的方程。顾名思义，BRDF 就是一个描述光如何从给定的两个方向（入射光方向 $l$ 和出射方向 $v$）在表面进行反射的函数。</p>
<p>BRDF 的精确定义是出射辐射率的微分（differential outgoing radiance）和入射辐照度的微分（differential incoming irradiance）之比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516100712194.png" alt="image-20220516100712194"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516100727310.png" alt="image-20220516100727310"></p>
<p>一个最常见的疑问是，BRDF 为什么要取这样的定义。BRDF 为什么被定义为辐射率（radiance）和辐照度（irradiance）之比，而不是 radiance 和  radiance 之比，或者 irradiance 和 irradiance 之比呢？</p>
<p>首先，我们分别重温它们的定义：</p>
<ul>
<li>辐照度（Irradiance，又译作辉度，辐射照度），表示单位时间内到达单位面积的辐射通量，也就是辐射通量对于面积的密度，通常用符号 $E$ 表示，单位 $W&#x2F;m^2$ ，瓦特每平方米。</li>
<li>辐射率（Radiance，又译作光亮度），表示每单位立体角每单位投影面积的辐射通量，通常用符号 $L$ 表示,单位是 $W·sr^{-1}·m^{-2}$，瓦特每球面弧度每平方米。</li>
</ul>
<p>那么关于这个问题，我们可以这样理解：因为照射到入射点的不同方向的光，都可能从指定的反射方向出射，所以当考虑入射时，需要对面积进行积分。而辐照度 irradiance 正好表示单位时间内到达单位面积的辐射通量。所以 BRDF 函数，选取入射时的辐照度 Irradiance，和出射时的辐射率 Radiance，可以简单明了地描述出<strong>入射光线经过某个表面反射后如何在各个出射方向上分布</strong>。而直观来说，<strong>BRDF 的值给定了入射方向和出射方向能量的相对量</strong>。</p>
<h4 id="2-2-BRDF-的非微分形式"><a href="#2-2-BRDF-的非微分形式" class="headerlink" title="2.2 BRDF 的非微分形式"></a>2.2 BRDF 的非微分形式</h4><p>当光源类型不是面光源，而是诸如点光源或方向光源时，BRDF 定义可以用非微分形式表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516101214326.png" alt="image-20220516101214326"></p>
<p>其中：</p>
<ul>
<li>$E(l)$ 是光源从入射方向 $l$ 投影到平面法线方向的光的辐照度（irradiance）</li>
<li>$L_o(v)$ 是在视线 $v$ 的方向上产生的出射辐射率（radiance）</li>
</ul>
<h4 id="2-3-BRDF-与着色方程"><a href="#2-3-BRDF-与着色方程" class="headerlink" title="2.3 BRDF 与着色方程"></a>2.3 BRDF 与着色方程</h4><p>根据 BRDF 定义，可以很容易写出用 n 个非面光源来拟合一般的着色方程：<br>$$<br>L_o(v) &#x3D; \sum_{k&#x3D;1}^{n} f(l_k, v) \otimes E_{L_k}cos\theta_{i_k}<br>$$<br>其中，k 是每个非面光源编号，符号 $\otimes$ 表示分段向量乘法，$E_{L_k}$ 表示着色点接收到的第 k 个非面光源入射的光的能量，即辉度（irradiance），因为 BRDF 和辉度都是 RGB 向量，所以需要对应的进行向量乘法再累加起来。</p>
<p>同理可以得到对于面光源的积分形式的着色方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516102543469.png" alt="image-20220516102543469"></p>
<p>含义同上，只是将累加变成了各个方向的积分。这在之前的笔记中有详细解释，这里不再赘述。</p>
<p>考虑到入射和出射方向都拥有两个自由度（通常参数化是使用两个角度：相对于表面法线的仰角 $\theta$ 和关于法线的旋转角度 $\phi$），一般情况下，BRDF 是拥有四个标量变量的函数。特别地，各向同性 BRDF（Isotropic BRDF）是一个重要的特殊情况，这样的 BRDF 在入射和出射方向围绕表面法线变化（保持相同的相对夹角）时保持不变。所以，各向同性 BRDF 是关于三个标量的函数。</p>
<h4 id="2-4-BRDF-可视化"><a href="#2-4-BRDF-可视化" class="headerlink" title="2.4 BRDF 可视化"></a>2.4 BRDF 可视化</h4><p>一种理解 BRDF 的方法就是在输入方向保持恒定的情况下对它进行可视化表示，如下图。对于给定方向的入射光来说，图中显示了出射光的能力分布：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516103729812.png" alt="image-20220516103729812"></p>
<p>在交点附近球形部分是漫反射分量，因此出射光来任何方向上的反射概率相等。椭圆部分是一个反射波瓣（Reflectance Lobe）。它形成了镜面分量。显然，这些波瓣位于入射光的反射方向上，波瓣厚度对应反射的模糊性。根据互易原理，可以将这些相同的可视化形成认为是每个不同入射光方向对单个出射方向的贡献量大小。</p>
<h4 id="2-5-BRDF-的性质"><a href="#2-5-BRDF-的性质" class="headerlink" title="2.5 BRDF 的性质"></a>2.5 BRDF 的性质</h4><p>BRDF 的性质包括：非负性、可逆性、线性、能量守恒，具体可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/">【计算机图形学】（十四）材质</a>的第七部分。</p>
<h3 id="3-BRDF-的模型分类"><a href="#3-BRDF-的模型分类" class="headerlink" title="3 BRDF 的模型分类"></a>3 BRDF 的模型分类</h3><p>BRDF 模型可以分为如下几类：</p>
<ul>
<li><strong>经验模型（Empirical Models）</strong>：使用基于实验提出的公式对 BRDF 做快速估计</li>
<li><strong>数据驱动的模型（Data-driven Models）</strong>：采集真实材质表面在不同光照角度和观察角将 BRDF 按照实测数据建立查找表，记录在数据库中，以便于快速的查找和计算</li>
<li><strong>基于物理的模型（Physical-based Models）</strong>：根据物体表面材料的几何以及光学属性建立反射方程，从而计算 BRDF，实现极具真实感的渲染效果。</li>
</ul>
<h4 id="3-1-BRDF-经验模型"><a href="#3-1-BRDF-经验模型" class="headerlink" title="3.1 BRDF 经验模型"></a>3.1 BRDF 经验模型</h4><p>关于  BRDF 的经验模型，有如下几个要点：</p>
<ul>
<li>经验模型提供简洁的公式以便于反射光线的快速计算</li>
<li>经验模型不考虑材质特性，仅仅提供一个反射光的粗糙近似</li>
<li>经验模型不一定满足物理定律，比如可逆性或能量守恒定律</li>
<li>经验模型因为其简洁和高效性被广泛运用</li>
</ul>
<p>常见的 BRDF 经验模型有：</p>
<ul>
<li>Lambert 漫反射模型</li>
<li>Phong 模型</li>
<li>Blinn-Phong 模型</li>
</ul>
<h4 id="3-2-数据驱动的-BRDF-模型"><a href="#3-2-数据驱动的-BRDF-模型" class="headerlink" title="3.2 数据驱动的 BRDF 模型"></a>3.2 数据驱动的 BRDF 模型</h4><p>数据驱动的 BRDF 模型可以理解为，度量一个大的 BRDF 材质集合，并将其记录为高维向量，利用降维的方法从这些数据中计算出一个低维模型，这样基于查表的方式，可以直接找到渲染结果，省去大量的实时计算。</p>
<p>需要注意的是，由于这些数据由于采集自真实材质，即便渲染出来的结果很真实，但缺点是没有可供调整效果的参数，无法基于这些数据修改成想要的效果，另外部分极端角度由于仪器限制，无法获取到数据，而且采样点密集，数据量非常庞大，所以并不适合游戏等实时领域，一般可用在电影等离线渲染领域，也可以用来做图形学研究，衡量其他模型的真实程度。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516104422175.png" alt="image-20220516104422175"></p>
<h4 id="3-3-基于物理的-BRDF-模型"><a href="#3-3-基于物理的-BRDF-模型" class="headerlink" title="3.3 基于物理的 BRDF 模型"></a>3.3 基于物理的 BRDF 模型</h4><p><strong>基于物理的渲染 (PBR, Physically-based rendering)</strong> 是计算机图形学中用数学建模的方式模拟物体表面各种材质散射光线的属性从而渲染照片真实图片的技术，是近年来是实时渲染领域的大趋势。<br>基于物理的 BRDF 模型通过包含材质的各种几何及光学性质来尽可能精确的近似现实世界中的材料。<strong>而一个基于物理的 BRDF 要必须满足至少如下两条 BRDF 的特性：能量守恒、亥姆霍兹光路可逆性（Helmholtz Recoprpcity Rule）。</strong></p>
<p>常见的基于物理的  BRDF 模型有：</p>
<ul>
<li>Cook-Torrance BRDF 模型</li>
<li>Ward BRDF 模型</li>
</ul>
<p>下文将先介绍基于物理的 BRDF 常常用到到的菲涅尔反射，次表面散射和微平面理论等理论，然后分别概括这两种基于物理的 BRDF 模型。</p>
<h3 id="4-基于物理的-BRDF"><a href="#4-基于物理的-BRDF" class="headerlink" title="4 基于物理的 BRDF"></a>4 基于物理的 BRDF</h3><h4 id="4-1-前置知识"><a href="#4-1-前置知识" class="headerlink" title="4.1 前置知识"></a>4.1 前置知识</h4><p>前置知识包含次表面散射、菲涅尔项和微表面理论，具体可以参考之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/24/20220324-%E6%9D%90%E8%B4%A8/">【计算机图形学】（十四）材质的</a>第四、五部分。这里挑重点进行补充和总结。</p>
<p>菲涅耳方程（Fresnel equations）是一组用于描述光在两种不同折射率的介质中传播时的反射和折射的光学方程。方程中所描述的反射被称作“菲涅耳反射”。菲涅尔反射（Fresnel Reflectance）或者菲涅尔效果（Fresnel Effect），即当光入射到折射率不同的两个材质的分界面时，一部分光会被反射，而我们所看到的光线会根据我们的观察角度以不同强度反射的现象。菲涅尔反射能够真实地模拟真实世界中的反射。在真实世界中，除了金属之外，其它物质均有不同程度的菲涅尔反射效果。</p>
<p>简单来说，视线垂直于表面时，反射较弱，而当视线并非垂直表面时，夹角越小，反射越明显。对于粗糙表面来说，在接近平行方向的高光反射也会增强但不够达到 100% 的强度。为何如此是因为影响菲涅尔效应的关键参数在于每个微平面的法向量和入射光线的角度，而不是宏观平面的法向量和入射光线的角度。因此我们在宏观层面看到的实际上是微平面的菲涅尔效应的一个平均结果。</p>
<p>根据菲涅尔反射，若你看向一个圆球，那么圆球中心的反射会较弱，而靠近边缘是反射会较强，如下图所示。另外需注意，这种关系也受折射率影响。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516105824543.png" alt="image-20220516105824543"></p>
<p>微表面理论假设表面是由不同方向的微小细节表面，也就是微平面（microfacets）组成。每一个微小的平面都会根据它的法线方向在一个方向上反射光线。表面法线朝向光源方向和视线方向中间的微表面会反射可见光。然而，不是所有的表面法线和半角法线（half normal）相等的微表面都会反射光线，因为其中有些会被遮挡，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516105922147.png" alt="image-20220516105922147"></p>
<p>我们用法线分布函数（Normal Distribution Function，简写为 NDF）—— D(h) 来描述组成表面一点的所有微表面的法线分布概率。可以这样理解：向 NDF 输入一个朝向 h，NDF 会返回朝向是 h 的微表面数占微表面总数的比例，比如有 8% 的微表面朝向是 h，那么就有 8% 的微表面可能将光线反射到观察方向，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516110118379.png" alt="image-20220516110118379"></p>
<p>仅红色微平面的表面法线和半程向量 h 对齐，能参与从入射光线方向到视线方向的光线反射。</p>
<p>NDF 的定义公式为：<br>$$<br>D(h) &#x3D; \frac{\alpha^2}{\pi((n·h)^2(\alpha^2-1)+1)^2}<br>$$<br>在微观层面上不规则的表面会造成光的漫反射。例如，模糊的反射是由于光线的散射造成的。而反射的光线并不均匀，因此我们得到的高光反射是模糊的，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516110240348.png" alt="image-20220516110240348"></p>
<h4 id="4-2-Cook-Torrance-BRDF-模型"><a href="#4-2-Cook-Torrance-BRDF-模型" class="headerlink" title="4.2 Cook-Torrance BRDF 模型"></a>4.2 Cook-Torrance BRDF 模型</h4><p>Cook-Torrance 模型作为图形学中最早的基于物理的 BRDF 模型，由 Cook 和 Torrance 提出，是 Torrance-Sparrow 模型的一个应用版本。现今，Cook-Torrance 模型已经成为基于物理着色的标准模型之一。Cook-Torrance 模型将物理学中的菲涅尔反射引入了图形学，实现了比较逼真的效果。</p>
<p>Cook-Torrance 微平面着色模型（Cook-Torrance microfacet specular shading model），即 Microfacet Specular BRDF，定义为：<br>$$<br>f(l,v) &#x3D; \frac{F(l,h)G(l,v,h)D(h)}{4(n·h)(n·v)}<br>$$<br>其中：</p>
<ul>
<li>$F(l,h)$ 为菲涅尔反射函数，表示根据入射方向和观察方向，能够参与光的反射的微表面有多少光会被反射</li>
<li>$G(l,v,h)$ 为阴影遮罩函数（Geometry Factor，几何因子），即未被 shadow 或 mask 的比例，因为微表面凹凸不平，那么当入射光线贴着表面入射时，表面上就会有一部分微表面被其他微表面遮挡住而产生阴影，类似于环境光遮蔽，G 就是用来描述法线方向是半程向量的微表面中有多少微表面会因为互相遮挡而不被看到</li>
<li>$D(h)$ 是法线分布函数，即法线和半程向量一致的微表面的比例，表示有多少微表面会被看到，只有微表面的法线方向在光线入射方向和观察方向的半程向量方向才会被看到</li>
</ul>
<h4 id="4-3-Ward-BRDF-模型"><a href="#4-3-Ward-BRDF-模型" class="headerlink" title="4.3 Ward BRDF 模型"></a>4.3 Ward BRDF 模型</h4><p>一般情况下，我们可以将 BRDF 分为两类：</p>
<ul>
<li>各项同性（Isotropic）的 BRDF：反射不受与给定表面法向夹角的约束，随机表面微结构</li>
<li>各向异性（Anisotropic）的 BRDF：反射比随着与某个给定的表面法向之间的夹角而变化，图案的表面微结构，包括金属丝，绸缎，毛发等</li>
</ul>
<p>Phong 和 Cook-Torrance BRDF 模型都不能处理各项异性的效果，Ward 模型却可以。</p>
<p>Ward 模型介绍了更一般的表面法向表达方式：通过椭圆体（ellipsoids）这种允许各向异性反射的形式来表达。然而，由于没有考虑菲涅耳因子（Fresnel factor）和几何衰减因子（geometric attenuation factor），该模型更像是一种经验模型，但还是属于基于物理的 BRDF 模型。各向同性的 Ward 模型定义为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111305718.png" alt="image-20220516111305718"></p>
<h3 id="5-BRDF-引申"><a href="#5-BRDF-引申" class="headerlink" title="5 BRDF 引申"></a>5 BRDF 引申</h3><p>有不少与  BRDF 类似的函数：</p>
<ul>
<li>BSSRDF：Bidirectional Surface Scattering Reflectance Distribution，双向表面散反射分布函数</li>
<li>SBRDF(SVBRDF): spatially varying BRDF(spatial BRDF)，空间 BRDF</li>
<li>BTDF：Bidirectional Transmittance Distribution Function，双向透射分布函数</li>
<li>BSDF : Bidirectional Scattering Distribution Function，双向散射分布函数</li>
</ul>
<h4 id="5-1-BSSRDF"><a href="#5-1-BSSRDF" class="headerlink" title="5.1 BSSRDF"></a>5.1 BSSRDF</h4><p>BRDF 只是更一般方程的一种近似，这个方程就是 BSSRDF（Bidirectional scattering-surface reflectance distribution function，双向表面散反射分布函数）。BSSRDF 描述了出射辐射率与入射通量之间的关系，BSSRDF 函数通过把<strong>入射和出射位置作为函数的输入</strong>，描述了沿入射方向从物体表面的一点到另外一点，最后顺着出射方向出去的光线的相对量。注意，这个函数还考虑了物体表面的一点到另外一点，顺着出射方向出去的光线相对量，即光线从一点进入，并在内部发生了各种次表面散射，再从另一点出去，而 BRDF 只考虑了表面上的同一点。这个函数还考虑了物体表面不一致的情况，因为随着位置的变化，反射系数也会发生变化。在实时绘制中，物体表面上的位置可以用来获取颜色纹理、光泽度，以及凹凸纹理图等信息。</p>
<p>下图对比了 BRDF（上） 和 BSSRDF（下） 的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111833838.png" alt="image-20220516111833838"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/image-20220516111851009.png" alt="image-20220516111851009"></p>
<h4 id="5-2-SBRDF-SVBRDF"><a href="#5-2-SBRDF-SVBRDF" class="headerlink" title="5.2 SBRDF (SVBRDF)"></a>5.2 SBRDF (SVBRDF)</h4><p>一个捕获基于空间位置 BRDF 变化的函数被称为空间变化的 BRDF（Spatially Varying BRDF，SVBRDF）或称空间 BRDF，空间双向反射分布函数（Spatial BRDF，SBRDF）。</p>
<h4 id="5-3-BTDF-与-BSDF"><a href="#5-3-BTDF-与-BSDF" class="headerlink" title="5.3 BTDF 与 BSDF"></a>5.3 BTDF 与 BSDF</h4><p>即使一般的 BSSRDF 函数，无论其多么复杂，仍然忽略了现实世界中非常重要的一些变量，比如说光的偏振。此外，也没有处理穿过物体表面的光线传播，只是对反射情况进行了处理。为了处理光线传播的问题，对物体表面定义了两个 BRDF 和两个 BTDF（T 表示传播 “Transmittance”），每侧各有一个，这样就组成了 BSDF（S 表示散射“Scattering”）。</p>
<p>而在实践中，这些更复杂的函数很少使用，BRDF 和 SVBRDF 足以胜任一般情况下表面渲染的效果。</p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】全局光照总结</title>
    <url>/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中全局光照相关知识进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>全局光照概述</li>
<li>光线投射、光线追踪和路径追踪的区别</li>
<li>环境光遮蔽</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-全局光照"><a href="#1-全局光照" class="headerlink" title="1 全局光照"></a>1 全局光照</h3><p>全局光照 (Global Illumination，GI)，是指既考虑场景中直接来自光源的光照（Direct Light）又考虑经过场景中其他物体反射后的光照（Indirect Light）的一种渲染技术。使用全局光照能够有效地增强场景的真实感。<br>可以理解为：全局光照    &#x3D;  直接光照(Direct Light) +  间接光照(Indirect Light)</p>
<p>虽说实际应用中只有漫反射全局照明的模拟算法被称为全局照明算法，但其实理论上说反射、折射、阴影都属于全局光照的范畴，因为模拟它们的时候不仅仅要考虑光源对物体的直接作用还要考虑物体与物体之间的相互作用。也是因为，镜面反射、折射、阴影一般不需要进行复杂的光照方程求解，也不需要进行迭代的计算。因此，这些部分的算法已经十分高效，甚至可以做到实时。不同于镜面反射，光的漫反射表面反弹时的方向是近似“随机”，因此不能用简单的光线跟踪得到反射的结果，往往需要利用多种方法进行多次迭代，直到光能分布达到一个基本平衡的状态。</p>
<p>经过几十年的发展，全局光照现今已有多种实现方向，常见的全局光照主要流派列举如下：</p>
<ul>
<li>Ray tracing  光线追踪</li>
<li>Path tracing  路径追踪</li>
<li>Photon mapping  光子映射</li>
<li>Point Based Global Illumination  基于点的全局光照</li>
<li>Radiosity  辐射度</li>
<li>Metropolis light transport  梅特波利斯光照传输</li>
<li>Spherical harmonic lighting  球谐光照</li>
<li>Ambient occlusion  环境光遮蔽</li>
<li>Voxel-based Global Illumination  基于体素的全局光照</li>
<li>Light Propagation Volumes Global Illumination</li>
<li>Deferred Radiance Transfer Global Illumination</li>
<li>Deep G-Buffer based Global Illumination</li>
</ul>
<p>而其中的每种流派，又可以划分为 N 种改进和衍生算法。<br>如光线追踪（Ray Tracing）派系，其实就是一个框架，符合条件的都可称为光线追踪，其又分为递归式光线追踪（Whitted-style Ray Tracing），分布式光线追踪（Distribution Ray Tracing），蒙特卡洛光线追踪（Monte Carlo Ray Tracing）等。<br>而路径追踪（Path tracing）派系，又分为蒙特卡洛路径追踪（Monte Carlo Path Tracing），双向路径追踪（Bidirectional Path Tracing），能量再分配路径追踪（Energy Redistribution Path Tracing）等。<br>其中有些派系又相互关联，如路径追踪，就是基于光线追踪，结合了蒙特卡洛方法而成的一种新的派系。</p>
<h3 id="2-光线投射、光线追踪和路径追踪的区别"><a href="#2-光线投射、光线追踪和路径追踪的区别" class="headerlink" title="2 光线投射、光线追踪和路径追踪的区别"></a>2 光线投射、光线追踪和路径追踪的区别</h3><p>关于光线追踪和路径追踪可以查看之前的笔记：</p>
<ul>
<li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a></li>
<li><a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a></li>
<li><a href="https://lz328.github.io/LycTechStack.github.io/categories/RayTracer/">RayTracer 系列</a>前半部分实现的是光线追踪，后半部分加入蒙特卡洛后最终实现的是一个路径追踪器</li>
</ul>
<p>这里总结一下光线追踪、光线投射和路径追踪的区别：</p>
<ul>
<li><strong>光线追踪 Ray Tracing</strong>：这其实是个框架，而不是个方法。符合这个框架的都叫 ray tracing。这个框架就是从视点发射 ray，与物体相交就根据规则反射、折射或吸收。遇到光源或者走太远就停住。一般来说运算量不小。</li>
<li><strong>光线投射 Ray Casting</strong>：它就是 ray tracing 的第一步，发射光线，与物体相交。这个可以做的很快，也可以用来做遮挡、阴影等。</li>
<li><strong>路径追踪 Path Tracing</strong>：路径追踪就是 ray tracing + 蒙特卡洛法。在相交后会选一个随机方向继续跟踪，并根据 BRDF 计算颜色。运算量也不小。还有一些小分类，比如 Bidirectional path tracing。</li>
</ul>
<h3 id="3-环境光遮蔽"><a href="#3-环境光遮蔽" class="headerlink" title="3 环境光遮蔽"></a>3 环境光遮蔽</h3><p>环境光遮蔽（Ambient Occlusion，简称 AO）是全局光照明的一种近似替代品，可以产生重要的视觉明暗效果，通过描绘物体之间由于遮挡而产生的阴影， 能够更好地捕捉到场景中的细节，可以解决漏光，阴影漂浮等问题，改善场景中角落、锯齿、裂缝等细小物体阴影不清晰等问题，增强场景的深度和立体感。<br>可以说，环境光遮蔽在直观上给玩家的主要感觉体现在画面的明暗程度上，未开启环境光遮蔽特效的画面光照稍亮一些；而开启环境光遮蔽特效之后， 局部的细节画面尤其是暗部阴影会更加明显一些。</p>
<p>Ambient Occlusion 的细分种类有：</p>
<ul>
<li>SSAO-Screen space ambient occlusion</li>
<li>SSDO-Screen space directional occlusion</li>
<li>HDAO-High Definition Ambient Occlusion</li>
<li>HBAO+-Horizon Based Ambient Occlusion+</li>
<li>AAO-Alchemy Ambient Occlusion</li>
<li>ABAO-Angle Based Ambient Occlusion</li>
<li>PBAO</li>
<li>VXAO-Voxel Accelerated Ambient Occlusion</li>
</ul>
<p>一般而言，Ambient Occlusion 最常用方法是 SSAO，如 Unreal Engine 4 中的 AO，即是用 SSAO 实现。关于 SSAO 的原理可以查看这篇文章简要了解：<a href="https://zhuanlan.zhihu.com/p/46633896">环境遮罩之SSAO原理</a></p>
<p>总的来说 SSAO 是在屏幕空间进行的环境光遮蔽计算，以牺牲部分渲染效果和精度的代价，来换取高时效性，适用于游戏等实时渲染领域。</p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】非真实感渲染总结</title>
    <url>/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中的非真实感渲染技术进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>非真实感渲染（NPR）的基本思想</li>
<li>卡通渲染</li>
<li>轮廓描边方法总结</li>
<li>其他风格的 NPR 渲染技术</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-非真实感渲染概述"><a href="#1-非真实感渲染概述" class="headerlink" title="1 非真实感渲染概述"></a>1 非真实感渲染概述</h3><p>非真实感渲染（Non-Photorealistic Rendering，NPR），亦被称为风格化渲染（Stylistic Rendering），是致力于为数字艺术提供多种表达方式的一种渲染流派。与传统的追求照片真实感的真实感渲染（Photorealistic Rendering）计算机图形学不同，非真实感渲染旨在模拟艺术式的绘制风格，也用于尝试新的绘制风格。</p>
<p>NPR 的目的之一就是创建类似技术示意图、技术图纸相关的图像，而另一个应用领域便是对绘画风格和自然媒体（如铅笔、钢笔、墨水、木炭、水彩画等）进行模拟。这是一个涉及内容非常之多的应用领域，为了捕捉各种媒体的真实效果，人们已经提出了各种不同的算法。</p>
<h3 id="2-卡通渲染"><a href="#2-卡通渲染" class="headerlink" title="2 卡通渲染"></a>2 卡通渲染</h3><p>卡通渲染（Toon Rendering）作为一种特殊形式的非真实感渲染方法，近年来倍受关注。这种渲染风格能够给人以独特的感染力与<br>童趣。这种风格很受欢迎的原因之一是 McCloud 的经典著作《Understanding Comics》中所讲述到的“通过简化进行增强（Amplification Through Simplification）”。通过简化并剔除所包含的混杂部分，可以突出于主题相关的信息，而大部分观众都会认同那些用简单风格描绘出来的卡通形象。</p>
<p>可以将最<strong>卡通渲染基本的三个要素</strong>概括为：</p>
<ul>
<li>锐利的阴影（Sharp shadows）</li>
<li>少有或没有高亮的点（Little or no highlight）</li>
<li>对物体轮廓进行描边（Outline around objects）</li>
</ul>
<p>卡通渲染有许多不同的实现方法：</p>
<ul>
<li>对于含有纹理但没有光照的模型来说，可以通过对纹理进行量化来近似具有实心填充颜色的卡通风格。</li>
<li>对于明暗处理，有两种最为常见的方法，一种是用实心颜色填充多边形区域。但这种方式实用价值不大。另一种是使用 2-tone 方法来表示光照效果和阴影区域。也称为硬着色方法（Hard Shading），可以通过将传统光照方程元素重新映射到不同的调色板上来实现。此外，一般用黑色来绘制图形的轮廓，可以达到增强卡通视觉效果的目的。</li>
</ul>
<p>具体的着色方法，可以理解为在 Fragment shader 中测试每个像素漫反射 diffuse 中的 NdotL 值，让漫反射形成一个阶梯函数，不同的 NdotL 区域对应不同的颜色。下图显示了不同的漫反射强度值的着色部分阶梯指定了不同的像素颜色。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518150810699.png" alt="image-20220518150810699"></p>
<p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中实现了一个简单的 NPR 渲染。</p>
<h3 id="3-轮廓描边方法总结"><a href="#3-轮廓描边方法总结" class="headerlink" title="3 轮廓描边方法总结"></a>3 轮廓描边方法总结</h3><p>轮廓描边的渲染方法可以分为以下五种：</p>
<ul>
<li>基于视点方向的描边</li>
<li>基于过程几何方法的描边</li>
<li>基于图像处理的描边</li>
<li>基于轮廓边缘检测的描边</li>
<li>混和轮廓描边</li>
</ul>
<h4 id="3-1-基于视点方向的描边"><a href="#3-1-基于视点方向的描边" class="headerlink" title="3.1 基于视点方向的描边"></a>3.1 基于视点方向的描边</h4><p>基于视点方向的描边方法，即表面角描边（Surface Angle Silhouetting），其基本思想是使用视点方向（view point）和表面法线（surface normal）之间的点乘结果得到轮廓线信息。如果此点乘结果接近于零，那么可以断定这个表面极大概率是侧向（Edge-on）的视线方向，而我们就将其视做轮廓边缘，进行描边。在实际应用中，通常使用一张一维纹理，也就是使用视角方向与顶点法向的点乘对该纹理进行采样。<br>需要注意，这种技术仅适用于一些特定的模型，这些模型必须保证法线与轮廓边缘之间存在一定关系。诸如立方体这样的模型，此方法并不太适用，因为往往无法得到轮廓边缘。但我们可以通过显式地绘制出折缝边缘，来正确地表现出这类比较明显的特征。</p>
<h4 id="3-2-基于过程几何方法的描边"><a href="#3-2-基于过程几何方法的描边" class="headerlink" title="3.2 基于过程几何方法的描边"></a>3.2 基于过程几何方法的描边</h4><p>基于过程几何方法生成的描边，即过程几何描边（Procedural Geometry Silhouetting），基本思想是先渲染正向表面（frontfaces），再渲染背向表面（backfaces），从而使得轮廓边缘可见，达到描边的目的。</p>
<p>有多种方法用来渲染背向表面，且各有优缺点。但它们都是先渲染正向表面，然后打开正向表面裁剪（culling）开关，同时关闭背向裁剪开关。这样这个 pass 中的渲染结果便只会显示出背向表面。</p>
<p>一种基于过程几何方法生成的描边的方法是仅仅渲染出背向表面的边界线（而不是面），使用偏置（Biasing）或者其他技术来确保这些线条恰好位于正向表面之前。这样就可以将除轮廓边缘之外的其他所有线条全部隐藏起来。这种方法非常适合单像素宽的线条，但如果线条的宽度超过这个值，那么通常会出现无法连接独立线段的情况，从而造成明显的缝隙。</p>
<p>另一种渲染较宽描边线条的方法是直接将背面表面本身渲染成黑色。但没有任何偏置操作，背向表面就会保持不可见，所以需要做的就是通过偏置将这些背向表面沿屏幕 Z 方向向前移动，这样，便只有背向表面的三角形边缘是可见的，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518151628850.png" alt="image-20220518151628850"></p>
<h4 id="3-3-基于图像处理的描边"><a href="#3-3-基于图像处理的描边" class="headerlink" title="3.3 基于图像处理的描边"></a>3.3 基于图像处理的描边</h4><p>基于图像处理生成轮廓描边（Silhouetting by Image Processing），即通过在各种缓冲区上执行图像处理技术，来实现非真实渲染的方法。可以将其理解为一种后处理操作。通过寻找相邻 Z 缓冲数值的不连续性，就可以确定大多数轮廓线的位置。同样，借助邻接表面法线向量的不连续性，可以确定出分界线（往往也是轮廓线）边缘的位置。此外，利用环境色对场景进行绘制，也可以用来检测前两种方法可能会漏掉的边缘。</p>
<h4 id="3-4-基于轮廓边缘检测的描边"><a href="#3-4-基于轮廓边缘检测的描边" class="headerlink" title="3.4 基于轮廓边缘检测的描边"></a>3.4 基于轮廓边缘检测的描边</h4><p>可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的具体介绍。</p>
<h4 id="3-5-混合轮廓描边"><a href="#3-5-混合轮廓描边" class="headerlink" title="3.5 混合轮廓描边"></a>3.5 混合轮廓描边</h4><p>混和轮廓描边（Hybrid Silhouetting），即结合了图像处理方法和几何要素方法，来渲染轮廓的方法。<br>这种方法的具体思想是：首先，找到一系列轮廓边缘的列表。其次，渲染出所有物体的三角形和轮廓边缘，同时为他们指定一个不同的 ID 值（也就是说，赋予不同的颜色）。接着读取该 ID 缓冲器并从中判断出可见的轮廓边缘，随之对这些可见线段进行重叠检测，并将它们连接起来形成平滑的笔划路径。最后就可以对这些重建起来的路径进行风格化笔划渲染，其中，这些笔划本身可以用很多方法来进行风格化处理，包括变细、火焰、摆动、淡化等效果，同时还有深度和距离信息。如下图是使用混合轮廓描边方法生成的图像，其中可以将找到的轮廓边缘连接起来作为笔划进行渲染：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152106468.png" alt="image-20220518152106468"></p>
<h3 id="4-其他风格的-NPR-技术"><a href="#4-其他风格的-NPR-技术" class="headerlink" title="4 其他风格的 NPR 技术"></a>4 其他风格的 NPR 技术</h3><p>除了卡通渲染这种比较受欢迎的模拟风格之外，还存在其他各式各样的风格。NPR 效果涵盖的范围非常广泛，RTR3 中主要谈了 3 种不同的其他风格的 NPR 渲染技术：</p>
<ul>
<li>纹理调色板（Palette of Textures）</li>
<li>色调艺术图（Tonal Art Maps，TAM）</li>
<li>嫁接（Graftals）</li>
</ul>
<h4 id="4-1-纹理调色板（Palette-of-Textures）"><a href="#4-1-纹理调色板（Palette-of-Textures）" class="headerlink" title="4.1 纹理调色板（Palette of Textures）"></a>4.1 纹理调色板（Palette of Textures）</h4><p>纹理调色板（palette of textures）由 Lake 等人讨论提出，基本思想是通过漫反射着色项（diffuse shading term）的不同，来选择应用于物体表面上的不同纹理。随着漫反射项逐渐变暗，可以选用相应更暗的纹理，而为了能够产生手绘的效果，可以使用屏幕空间坐标来采样纹理。同时，为了增强绘制效果，可以在屏幕空间上的所有表面上运用纸纹理。随着物体的运动，他们就可以在纹理之间进行穿梭。原因在于这个纹理是在屏幕空间中实现的。此外，也可以在世界空间中运用这个纹理，这样就能够得到一个与屏幕空间完全不同的效果。</p>
<p>下图是使用纹理调色板、纸纹理，以及轮廓边缘绘制生成的一幅图像：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152605870.png" alt="image-20220518152605870"></p>
<h4 id="4-2-色调艺术图（Tonal-Art-Maps）"><a href="#4-2-色调艺术图（Tonal-Art-Maps）" class="headerlink" title="4.2 色调艺术图（Tonal Art Maps）"></a>4.2 色调艺术图（Tonal Art Maps）</h4><p>通过在纹理之间进行切换形成的硬着色效果和卡通着色效果之间的一种混合，Praun 等人提出了一种可以实时生成笔划纹理分级细化图的方法，并可以将其以平滑的方式运用到物体表面上。第一步是生成即时使用的纹理，称为色调艺术图（Tonal Art Maps，TAM）,主要思想是将笔划绘制为分级细分图层次。下图是使用 TAM 渲染的过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152848606.png" alt="image-20220518152848606"></p>
<p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a>中的素描风格就使用了简化的 TAM 算法。</p>
<h4 id="4-3-嫁接（Graftals）"><a href="#4-3-嫁接（Graftals）" class="headerlink" title="4.3  嫁接（Graftals）"></a>4.3  嫁接（Graftals）</h4><p>嫁接（Graftals）的基本思想，是将几何或者贴花纹理应用到物体表面，从而产生某种特殊效果。可以通过所需要的细节层次，物体表面相对视点的方位或者其他因素，对纹理进行控制。这种方法可以用来模拟钢笔或者画刷的笔刷，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518152954390.png" alt="image-20220518152954390"></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（一）环境配置</title>
    <url>/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>之前我们实现过一个光线追踪器，从这一节开始我们要实现一个运行在 CPU 上的简单的光栅化渲染器，并在实现过程中进一步理解渲染管线的流程和各种细节。首先从配置环境和熟悉 OpenGL 开始。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h3><p>我们使用 GLFW 和 GLAD 来显示最终渲染的图片，这些可以参照<a href="https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/#glfw">LearnOpenGL CN</a>上的教程来进行配置。</p>
<p>使用 GLM 作为数学库，下载地址：<a href="https://github.com/g-truc/glm/releases">Releases · g-truc&#x2F;glm · GitHub</a></p>
<p>也可以使用和光线追踪器中一样的 STB 图像库来输出图片。</p>
<h3 id="2-OpenGL-基础"><a href="#2-OpenGL-基础" class="headerlink" title="2 OpenGL 基础"></a>2 OpenGL 基础</h3><p>下面是一个简单的 OpenGL 程序，但展示了所有 OpenGL 程序的通用流程和框架，包含详细注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些回调函数</span></span><br><span class="line"><span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line"><span class="comment">// 这里我们在改变窗口大小的时候也改变视口大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测是否按下 ESC 键，如果按下则将WindowShouldClose属性设置为true，这样既可退出渲染循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像设置</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器代码，存放在字符串中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片元着色器代码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line"><span class="string">&quot;void main()\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line"><span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line"><span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW，并配置版本信息等</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 GLFW 创建一个窗口</span></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD 用来来管理OpenGL的函数指针，使其在不同版本不同硬件上能够正确运行</span></span><br><span class="line">    <span class="comment">// 因此在使用 OpenGL 函数前需要先初始化 GLAD</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并编译顶点着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="type">int</span> success;</span><br><span class="line">    <span class="type">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建并编译片元着色器代码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">    <span class="comment">// 检查编译错误</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将着色器代码链接为一个着色器程序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="built_in">glLinkProgram</span>(shaderProgram);</span><br><span class="line">    <span class="comment">// 检查链接错误</span></span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ；链接完成后即可删除着色器对象</span></span><br><span class="line">    <span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">    <span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个三角形</span></span><br><span class="line">    <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点缓冲区VBA和顶点数组缓冲区VAO</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VBO, VAO;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 绑定顶点数组缓冲</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="comment">// 绑定顶点缓冲，顶点缓冲是GL_ARRAY_BUFFER类型</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 将上面的顶点数据复制到顶点缓冲中</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 链接顶点属性，即告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除缓冲区绑定，非必要</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 是否按下ESC关闭窗口</span></span><br><span class="line">        <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置清空屏幕缓冲所用的颜色</span></span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 用设置的颜色清空颜色缓冲，可选的还有深度缓冲和模板缓冲</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用双缓冲渲染，屏幕显示前缓冲区，渲染在后缓冲进行，因此每一帧交换缓冲区</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行效果如图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/19/20220519-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20220519114457379.png" alt="image-20220519114457379"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（四）纹理</title>
    <url>/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>上一节中我们完成了三维物体的渲染，显示了一个立方体，这一节我们为立方体加上一个图片纹理变为一个木箱。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-OpenGL-中的纹理"><a href="#1-OpenGL-中的纹理" class="headerlink" title="1 OpenGL 中的纹理"></a>1 OpenGL 中的纹理</h3><p>首先来看 OpenGL 中如何使用纹理有关的操作，可以参考官方教程：[纹理 - LearnOpenGL CN](<a href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;06 Textures&#x2F;)</p>
<h3 id="2-实现纹理类"><a href="#2-实现纹理类" class="headerlink" title="2 实现纹理类"></a>2 实现纹理类</h3><p>然后我们自己手动实现一个简单的纹理类，纹理环绕方式使用 GL_REPEAT 的方式，即超过 1.0 的纹理坐标就直接重复，纹理过滤的方式采用最近邻方式，加载图片还是使用简单强大的 stbi 库，纹理类的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 图片纹理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEXTURE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXTURE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> channels;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>() : <span class="built_in">width</span>(<span class="number">-1</span>), <span class="built_in">height</span>(<span class="number">-1</span>), <span class="built_in">channels</span>(<span class="number">-1</span>), <span class="built_in">data</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> std::string&amp; Path) &#123;</span><br><span class="line">        <span class="built_in">LoadTexture</span>(Path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Texture</span>(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Texture&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Texture&amp; t) &#123;</span><br><span class="line">        width = t.width;</span><br><span class="line">        height = t.height;</span><br><span class="line">        channels = t.channels;</span><br><span class="line">        <span class="keyword">if</span> (t.data) &#123;</span><br><span class="line">            data = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(width * height * channels);</span><br><span class="line">            <span class="built_in">memcpy</span>(data, t.data, width * height * channels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LoadTexture</span><span class="params">(<span class="type">const</span> std::string&amp; Path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">            <span class="built_in">free</span>(data);</span><br><span class="line">        data = <span class="built_in">stbi_load</span>(Path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纹理采样，使用重复寻址方式,等同于OpenGL的GL_REPEAT</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">Sample2D</span><span class="params">(<span class="type">const</span> glm::vec2&amp; texcoord)</span> </span>&#123;</span><br><span class="line">		<span class="type">float</span> x = texcoord.x - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.x);</span><br><span class="line">		<span class="type">float</span> y = texcoord.y - (<span class="type">float</span>)<span class="built_in">floor</span>(texcoord.y);</span><br><span class="line">		x = x &lt; <span class="number">0</span> ? -x : x;</span><br><span class="line">		y = y &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetColor</span>(x * (width - <span class="number">1</span>), y * (height - <span class="number">1</span>)) / <span class="number">255.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取颜色，对不同通道纹理图片分别处理，以便于加载法线、高度纹理等</span></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width || y &lt; <span class="number">0</span> || y &gt;= height)</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">switch</span> (channels) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor1</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor2</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor3</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">GetColor4</span>(x, y);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = y * width + x;</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">2</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">3</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">glm::vec4 <span class="title">GetColor4</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xy = <span class="number">4</span> * (y * width + x);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(*(data + xy), *(data + xy + <span class="number">1</span>), *(data + xy + <span class="number">2</span>), *(data + xy + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改 Shader 类，加入纹理成员，并修改片元着色器，将颜色改为纹理采样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shader</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">        texture = <span class="keyword">new</span> <span class="built_in">Texture</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 ModelMatrix;</span><br><span class="line">    glm::mat4 ViewMatrix;</span><br><span class="line">    glm::mat4 ProjectMatrix;</span><br><span class="line">    Texture* texture;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">        V2F o;</span><br><span class="line">        <span class="comment">// 变换到世界空间</span></span><br><span class="line">        o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line">        <span class="comment">// 变换到裁剪空间</span></span><br><span class="line">        o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line">        <span class="comment">// 法线变换</span></span><br><span class="line">        o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">        o.texcoord = a2v.texcoord;</span><br><span class="line">        o.color = a2v.color;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 片元着色器</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (texture-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::vec4 color = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord);</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">        ModelMatrix = model;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">        ViewMatrix = view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">        ProjectMatrix = project;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTexture</span><span class="params">(std::string path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        texture-&gt;<span class="built_in">LoadTexture</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后在 Draw 类中加入纹理图片路径：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">        FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">        shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">        shader-&gt;<span class="built_in">setTexture</span>(TexturePath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;texture_box2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(0,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box.png" alt="texture_box"></p>
<h3 id="3-透视纹理映射"><a href="#3-透视纹理映射" class="headerlink" title="3 透视纹理映射"></a>3 透视纹理映射</h3><p>可以看出当立方体的面不正对我们的时候，纹理出现了变形。这是因为我们对顶点插值时使用的插值参数是通过顶点间的 x, y 坐标求出的，但是透视投影之后纹理坐标并不跟投影点 x , y 坐标线性相关。这种直接插值纹理坐标的方式被称为<strong>仿射映射</strong>，解决办法是做<strong>透视映射</strong>，具体可以查看<a href="https://blog.csdn.net/popy007/article/details/5570803">深入探索透视纹理映射</a>这篇文章。</p>
<p>总之实际的做法就是在透视除法时，将除了屏幕坐标之外的所有值都除以 w 值，然后再进行插值，这样就可以得到正确的纹理映射关系，最后在扫描线函数中，调用片元着色器之前再乘以 w 恢复即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录下原本的 w</span></span><br><span class="line">    v.w = v.windowPos.w;</span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他属性也要除以 w，以便于正确插值，之后在片元着色器之前再乘以原本的 w 恢复</span></span><br><span class="line">    v.worldPos /= v.w;</span><br><span class="line">    v.normal /= v.w;</span><br><span class="line">    v.texcoord /= v.w;</span><br><span class="line">    v.color /= v.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            v.worldPos *= v.w;</span><br><span class="line">            v.normal *= v.w;</span><br><span class="line">            v.texcoord *= v.w;</span><br><span class="line">            v.color *= v.w;</span><br><span class="line"></span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box2.png" alt="texture_box2"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/22/20220522-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%BA%B9%E7%90%86/texture_box3.png" alt="texture_box3"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（五）相机</title>
    <url>/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<p>上一节实现了纹理映射，但观察矩阵和投影矩阵目前还是在主函数中设定的，为此我们需要一个相机类来管理，同时方便之后一些算法的实现。</p>
<p><em><span id="more"></span></em></p>
<p>MVP 矩阵中， M 矩阵负责改变模型在世界空间的位置和姿态，V 矩阵需要相机位置和相机的三个向量（up、right、front）来确定，P 矩阵跟视场大小、宽高比和远近平面位置有关。因此相机类主要负责管理确定 V 和 P 矩阵的参数。</p>
<p>这里相机类的实现可以参考之前光线追踪器中的相机类，只需要给定相机的位置、lookat 位置和在世界空间的 up 方向就可以确定相机的三个向量 up、right 和 front；对于相机旋转，我们使用欧拉角，由于大部分第一人称游戏也不支持滚转角旋转，因此我们也只实现俯仰角和偏航角，具体计算方法也很简单，以（0, 0, -1）为默认观察方向：</p>
<ul>
<li>对于每一个 front 向量，将其投影到 XOZ  平面（即把 y 置 0 再单位化）</li>
<li>front 向量和投影向量的夹角即为俯仰角，需要注意俯仰角不能超过 90 度否则整个视野会倒过来</li>
<li>投影向量与（0, 0, -1）的夹角为偏航角</li>
</ul>
<p>由此我们可以写出相机类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CAMERA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Front;</span><br><span class="line">    glm::vec3 Up;</span><br><span class="line">    glm::vec3 Right;</span><br><span class="line">    glm::vec3 WorldUp;</span><br><span class="line">    <span class="comment">// 视场和宽高比</span></span><br><span class="line">    <span class="type">float</span> Fov;</span><br><span class="line">    <span class="type">float</span> Aspect;</span><br><span class="line">    <span class="comment">// 远近平面距离</span></span><br><span class="line">    <span class="type">float</span> Near;</span><br><span class="line">    <span class="type">float</span> Far;</span><br><span class="line">    <span class="comment">// 俯仰和偏航角</span></span><br><span class="line">    <span class="type">float</span> Pitch;</span><br><span class="line">    <span class="type">float</span> Yaw;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Camera</span>(</span><br><span class="line">        glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">        glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3 lookat = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">        <span class="type">float</span> fov = <span class="number">60.0f</span>,</span><br><span class="line">        <span class="type">int</span> w = <span class="number">800</span>,</span><br><span class="line">        <span class="type">int</span> h = <span class="number">600</span>,</span><br><span class="line">        <span class="type">float</span> n = <span class="number">0.3f</span>,</span><br><span class="line">        <span class="type">float</span> f = <span class="number">100</span></span><br><span class="line">    ) :</span><br><span class="line">        <span class="built_in">Position</span>(position), <span class="built_in">WorldUp</span>(up), <span class="built_in">Fov</span>(glm::<span class="built_in">radians</span>(fov)), <span class="built_in">Aspect</span>((<span class="type">float</span>)w / h), <span class="built_in">Pitch</span>(<span class="number">0</span>), <span class="built_in">Yaw</span>(<span class="number">0</span>), <span class="built_in">Near</span>(n), <span class="built_in">Far</span>(f)</span><br><span class="line">    &#123;</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(lookat - Position);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 Front 向量计算欧拉角</span></span><br><span class="line">        <span class="function">glm::vec3 <span class="title">WorldFront</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        glm::vec3 FrontXZ = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(Front.x, <span class="number">0</span>, Front.z));</span><br><span class="line">        <span class="type">float</span> yd = glm::<span class="built_in">dot</span>(WorldFront, FrontXZ);</span><br><span class="line">        <span class="type">float</span> pd = glm::<span class="built_in">dot</span>(Front, FrontXZ);</span><br><span class="line">        <span class="keyword">if</span> (yd &gt; <span class="number">1.0</span>)</span><br><span class="line">            yd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (yd &lt; <span class="number">-1</span>)</span><br><span class="line">            yd = <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &gt; <span class="number">1.0</span>)</span><br><span class="line">            pd = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pd &lt; <span class="number">-1</span>)</span><br><span class="line">            pd = <span class="number">-1.0</span>;</span><br><span class="line">        Yaw = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(yd));</span><br><span class="line">        Pitch = glm::<span class="built_in">degrees</span>(<span class="built_in">acos</span>(pd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">ViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetViewMatrix</span>(Position, Front, Right, Up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">PerspectiveMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPerspectiveMatrix</span>(Fov, Aspect, Near, Far);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateFov</span><span class="params">(<span class="type">float</span> fov = <span class="number">60.0f</span>)</span> </span>&#123;</span><br><span class="line">        Fov = glm::<span class="built_in">radians</span>(fov);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateAspect</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        Aspect = (<span class="type">float</span>)w / h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改俯仰角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotatePitch</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Pitch += angle;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &gt; <span class="number">89.0</span>)</span><br><span class="line">            Pitch = <span class="number">89.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Pitch &lt; <span class="number">-89.0</span>)</span><br><span class="line">            Pitch = <span class="number">-89.0</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更改偏航角，更改相机姿态后要重新计算三个向量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RotateYaw</span><span class="params">(<span class="type">float</span> angle)</span> </span>&#123;</span><br><span class="line">        Yaw += angle;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &gt; <span class="number">360</span>)</span><br><span class="line">            Yaw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Yaw &lt; <span class="number">0</span>)</span><br><span class="line">            Yaw = <span class="number">360</span>;</span><br><span class="line">        <span class="built_in">UpdateCameraVectors</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 更新相机三个向量，根据俯仰角和偏航角计算</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        glm::vec3 front;</span><br><span class="line">        front.x = -<span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        front.z = -<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">        Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">        Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));</span><br><span class="line">        Up = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>相机应该作为全局变量，以便于之后的裁剪等算法获取相机相关的参数，因此我们在 <code>Global.h</code> 中加入全局变量的定义，将渲染管线以及之后要实现的材质等也设置为全局对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">Camera* camera;</span><br><span class="line">Draw* dw;</span><br><span class="line">Material* currentMat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;camera.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setViewMatrix</span>(camera-&gt;<span class="built_in">ViewMatrix</span>());</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw-&gt;<span class="built_in">setProjectMatrix</span>(camera-&gt;<span class="built_in">PerspectiveMatrix</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">45.0</span>;</span><br><span class="line">    dw-&gt;<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制，渲染管线流程</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到和之前一样的结果说明正确：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/23/20220523-%E6%B8%B2%E6%9F%93%E5%99%A8-%E7%9B%B8%E6%9C%BA/camera.png" alt="camera"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（七）加载模型</title>
    <url>/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>上一节我们实现了各种剔除和裁剪算法，目的是在处理复杂模型和场景的时候也能够保证效率，避免无用计算。这一节我们来向场景中加载模型。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-模型、对象、网格的关系"><a href="#1-模型、对象、网格的关系" class="headerlink" title="1 模型、对象、网格的关系"></a>1 模型、对象、网格的关系</h3><p>在实现加载模型的功能之前，我们首先要了解模型由什么组成。一个模型（Model）包含多个对象（Object），每个对象拥有网格（Mesh）和材质（Material），网格存储了多边形的绘制信息，包括顶点位置、顶点法向、顶点纹理坐标，顶点索引；材质存储了光照和贴图信息，比如漫反射光颜色、镜面反射光颜色、镜面反射光泽度、纹理贴图信息等。所有这些数据都提供给 Shader 来使用，因此一个 Shader 需要绑定一个材质才能发挥作用。</p>
<h3 id="2-材质与对象类"><a href="#2-材质与对象类" class="headerlink" title="2 材质与对象类"></a>2 材质与对象类</h3><p>了解了这些关系后，我们开始实现相应的类。首先是材质类，最简单的材质包括漫反射颜色、镜面反射颜色、Glossy 扰动和一张主纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 材质类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Texture.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准光照材质包括</span></span><br><span class="line"><span class="comment">//漫反射颜色 镜面反射颜色 镜面反射强度</span></span><br><span class="line"><span class="comment">//纹理一张</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec4 Specular;</span><br><span class="line">    <span class="type">int</span> Gloss;</span><br><span class="line">    Texture* MainTex;</span><br><span class="line">    Shader* shader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Material</span>() :</span><br><span class="line">        <span class="built_in">Color</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Specular</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">        <span class="built_in">Gloss</span>(<span class="number">32</span>),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">Material</span>(<span class="type">const</span> glm::vec4&amp; color, <span class="type">const</span> glm::vec4&amp; specular, <span class="type">const</span> <span class="type">int</span>&amp; gloss) :</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Gloss</span>(gloss),</span><br><span class="line">        <span class="built_in">MainTex</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Material</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetShader</span><span class="params">(Shader* s)</span> </span>&#123;</span><br><span class="line">        shader = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTexture</span><span class="params">(Texture* t)</span> </span>&#123;</span><br><span class="line">        MainTex = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后是 Object 类，一个 Object 包含一个 Mesh 和一个 Material：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Object类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OBJECT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mesh mesh;</span><br><span class="line">    Material material;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Mesh&amp; m, <span class="type">const</span> Material&amp; mat) &#123;</span><br><span class="line">        mesh = m;</span><br><span class="line">        material = mat;</span><br><span class="line">    &#125;</span><br><span class="line">    Object&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Object&amp; obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        mesh = obj.mesh;</span><br><span class="line">        material = obj.material;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3 模型类"></a>3 模型类</h3><p>最后是模型类，模型类需要能够加载 obj 模型并解析，之前在图形学中我们了解过 obj 文件的格式，这里再复习一遍。</p>
<p>一个典型的 obj 文件使用记事本打开可以看到如下格式，这里使用我们项目中用到的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3ds Max Wavefront OBJ Exporter v0.97b - (c)2007 guruware</span><br><span class="line"># File Created: 04.08.2011 15:18:00</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object01</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">v  -7.0063 72.8042 6.8872</span><br><span class="line">v  -6.9854 72.8711 8.2541</span><br><span class="line">v  -7.8984 74.1601 6.7762</span><br><span class="line">......</span><br><span class="line"># 65 vertices</span><br><span class="line"></span><br><span class="line">vn -0.8222 -0.5678 0.0404</span><br><span class="line">vn -0.7979 -0.5926 0.1101</span><br><span class="line">vn -0.8362 -0.5469 0.0396</span><br><span class="line">......</span><br><span class="line"># 70 vertex normals</span><br><span class="line"></span><br><span class="line">vt 0.4465 -0.7212 0.0000</span><br><span class="line">vt 0.4014 -0.7905 0.0000</span><br><span class="line">vt 0.4932 -0.8096 0.0000</span><br><span class="line">......</span><br><span class="line"># 36 texture coords</span><br><span class="line"></span><br><span class="line">g Object01</span><br><span class="line">s 1</span><br><span class="line">f 1/1/1 2/2/2 3/3/3 </span><br><span class="line">s 2</span><br><span class="line">f 3/3/4 2/2/2 4/4/5 </span><br><span class="line">s 3</span><br><span class="line">f 5/5/6 2/2/2 1/1/1 </span><br><span class="line">......</span><br><span class="line"># 0 polygons - 104 triangles</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># object Object02</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>每一个 Object 下面都有 v、vn、vt 和 g、s、f 开头的数据，它们分别代表：</p>
<ul>
<li>v（vertex） ：后面记录了一个顶点坐标</li>
<li>vn（vertex normal）：后面记录了一个法线</li>
<li>vt（vertex texcood）：后面记录了一个纹理坐标</li>
<li>g（geometry）：代表下面将开始几何信息</li>
<li>s：后面跟图元编号</li>
<li>f（face）：后面后面记录了一个面的三个顶点所使用的顶点坐标、法线和纹理坐标（也可以是四个或者多个组成多边形）</li>
<li>5&#x2F;5&#x2F;6：表示该顶点使用第 5 个 v，第 5 个 vn，第 6 个 vt，这个索引是全局的</li>
</ul>
<p>于是我们可以实现模型 Model 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Model类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Object&gt; objects;</span><br><span class="line">    <span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Model</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> std::string&amp; path) &#123;</span><br><span class="line">        <span class="built_in">LoadObj</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Model</span>(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Model&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Model&amp; model) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;model == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        objects = model.objects;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetMaterial</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; id, <span class="type">const</span> Material&amp; m)</span> </span>&#123;</span><br><span class="line">        objects[id].material = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadObj</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">in</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!in) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Open Obj File Error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;glm::vec3&gt; vertexs;</span><br><span class="line">        std::vector&lt;glm::vec3&gt; normals;</span><br><span class="line">        std::vector&lt;glm::vec2&gt; texcoords;</span><br><span class="line"></span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> currentObjectNums = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            std::<span class="built_in">getline</span>(in, line);</span><br><span class="line">            <span class="comment">// 顶点数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;v &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    currentObjectNums++;</span><br><span class="line">                    Object o;</span><br><span class="line">                    objects.<span class="built_in">push_back</span>(o);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 v;</span><br><span class="line">                iss &gt;&gt; v.x;</span><br><span class="line">                iss &gt;&gt; v.y;</span><br><span class="line">                iss &gt;&gt; v.z;</span><br><span class="line">                vertexs.<span class="built_in">push_back</span>(v);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 法线数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vn &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vn;</span><br><span class="line">                iss &gt;&gt; vn.x;</span><br><span class="line">                iss &gt;&gt; vn.y;</span><br><span class="line">                iss &gt;&gt; vn.z;</span><br><span class="line">                normals.<span class="built_in">push_back</span>(vn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 纹理坐标</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;vt &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">3</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                glm::vec3 vt;</span><br><span class="line">                iss &gt;&gt; vt.x;</span><br><span class="line">                iss &gt;&gt; vt.y;</span><br><span class="line">                vt.y = <span class="number">1</span> - vt.y;</span><br><span class="line">                <span class="comment">// 纹理坐标z为0</span></span><br><span class="line">                iss &gt;&gt; vt.z;</span><br><span class="line">                texcoords.<span class="built_in">push_back</span>(glm::<span class="built_in">vec2</span>(vt.x, vt.y));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 图元数据</span></span><br><span class="line">            <span class="keyword">if</span> (!line.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;f &quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                line = line.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">                <span class="type">char</span> bar;</span><br><span class="line">                <span class="type">int</span> vIndex, vtIndex, vnIndex;</span><br><span class="line">                <span class="comment">//解析每个顶点数据 eg：1/1/1</span></span><br><span class="line">                <span class="type">int</span> offset = objects[currentObjectNums].mesh.VBO.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    iss &gt;&gt; vIndex &gt;&gt; bar &gt;&gt; vtIndex &gt;&gt; bar &gt;&gt; vnIndex;</span><br><span class="line">                    <span class="function">Vertex <span class="title">vertex</span><span class="params">(vertexs[vIndex - <span class="number">1</span>], glm::vec4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), texcoords[vtIndex - <span class="number">1</span>], normals[vnIndex - <span class="number">1</span>])</span></span>;</span><br><span class="line">                    objects[currentObjectNums].mesh.VBO.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">                    objects[currentObjectNums].mesh.EBO.<span class="built_in">push_back</span>(offset + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        in.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-绘制模型"><a href="#4-绘制模型" class="headerlink" title="4 绘制模型"></a>4 绘制模型</h3><p>接下来在我们原来的 <code>DarwMesh</code> 函数基础上，稍作修改实现绘制对象和绘制模型的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制一个模型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawModel</span><span class="params">(Model&amp; model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; model.objects.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">DrawObject</span>(model.objects[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawObject</span><span class="params">(Object&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currentMat = &amp;obj.material;</span><br><span class="line">    currentMat-&gt;shader-&gt;texture = currentMat-&gt;MainTex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj.mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = obj.mesh.VBO[obj.mesh.EBO[i]];</span><br><span class="line">        p2 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = obj.mesh.VBO[obj.mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = currentMat-&gt;shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>修改主函数，加载模型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string TEXTURE_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\Textures\\box.png&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;Model.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用标准Shader</span></span><br><span class="line">    Shader shader;</span><br><span class="line">    <span class="comment">// 加载模型</span></span><br><span class="line">    Material bodyMat;</span><br><span class="line">    bodyMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">bodyTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_body02.jpg&quot;</span>)</span></span>;</span><br><span class="line">    bodyMat.<span class="built_in">SetTexture</span>(&amp;bodyTexture);</span><br><span class="line"></span><br><span class="line">    Material faceMat;</span><br><span class="line">    faceMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">faceTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex002f_body01.jpg&quot;</span>)</span></span>;</span><br><span class="line">    faceMat.<span class="built_in">SetTexture</span>(&amp;faceTexture);</span><br><span class="line"></span><br><span class="line">    Material mouseMat;</span><br><span class="line">    mouseMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">mouseTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Texf_mouse.jpg&quot;</span>)</span></span>;</span><br><span class="line">    mouseMat.<span class="built_in">SetTexture</span>(&amp;mouseTexture);</span><br><span class="line"></span><br><span class="line">    Material eyeMat;</span><br><span class="line">    eyeMat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">eyeTexture</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\Tex001f_eye.jpg&quot;</span>)</span></span>;</span><br><span class="line">    eyeMat.<span class="built_in">SetTexture</span>(&amp;eyeTexture);</span><br><span class="line"></span><br><span class="line">    <span class="function">Model <span class="title">model</span><span class="params">(<span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Assets\\neptune\\neptune.obj&quot;</span>)</span></span>;</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">0</span>, mouseMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">1</span>, faceMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">2</span>, bodyMat);</span><br><span class="line">    model.<span class="built_in">SetMaterial</span>(<span class="number">3</span>, eyeMat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建箱子</span></span><br><span class="line">    Mesh box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    Material mat;</span><br><span class="line">    mat.<span class="built_in">SetShader</span>(&amp;shader);</span><br><span class="line">    <span class="function">Texture <span class="title">boxt</span><span class="params">(TEXTURE_PATH)</span></span>;</span><br><span class="line">    mat.<span class="built_in">SetTexture</span>(&amp;boxt);</span><br><span class="line">    <span class="function">Object <span class="title">obj</span><span class="params">(box, mat)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化相机</span></span><br><span class="line">    camera = <span class="keyword">new</span> <span class="built_in">Camera</span>(</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">5.0f</span>),    <span class="comment">// 相机位置</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),    <span class="comment">// 世界空间的up方向</span></span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">4.0f</span>),    <span class="comment">// 相机lookat</span></span><br><span class="line">        <span class="number">60.0f</span>,                            <span class="comment">// 垂直视场</span></span><br><span class="line">        SCR_WIDTH,                        <span class="comment">// 宽</span></span><br><span class="line">        SCR_HEIGHT,                        <span class="comment">// 高</span></span><br><span class="line">        <span class="number">0.3f</span>,                            <span class="comment">// near</span></span><br><span class="line">        <span class="number">100</span>                                <span class="comment">// far</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line">    <span class="comment">// 改变渲染模式，默认为纹理填充，改变后为只绘制边框</span></span><br><span class="line">    <span class="comment">//dw-&gt;ChangeRenderMode();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    ViewMatrix = camera-&gt;<span class="built_in">ViewMatrix</span>();</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    ProjectMatrix = camera-&gt;<span class="built_in">PerspectiveMatrix</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将箱子左移两单位</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 让箱子在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">0.0</span>;</span><br><span class="line">    ModelMatrix *= glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="comment">// 旋转后要更新法线</span></span><br><span class="line">    <span class="built_in">UpdateNormalMatrix</span>();</span><br><span class="line">    <span class="comment">// 绘制箱子</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawObject</span>(obj);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 因为模型太大，需要缩小100倍</span></span><br><span class="line">    ModelMatrix = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>));</span><br><span class="line">    <span class="comment">// 绘制模型</span></span><br><span class="line">    dw-&gt;<span class="built_in">DrawModel</span>(model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw-&gt;<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/Model1.png" alt="Model1"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（八）光源</title>
    <url>/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>到目前为止我们的渲染管线已经基本为完整了，从模型加载到顶点着色器，再经过裁剪到片元着色器，但在片元着色器中我们目前还只是输出顶点颜色或者纹理值，还没有加入光照计算，这一节我们就来加入光照的计算。最简单的 Blinn Phong 模型我们已经非常熟悉了，所以这一节的重点并不是光照的计算，而是了解三种光源是如何实现的。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-光源概述"><a href="#1-光源概述" class="headerlink" title="1 光源概述"></a>1 光源概述</h3><p>在 RTR 一书中，作者将光源分为三种，分别是：平行光（direction）、点光源（point）和聚光灯（spot）。我们分别来实现这三种光源。</p>
<h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h3><p>在实现光源之前我们需要一些函数和变量，首先是在 <code>Global.h</code> 中定义的环境光项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>还有计算反射方向的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射的计算 2n * cos(n,l) - l = r</span></span><br><span class="line"><span class="comment">// lightDir是光指向片元的方向</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> glm::vec3&amp; lightDir, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightDir - <span class="number">2</span> * glm::<span class="built_in">dot</span>(normal, lightDir) * normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-平行光"><a href="#3-平行光" class="headerlink" title="3 平行光"></a>3 平行光</h3><p>在实现各类光源之前我们先实现一个光源基类，这样其他光源都派生自该基类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 光源基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Color;</span><br><span class="line">    glm::vec3 Specular;</span><br><span class="line">    glm::vec3 Direction;</span><br><span class="line">    <span class="type">float</span> Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Light</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Light</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) :</span><br><span class="line">        <span class="built_in">Position</span>(pos),</span><br><span class="line">        <span class="built_in">Color</span>(color),</span><br><span class="line">        <span class="built_in">Specular</span>(specular),</span><br><span class="line">        <span class="built_in">Direction</span>(dir),</span><br><span class="line">        <span class="built_in">Intensity</span>(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是平行光，平行光不需要位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平行光，不需要位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DirectionLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>) : </span><br><span class="line">        <span class="built_in">Light</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), color, specular, dir, i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们新建一个 <code>BlinnPhongShader</code> 类继承于基本的 Shader 类，在其中实现平行光的计算，并修改片元着色器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLINNPHONG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Light.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Material.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlinnPhongShader</span> : <span class="keyword">public</span> Shader &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BlinnPhongShader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量都要是单位向量</span></span><br><span class="line">    <span class="comment">// ViewDir是片元指向摄像机的方向</span></span><br><span class="line">    <span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcDirLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> DirectionLight&amp; dirLight,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -dirLight.Direction), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - dirLight.Direction);</span><br><span class="line">        <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">        glm::vec3 diffuse = dirLight.Color * diff * albedo;</span><br><span class="line">        glm::vec3 specular = dirLight.Specular * spec;</span><br><span class="line">        <span class="keyword">return</span> (diffuse + specular) * dirLight.Intensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">        glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">        glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">        glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">        glm::vec3 result = Ambient * albedo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">            result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后在主函数中加入一个平行光：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 平行光源</span></span><br><span class="line"><span class="function">DirectionLight <span class="title">dir</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">1.0</span>)</span></span>;</span><br><span class="line">dirLights = &amp;dir;</span><br><span class="line">dirLtNums = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用光照Shader</span></span><br><span class="line">BlinnPhongShader shader;</span><br><span class="line"><span class="comment">// 加载模型</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>查看效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112039177.png" alt="image-20220525112039177"></p>
<h3 id="4-点光源"><a href="#4-点光源" class="headerlink" title="4 点光源"></a>4 点光源</h3><p>点光源无所谓方向，它向四周均匀发光，光照强度和距离成反比，我们使用常数项、一次项和二次项来控制光照衰减，首先是点光源类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点光源，不需要方向</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span> : <span class="keyword">public</span> Light &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> Constant;        <span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> Linear;        <span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> Quadratic;    <span class="comment">// 二次项</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PointLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span></span><br><span class="line">    ) : <span class="built_in">Light</span>(pos, color, specular, glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), i), <span class="built_in">Constant</span>(c), <span class="built_in">Linear</span>(l), <span class="built_in">Quadratic</span>(q)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是计算点光源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算点光源</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcPtLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> PointLight&amp; ptLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到光源的距离</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, ptLight.Position);</span><br><span class="line">    <span class="comment">// 强度衰减因子</span></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (ptLight.Constant + ptLight.Linear * distance +</span><br><span class="line">                               ptLight.Quadratic * (distance * distance));</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - ptLight.Position);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = ptLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = ptLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= attenuation;</span><br><span class="line">    specular *= attenuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * ptLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片元着色器中加入点光源贡献：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主函数中加入一个点光源：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">PointLight <span class="title">pt</span><span class="params">(glm::vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">ptLights = &amp;pt;</span><br><span class="line">ptLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查看效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525112022188.png" alt="image-20220525112022188"></p>
<h3 id="5-聚光灯"><a href="#5-聚光灯" class="headerlink" title="5 聚光灯"></a>5 聚光灯</h3><p>聚光灯可以理解为手电筒，只有在与手电筒正方向夹角在一定范围内的像素才会被照亮。像素到光源位置的方向与光源正向夹角被称为切光角，切光角在设定范围内的像素，按照点光源的方式计算光照。切光角之外的像素不会被照亮。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525110724976.png" alt="image-20220525110724976"></p>
<p>为了避免边缘突变，可以设立一个外切光角，在内外切光角之间使用插值乘以计算结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span> : <span class="keyword">public</span> PointLight &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> innerCutOff;        <span class="comment">// 内切光角范围</span></span><br><span class="line">    <span class="type">float</span> outterCutOff;        <span class="comment">// 外切光角范围</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpotLight</span>(</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; pos = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; dir = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; color = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> glm::vec3&amp; specular = glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; i = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; c = <span class="number">1.0f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; l = <span class="number">0.09f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; q = <span class="number">0.032f</span>,</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; icut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">12.5f</span>)),</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span>&amp; ocut = glm::<span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="number">17.5</span>))</span><br><span class="line">    ) : <span class="built_in">PointLight</span>(pos, color, specular, i, c, l, q), <span class="built_in">innerCutOff</span>(icut), <span class="built_in">outterCutOff</span>(ocut)</span><br><span class="line">    &#123;</span><br><span class="line">        Direction = dir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>计算聚光灯：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算聚光灯，切光角以内按点光源计算</span></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">CalcSpLight</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SpotLight&amp; spLight,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldPos,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldNormal,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; worldViewDir,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> glm::vec3&amp; albedo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    glm::vec3 lightDir = glm::<span class="built_in">normalize</span>(worldPos - spLight.Position);</span><br><span class="line">    <span class="comment">// 切光角</span></span><br><span class="line">    <span class="type">float</span> theta = glm::<span class="built_in">dot</span>(lightDir, glm::<span class="built_in">normalize</span>(spLight.Direction));</span><br><span class="line">    <span class="comment">// 内外切光角插值系数</span></span><br><span class="line">    <span class="type">float</span> weight = <span class="built_in">saturate</span>((theta - spLight.outterCutOff) / (spLight.innerCutOff - spLight.outterCutOff));</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">Lerp</span>(<span class="number">0</span>, <span class="number">1</span>, weight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按点光源计算</span></span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">distance</span>(worldPos, spLight.Position);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (spLight.Constant + spLight.Linear * distance +</span><br><span class="line">                               spLight.Quadratic * (distance * distance));</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(glm::<span class="built_in">dot</span>(worldNormal, -lightDir), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glm::vec3 halfDir = glm::<span class="built_in">normalize</span>(worldViewDir - lightDir);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(glm::<span class="built_in">dot</span>(halfDir, worldNormal), <span class="number">0</span>), currentMat-&gt;Gloss);</span><br><span class="line"></span><br><span class="line">    glm::vec3 diffuse = spLight.Color * diff * albedo;</span><br><span class="line">    glm::vec3 specular = spLight.Specular * spec;</span><br><span class="line"></span><br><span class="line">    diffuse *= (attenuation * intensity);</span><br><span class="line">    specular *= (attenuation * intensity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  (diffuse + specular) * spLight.Intensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在片元着色器中加入聚光灯贡献：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">    glm::vec3 albedo = texture-&gt;<span class="built_in">Sample2D</span>(v.texcoord) * currentMat-&gt;Color;</span><br><span class="line">    glm::vec3 worldNormal = glm::<span class="built_in">normalize</span>(v.normal);</span><br><span class="line">    glm::vec3 worldViewDir = glm::<span class="built_in">normalize</span>(camera-&gt;Position - glm::<span class="built_in">vec3</span>(v.worldPos));</span><br><span class="line"></span><br><span class="line">    glm::vec3 result = Ambient * albedo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dirLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcDirLight</span>(*(dirLights + i), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcPtLight</span>(*(ptLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; spLtNums; i++)</span><br><span class="line">        result += BlinnPhongShader::<span class="built_in">CalcSpLight</span>(*(spLights + i), glm::<span class="built_in">vec3</span>(v.worldPos), worldNormal, worldViewDir, albedo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中加入聚光灯：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="function">SpotLight <span class="title">sp</span><span class="params">(camera-&gt;Position, camera-&gt;Front)</span></span>;</span><br><span class="line">spLights = &amp;sp;</span><br><span class="line">spLtNums = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>最终的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%85%89%E6%BA%90/image-20220525111959282.png" alt="image-20220525111959282"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（九）改进光栅化</title>
    <url>/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<p>现在我们的渲染管线已经基本具备了所有的要素，但是作为光栅化渲染器，我们目前的光栅化算法太过老旧，扫描线算法简单高效，但难以并行化（毕竟操作的单位是一条线），并且在实现时还存在由于多次插值的精度损失导致的多个三角形间存在接缝等问题。因此现在已经不被使用，之前在图形学中我们学习过另一种光栅化方法，这节我们来讨论该方法的一些具体实现细节。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-边界函数算法"><a href="#1-边界函数算法" class="headerlink" title="1 边界函数算法"></a>1 边界函数算法</h3><p>关于边界函数算法，原理同样非常简单，就是用点和三角形三个顶点连线的向量叉乘来判断点是否在三角形内部，具体可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%85%89%E6%A0%85%E5%8C%96/">【计算机图形学】（三）光栅化</a>，其中还包含了 C++ 代码实现。我们先照搬过来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Vector3f* _v存储三角形的三个顶点坐标，顶点顺序为逆时针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//用像素中心坐标判断</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">p</span><span class="params">(<span class="type">float</span>(x) + <span class="number">0.5</span>, <span class="type">float</span>(y) + <span class="number">0.5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向量AB和AC叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signofTrig = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量AB和AP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfAB = (_v[<span class="number">1</span>].<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) - (_v[<span class="number">1</span>].<span class="built_in">y</span>() - _v[<span class="number">0</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">0</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量CA和CP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfCA = (_v[<span class="number">0</span>].<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">0</span>].<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="comment">//向量BC和BP叉乘的纵坐标</span></span><br><span class="line">    <span class="type">float</span> signOfBC = (_v[<span class="number">2</span>].<span class="built_in">x</span>() - _v[<span class="number">1</span>].<span class="built_in">x</span>()) * (p.<span class="built_in">y</span>() - _v[<span class="number">2</span>].<span class="built_in">y</span>()) - (_v[<span class="number">2</span>].<span class="built_in">y</span>() - _v[<span class="number">1</span>].<span class="built_in">y</span>()) * (p.<span class="built_in">x</span>() - _v[<span class="number">2</span>].<span class="built_in">x</span>());</span><br><span class="line">    <span class="type">bool</span> d1 = (signOfAB * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d2 = (signOfCA * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> d3 = (signOfBC * signofTrig &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> d1 &amp;&amp; d2 &amp;&amp; d3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓边界函数实际上就是上述代码中的 <code>(signOfAB * signofTrig &gt; 0)</code> 等这三个判断条件，因为这个条件判断了点和三角形的一条边界的位置关系，因此被称为边界函数。根据边界函数经过推导可以看出每次移动一个像素得到的边界函数和之前的边界函数的差值是固定的，具体推导过程可以查看<a href="https://zhuanlan.zhihu.com/p/140926917">图形学底层探秘 - 更现代的三角形光栅化与插值算法的实现与优化</a>，因此我们不需要每次都计算叉乘，只需要在前一次的结果上加上差值即可。</p>
<p>另一个问题是，我们对每个三角形的 Bounding Box 内的像素进行遍历来判断其是否在三角形内部，那么至少会有一半的像素不在三角形内而造成计算浪费，因此出现了分块优化算法，即将 Bounding Box 进行分块，然后只判断每块四个角上的像素是否在三角形内，如果每块的四个像素都在三角形内部或者外部，其他像素就不需要再进行判断了，如果四个像素部分在内部部分在外部就执行正常的算法在块内逐像素判断。这个方法对于占屏幕面积较大的三角形优化效果明显，但如果是小三角形或是斜长的细三角形，反而不如不分块来得快。而且，太大的分块会进一步降低小三角形的绘制效率，而太小的分块又变回了逐像素算法，因此分块的大小需要仔细的权衡。</p>
<h3 id="2-重心插值"><a href="#2-重心插值" class="headerlink" title="2 重心插值"></a>2 重心插值</h3><p>扫描线算法中使用线性插值就可以确定片元的各种属性值，而在边界函数算法中需要使用重心插值，关于重心坐标我们之前的笔记中也有具体的推导：<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a>中的第4部分。</p>
<p>在实现中我们如何计算重心坐标呢？首先整个三角形的面积可以通过：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}a·b·sin\theta<br>$$<br>来计算，也就是三角形两条边叉乘得到的向量模的一半，以 AB 和 BC 边为例，三角形的面积为：<br>$$<br>S_{\Delta} &#x3D; \frac{1} {2}(A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx)<br>$$<br>而我们的三个边界函数相加：<br>$$<br>F_{AB}(P) + F_{BC}(P) + F_{CA}(P) &#x3D; A_xB_y - A_yBx + B_xC_y - B_yCx + C_xA_y - C_yAx<br>$$<br>刚好是三角形面积的二倍，即：<br>$$<br>\frac{F_{AB}(P) + F_{BC}(P) + F_{CA}(P)} {2S_{\Delta} } &#x3D; 1<br>$$<br>而重心坐标就是小三角形面积和整个三角形面积的比值，因此我们可以直接通过边界函数得到点 P 的重心坐标：<br>$$<br>\alpha &#x3D; \frac{F_{AB}(P)} { {2S_{\Delta} } },\beta &#x3D; \frac{F_{BC}(P)} { {2S_{\Delta} } },\gamma &#x3D; \frac{F_{CA}(P)} { {2S_{\Delta} } }<br>$$<br>这样整个光栅化算法就完成了。需要注意的是重心插值和之前的线性插值一样，都需要进行透视插值校正，即在透视除法中将所有属性都除以 w 值，最后在片元着色器之前再乘以 w 值恢复。关于透视插值校正我们将在下一节详细讨论。</p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于透视插值校正</title>
    <url>/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/</url>
    <content><![CDATA[<p>在之前的光栅化渲染器中，我们在光栅化插值的过程中对所有顶点的属性都除以了该顶点的深度值 w，然后又在线性插值之后乘以了该点的深度值，这样才能得到正确的插值属性，这一步叫做透视插值校正。这一节我们来详细讨论透视插值校正的具体原理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-为什么需要透视插值校正"><a href="#1-为什么需要透视插值校正" class="headerlink" title="1 为什么需要透视插值校正"></a>1 为什么需要透视插值校正</h3><p>透视投影我们已经非常熟悉了，透视投影是为了模拟人眼所看到的近大远小的效果，比如一个正方形，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/image-20220525160340619.png" alt="image-20220525160340619"></p>
<p>如果是正交投影，那么点 Q 就在 BC 连线中点处，而如果是透视投影，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/2022-05-25160428.png" alt="屏幕截图 2022-05-25 160428"></p>
<p>点 Q 就不再处于 BC 连线的中间处了，在我们的渲染器中纹理出现变形的原因就是我们在对顶点的纹理坐标进行插值的时候没有考虑透视的影响。如下图，红色坐标为纹理坐标，黑色为顶点位置：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-d6f128e3e3150d0ab3941dfdc452e111_r.jpg" alt="v2-d6f128e3e3150d0ab3941dfdc452e111_r"></p>
<p>当摄像机视线垂直于平面时，将贴图按照 uv 坐标插值，贴到正方形上会如右图所示，不会出现任何问题，但如果相机不垂直于平面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-67871f21f22f9573e64d3bd30788c033_b.jpg" alt="v2-67871f21f22f9573e64d3bd30788c033_b"></p>
<p>本来按照正确的透视，正方形的中心点应该在 AC 和 BD 的交点 Q，我们应该把纹理坐标为 (0.5, 0.5) 的颜色值赋给 Q，但是图中却赋给了 P 点，这是因为我们在光栅化插值的时候，使用的是屏幕坐标进行的线性插值，屏幕坐标是投影后的坐标，是没有考虑近大远小的。</p>
<p>也就是说通，过屏幕坐标插值，可以得到 AC 的中点为点 P，AB 的中点为点 N，AD 的中点为点 M，这些都是投影后屏幕上线段的中点，而不是实际这个正方形在空间中线段的中点，因此就会出现纹理映射错误的情况。所以这时候我们就需要进行透视插值校正。</p>
<h3 id="2-如何进行透视插值校正"><a href="#2-如何进行透视插值校正" class="headerlink" title="2 如何进行透视插值校正"></a>2 如何进行透视插值校正</h3><p>我们在二维空间中进行推导会简单许多。下图为二维空间中的投影，因为是二维，所以我们把 x 坐标全部置 0，各种几何关系如图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-9ef76bf017541df6b268f0fc5d50f400_b.jpg" alt="v2-9ef76bf017541df6b268f0fc5d50f400_b"></p>
<p>二维空间中的线段 AB 被投影到 Z &#x3D; C 平面上，显示为线段 A’B’，利用投影平面的坐标进行插值可以得到：<br>$$<br>P’ &#x3D; (1-m)A’ + mB’<br>$$<br>于是现在的问题是，如何通过屏幕上的点 P‘ 得到空间中原本的点 P，并求出一个插值关系：<br>$$<br>P &#x3D; (1-n)A + nB<br>$$<br>最简单的方法自然是对点 P’ 应用透视投影变换的逆变换，但矩阵变换太麻烦，我们完全可以通过几何关系解决这个问题。</p>
<p>在图中添加两条辅助线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E9%80%8F%E8%A7%86%E6%8F%92%E5%80%BC%E6%A0%A1%E6%AD%A3/v2-1766a667c7a314f19092ecc00ea03b6b_b.jpg" alt="v2-1766a667c7a314f19092ecc00ea03b6b_b"></p>
<p>根据三角形相似可以得到：<br>$$<br>\frac{n}{1-n} &#x3D; \frac{|AG|}{|BK|} &#x3D; \frac{|A’P’|\frac{Z_1}{c}}{|B’P’|\frac{Z_2}{c}} &#x3D; \frac{mZ_1}{(1-m)Z_2}<br>$$<br>等式两边取倒数可得：<br>$$<br>\frac{1}{n} - 1 &#x3D; \frac{(1-m)Z_2}{mZ_1}<br>$$<br>由此可以解得：<br>$$<br>n &#x3D; \frac{mZ_1}{mZ_1 + (1-m)Z_2}<br>$$<br>这样我们就得到了已知屏幕空间的插值系数 m，求观察空间的插值系数 n 的方法。使用插值系数 n 就可以对顶点的任意属性进行插值了。比如点 P 的 Z 坐标：<br>$$<br>Z_n &#x3D; (1-n)Z_1 + nZ_2 &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}Z_1 + \frac{mZ_1}{mZ_1 + (1-m)Z_2}Z_2<br>$$<br>化简后得到：<br>$$<br>Z_n &#x3D; \frac{Z_1Z_2}{mZ_1 + (1-m)Z_2} &#x3D; \frac{1}{\frac{1-m}{Z_1} + \frac{m}{Z_2}}<br>$$<br>这样计算其他属性的插值就可以直接将 $Z_n$ 带入，为什么要将 $Z_n$ 带入呢？因为我们的观察方向都是沿着 -Z 轴方向，所以透视的缩放关系只和深度 Z 有关。比如求点 P 的纹理坐标：<br>$$<br>UV_P &#x3D; \frac{(1-m)Z_2}{mZ_1 + (1-m)Z_2}UV_A + \frac{mZ_1}{mZ_1 + (1-m)Z_2}UV_B<br>$$<br>将 $Z_n$ 带入得：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-m}{Z_1}UV_A + \frac{m}{Z_2}UV_B)<br>$$<br>上式就是我们在代码中实现的，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的线性插值之后再乘以插值点的深度值，就完成了线性插值的透视校正。</p>
<p>现在推广到三维空间，可以得到：<br>$$<br>Z_n &#x3D; \frac{1}{\frac{1-u-v}{Z_1} + \frac{u}{Z_2} + \frac{v}{Z_3}}<br>$$<br>其中 u 和 v 是重心插值系数：<br>$$<br>P &#x3D; (1-u-v)A + uB + vC<br>$$<br>于是在三维空间中，点 P 的纹理坐标为：<br>$$<br>UV_P &#x3D; Z_n(\frac{1-u-v}{Z_1}UV_A + \frac{u}{Z_2}UV_B + \frac{v}{Z_3}UV_C)<br>$$<br>于是同样的，在透视除法中，将所有顶点的所有属性都除以其深度值 w（经过投影变换，w 是 -Z，一次乘法一次除法负号消掉了），然后使用屏幕坐标对顶点进行所有属性的重心插值之后再乘以插值点的深度值，就完成了重心插值的透视校正。</p>
]]></content>
      <tags>
        <tag>计算机图形学</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎】（二）游戏引擎中的渲染系统</title>
    <url>/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>游戏引擎中的渲染系统和我们之前学习的实时渲染或离线渲染系统不完全相同，游戏引擎中的渲染系统除了渲染外还需要考虑更多的事情。因为渲染系统只是游戏中的一部分，不可能将设备全部的资源投入到渲染中，因此大量游戏对象的绘制资源如何组织，如何管理，如何调度是游戏引擎的渲染系统需要额外考虑的事情。此外，游戏中的渲染对实时性要求更高，因此必须充分利用有限的资源来达到最好的效果，所以需要对渲染加速算法和 GPU 的架构有一定的了解。这一节我们对游戏引擎中的渲染系统所涉及的方方面面进行大致的了解。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-GPU-架构"><a href="#1-GPU-架构" class="headerlink" title="1 GPU 架构"></a>1 GPU 架构</h3><p>GPU 是渲染系统使用的核心工具，要想使游戏引擎充分利用资源，就要对 GPU 的架构有所了解。关于现代 GPU 架构，这篇文章写的比较细致：<a href="https://zhuanlan.zhihu.com/p/406096300">现代渲染引擎开发-GPU架构</a>，这里只总结重点：</p>
<ul>
<li>SIMD是单指令多数据，一条指令处理多个数据，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155458175.png" alt="image-20220526155458175"></p>
<ul>
<li>SIMT是单指令多线程，N 卡使用这种方式，即单条指令在多个核上分多个线程执行</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526155551595.png" alt="image-20220526155551595"></p>
<ul>
<li>GPU 中最重要的计算单元是 CU，N 卡中为 CUDA Core，还有专门支持光追的 RT Core 和支持 AI 运算的 Tensor Core 等，多个 CU 组成一个 GPC，也叫做 Shader Engine</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526160001900.png" alt="image-20220526160001900"></p>
<ul>
<li>GPU 对性能的瓶颈包括：内存瓶颈、ALU（整形运算单元）瓶颈、TMU（纹理映射单元）瓶颈、BW（带宽）瓶颈等</li>
</ul>
<h3 id="2-渲染资源管理"><a href="#2-渲染资源管理" class="headerlink" title="2 渲染资源管理"></a>2 渲染资源管理</h3><p>游戏中的所有对象被称为 GameObject（GO），每一个 GO 包含很多组件，比如模型、语音、动画等等，GO 之间还可以通过事件系统进行交流，并根据其他 GO 发来的消息做出响应。其中，与渲染相关的组件就称为 Renderable，Renderable 包含渲染这个 GO 所需的所有数据，包括顶点、法线、纹理坐标、材质、贴图等等。游戏引擎需要将这些数据高效地组织起来。</p>
<p>顶点数据的组织我们在 OpenGL 中已经了解，分为顶点数据和顶点索引，顶点索引就描述了所有图元由哪些顶点组成，因为很多图元之间会共享顶点，这样就不需要为每个图元单独存储顶点，从而避免资源浪费。</p>
<p>一个 GO 最重要的就是要有一个模型，模型由网格 Mesh 组成，因为模型的不同部位可能需要不同的材质，所以一个模型又分为了多个子 Mesh，称为 SubMesh，每个 SubMesh 有它对应的材质（Material），材质包含纹理（Texture）和 Shader 等，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161157448.png" alt="image-20220526161157448"></p>
<p>在实际的游戏中，许多游戏对象的 Renderable 可能是重复的，比如许多步兵 NPC，渲染它们需要的数据是完全一样的，如果为每个 GO 都存储一遍这些数据那将会是极大的浪费，因此游戏引擎将所有这些资源放入了资源池中，不同的 GO 只需要存储资源池中资源的索引即可，比如一个模型的 Mesh 对应 Mesh 池中的哪些图元，使用 Shader 池中的哪些 Shader 去渲染，这样就将资源紧凑的管理起来了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161435933.png" alt="image-20220526161435933"></p>
<p>这种管理方式也是游戏引擎中很常见的一种管理方式，用来应对资源复用的问题，不只是在渲染系统中，其他系统中也广泛使用了这种管理方式。因此每一个 GO 只是这些资源的组合，是实例化的资源。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526161628614.png" alt="image-20220526161628614"></p>
<p>此外，因为不同的 GO 会有不同的材质，即使是一个 GO 也会在不同部位使用不同的材质，如果不做任何优化的进行渲染，会有大量的材质更新操作，即卸载掉这个材质的纹理和 Shader，并加载 另一个材质的纹理和 Shader，这样也会造成性能的下降，因此一般的做法是将 SubMesh 按照材质排序，将所有材质相同的 SubMesh 放在一起，这样只需要加载一次材质就可以渲染所有使用该材质的 SubMesh：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/26/20220526-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F/image-20220526162146227.png" alt="image-20220526162146227"></p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【高质量实时渲染】实时光线追踪</title>
    <url>/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>随着 NVIDIA 图灵架构的问世，实时光线追踪由不可能变为了可能，并且由于光线追踪能够带来自然的软阴影、环境光照、全局光照、环境光遮蔽等效果，其迅速成为主流 3A 大作的标配。这一节来简要了解实时光线追踪的实现思路以及主要解决的问题。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-实时光线追踪基本思路"><a href="#1-实时光线追踪基本思路" class="headerlink" title="1 实时光线追踪基本思路"></a>1 实时光线追踪基本思路</h3><p>NVIDIA 在 2018 年推出了 RTX 系列显卡，采用 Turing 架构，引入了专门处理光线追踪的 RT Core，使得光线追踪这种计算开销极大的算法能够实时运行。</p>
<p>实时光线追踪和离线光线追踪使用的算法完全一致，都是采样光线，计算交点，然后循环迭代，RTX 20 系列支持每秒 100 亿根光线的处理，这个数字看似很多，但实际上还要除以屏幕的分辨率，通常就是几千万个像素，还要除以帧率，因此最终实际上目前真正的实时光线追踪只能达到每帧每个像素采样一根光线。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142644271.png" alt="image-20220609142644271"></p>
<p>可想而知这样得出的结果是噪声非常严重的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142722281.png" alt="image-20220609142722281"></p>
<p>因此实时光线追踪的重点实际上不是光线追踪，而是如何对 1 SPP 的 RTRT 结果进行降噪，使其达到和离线光线追踪一样的效果。下图展示了现在的实时光线追踪降噪技术所能达到的效果，非常不可思议：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609142901751.png" alt="image-20220609142901751"></p>
<p>简单来说，实时光线追踪会首先生成一张 1 SPP 的 noisy 结果，然后对单帧进行图像空间降噪（Spatial Denoising），之后再联合前一帧图像（任何时候都假设前一帧已经没有噪声）进行时域降噪（Temporal Denoising），最终得到一帧没有噪声的结果。</p>
<h3 id="2-Spatial-Denoising"><a href="#2-Spatial-Denoising" class="headerlink" title="2 Spatial Denoising"></a>2 Spatial Denoising</h3><h4 id="2-1-联合双边滤波"><a href="#2-1-联合双边滤波" class="headerlink" title="2.1 联合双边滤波"></a>2.1 联合双边滤波</h4><p>单帧图像空间降噪简单的自然是使用低通滤波，比如高斯模糊，这样可以去掉高频的噪声，但同时也会丢掉图像中高频的信息，也就是一些细节，因此为了保留图像细节一般使用双边滤波（Bilateral Filtering）进行降噪。</p>
<p>双边滤波只是对高斯滤波的改进，高斯滤波只考虑了像素之间的距离作为权值的衰减因素，而为了保留高频信息，双边滤波还考虑了颜色，当两个像素的颜色差异过大时，权值也进一步变小，这样就可以保留原图中的边缘等高频信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609143945517.png" alt="image-20220609143945517"></p>
<p>上式中后一项是对颜色的距离进行了一个计算，这样相当于两个高斯分布的乘积作为一个像素周围其他像素的权值。</p>
<p>更进一步，既然可以考虑颜色，那么自然也可以考虑更多的因素，<strong>联合双边滤波（Joint Bilateral Filtering）</strong>就是将许多不同因素作为影响权值衰减的因素，除了像素之间的距离、颜色之外，还可以利用 G-Buffer 中存储的每个像素的深度、法线、反射率等等，因此联合双边滤波非常适合用来做 RTRT 的图像降噪，因为 G-Buffer 中的信息在渲染时就可以顺便得到，几乎不需要任何额外开销。</p>
<p>需要说明的是，上面是以高斯滤波为例的，实际上双边滤波或者联合双边滤波中的衰减系数不一定要是高斯分布的，可以是指数分布、余弦分布等等，只要能够描述衰减关系就可以。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144749719.png" alt="image-20220609144749719"></p>
<p>下面以一个例子来说明联合双边滤波的作用：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609144824808.png" alt="image-20220609144824808"></p>
<p>这是一张噪声很大的渲染结果，我们使用联合双边滤波考虑深度、法线、颜色的影响，于是在对点 B 进行滤波时，可能会将点 A 和点 C 的贡献加入到点 B，但是因为点 A 和点 B 的深度差异比较大，因此点 A 的贡献就会变小，而点 C 和点 B 的法线差异比较大，因此点 C 的贡献也会变小。而点 D 和点 E 的深度和法线相差不大，但颜色相差很大，因此权值也会变小，这样就可以得到比较好的滤波效果。</p>
<h4 id="2-2-大范围滤波优化"><a href="#2-2-大范围滤波优化" class="headerlink" title="2.2 大范围滤波优化"></a>2.2 大范围滤波优化</h4><p>这里还有一个问题需要讨论，因为使用联合双边滤波，我们的滤波核范围通常很大，不是通常的 5 * 5 或者 7 * 7，如果滤波核是 128 * 128，那么对每个像素进行滤波都要访问它周围一万多个像素，会非常耗时，因此需要对大滤波核的滤波进行优化，通常使用以下两种方法：</p>
<ul>
<li>Separate Passes：也就是将 128 * 128 的一次滤波分为 1 * 128 和 128 * 1 两次滤波，这样就可以大幅降低复杂度，只需要访问 256 次就可以完成之前访问一万多次的工作：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609145638690.png" alt="image-20220609145638690"></p>
<p>这么做可行的原因在于二维高斯分布本身就是两个一维高斯分布的乘积，因此也自然可以将一次二维滤波拆成两次一维滤波。但是对于双边滤波和联合双边滤波，不再是简单的二维高斯分布，因此不满足这样的特性，理论上不能使用这个方法，不过工业界依然使用这样的方法，在滤波核不是特别大的时候不会看出什么问题。</p>
<ul>
<li>Progressively Growing Sizes：这种方法将一个大的滤波拆分成多次小的滤波，但是每次小的滤波所取得周围像素的间隔会逐渐增大，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150034090.png" alt="image-20220609150034090"></p>
<p>将一个 64 * 64 的滤波拆分成了 5 次 5 * 5 的滤波，第一次在像素周围 5 * 5 的区域进行，第二次取的像素之间都会间隔 2 个像素，第三次间隔 4 个像素，直到第 5 次，间隔 16 个像素，整个区域刚好就是 64 * 64，这样将 64 * 64 变成了 5 * 5 * 5，同样大幅降低了复杂度。</p>
<h4 id="2-3-异常像素移除"><a href="#2-3-异常像素移除" class="headerlink" title="2.3 异常像素移除"></a>2.3 异常像素移除</h4><p>异常像素移除（Outlier Removal）是在进行滤波之前做的一项工作，所谓异常像素（outlier）是指在噪声图像中会有一些非常亮的像素，如果不去除，那在滤波的时候这些非常亮的像素就会扩散到周围一定的区域造成异常：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609150605655.png" alt="image-20220609150605655"></p>
<p>去除他们的方法非常简单，对每一个像素，取它周围一定区域，通常是 7 * 7，然后求出这个区域内颜色的均值和方差，根据均值和方差可以确定一个范围：<br>$$<br>[\mu-k\sigma,\mu+k\sigma]<br>$$<br>将不在这个范围内的像素颜色截断在这个范围内即可。</p>
<h3 id="3-Temporal-Denoising"><a href="#3-Temporal-Denoising" class="headerlink" title="3 Temporal Denoising"></a>3 Temporal Denoising</h3><h4 id="3-1-Motion-Vector"><a href="#3-1-Motion-Vector" class="headerlink" title="3.1 Motion Vector"></a>3.1 Motion Vector</h4><p>时域滤波是实时光线追踪能够实现的重要原因之一，基本思想就是假设前一帧总是没有噪声的，于是可以将这一帧的像素所显示的位置对应到前一帧的那个像素找到，将它的颜色和这一帧像素的颜色线性融合起来，实现非常好的降噪效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151126653.png" alt="image-20220609151126653"></p>
<p>对于第 i 帧的一个像素，我们可以从 G-Buffer 中得到该像素对应的世界空间位置，如果没有 G-Buffer，还可以通过屏幕坐标逆变换得到世界空间坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151336724.png" alt="image-20220609151336724"></p>
<p>然后我们在渲染的过程中一定知道这两帧之间物体是怎样移动的，因为我们掌控整个渲染过程，也就知道整个场景的变化过程，于是将当前帧的位置进行场景变换的逆变换，得到前一帧中该点的位置：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151431056.png" alt="image-20220609151431056"></p>
<p>再利用前一帧的各种矩阵将该点投影到屏幕上，就得到了前一帧中对应的像素坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151532403.png" alt="image-20220609151532403"></p>
<p>将该像素的颜色和当前帧的颜色进行融合：<br>$$<br>color_i &#x3D; \alpha color_i + (1-\alpha)color_{i-1}<br>$$<br>因为前一帧是没有噪声的图片，所以会让前一帧的颜色的权值更大，一般来说 $\alpha$ 取 0.1 到 0.2，也就是说当前帧的颜色有 80% 到 90% 取决于前一帧。</p>
<p>于是整个实时光线追踪去噪的过程可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609151859574.png" alt="image-20220609151859574"></p>
<p>其中带有 - 的表示滤波后的图片，带有 ~ 的表示没有滤波的图片，什么都没有的表示没有噪声的图片。上面的公式表示先对当前帧进行单帧的 Spatial Denoising，再联合前一帧进行 Temporal Denoising。</p>
<p>下图是 1 SPP 的 RTRT 结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152103914.png" alt="image-20220609152103914"></p>
<p>使用了上述去噪方法后得到的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152123879.png" alt="image-20220609152123879"></p>
<p>这里的图片相比于有噪声的结果看起来变亮了很多，但实际上并没有，只是因为 RTRT 得出的有噪声的结果中像素的颜色很大，经过色调映射显示出来就会显得很暗，去噪的过程一定是能量守恒的。</p>
<p>下面是离线光线追踪的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152151531.png" alt="image-20220609152151531"></p>
<p>可以看到除了一些物体接触的地方的阴影没有渲染出来之外，实时光线追踪的结果和离线结果非常接近。</p>
<h4 id="3-2-Temporal-的问题"><a href="#3-2-Temporal-的问题" class="headerlink" title="3.2 Temporal 的问题"></a>3.2 Temporal 的问题</h4><p>时域去噪方法效果很好，但存在很多问题：</p>
<ul>
<li>切换场景的时候，时域去噪会失效，因为前后两帧几乎没有任何对应关系：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152409311.png" alt="image-20220609152409311"></p>
<ul>
<li>当我们在一个场景中的倒退的时候也会有问题，因为倒退的时候会有更多场景中的景象进入视野，于是就会出现当前帧的某个地方在上一帧中还没出现：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152546782.png" alt="image-20220609152546782"></p>
<ul>
<li>还有当物体移动的时候，会对其他物体造成遮挡，前后两帧中遮挡关系不一样，导致同一个位置会对应到不同的物体上，造成拖影现象：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609152716311.png" alt="image-20220609152716311"></p>
<ul>
<li>以及由于光源移动造成的阴影拖影现象，虽然物体没有动，但是因为光照关系变了导致这一点的着色结果变了，从而使得后一帧融合了前一帧的颜色会显示出前一帧的拖影：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153019170.png" alt="image-20220609153019170"></p>
<h4 id="3-3-Clamping"><a href="#3-3-Clamping" class="headerlink" title="3.3 Clamping"></a>3.3 Clamping</h4><p>解决上述问题的一个最简单的方法是将前一帧对应的像素的颜色截断到当前帧像素周边一定范围内颜色的均值附近，利用上面的异常像素移除的方法就可以实现，然后再融合到当前像素上，这样可以一定程度解决前后帧颜色不对应的情况，但对于切换场景等情况也无能为力。此外由于将没有噪声的颜色截断到了有噪声的颜色范围内，一定会引入新的噪声。</p>
<h4 id="3-4-其他解决方案"><a href="#3-4-其他解决方案" class="headerlink" title="3.4 其他解决方案"></a>3.4 其他解决方案</h4><p>Clamping 自然是一个简单的解决方案，但会引入新的问题，对于遮挡、阴影、Glossy 等情况如何寻找上一帧可用的像素信息是一个相对复杂的问题，一些更好的解决方案可以参考[实时渲染｜Filtering and Denoising：Temporal Reliable Motion Vector](<a href="https://zhuanlan.zhihu.com/p/376502501#:~:text=Motion">https://zhuanlan.zhihu.com/p/376502501#:~:text=Motion</a> Vector 通过后向投影的方法计算得到的前一帧位置，减去当前帧位置，得到的二维向量就是,Motion vector ，如下图 ：)中提到的方法。</p>
<h3 id="4-SVGF"><a href="#4-SVGF" class="headerlink" title="4 SVGF"></a>4 SVGF</h3><p>Spatiotemporal Variance-Guided Filtering 是一个实时光线追踪的具体解决方案，流程和我们上面说到的一致，只是在滤波核的设计上加入了一些更周全的考虑，因此可以得到非常好的效果。</p>
<p>SVGF 同样考虑了三个因素来影响滤波权值衰减：深度、法线和颜色。</p>
<p>对于深度，如下图中的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153703827.png" alt="image-20220609153703827"></p>
<p>由于箱子是侧对我们的，点 A 和点 B 的深度会有差异而使得滤波时的权值变小，但实际上他们属于同一面，不应该因为深度差异是他们的融合权值变小，因此引入了深度的梯度来修正这个影响，其中 $\epsilon$ 是为了防止两个点距离过近导致分母为 0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609153851851.png" alt="image-20220609153851851"></p>
<p>对于法线，使用了两点法线的点乘来作为衰减因素，同时加了一个指数来控制衰减的速度，这个指数和布林冯模型中高光的指数作用完全一致：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154028387.png" alt="image-20220609154028387"></p>
<p>对于颜色，SVGF 使用的是光照度，也就是像素的灰度值，首先计算了像素周围 7 * 7 范围内的灰度方差，然后还将这个方差进行了时域上的平均，最后在当前帧又取了周围 3 * 3 区域的方差来进行滤波衰减：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220609154224920.png" alt="image-20220609154224920"></p>
<p>SVGF 速度快效果好，但是拖影问题依然存在。</p>
]]></content>
      <categories>
        <category>高质量实时渲染</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Piccolo代码解读】渲染系统（一）渲染流程</title>
    <url>/LycTechStack.github.io/2022/06/18/20220618-Pilot-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>上一节中我们了解了引擎的整体运行流程以及反射机制的实现，这一节开始探究 Piccolo 的渲染系统是如何实现的，首先来了解渲染系统的整个流程。</p>
<p><em><span id="more"></span></em></p>
<p>回顾上一节中，引擎运行时最核心的函数 <code>tickOneFrame()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到引擎每一帧的流程就是先进行 <code>logicalTick</code>，然后通过 <code>swapLogicRenderData</code> 进行渲染系统的数据更新，最后进行渲染 <code>rendererTick</code>，之后还有一些窗口的事件响应。接下来我们从 <code>logicalTick</code> 开始看看整个系统是如何运行的。</p>
<h3 id="1-logicalTick"><a href="#1-logicalTick" class="headerlink" title="1 logicalTick"></a>1 logicalTick</h3><p><code>logicalTick</code>  的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::logicalTick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_world_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    g_runtime_global_context.m_input_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>logicalTick</code>  内部调用了世界管理系统的 tick 和输入管理系统的 tick。</p>
<h4 id="1-1-世界管理系统"><a href="#1-1-世界管理系统" class="headerlink" title="1.1 世界管理系统"></a>1.1 世界管理系统</h4><p>世界管理系统 <code>m_world_manager</code> 属于 <code>WorldManager</code> 类，该类用于管理整个游戏世界，包括编辑世界和运行世界，世界中包含各种关卡（Level），于是  <code>WorldManager</code> 的 tick 实际上就是调用关卡的 tick：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorldManager::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_world_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">loadWorld</span>(m_current_world_url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tick the active level</span></span><br><span class="line">    std::shared_ptr&lt;Level&gt; active_level = m_current_active_level.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (active_level)</span><br><span class="line">    &#123;</span><br><span class="line">        active_level-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而关卡类 Level 就是用于管理游戏对象（GO）的类，包含多个 Game Objects，于是 Level 的 tick 函数自然就是调用每个 GO 的 tick：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Level::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_is_loaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; id_object_pair : m_gobjects)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(id_object_pair.second);</span><br><span class="line">        <span class="keyword">if</span> (id_object_pair.second)</span><br><span class="line">        &#123;</span><br><span class="line">            id_object_pair.second-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_current_active_character &amp;&amp; g_is_editor_mode == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_current_active_character-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到除了调用每个 GO 的 tick ，最后还判断了是否有当前激活的角色和是否在编辑模式，如果不在编辑模式且存在激活的角色（也就是可被控制的角色），就调用该角色的 tick。角色 Character 类可以通过游戏对象 GObject 类来创建，因此它们都属于游戏对象，而 GObject 类的成员如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GObjectID   m_id &#123;k_invalid_gobject_id&#125;;</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::string m_definition_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to use the ReflectionPtr due to that the components need to be reflected </span></span><br><span class="line">    <span class="comment">// in editor, and it&#x27;s polymorphism</span></span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br></pre></td></tr></table></figure>

<p>每一个 GO 包含唯一的 GID 标识，名字，读取的链接以及各种组件，这些组件需要使用反射，因为组件有许多不同的类型，比如动画组件、mesh 组件、运动组件、相机组件等等，并且这些组件还要显示在组件面板，所以需要用到反射机制。于是每一个 GO 的 tick 就是调用它所有组件的 tick：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GObject::tick</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : m_components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldComponentTick</span>(component.<span class="built_in">getTypeName</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            component-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不同组件的 tick 自然就是对应于动画、物理、相机运动、物体形变等各个逻辑系统的运算。</p>
<h4 id="1-2-输入管理系统"><a href="#1-2-输入管理系统" class="headerlink" title="1.2 输入管理系统"></a>1.2 输入管理系统</h4><p>输入管理系统 <code>InputSystem</code> 类自然是用来管理鼠标、键盘的各种输入并作出响应，这里不多赘述。</p>
<h3 id="2-swapLogicRenderData"><a href="#2-swapLogicRenderData" class="headerlink" title="2 swapLogicRenderData"></a>2 swapLogicRenderData</h3><p>逻辑系统运算完毕后，这一帧的世界就构建完成了，但是逻辑运算是在当前世界上进行的，如果世界的资源发生了改变，那么逻辑系统告诉渲染系统更新了哪些资源，渲染系统要获取这些资源加入到渲染资源中，这是通过渲染系统中的 <code>swapLogicRenderData</code> 函数完成的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::swapLogicRenderData</span><span class="params">()</span> </span>&#123; m_swap_context.<span class="built_in">swapLogicRenderData</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该函数调用了渲染系统的成员 <code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数， <code>m_swap_context</code> 属于 <code>RenderSwapContext</code> 类，其中包含要交换的数据 <code>RenderSwapData</code>，<code>RenderSwapData</code> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderSwapData</span></span><br><span class="line">&#123;</span><br><span class="line">    std::optional&lt;LevelResourceDesc&gt;      level_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_resource_desc;</span><br><span class="line">    std::optional&lt;GameObjectResourceDesc&gt; game_object_to_delete;</span><br><span class="line">    std::optional&lt;CameraSwapData&gt;         camera_swap_data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDirtyGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDeleteGameObject</span><span class="params">(GameObjectDesc desc)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中包含关卡资源、游戏对象、相机数据，这些都是在逻辑系统计算的。这里使用了 C++ 17 的新特性 <code>optional</code>，为了之后可以通过 <code>has_value</code> 函数快速判断是否需要在渲染系统中更新这些资源的数据。</p>
<p><code>m_swap_context</code> 的 <code>swapLogicRenderData</code> 函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swapLogicRenderData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isReadyToSwap</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RenderSwapContext::isReadyToSwap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(m_swap_data[m_render_swap_data_index].level_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_resource_desc.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].game_object_to_delete.<span class="built_in">has_value</span>() ||</span><br><span class="line">             m_swap_data[m_render_swap_data_index].camera_swap_data.<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSwapContext::swap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resetLevelRsourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectResourceSwapData</span>();</span><br><span class="line">    <span class="built_in">resetGameObjectToDelete</span>();</span><br><span class="line">    <span class="built_in">resetCameraSwapData</span>();</span><br><span class="line">    std::<span class="built_in">swap</span>(m_logic_swap_data_index, m_render_swap_data_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其功能就是当需要在渲染系统中更新这些资源的数据时就进行数据交换操作。</p>
<h3 id="3-rendererTick"><a href="#3-rendererTick" class="headerlink" title="3 rendererTick"></a>3 rendererTick</h3><p>接下来就是最重要的 rendererTick 了，rendererTick 调用了渲染系统的 tick 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::rendererTick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">tick</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染系统的 tick 函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSystem::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process swap data between logic and render contexts</span></span><br><span class="line">    <span class="built_in">processSwapData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare render command context</span></span><br><span class="line">    m_rhi-&gt;<span class="built_in">prepareContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame buffer</span></span><br><span class="line">    m_render_resource-&gt;<span class="built_in">updatePerFrameBuffer</span>(m_render_scene, m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update per-frame visible objects</span></span><br><span class="line">    m_render_scene-&gt;<span class="built_in">updateVisibleObjects</span>(std::<span class="built_in">static_pointer_cast</span>&lt;RenderResource&gt;(m_render_resource),</span><br><span class="line">                                         m_render_camera);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare pipeline&#x27;s render passes data</span></span><br><span class="line">    m_render_pipeline-&gt;<span class="built_in">preparePassData</span>(m_render_resource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render one frame</span></span><br><span class="line">    <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::FORWARD_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;forwardRender(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_render_pipeline_type == RENDER_PIPELINE_TYPE::DEFERRED_PIPELINE)</span><br><span class="line">    &#123;</span><br><span class="line">        m_render_pipeline-&gt;<span class="built_in">deferredRender</span>(m_rhi, m_render_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(__FUNCTION__, <span class="string">&quot;unsupported render pipeline type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是处理从逻辑系统交换来的数据，也就是根据场景或者 GO 是否有变化从硬盘加载对应的资源或者卸载部分资源，然后准备渲染的各种数据。这些数据包括：</p>
<ul>
<li>变换矩阵、场景的光源数据，这通过 <code>updatePerFrameBuffer</code> 函数来设定，该函数根据场景和相机来获取矩阵和场景的光照信息，而整个渲染场景的光源在系统初始化的时候会进行构建，之后不会改变，相机会在逻辑 tick 中改变；</li>
<li>可见的物体数据，这通过 <code>updateVisibleObjects</code> 函数进行，实际上就是在进入渲染之前，把完全不可见的物体剔除掉。</li>
</ul>
<p>数据准备完毕后准备渲染的 Pass，最后根据指定的渲染模式进行前向渲染或者延迟渲染。</p>
<p>下一节开始我们将学习这些流程的具体实现。</p>
]]></content>
      <categories>
        <category>Piccolo引擎代码解读</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识汇总】数学相关</title>
    <url>/LycTechStack.github.io/2022/06/28/20220628-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-3D%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>本篇总结图形学中常用的数学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p>
<p><em><span id="more"></span></em></p>
<h4 id="给定点集如何求凸包"><a href="#给定点集如何求凸包" class="headerlink" title="给定点集如何求凸包"></a>给定点集如何求凸包</h4><p>求凸包算法可以查看<a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552"> 凸包（Convex Hull）问题算法详解</a>，其中比较重要的是分治法、步进法和扫描法：</p>
<ul>
<li>分治法首先找到一定在凸包上的两个点，然后连线将凸包分为上包和下包，在上包和下包中分别找到距离直线最远的点，连线继续划分，直到找到全部凸包上的点</li>
<li>步进法从一个凸包上的点出发，逆时针寻找其他凸包上的点，每次找到一个点，再从该点出发继续寻找，寻找时是通过连线夹角判断是否为凸包上的点的</li>
<li>Graham 扫描法先找到一个凸包上的点，然后以该点为原点对其他点做平移，然后根据各点相对于原点的辐角和距离排序，然后扫描该序列中的点，利用类似单调栈的思路维护凸包点，直到扫描完全部点</li>
</ul>
<h4 id="向量点乘和叉乘的几何意义"><a href="#向量点乘和叉乘的几何意义" class="headerlink" title="向量点乘和叉乘的几何意义"></a>向量点乘和叉乘的几何意义</h4><p>点乘代表一个向量在另一个向量方向上的投影，同时也可以快速求得两向量的夹角，进而判断向量是否同向等等；</p>
<p>叉乘得到的自然是平面法向量，此外叉乘向量的模是两向量构成的平行四边形的面积。</p>
<h4 id="判断点在三角形内的方法"><a href="#判断点在三角形内的方法" class="headerlink" title="判断点在三角形内的方法"></a>判断点在三角形内的方法</h4><p>向量叉乘，判断 z 坐标是否同向</p>
<p>代数几何判断点和直线的位置，本质上和向量叉乘一样</p>
<p>重心坐标，其实就是求面积，三个小三角形面积和为大三角形面积说明点在内部，其实就是重心坐标非负</p>
<h4 id="判断点在矩形内部的方法"><a href="#判断点在矩形内部的方法" class="headerlink" title="判断点在矩形内部的方法"></a>判断点在矩形内部的方法</h4><p>同样是叉乘，判断点在四条边的内部即可</p>
<p>面积法也可以，可以看作是重心坐标的推广</p>
<h4 id="如何判断凸多边形"><a href="#如何判断凸多边形" class="headerlink" title="如何判断凸多边形"></a>如何判断凸多边形</h4><p>逆时针遍历每三个点，判断点在前两个点连线的哪一侧，都在左侧就是凸多边形，都在右侧就是凹多边形</p>
<p>向量叉乘，每三个点组成两个向量，依次叉乘，结果都为正方向为凸多边形</p>
<p>也可以对多边形求凸包，凸包点数和多边形顶点数一样就是凸多边形，少于多边形点数就是凹多边形，但是这种方法没必要</p>
<h4 id="叉乘求多边形面积"><a href="#叉乘求多边形面积" class="headerlink" title="叉乘求多边形面积"></a>叉乘求多边形面积</h4><p>叉乘求的是有向面积，只要逆时针每三个点求叉乘再累加起来就是多边形面积的二倍。</p>
<h4 id="空间两直线的距离"><a href="#空间两直线的距离" class="headerlink" title="空间两直线的距离"></a>空间两直线的距离</h4><p>可以查看<a href="https://blog.csdn.net/zhyh1435589631/article/details/52960121">求空间两条直线之间的距离</a>，主要分为两种情况：</p>
<ul>
<li>平行直线间的距离，相当于求点到直线的距离</li>
<li>异面不平行直线距离，求两条直线上任意两点间连线在两直线方向向量叉乘方向上的投影长度</li>
</ul>
<h4 id="点到三角形的最近距离"><a href="#点到三角形的最近距离" class="headerlink" title="点到三角形的最近距离"></a>点到三角形的最近距离</h4><p>求点和三角形任意一点连线在三角形平面法向上的投影长度即可，平面法向通过三角形三点叉乘可以得到</p>
<h4 id="给定法线和入射光线求反射光线"><a href="#给定法线和入射光线求反射光线" class="headerlink" title="给定法线和入射光线求反射光线"></a>给定法线和入射光线求反射光线</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/">【RayTracer】（五）金属材质</a>中的 3.1 部分</p>
<h4 id="行列式为-0-有什么意义"><a href="#行列式为-0-有什么意义" class="headerlink" title="行列式为 0 有什么意义"></a>行列式为 0 有什么意义</h4><p>行列式的几何意义和叉乘一样，都代表面积（二维）或者体积（三维），为 0 意味着二维中中两向量重合或者三位重量平面重合，具体的行列式几何意义可以查看<a href="https://www.cnblogs.com/AndyJee/p/3491487.html">【线性代数的几何意义】行列式的几何意义</a></p>
<h4 id="齐次坐标的意义"><a href="#齐次坐标的意义" class="headerlink" title="齐次坐标的意义"></a>齐次坐标的意义</h4><p>为了让所有变换都表示成矩阵向量乘法的形式，引入了齐次坐标。</p>
<p>关于齐次坐标可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>的 1.3 部分</p>
<h4 id="光线和球体求交点及优化"><a href="#光线和球体求交点及优化" class="headerlink" title="光线和球体求交点及优化"></a>光线和球体求交点及优化</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E7%89%A9%E4%BD%93%E7%B1%BB/">【RayTracer】（二）实现物体类</a></p>
<h4 id="光线和三角形求交点"><a href="#光线和三角形求交点" class="headerlink" title="光线和三角形求交点"></a>光线和三角形求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>的 3.3 部分</p>
<h4 id="光线和-AABB-求交点"><a href="#光线和-AABB-求交点" class="headerlink" title="光线和 AABB 求交点"></a>光线和 AABB 求交点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>第 4 部分</p>
<h4 id="M-矩阵对模型的变换顺如何确定"><a href="#M-矩阵对模型的变换顺如何确定" class="headerlink" title="M 矩阵对模型的变换顺如何确定"></a>M 矩阵对模型的变换顺如何确定</h4><p>M 矩阵将模型坐标从模型空间变换到世界空间，一般涉及缩放、旋转、平移三种操作，操作顺序不同得到的变换结果也不同，一般要先缩放、后旋转最后平移，因为在物体刚刚放入世界坐标系的时候使用的是本地坐标，也就是本地和全局坐标系的原点和坐标轴都是重合的，此时所有物体都“把世界坐标系当做自己的本地坐标系”。而经过了坐标变换之后：</p>
<ul>
<li>缩放变换不改变坐标轴的走向，也不改变原点的位置，所以两个坐标系仍然重合。</li>
<li>旋转变换改变坐标轴的走向，但不改变原点的位置，所以两个坐标系坐标轴不再处于相同走向。</li>
<li>平移变换不改变坐标轴走向，但改变原点位置，两个坐标系原点不再重合。</li>
</ul>
<p>这样就可以解释问什么缩放不能在旋转之后，而缩放和旋转都不能在平移之后了。 于是符合直觉的的顺序只能是 缩放 -&gt; 旋转 -&gt; 平移 。</p>
<h4 id="法线矩阵是什么"><a href="#法线矩阵是什么" class="headerlink" title="法线矩阵是什么"></a>法线矩阵是什么</h4><p>法线变换矩阵是原变换矩阵的逆转置，具体可以查看<a href="https://blog.csdn.net/Qinhaifu/article/details/102476692">法线矩阵</a>以及笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a></p>
<h4 id="为什么矩阵-4-维但向量只用-3-维就可以"><a href="#为什么矩阵-4-维但向量只用-3-维就可以" class="headerlink" title="为什么矩阵 4 维但向量只用 3 维就可以"></a>为什么矩阵 4 维但向量只用 3 维就可以</h4><p>向量的齐次坐标第 4 维为 0，矩阵 4 维是为了可以同时对向量和点进行变换，对于向量不存在平移变化，所以三维就够了</p>
<h4 id="特征值和特征向量的意义"><a href="#特征值和特征向量的意义" class="headerlink" title="特征值和特征向量的意义"></a>特征值和特征向量的意义</h4><p>查看<a href="https://blog.csdn.net/qq_32742009/article/details/82217051">矩阵的特征向量、特征值及其含义</a></p>
<h4 id="正交矩阵的特征"><a href="#正交矩阵的特征" class="headerlink" title="正交矩阵的特征"></a>正交矩阵的特征</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/120170892">正交矩阵学习小结</a></p>
<h4 id="旋转矩阵的特征值"><a href="#旋转矩阵的特征值" class="headerlink" title="旋转矩阵的特征值"></a>旋转矩阵的特征值</h4><p>三维旋转矩阵的特征值为 1 和与旋转角有关的一对共轭复数，具体可以查看<a href="https://blog.csdn.net/lewif/article/details/105110720">坐标变换(7)—旋转矩阵和特征向量</a></p>
<h4 id="欧拉角和万向锁"><a href="#欧拉角和万向锁" class="headerlink" title="欧拉角和万向锁"></a>欧拉角和万向锁</h4><p>欧拉角优势在于简单，但旋转顺序影响结果并且存在万向锁问题，四元数可以解决万向锁问题</p>
<h4 id="四元数的概念、作用和插值方法"><a href="#四元数的概念、作用和插值方法" class="headerlink" title="四元数的概念、作用和插值方法"></a>四元数的概念、作用和插值方法</h4><p>四元数的概念和理解查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/03/20200303-%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%9B%9B%E5%85%83%E6%95%B0/">【计算机图形学】（二）旋转与四元数</a></p>
<p>四元数的球面线性插值查看<a href="https://blog.csdn.net/weixin_42595073/article/details/100704061">四元数的插值方法</a></p>
<h4 id="最小二乘法的几何意义"><a href="#最小二乘法的几何意义" class="headerlink" title="最小二乘法的几何意义"></a>最小二乘法的几何意义</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqaure method）</a></p>
<h4 id="矩阵特征值分解和奇异值分解"><a href="#矩阵特征值分解和奇异值分解" class="headerlink" title="矩阵特征值分解和奇异值分解"></a>矩阵特征值分解和奇异值分解</h4><p>特征值分解只适用于方阵，奇异值分解适用于任意矩阵</p>
<p>查看<a href="https://zhuanlan.zhihu.com/p/480389473">【彻底搞懂】矩阵奇异值分解（SVD）</a>和<a href="https://zhuanlan.zhihu.com/p/122259109">强大的矩阵奇异值分解(SVD)</a></p>
<h4 id="多元函数全微分"><a href="#多元函数全微分" class="headerlink" title="多元函数全微分"></a>多元函数全微分</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/485956707">通俗理解多元函数的全微分</a></p>
]]></content>
      <categories>
        <category>知识汇总</category>
      </categories>
      <tags>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识汇总】图形学和API相关</title>
    <url>/LycTechStack.github.io/2022/07/02/20220702-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E5%9B%BE%E5%BD%A2%E5%AD%A6%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>本篇总结图形学相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p>
<p><em><span id="more"></span></em></p>
<h4 id="GPU-渲染管线"><a href="#GPU-渲染管线" class="headerlink" title="GPU 渲染管线"></a>GPU 渲染管线</h4><p>可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/">【Real-Time Rendering】图形渲染管线</a> 和 <a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-GPU%E7%AE%A1%E7%BA%BF/">【Real-Time Rendering】GPU 管线</a></p>
<p>图形渲染管线是抽象的图像渲染流程，GPU 渲染管线是现代 GPU 对该流程的具体实现。</p>
<h4 id="图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵"><a href="#图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵" class="headerlink" title="图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵"></a>图形渲染过程中有哪些坐标空间？他们是如何进行变换的？具体的矩阵</h4><p>包括模型空间、世界空间、观察空间、裁剪空间、NDC和屏幕空间</p>
<p>M 变换从模型空间到世界空间</p>
<p>V 变换从世界空间到观察空间</p>
<p>P 变换从观察空间到裁剪空间</p>
<p>透视除法从裁剪空间到 NDC</p>
<p>视口变换从 NDC 到屏幕空间</p>
<p>各种矩阵的推导查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/">【光栅化渲染器】（三）变换与深度测试</a></p>
<h4 id="变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化"><a href="#变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化" class="headerlink" title="变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化"></a>变换过程中的坐标系哪些是左手系哪些是右手系，为什么会发生变化</h4><p>模型空间和世界空间是什么坐标系不重要，描述的都是一样的世界，但观察空间就取决于我们的定义了，OpenGL 中模型、世界、相机坐标系使用的都是右手系，即沿 -Z 轴方向观察，经过投影之后变换到裁剪空间是左手系，因为在观察空间中，沿 -Z 方向观察，距离我们近的物体 Z 坐标更大，距离我们远的物体 Z 坐标更小，经过投影矩阵的变换，所有物体的 Z 坐标被变换到 -w 到 w 之间，其中较大的  Z 值 被映射到 -w，较小的 Z 值被映射到 w，也就是距离我们近的物体 Z 会更小，距离我们远的物体 Z 会更大，这正是左手坐标系的 Z 轴走向。</p>
<h4 id="正交投影和透视投影有什么区别"><a href="#正交投影和透视投影有什么区别" class="headerlink" title="正交投影和透视投影有什么区别"></a>正交投影和透视投影有什么区别</h4><p>正交投影的视锥体是一个立方体，进行的是平行投影，相当于只做了平移和缩放，透视投影的视锥体是一个四棱台，近大远小，本质上相当于利用 Z 坐标对其他坐标进行了缩放。</p>
<h4 id="NDC-是什么"><a href="#NDC-是什么" class="headerlink" title="NDC 是什么"></a>NDC 是什么</h4><p>归一化设备坐标系，x 和 y 都是 -1 到 1 之间，Z 在 -1 到 1 （OpenGL）或 0 到 1 之间（DirectX），方便通过视口变换得到屏幕坐标。</p>
<h4 id="视口变换的作用是什么，空间的维度是如何变化的"><a href="#视口变换的作用是什么，空间的维度是如何变化的" class="headerlink" title="视口变换的作用是什么，空间的维度是如何变化的"></a>视口变换的作用是什么，空间的维度是如何变化的</h4><p>视口变换将 NDC 坐标变换到屏幕空间上，也叫屏幕映射，虽然屏幕坐标可以认为是二维的，但是依然保留了每个片段的深度。</p>
<h4 id="顶点着色器的作用"><a href="#顶点着色器的作用" class="headerlink" title="顶点着色器的作用"></a>顶点着色器的作用</h4><p>顶点着色器用于进行顶点处理，必须完成的就是将顶点坐标变换到裁剪空间，也可以做顶点的着色、移动等处理。</p>
<h4 id="片元和像素的区别"><a href="#片元和像素的区别" class="headerlink" title="片元和像素的区别"></a>片元和像素的区别</h4><p>片元是像素的候选</p>
<h4 id="逐顶点光照和逐片元光照"><a href="#逐顶点光照和逐片元光照" class="headerlink" title="逐顶点光照和逐片元光照"></a>逐顶点光照和逐片元光照</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/09/20220309-%E7%9D%80%E8%89%B2/">【计算机图形学】（六）着色</a></p>
<h4 id="光栅化的作用"><a href="#光栅化的作用" class="headerlink" title="光栅化的作用"></a>光栅化的作用</h4><p>生成片元。找到三角形覆盖哪些像素，生成对应的片元。</p>
<h4 id="常用的光栅化算法"><a href="#常用的光栅化算法" class="headerlink" title="常用的光栅化算法"></a>常用的光栅化算法</h4><p>扫描线和边界函数算法，具体查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/">【光栅化渲染器】（二）框架搭建</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/25/20220525-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%94%B9%E8%BF%9B%E5%85%89%E6%A0%85%E5%8C%96/">【光栅化渲染器】（九）改进光栅化</a></p>
<h4 id="Phong-和-Blinn-Phong-的区别，为什么这么改进"><a href="#Phong-和-Blinn-Phong-的区别，为什么这么改进" class="headerlink" title="Phong 和 Blinn Phong 的区别，为什么这么改进"></a>Phong 和 Blinn Phong 的区别，为什么这么改进</h4><p>区别在于高光项的计算，改进的原因一方面在于计算量，另一方面因为视线方向可能和反射方向夹角大于 90 度，从而导致高光截断或者过渡不自然，而正常情况下半程向量和法线夹角不可能大于 90 度，从而使得高光过度更加自然。</p>
<h4 id="走样产生的原因，如何解决"><a href="#走样产生的原因，如何解决" class="headerlink" title="走样产生的原因，如何解决"></a>走样产生的原因，如何解决</h4><p>光栅化的走样和纹理走样</p>
<p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/">【计算机图形学】（四）反走样</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/">【计算机图形学】（七）纹理映射</a></p>
<h4 id="MipMap-的作用、原理、如何确定使用哪一层"><a href="#MipMap-的作用、原理、如何确定使用哪一层" class="headerlink" title="MipMap 的作用、原理、如何确定使用哪一层"></a>MipMap 的作用、原理、如何确定使用哪一层</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/">【计算机图形学】（七）纹理映射</a></p>
<h4 id="法线贴图的种类，优缺点"><a href="#法线贴图的种类，优缺点" class="headerlink" title="法线贴图的种类，优缺点"></a>法线贴图的种类，优缺点</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/">【Real-Time Rendering】纹理总结</a>第七部分</p>
<h4 id="伽马校正是什么，为什么需要"><a href="#伽马校正是什么，为什么需要" class="headerlink" title="伽马校正是什么，为什么需要"></a>伽马校正是什么，为什么需要</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/">【RayTracer】（四）漫反射材质</a>第三部分</p>
<h4 id="HDR-和色调映射，常用的映射算法"><a href="#HDR-和色调映射，常用的映射算法" class="headerlink" title="HDR 和色调映射，常用的映射算法"></a>HDR 和色调映射，常用的映射算法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">【Real-Time Rendering】基于图像的渲染技术总结</a>第 10 部分</p>
<h4 id="Shadow-Map-的实现、缺点、有哪些改进"><a href="#Shadow-Map-的实现、缺点、有哪些改进" class="headerlink" title="Shadow Map 的实现、缺点、有哪些改进"></a>Shadow Map 的实现、缺点、有哪些改进</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/">【高质量实时渲染】实时阴影</a></p>
<h4 id="PCF-和-PCSS"><a href="#PCF-和-PCSS" class="headerlink" title="PCF 和 PCSS"></a>PCF 和 PCSS</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/">【高质量实时渲染】实时阴影</a></p>
<h4 id="常用的抗锯齿方法"><a href="#常用的抗锯齿方法" class="headerlink" title="常用的抗锯齿方法"></a>常用的抗锯齿方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/">【Real-Time Rendering】图形渲染和视觉处理</a>第三部分和<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/06/20220306-%E5%8F%8D%E8%B5%B0%E6%A0%B7/">【计算机图形学】（四）反走样</a></p>
<h4 id="什么是模板测试"><a href="#什么是模板测试" class="headerlink" title="什么是模板测试"></a>什么是模板测试</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/">【Real-Time Rendering】模板测试和深度测试</a></p>
<h4 id="透明度混合和透明度测试"><a href="#透明度混合和透明度测试" class="headerlink" title="透明度混合和透明度测试"></a>透明度混合和透明度测试</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/">【Unity Shader】（三）透明效果</a></p>
<h4 id="各种物体的的渲染顺序"><a href="#各种物体的的渲染顺序" class="headerlink" title="各种物体的的渲染顺序"></a>各种物体的的渲染顺序</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/">【Unity Shader】（三）透明效果</a></p>
<h4 id="顺序无关的透明渲染算法"><a href="#顺序无关的透明渲染算法" class="headerlink" title="顺序无关的透明渲染算法"></a>顺序无关的透明渲染算法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/13/20220513-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A7%86%E8%A7%89%E5%A4%96%E8%A7%82/">【Real-Time Rendering】图形渲染和视觉处理</a>第 4 部分</p>
<h4 id="compute-shader-是干嘛的"><a href="#compute-shader-是干嘛的" class="headerlink" title="compute shader 是干嘛的"></a>compute shader 是干嘛的</h4><p>在图形管线之外的，但可以将计算数据传入管线或回传给自己，实现利用 GPU 进行通用计算任务</p>
<h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>经典渲染方程和实时渲染中的渲染方程（带 visibility 项）</p>
<h4 id="BRDF-简介"><a href="#BRDF-简介" class="headerlink" title="BRDF 简介"></a>BRDF 简介</h4><p>描述入射光和出射光关系的函数，分为经验模型、物理模型和测量模型，各类常用的模型举例，以及各向同性各向异性</p>
<p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-BRDF%E6%80%BB%E7%BB%93/">【Real-Time Rendering】BRDF 总结</a></p>
<h4 id="菲涅尔项-F0-的意义"><a href="#菲涅尔项-F0-的意义" class="headerlink" title="菲涅尔项 F0 的意义"></a>菲涅尔项 F0 的意义</h4><p>F0 是基础反射率，与介质的折射率有关，可以代表物体本身的颜色，从 SG 模型的 Specular 纹理中得到或者从 MR 模型的 base color 纹理中采样再经过 metalic 插值得到</p>
<h4 id="PBR-的原理"><a href="#PBR-的原理" class="headerlink" title="PBR 的原理"></a>PBR 的原理</h4><p>基于物理的渲染，关键在于能量守恒，菲涅尔项和 BRDF 的计算（cook-torrance 模型）</p>
<h4 id="PBR-的计算需要哪些量"><a href="#PBR-的计算需要哪些量" class="headerlink" title="PBR 的计算需要哪些量"></a>PBR 的计算需要哪些量</h4><p>基础反射率 F0，粗糙程度，光线和法线夹角，观察方向和法线夹角</p>
<h4 id="光线追踪和路径追踪"><a href="#光线追踪和路径追踪" class="headerlink" title="光线追踪和路径追踪"></a>光线追踪和路径追踪</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>、<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十三）路径追踪</a>、<a href="https://lz328.github.io/LycTechStack.github.io/2022/06/09/20220609-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【高质量实时渲染】实时光线追踪</a></p>
<h4 id="蒙特卡洛积分方法"><a href="#蒙特卡洛积分方法" class="headerlink" title="蒙特卡洛积分方法"></a>蒙特卡洛积分方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/24/20220424-RayTracer-%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7/">【RayTracer】（十八）重要性采样</a></p>
<h4 id="延迟渲染的原理，对比正向渲染，延迟渲染的改进"><a href="#延迟渲染的原理，对比正向渲染，延迟渲染的改进" class="headerlink" title="延迟渲染的原理，对比正向渲染，延迟渲染的改进"></a>延迟渲染的原理，对比正向渲染，延迟渲染的改进</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/">【Real-Time Rendering】延迟渲染总结</a></p>
<h4 id="延迟渲染和-MSAA"><a href="#延迟渲染和-MSAA" class="headerlink" title="延迟渲染和 MSAA"></a>延迟渲染和 MSAA</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/">【Real-Time Rendering】延迟渲染总结</a></p>
<h4 id="一些提高渲染效率的方法"><a href="#一些提高渲染效率的方法" class="headerlink" title="一些提高渲染效率的方法"></a>一些提高渲染效率的方法</h4><p>固定视角渲染只渲染一次固定物体，剔除被 UI 遮挡的物体</p>
<p>双缓冲或者三重缓冲保持帧率稳定</p>
<p>其他查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/">【Real-Time Rendering】渲染加速技术总结</a></p>
<h4 id="如何优化-shader-代码"><a href="#如何优化-shader-代码" class="headerlink" title="如何优化 shader 代码"></a>如何优化 shader 代码</h4><p>尽量避免分支语句、条件判断和循环，尽量减少纹理采样次数，减少复杂数学函数调用，少在片段着色器做矩阵运算，降低浮点数精度等</p>
<p>具体查看<a href="https://zhuanlan.zhihu.com/p/210221918">Shader中的代码优化原理分析</a></p>
<h4 id="GLFW-的作用"><a href="#GLFW-的作用" class="headerlink" title="GLFW 的作用"></a>GLFW 的作用</h4><p>用于创建窗口，创建 OpenGL 上下文、接收一些鼠标键盘事件的第三方库</p>
<p>所谓上下文是指保存了一系列的变量用来描述 OpenGL 此刻需要如何运行的信息，因为 OpenGL 本身就是一个非常庞大的状态机(State Machine) ，其状态通常被称为 OpenGL 上下文(Context)，应用程序中可以创建多个不同的上下文，他们分别在各自的线程中使用。上下文之间共享纹理，缓冲区等资源，采用这中方案更为高效，因为它避免了反复切换上下文，或者大量修改渲染状态所造成的较大的开销。</p>
<h4 id="GLAD-和-GLEW"><a href="#GLAD-和-GLEW" class="headerlink" title="GLAD 和 GLEW"></a>GLAD 和 GLEW</h4><p>对底层 OpenGL 接口的封装，可以让代码跨平台</p>
<h4 id="DirectX-和-OpenGL"><a href="#DirectX-和-OpenGL" class="headerlink" title="DirectX 和 OpenGL"></a>DirectX 和 OpenGL</h4><p>查看<a href="https://cloud.tencent.com/developer/article/1532783">微软DirectX和OpenGL的区别（比较详细）</a></p>
<p>总结来说 OpenGL 只提供核心的渲染功能，至于窗口显示，设备输入处理等都需要第三方库，但 OpenGL 有良好的跨平台特性</p>
<p>DirectX 并不是一个单纯的图形API，它是由微软公司开发的用途广泛的API，它可让以 windows 为平台的游戏或多媒体程序获得更高的执行效率，加强 3d 图形和声音效果。</p>
<h4 id="后处理方法"><a href="#后处理方法" class="headerlink" title="后处理方法"></a>后处理方法</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">【Unity Shader】（七）基础屏幕特效</a>和<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">【Unity Shader】（八）高级屏幕特效</a></p>
<h4 id="NPR-基本原理、描边算法"><a href="#NPR-基本原理、描边算法" class="headerlink" title="NPR 基本原理、描边算法"></a>NPR 基本原理、描边算法</h4><p><a href="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/">【Unity Shader】（九）非真实感渲染</a></p>
<h4 id="利用深度和屏幕坐标算世界坐标"><a href="#利用深度和屏幕坐标算世界坐标" class="headerlink" title="利用深度和屏幕坐标算世界坐标"></a>利用深度和屏幕坐标算世界坐标</h4><p>利用屏幕坐标得到 NDC 坐标，或者将纹理坐标映射到 NDC 坐标 -1 到 1 范围内，再乘以投影矩阵的逆矩阵得到投影前的坐标，记得除以 w 值进行坐标归一化，然后再乘以 V 矩阵的逆矩阵得到世界空间坐标</p>
<p>具体查看<a href="https://blog.csdn.net/ag_cill/article/details/61428172">Unity根据深度值计算世界坐标</a></p>
<h4 id="深度精度问题和-reversed-Z"><a href="#深度精度问题和-reversed-Z" class="headerlink" title="深度精度问题和 reversed-Z"></a>深度精度问题和 reversed-Z</h4><p>查看<a href="https://www.cnblogs.com/jackmaxwell/p/6851728.html">Reversed-Z详解</a>和<a href="https://juejin.cn/post/6844904053193834503">Depth精度问题分析</a></p>
<h4 id="延迟渲染具体实现"><a href="#延迟渲染具体实现" class="headerlink" title="延迟渲染具体实现"></a>延迟渲染具体实现</h4><p>查看<a href="https://blog.csdn.net/lengyoumo/article/details/104489830"> unity shader 实现延迟渲染代码加注释</a></p>
<h4 id="延迟渲染实现-AO"><a href="#延迟渲染实现-AO" class="headerlink" title="延迟渲染实现 AO"></a>延迟渲染实现 AO</h4><p>查看<a href="https://zhuanlan.zhihu.com/p/86443667">SSAO 屏幕空间环境光遮蔽（与延迟渲染的pass结合）</a></p>
<p>简单来说就是利用 G-Buffer 中的信息生成一张 AO 贴图，之后在渲染 Pass 中利用这张帖图乘到光照结果上即可</p>
<h4 id="Unity-有哪些管线"><a href="#Unity-有哪些管线" class="headerlink" title="Unity 有哪些管线"></a>Unity 有哪些管线</h4><p>Unity 提供以下渲染管线：</p>
<ul>
<li><a href="https://docs.unity.cn/cn/2019.4/Manual/built-in-render-pipeline.html">内置渲染管线</a>是 Unity 的默认渲染管线。这是通用的渲染管线，其自定义选项有限。</li>
<li><a href="https://docs.unity.cn/cn/2019.4/Manual/universal-render-pipeline.html">通用渲染管线 (URP)</a> 是一种可快速轻松自定义的可编程渲染管线，允许您在各种平台上创建优化的图形。</li>
<li><a href="https://docs.unity.cn/cn/2019.4/Manual/high-definition-render-pipeline.html">高清渲染管线 (HDRP)</a> 是一种可编程渲染管线，可让您在高端平台上创建出色的高保真图形。</li>
<li>可以使用 Unity 的可编程渲染管线 API 来创建自定义的<a href="https://docs.unity.cn/cn/2019.4/Manual/ScriptableRenderPipeline.html">可编程渲染管线 (SRP)</a>。这个过程可以从头开始，也可以修改 URP 或 HDRP 来适应具体需求。</li>
</ul>
<h4 id="OpenGL-的渲染管线"><a href="#OpenGL-的渲染管线" class="headerlink" title="OpenGL 的渲染管线"></a>OpenGL 的渲染管线</h4><p>和正常管线基本一致，具体查看<a href="https://www.cnblogs.com/yyxt/p/4056417.html">OpenGL渲染管线</a></p>
<h4 id="帧缓冲有哪些，什么是离屏渲染"><a href="#帧缓冲有哪些，什么是离屏渲染" class="headerlink" title="帧缓冲有哪些，什么是离屏渲染"></a>帧缓冲有哪些，什么是离屏渲染</h4><p>帧缓冲包含颜色缓冲、深度缓冲和模板缓冲，离屏渲染就是将渲染结果存到自定义的帧缓冲中进行一些后处理，再将该缓冲中的内容发送到默认缓冲显示到屏幕上。 </p>
<p>具体查看<a href="https://zhuanlan.zhihu.com/p/373993587">帧缓冲详解</a></p>
]]></content>
      <categories>
        <category>知识汇总</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎】（四）游戏引擎中的物理系统</title>
    <url>/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>物理系统是游戏引擎中最重要的逻辑系统，也是游戏引擎中极为复杂和庞大的系统，物理决定了游戏世界是否符合人对真实世界的认知，好的物理系统能让游戏可玩性大幅提升，这一节来简单了解游戏引擎中的物理系统和简单的碰撞检测思路。因为物理系统非常复杂，因此我们先学习基础的概念和思想，之后如果有必要会在专门的物理专题中进一步学习详细的算法和实现。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-物理系统的基本概念"><a href="#1-物理系统的基本概念" class="headerlink" title="1 物理系统的基本概念"></a>1 物理系统的基本概念</h3><p>在游戏引擎中，物理世界和玩家看到的游戏世界是有一定区别的，渲染和动画是为了让物理世界以更酷炫的方式呈现在玩家面前，而整个游戏世界的运行可能是像下图中右边的样子：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704104605567.png" alt="image-20220704104605567"></p>
<p>游戏世界中的所有物体在物理世界中都被称为 Actor，Actor 通常都是一些简单的几何形状，而不是精细的模型，Actor 具体分为几种类型，首先是静态的 Actor，也就是静止不动的物体，比如墙体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704104753035.png" alt="image-20220704104753035"></p>
<p>还有动态的 Actor，比如角色和 NPC：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704104828190.png" alt="image-20220704104828190"></p>
<p>还有一类特殊的 Actor 叫做触发器（Trigger），比如我们走到某个位置，门就会自动打开，或者老头环中升降梯的触发方块；最后还有一些 Actor 可能不符合现实世界的运动规律，但却是游戏性需要的，这类 Actor 称为 Kinematic。</p>
<p>这些 Actor 的形状一般都非常简单，因为物理系统需要计算物体之间的碰撞和力的作用，复杂的模型是不便于计算的，因此 Actor 一般都是球体、胶囊体、立方体等，复杂一点的还有不规则凸面体和三角形片面等：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704105231249.png" alt="image-20220704105231249"></p>
<p>一般来说游戏中比较小的物体都会用球体，而角色用胶囊体，房屋和箱子或者墙面就使用立方体，其他比较复杂的需要相对比较精细计算的物体才使用凸包等。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704105406867.png" alt="image-20220704105406867"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704105357458.png" alt="image-20220704105357458"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704105348630.png" alt="image-20220704105348630"></p>
<p>对于每一个 Actor，要进行物理计算，就需要有他们的 Shape 以及重心，还有其他物理材质属性，比如摩擦系数、弹力系数等等。</p>
<h3 id="2-物理模拟"><a href="#2-物理模拟" class="headerlink" title="2 物理模拟"></a>2 物理模拟</h3><p>物理模拟最重要的就是模拟物体在不同力作用下的运动，由于游戏中几乎不存在规则运动，因为各种力是与游戏交互息息相关的，在游戏运行之前我们不知道这些力会是什么样，因此也没有办法建立解析的物理运动模型，比如标准的圆周运动等，于是就需要根据物体当前的运动状态和力的作用，模拟物体的运动。</p>
<p>对于真实世界理想的运动，在任何时间根据位置就可以通过求导就算出速度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110022222.png" alt="image-20220704110022222"></p>
<p>但游戏世界我们不知道物体是怎样运动的，我们知道的只有物体在当前时刻的位置和速度，要以此来估算下一时刻的位置和速度，从而模拟物体的真实运动：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704105959737.png" alt="image-20220704105959737"></p>
<p>从数学上严格的来计算，下一时刻物体的位置应该是从当前时刻到下一时刻速度的积分加上当前位置：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110120510.png" alt="image-20220704110120510"></p>
<p>但我们不知道下一时刻的速度和这之间速度的变化，所以要去进行估算，显式欧拉积分的思想是利用当前时刻的力估计下一时刻的速度，然后用当前时刻的速度估算下一时刻的位置：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110255149.png" alt="image-20220704110255149"></p>
<p>但这样的问题是会使得模拟出的轨迹向外偏离，因为我们用的是当前时刻的力进行的估计，而对于圆周运动当前时刻的力肯定要比下一时刻的力的方向向外：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110406179.png" alt="image-20220704110406179"></p>
<p>由此也说明显式欧拉积分是不稳定的，很难收敛，除非步长非常小，但那样又会增大计算量，不过好处是计算简单。</p>
<p>另一种隐式欧拉积分正好相反，假设我们已知下一时刻的力和速度，来反向逼近结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110612974.png" alt="image-20220704110612974"></p>
<p>这样做相比于显式积分更加稳定，但求解也更困难。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110632409.png" alt="image-20220704110632409"></p>
<p>物理引擎中一般使用半隐式欧拉积分，即使用当前时刻的力估计下一时刻的速度，再用下一时刻的速度估计下一时刻的位置，相当于结合了显式和隐式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704110807928.png" alt="image-20220704110807928"></p>
<p>这样的方法被证明是稳定的，而且模拟结果非常好，并且易于计算。</p>
<p>当然在游戏中，物体不是一个质点，是有体积的，收到力的作用后，物体的运动也不仅仅是在世界空间的运动，还包含物体本身的旋转等运动，因此还涉及到刚体动力学的许多知识，这里就不展开了。</p>
<h3 id="3-碰撞检测"><a href="#3-碰撞检测" class="headerlink" title="3 碰撞检测"></a>3 碰撞检测</h3><p>碰撞检测一般分为两个阶段，首先是粗检测，利用 AABB 来进行初步检测，判断物体是否相交，如果相交再进行精细的计算二者的相交位置，深度等。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111213558.png" alt="image-20220704111213558"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111147867.png" alt="image-20220704111147867"></p>
<h4 id="3-1-粗检测阶段"><a href="#3-1-粗检测阶段" class="headerlink" title="3.1 粗检测阶段"></a>3.1 粗检测阶段</h4><p>粗检测阶段一般可以利用 BVH，类似于渲染中的视锥体剔除，但更好的方法是 Sort and Sweep 方法，分为两个阶段：</p>
<p>首先是 Sort 阶段，对场景中所有的 AABB 的边界在不同维度上进行排序，从而可以轻松的判断是否相交，类似于判断重复区间：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111410029.png" alt="image-20220704111410029"></p>
<p>由于场景中大部分物体的位置都是固定不变的，因此一旦排好序之后，只需要调整移动的物体在排序中的位置即可，而对于一个有序数组，调整某些元素的位置是很快的，这就是第二个 Sweep 阶段：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111521998.png" alt="image-20220704111521998"></p>
<h4 id="3-2-精细检测阶段"><a href="#3-2-精细检测阶段" class="headerlink" title="3.2 精细检测阶段"></a>3.2 精细检测阶段</h4><p>经过粗检测之后就要具体求解交点深度、位置和朝向等信息，从而施加碰撞力了，这部分求交相对比较困难，对于简单形体的 Actor 来说还比较简单，比如球体之间的求交或者胶囊体的求交：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111722150.png" alt="image-20220704111722150"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111732053.png" alt="image-20220704111732053"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111748168.png" alt="image-20220704111748168"></p>
<p>但对于凸多面体就比较困难了，这里简单了解两个算法的思路，这两个算法不仅适用于碰撞检测，还适用于其它系统。</p>
<h5 id="3-2-1-Minkowski-Difference-based-Methods"><a href="#3-2-1-Minkowski-Difference-based-Methods" class="headerlink" title="3.2.1 Minkowski Difference-based Methods"></a>3.2.1 Minkowski Difference-based Methods</h5><p>明可夫斯基和是集合论中的概念，两个集合的明可夫斯基和定义为集合中全部元素两两相加形成的新的集合：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704111957916.png" alt="image-20220704111957916"></p>
<p>对于几何中的点集来说，如果是一个无穷点集 B，比如三角形覆盖的点和一个点 A 的明可夫斯基和表示的就是点集 B 中的所有点加上点 A 所形成的新的三角形覆盖的所有点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112125293.png" alt="image-20220704112125293"></p>
<p>而一个无穷点集 B 和一条线段 A 的明可夫斯基和表示的就是点集 B 中的所有点在线段 A 方向上进行移动，所形成的新的多边形覆盖的所有点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112253484.png" alt="image-20220704112253484"></p>
<p>同理，一个无穷点集 B 和另一个无穷点集 A 的明可夫斯基和表示的就是点集 B 中的所有点在 A 各个边方向上进行移动，所形成的新的多边形覆盖的所有点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112344185.png" alt="image-20220704112344185"></p>
<p>也就是两个凸多边形的明可夫斯基和会形成一个新的凸多边形。并且这个新的凸多边形实际上就是两个凸多边形所有顶点之和所对应的点的凸包：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112514203.png" alt="image-20220704112514203"></p>
<p>有了加法自然可以定义减法，将一个点集中的所有点取反再相加即可：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112547495.png" alt="image-20220704112547495"></p>
<p>于是当两个凸多边形有交点的时候，他们的明可夫斯基差形成的凸多边形一定会过原点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112633775.png" alt="image-20220704112633775"></p>
<p>由此可以判断二者是否相交，并且可以求出相交的具体深度、位置等属性。至于如何快速判断凸多边形过原点，一个著名的方法是 GJK 算法，是通过迭代不断逼近原点的方法，这里不展开。</p>
<h5 id="3-2-2-Separating-Axis-Theorem-SAT"><a href="#3-2-2-Separating-Axis-Theorem-SAT" class="headerlink" title="3.2.2 Separating Axis Theorem (SAT)"></a>3.2.2 Separating Axis Theorem (SAT)</h5><p>分离轴算法也是常用的凸多面体求交算法，二维情况下如果两个凸多边形没有交点，那么一定存在一个轴可以使得；两个多边形的顶点分列两侧：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/04/20220704-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/image-20220704112931417.png" alt="image-20220704112931417"></p>
<p>于是遍历多边形的每条边作为轴，判断顶点和直线关系，如果存在任何一条轴能把两个多边形的顶点完全分开就说明二者没有交点，三维中的情况更加复杂一些，这里也不再赘述了。</p>
<p>碰撞检测结束后，还要根据算出来的碰撞点、力的朝向等对碰撞的物体做出响应，最简单的就是分别给物体一个力让他们分开，具体如何计算也不展开了，之后如果有必要，会在物理专题中详细学习。</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（二）线性动态规划之带维度单串问题</title>
    <url>/LycTechStack.github.io/2022/03/10/20220310-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%B8%A6%E7%BB%B4%E5%BA%A6%E5%8D%95%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="带维度单串问题"><a href="#带维度单串问题" class="headerlink" title="带维度单串问题"></a>带维度单串问题</h3><p>上一篇中的单串问题，子问题仅与位置 i 有关，也就是 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 $dp[i][k]$。其中 k 上可能有二分，贪心等算法。这类问题相比于普通单串问题要更复杂，需要多见多积累。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-经典问题：最大平均值和的分组"><a href="#1-经典问题：最大平均值和的分组" class="headerlink" title="1 经典问题：最大平均值和的分组"></a>1 经典问题：<a href="https://leetcode-cn.com/problems/largest-sum-of-averages/">最大平均值和的分组</a></h4><blockquote>
<p>问题描述：</p>
<p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成最多 k 个相邻的非空子数组 。 <strong>分数</strong>由每个子数组内的平均值的总和构成。</p>
<p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>
<p>返回我们所能得到的最大<strong>分数</strong>是多少。</p>
</blockquote>
<p>我们用 $dp[i][k]$ 表示把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数，于是 $dp[i][k]$ 在状态转移时取决于 $dp[j][k-1]$ 和 $avg(i,j-1)$，其中$j&gt;i$，$avg(i,j-1)$表示从 i 到 j-1 区间内的平均值，<strong>也就是把数组 nums[i…n-1] 分成 k 个区间所能取得的最大分数取决于把数组 nums[j…n-1] （j &gt; i）分成 k-1 个区间取得的最大分数加上从 nums[i] 到 nums[j-1] 的平均值</strong>。于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][k] = dp[j][k-1] + avg(i, j-1);</span><br></pre></td></tr></table></figure>

<p>可以看出，k状态的推导与 k-1 状态有关，因此我们先从小到大枚举k，k&#x3D;1时，$dp[i][1]$相当于不划分子区间，也就是从nums[i] 到 nums[n-1] 的平均值。在每一次枚举k时，也就相当于一个单独的单串问题，枚举 i 和 j 进行状态转移即可。</p>
<p>因为 k 状态的推导只与 k-1 状态有关，所以利用滚动数组的思想，不需要使用二维数组存储状态信息，只用一维数组即可，因为我们从小到大遍历位置 i ，每次状态转移时，比 i 大的位置 dp[j] 还存储着 k-1 时的状态，然后我们利用这个状态更新 dp[i] ，此时 dp[i] 就被更新到了 k 状态。</p>
<p>另外计算区间平均值可以利用前缀和，避免重复计算，可以在O(1)时间内算出区间平均值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和方便快速计算区间平均值</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第k次推导只与k-1的状态有关，因此只用一维数组就可以</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 初始化，相当于k=1的情况，初始化dp[i][1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = (sums[n]-sums[i])/<span class="built_in">double</span>(n-i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; ++k)    <span class="comment">//为了好理解k从2开始枚举，实际上无所谓</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//普通的单串问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], (sums[j]-sums[i])/(j-i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-经典问题：股票系列"><a href="#2-经典问题：股票系列" class="headerlink" title="2 经典问题：股票系列"></a>2 经典问题：股票系列</h4><p>股票系列问题是 $dp[i][k]$ 这种状态设计模式的经典问题。同时还包含更复杂的情况 $dp[i][k][state]$ .</p>
<h5 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。<br>你可以在某一天买入，在之后的某一天卖出，返回你能获得的最大利润 。</p>
</blockquote>
<p>股票系列的入门问题，只能买卖一次股票，因此只是一个简单的单串问题，第 k 天能够获得的最大利润只与第 k-1 天能获得的最大利润有关：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[k] = max(dp[k-1], prices[k] - minprice)</span><br></pre></td></tr></table></figure>

<p>当然因为这道题非常简单，一次遍历记录 minprice 和 maxprofits就可以解决。</p>
<h5 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们可以多次买卖股票，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>因此每天我们都只可能有两种状态，一种是持有股票，一种是不持有股票。于是定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大利润，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大利润。分别考虑这两种状态如何转移即可。</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么那么可能的转移状态为前一天已经没有股票，即 $dp[i-1][0]$，或者前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，并获得 $prices[i]$ 的收益。因此为了收益最大化，我们列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里有1股股票，那么那么可能的转移状态为前一天已经有1股股票，即 $dp[i-1][1]$，或者前一天结束的时候手里没有股票，即$dp[i-1][0]$，这时候我们要买入1股，所以总利润要减去今天的股票价格 $prices[i]$。因此可以列出如下的转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</span><br></pre></td></tr></table></figure>

<p>对于初始状态，根据状态的定义，我们可以知道第 0 天交易结束的时候 $dp[0][0]&#x3D;0$， $dp[0][1]&#x3D;-prices[0]$。</p>
<p>由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，所以最终结果返回 $dp[n-1][0]$即可。</p>
<p><strong>另外</strong>，本题使用贪心算法会更简单，但不容易想到，不过这道题中我们<strong>可以用动态规划推导出贪心算法</strong>。</p>
<p>动态规划的状态定义定义和上面的方法稍有不同，定义状态 $dp[i][0]$ 表示第 i 天交易完后手里没有股票的最大<strong>纯利润</strong>，$dp[i][1]$表示第 i 天交易完后手里持有1股股票的最大<strong>纯利润</strong>。什么是纯利润呢，也就是我们不考虑买入和卖出股票本身的花费，只考虑买入和卖出时，所获得的股票差价。比如第一天买入时价格是7，第二天卖出时价格是1，我们的纯利润就是-6。 所以按照这个状态定义，初始状态 $dp[0][0]$ 和 $dp[0][1]$ 都是0。然后我们可以重新考虑这次状态该如何转移：</p>
<ul>
<li>如果第 i 天交易完后手里没有股票，那么可能的情况是前一天已经没有股票，那么今天的纯利润就是前一天的纯利润，即 $dp[i-1][0]$，因为今天什么操作都没做；另一种情况是前一天结束的时候手里持有一股股票，即$dp[i-1][1]$，这时候我们要将其卖出，卖出后我们获得的纯利润是 $prices[i] - prices[i-1]$，于是今天的纯利润就是前一天持有1股股票的纯利润加上今天卖出后的纯利润。因此可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果第 i 天交易完后手里持有1股股票，那么可能的情况是前一天就持有1股股票，并且今天我们不卖出，那么到今天为止我们应该得到的纯利润，就是前一天的纯利润加上今天和昨天的差价，虽然我们今天没有卖出，但是还是要知道今天我们的盈亏是多少，因为每一天的盈亏加起来就是之后某一天卖出的时候我们能获得的纯利润；另一种情况就是前一天没有持有股票，今天买入，那么今天获得的纯利润就是前一天的纯利润，因为今天只是买入一股股票，也并没有收益，因此我们可以写出状态转移方程：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1] = max(dp[i-1][0], dp[i-1][1] + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>神奇事情发生了，<strong>两种情况的状态转移方程一模一样</strong>，那就说明无论我们今天是否卖出，对于我们能获得的<strong>纯利润</strong>这一个属性来说，都是一样的，要么是前一天不持股时的纯利润，要么是前一天持股的纯利润加上昨天和今天股票的差价，这二者取最大值就是我们到今天为止获得的最大纯利润。</p>
<p>于是状态方程可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp = max(dp, dp + prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>因为$dp[i][0]&#x3D;dp[i][1]$，那就可以都用 $dp$ 替换，也就得到了上面的方程，再改变一下写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp += max(0, prices[i] - prices[i-1])</span><br></pre></td></tr></table></figure>

<p>这个关系式其实代表了贪心算法的思想，那就是：要使我们最后的纯利润最大，就要保证每一天的纯利润最大。</p>
<p>因此我们只要计算每一天和前一天的差价，把所有不小于 0 的差价全加起来，也就是我们最终能获得的最大总利润了。这个过程我们不需要考虑实际是否买入和卖出，因为最后加起来就相当于一次性买入和卖出了。</p>
<p>比如题目中的例子[1, 2, 3, 4, 5]，按照贪心算法，答案很简单等于4，相当于每一天都卖出前一天再买入，但是实际的交易过程并不是进行 4 次买入和 4 次卖出，而是在第 1 天买入，第 5 天卖出。</p>
<p>关于贪心算法的正常推导思路，可以查看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">官方题解方法二</a>。</p>
<h5 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>2</strong> 次交易，但同一时间只能最多持有一股股票。例如：</p>
<p>股票价格 [1, 2, 3, 4, 5]，我们不能在第 1 天和第 2 天接连购买股票，之后第 5 天再将它们卖出。</p>
</blockquote>
<p>这一次我们不能无限次进行交易了，题目规定了最多只能交易 2 次，因此我们的状态设计要把当前交易的次数考虑进去。</p>
<p>在上一个股票问题中，我们定义的状态 $dp[i][state]$ 表示的是第 i 天我们持有 state 支股票（state等于0或1）时最大的利润，那么这次我们定义状态 $dp[i][k][state]$ 表示<strong>第 i 天我们已经购买了 k 次股票后手中还持有 state 支股票时的最大利润</strong>，其中 k 只能是0，1或者2，因为我们最多只能交易 2 次，也就代表最多只能两次买入股票。那么我们的状态转移将分为下面 4 种情况：</p>
<ul>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][1][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了一次交易（买入并卖出），并且第 i 天也没有买入， 此时最大总利润就是前一天已经购买了 1 次股票且手中持有 0 支股票时的最大总利润 $dp[i-1][1][0]$，因为我们在第 i 天什么也没有做</li>
<li>要么我们在第 i 天之前买入了一支股票，并在第 i 天卖出，完成了 1 次交易，此时最大总利润是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$ 加上卖出股票获得的 $prices[i]$</li>
</ul>
<p>因此 $dp[i][1][0]$ 取决于上面两种情况的较大者，于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>1</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][1][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前一次都没有买入股票，并在第 i 天买入，此时最大总利润就是买入股票的花费 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 1 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 1 次股票且手中持有 1 支股票时最大总利润 $dp[i-1][1][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>0</strong> 支股票时的最大总利润 $dp[i][2][0]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前已经完成了两次交易（买入并卖出），此时我们无法再进行交易，因此最大总利润就是前一天已经完成两次交易后的最大总利润 $dp[i-1][2][0]$</li>
<li>要么我们在第 i 天之前已经完成了 一次交易（买入并卖出），并且第 2 次购买了一只股票，然后在第 i 天卖出，完成第 2 次交易，此时最大总利润就是前一天已经购买了 2 次股票并且手中还持有 1 支股票时的最大总利润 $dp[i-1][2][1]$ 加上卖出股票获得的利润 $prices[i]$</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 <strong>i</strong> 天已经购买了 <strong>2</strong> 次股票，手中还持有 <strong>1</strong> 支股票时的最大总利润 $dp[i][2][1]$，这种情况下有两种可能性：</p>
<ul>
<li>要么我们在第 i 天之前完成了一次交易并且没有再进行买入，然后在第 i 天买入，此时最大总利润就是前一天已经购买了 1 次股票并且手持 0 支股票时的最大总利润 $dp[i-1][1][0]$ 加上买股票的支出 $-prices[i]$</li>
<li>要么我们在第 i 天之前买入了 2 支股票，并且第 i 天也不卖出，此时最大总利润就是前一天已经购买了 2 次股票并且手持 1 支股票时的最大总利润 $dp[i-1][2][1]$，因为我们什么操作都没有做</li>
</ul>
<p>于是可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后返回的结果自然是最后一天已经购买了 1 次或者 2 次股票后并且手中还持有 0 支股票时的最大总利润 $dp[n-1][1][0]$ 和 $dp[n-1][2][0]$ 中的最大值。</p>
<p>根据上面的状态转移方程，直接可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然第 i 天的最大总利润只与第 i - 1 天的最大总利润有关，因此不需要使用三维数组，并且因为每一天只有 4 种状态，所以我们只需要 4 个整数就可以完成动态规划推导：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp10 = <span class="number">0</span>, dp11 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp20 = <span class="number">0</span>, dp21 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp10 = <span class="built_in">max</span>(dp10, dp11 + prices[i]);</span><br><span class="line">            dp11 = <span class="built_in">max</span>(dp11, - prices[i]);</span><br><span class="line">            dp20 = <span class="built_in">max</span>(dp20, dp21 + prices[i]);</span><br><span class="line">            dp21 = <span class="built_in">max</span>(dp21, dp10 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp10, dp20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到虽然推导过程很复杂，但代码非常简洁，这也正是动态规划的魅力。</p>
<h5 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>这次我们最多可以进行 <strong>k</strong> 次交易，但同一时间只能最多持有一股股票。</p>
</blockquote>
<p>和上一题几乎一样，理解了上题的思路，本题没有难度，只是在状态转移时要遍历购买股票的次数 k ，而不是只有 2 次了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化要注意，要把第一天购买1...k次后持有1支股票的情况都初始化，和上题一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">                dp[j][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j][<span class="number">1</span>], dp[j<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j][<span class="number">0</span>]);	<span class="comment">//结果是最后一天购买1...k次股票后还持有0支股票的最大利润的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h5><blockquote>
<p>题目描述：</p>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br><strong>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</strong><br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>这道题是 股票问题 II 的变体，多了一个冷却期，状态的推导并不难，关键在于状态要定义好，详细可以看<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/">力扣官方题解</a>。</p>
<h5 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h5><blockquote>
<p>问题描述：<br>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。</p>
</blockquote>
<p>同样是 股票问题 II 的变体，现在看来非常简单。</p>
<h4 id="3-粉刷房子系列"><a href="#3-粉刷房子系列" class="headerlink" title="3 粉刷房子系列"></a>3 粉刷房子系列</h4><h5 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/">粉刷房子</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有三种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>因为只有三种颜色，比较简单，$dp[i][k](k &#x3D; 0,1,2)$表示粉刷到第 i 间房子为止，将房间 i 粉刷成颜色 k ，最小总花费，因为只有三种颜色，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + costs[i][0]</span><br><span class="line">dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + costs[i][1]</span><br><span class="line">dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + costs[i][2]</span><br></pre></td></tr></table></figure>

<p>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上前一间房子粉刷成其他两种颜色时总花费的较小者。由于房间 i 的状态只取决于房间 i-1 ，因此也不需要用矩阵存储状态，只需要两个大小为3的数组（或者6个int）就可以。</p>
<h5 id="粉刷房子-II"><a href="#粉刷房子-II" class="headerlink" title="粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/">粉刷房子 II</a></h5><blockquote>
<p>问题描述：</p>
<p>给一排房子上色，相邻房子颜色不能相同，一共有 K 种可选的颜色，每个房子上每种颜色的花费不同，找到花费最小的上色方案，返回最小总花费。</p>
</blockquote>
<p>现在有 K 种颜色，状态转移方程就没有上面那么简单了，我们要遍历每一种颜色 k，计算$dp[i][k]$，那么此时的状态转移方程应该变为：<br>$$<br>dp[i][k] &#x3D; \min_{t&#x3D;0…K,t\neq k}(dp[i-1][t]) + costs[i][k]<br>$$<br>也就是将房间 i 粉刷成颜色 k 的最小总花费等于当前房子粉刷成颜色 k 的花费加上<strong>前一间房子粉刷成除颜色 k 以外的其他 K-1 种颜色时总花费的最小者</strong>。</p>
<p>所以只要求出第 i-1 个房间所有花费的最小值即可，但如果当前颜色 k 刚好是第 i-1 个房间的最小花费对应的颜色，那此时就应该取第 i-1 个房间第二小的花费，所以对每一个房间求出最小花费 min1st 和第二小花费 min2nd 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp_second[j] = (dp_first[j] == min1st ? min2nd : min1st) + costs[i][j]</span><br></pre></td></tr></table></figure>

<h5 id="粉刷房子-III"><a href="#粉刷房子-III" class="headerlink" title="粉刷房子 III"></a><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/">粉刷房子 III</a></h5><p>有余力可以了解</p>
<h4 id="4-经典问题：鸡蛋掉落"><a href="#4-经典问题：鸡蛋掉落" class="headerlink" title="4 经典问题：鸡蛋掉落"></a>4 经典问题：<a href="https://leetcode-cn.com/problems/super-egg-drop/">鸡蛋掉落</a></h4><blockquote>
<p>问题描述：</p>
<p>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</p>
<p>已知存在楼层 f ，满足 0 &lt;&#x3D; f &lt;&#x3D; n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;&#x3D; x &lt;&#x3D; n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p>
<p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p>
</blockquote>
<p>这是一道非常经典的面试题，但是难度较大，如果是作为机试题，对动态规划和数学理论的灵活运用要求非常高，因为不仅要推导动态规划方程，还要在编码过程中对动态规划过程进行优化，否则会超时无法通过全部测试用例。而如果不用动态规划的方法，就已经达到了竞赛级别，远超出了面试难度。当然因为问题过于经典，各方大佬也想出了各种容易理解的动态规划解法。</p>
<p>但是作为面试题，理解这道题的思路还是非常有必要而且不是那么困难的，因为面试题通常不会像原题这样问，面试通常会直接问：100层楼给你2个鸡蛋，怎么得出最小操作次数？显然也不是让你当场计算出正确答案14次，毕竟这道题即使是知道算法的情况下去手算也相当复杂，所以更重要的是思路。</p>
<p>这里放几个比较容易理解的题解，方法也比较主流，可以结合起来看，熟悉思路：</p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/">鸡蛋掉落官方题解</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/">题目理解 + 基本解法 + 进阶解法</a></p>
<p><a href="https://leetcode-cn.com/problems/super-egg-drop/solution/887-by-ikaruga/">【鸡蛋掉落】5 行代码，从求扔几次变为求多少层楼</a></p>
<h4 id="5-其他带维度单串问题"><a href="#5-其他带维度单串问题" class="headerlink" title="5 其他带维度单串问题"></a>5 其他带维度单串问题</h4><ul>
<li><p><a href="https://leetcode-cn.com/problems/toss-strange-coins/">抛掷硬币</a>：比较简单的带维度单串问题</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a>：与上面的最大平均值和的分组非常相似，只是把分组的平均值改成了分组的和，然后求这些分组和最大值的最小值，整体思路完全一致，状态转移方程稍有不同，另外本题用动态规划不是最优解，用<strong>贪心+二分查找</strong>的方法时空复杂度更优秀，思路也不难理解，具体可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">分割数组的最大值官方题解方法二</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/frog-jump/solution/">青蛙过河</a>：给定一个数组表示一条河上石头所在的位置，青蛙只能向前跳，且每次跳跃的距离只能是 k-1、k、k+1 其中之一，k是上一次跳跃的步数，第一次跳一步，问青蛙是是否能过河？</p>
</li>
</ul>
<p><strong>思路</strong>：动态规划解法比较难想，并且难优化，时空复杂度也并不友好，了解即可，这道题实际上使用记忆化搜索的方法会更好，这里顺便说一下记忆化搜索的思路，因为非常简单。</p>
<p>首先这显然是一个典型回溯问题，因此很自然想到使用深搜，深搜的递归代码也很好写，只要用当前位置加上跳跃距离，然后搜索石头数组看是否存在对应的石头就行了，搜索这里可以用二分查找（因为数组一定是严格递增的），也可以用哈希表，我这里使用哈希表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;	<span class="comment">//在O（1）时间内找到下一次跳的石头是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样会超时，超时的原因在于递归的时候存在重复递归，回溯的时候会有之前已经解决的子问题被重复计算，因此我们只要把每次计算的子问题的结果存下来，之后再遇到这个子问题直接返回对应的结果就行了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">int</span>,<span class="type">bool</span>&gt;&gt; memo;	<span class="comment">//存储子问题结果</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones, <span class="type">int</span> start, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(stones[start] + step == stones[stones.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果遇到已经解决过的问题，直接返回对应结果</span></span><br><span class="line">        <span class="keyword">if</span>(memo[start].<span class="built_in">find</span>(step) != memo[start].<span class="built_in">end</span>()) <span class="keyword">return</span> memo[start][step];</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(stones[start] + step) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] = <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memo[start][step] =  <span class="built_in">judge</span>(stones, map[stones[start] + step], step + <span class="number">1</span>) ||</span><br><span class="line">                        <span class="built_in">judge</span>(stones, map[stones[start] + step], step);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start][step];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canCross</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[stones[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memo.<span class="built_in">resize</span>(stones.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(stones, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把哈希表换成二分查找还可以进一步降低空间复杂度。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/allocate-mailboxes/">安排邮筒</a>：适当了解思路</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（三）线性动态规划之双串问题</title>
    <url>/LycTechStack.github.io/2022/03/12/20220312-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8F%8C%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="双串问题"><a href="#双串问题" class="headerlink" title="双串问题"></a>双串问题</h3><p>线性动态规划的另一大类问题就是双串问题，双串问题有两个输入串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置， $dp[i][j]$ 表示第一串考虑 [0..i] ，第二串考虑 [0..j] 时原问题的解。双串问题相比于单串问题难度更大，虽然状态的定义大同小异，但是状态转移需要考虑的情况往往更加复杂。</p>
<p><em><span id="more"></span></em></p>
<p>双串问题同样分为两种情况，大多数情况下较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。此时状态转移代码常见的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1..m</span><br><span class="line">    for j = 1..n</span><br><span class="line">        dp[i][j] = f(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p>另一种情况类似单串中依赖比 i 小的 O(n) 个子问题的情况，复杂度相对更高。</p>
<h4 id="1-经典问题：LCS系列"><a href="#1-经典问题：LCS系列" class="headerlink" title="1 经典问题：LCS系列"></a>1 经典问题：LCS系列</h4><h5 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h5><blockquote>
<p>问题描述：</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
</blockquote>
<p>这是最经典的双串动态规划问题，也比较简单，定义状态 $dp[i][j]$ 表示在 text1 的 [0…i] 上和 text2 的 [0…j] 上最长公共子序列长度，于是状态转移分为两种情况：</p>
<ul>
<li>当前字符 text1[i] &#x3D;&#x3D; text2[j]，那么此时找到了公共字符，$dp[i][j]$ 就等于 $dp[i-1][j-1]$ 的基础上加 1</li>
<li>当前字符 text1[i] !&#x3D; text2[j]，那么此时二者不是公共字符，$dp[i][j]$ 取决于 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/">两个字符串的最小ASCII删除和</a></h5><blockquote>
<p>给定两个字符串<code>s1</code> 和 <code>s2</code>，返回 <em>使两个字符串相等所需删除字符的 <strong>ASCII</strong> 值的最小和</em> 。</p>
</blockquote>
<p>可以转换成最长公共子序列问题，只不过这次我们求最长公共子序列的 ASCII 值的和，然后用两个字符串的总ASCII 值的和<strong>减去两倍的最长公共子序列的 ASCII 值的和</strong>，剩下的就是删掉的 ASCII 值的最小和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeleteSum</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total_asc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) total_asc += <span class="built_in">int</span>(s1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) total_asc += <span class="built_in">int</span>(s2[j]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">int</span>(s1[i<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total_asc - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然本题也可以直接定义和原问题一致的动态规划状态，具体可以看<a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/liang-ge-zi-fu-chuan-de-zui-xiao-asciishan-chu-he-/">官方题解</a>的方法。</p>
<h5 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h5><p>和最长公共子序列的区别在于重复子数组必须是连续的，因此当前两个数不相等时，不能再继续传递 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中的较大值，而是要将 $dp[i][j]$ 置 0 ，阻断状态传递，最终的结果取所有状态中的最大值就是最长重复子数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划是本题最容易想到并实现的方法，但并不是最好的方法，本题使用滑动窗口会效率会更高，不过不容易想到且编码相对复杂一些，具体可以看<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2/">滑动窗口解法</a>。</p>
<h4 id="2-经典问题：字符串匹配系列"><a href="#2-经典问题：字符串匹配系列" class="headerlink" title="2 经典问题：字符串匹配系列"></a>2 经典问题：字符串匹配系列</h4><h5 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h5><blockquote>
<p>问题描述：<br>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对任何一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<p>编辑距离是非常经典的一个问题，并且在机器翻译、语音识别等领域也应用广泛，值得深入研究。</p>
<p>题目实际上的意思是可以对两个单词都进行操作，只要最终两个单词相同即可，但我们要保证总操作次数最少，即编辑距离最小。</p>
<p>我们首先考虑状态的定义，双串问题的状态定义之前已经说过，几乎都是一样的，因此我们定义 $dp[i][j]$ 表示从 word1[0…i] 转换成word2[0…j] 所需要的最小操作数，也就是 word1[0…i] 到 word2[0…j] 的最小编辑距离。从前向后遍历两个单词更新状态，最终 $dp[m][n]$ 就是答案。接下来考虑状态转移过程。</p>
<p>因为我们对两个单词都可以插入、删除和替换，所以一共可以进行六种操作，看起来非常复杂，但我们仔细分析一下，假设某一时刻的状态 word1[0…i] 表示成 A ，word2[0…j] 表示成 B，那么从 A 转换到 B 有以下几种情况：</p>
<ul>
<li>在 A 的末尾插入一个字母，或者在B的末尾删除一个字母。这两种操作是等价的，比如 A&#x3D;goo， B&#x3D;good，此时从 A 转换到 B 我们可以在 A 的末尾插入字母 d ，也可以把 B 末尾的 d 删掉，因此这两种操作等价；</li>
<li>在 B 的末尾插入一个字母，或者在A的末尾删除一个字母。这两种操作是等价的，理由同上；</li>
<li>在 A 中替换一个字母或者在 B 中替换一个字母。这两种操作是等价的，比如 A&#x3D;good， B&#x3D;goom，我们可以把 A 的末尾 d 替换为 m，也可以把 B 的末尾 m 替换为 d。</li>
</ul>
<p>因此所有的六种操作实际上只有三种操作，这里要说明一下为什么都在末尾操作，因为我们的状态定义 $dp[i][j]$ 表示的就是以当前字母 word1[i] 结尾的单词和 word2[j] 结尾的单词之间的最小编辑距离，此前的编辑距离都已经计算完毕并且保证最小，因此我们每次只要关注单词末尾的操作就可以了。并且这里所有操作的顺序都不会影响最终结果，无论是先插入后删除，还是先删除后插入都不影响最终结果，所以我们在末尾的操作也与顺序无关，只要关注最小操作次数即可。</p>
<p>有了以上的分析，再去进行状态转移就很简单了，因为每次我们只需要考虑三种操作的情况：</p>
<ul>
<li><p>在 A 的末尾插入一个字母（相当于在 B 的末尾删除一个字母）。假如我们已经知道了从 <code>horse</code> 到 <code>ho</code> 的最小编辑距离为 d，那么从 <code>horse</code> 到 <code>hos</code> 的最小编辑距离就是 d 加上1，因为我们可以在d次操作后将 <code>horse</code> 变为 <code>ho</code> ，此时要么在末尾加上一个字母 s ，要么把 <code>hos</code> 中的 s 删掉，二者就相同了，因此这种情况下状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-1] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 B 的末尾插入一个字母（相当于在 A 的末尾删除一个字母）。和上面的情况类似，因此状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 A 末尾替换一个字母（相当于在 B 末尾替换一个字母）。此时又分为两种情况：</p>
<ul>
<li><p>A末尾的字母和B末尾的字母相等，此时不需要任何操作，状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>A末尾的字母和B末尾的字母不相等，此时可以任意替换一次使二者相等，也就是操作一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这就是状态转移时全部可能的情况，取他们之中的最小值，就可以保证每次状态转移时都是二者之间的最小编辑距离。</p>
<p>最后讨论一下边界情况：</p>
<ul>
<li>当 i &#x3D; 0 时，word1[0…i] 为空，此时想要转化为 word2[0…j] 需要操作 j 次，要么在 word1 末尾插入 j 次， 要么在 word2 末尾删除 j 次</li>
<li>同理当 j &#x3D; 0 时，word2[0…j] 为空，此时想要转化为 word1[0…i] 需要操作 i 次</li>
<li>i 和 j 都为 0 时，编辑距离显然为0</li>
</ul>
<p>这样一来代码就很好写了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//在A末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;	<span class="comment">//在B末尾插入的情况</span></span><br><span class="line">                <span class="type">int</span> replace = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];		<span class="comment">//替换的情况</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到 $dp[i][j]$ 的状态只与$dp[i][j-1]$ 、$dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以不用二维数组保存状态，改为一维，每次更新时， $dp[i][j-1]$ 就是 $dp[j-1]$ 已经计算完毕，$dp[i-1][j]$ 就是当前正在计算的位置 $dp[j]$，同时也是下一次计算时的 $dp[i-1][j-1]$，因此再用一个额外变量记录 $dp[i-1][j-1]$ 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m = word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (n * m == <span class="number">0</span>) <span class="keyword">return</span> n + m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> p = dp[<span class="number">0</span>];  <span class="comment">//保存dp[i-1][j-1]</span></span><br><span class="line">            dp[<span class="number">0</span>] = i;  <span class="comment">//相当于之前的另一个初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> insert_a = dp[j - <span class="number">1</span>] + <span class="number">1</span>;   <span class="comment">//dp[i][j-1] + 1</span></span><br><span class="line">                <span class="type">int</span> insert_b = dp[j] + <span class="number">1</span>;   <span class="comment">//dp[i-1][j] + 1</span></span><br><span class="line">                <span class="type">int</span> replace = p;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>]) replace += <span class="number">1</span>;</span><br><span class="line">                p = dp[j];  <span class="comment">//更新dp[i-1][j-1]，上一次的dp[i-1][j]，就是下一次的dp[i-1][j-1]</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(insert_a, <span class="built_in">min</span>(insert_b, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<p>其中：<code>&#39;?&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配任意字符串（包括空字符串）。</p>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
</blockquote>
<p>这是一个比较困难的问题，状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、问号和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是问号：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：此时 s[i] 也一定匹配，但是要考虑是否消耗掉这个星号，因为一个星号可以匹配多个字母，如果消耗掉这个星号，则 <code>dp[i][j] = dp[i-1][j]</code>；如果不消耗这个星号，则 <code>dp[i][j] = dp[i][j-1]</code>，具体是否使用要看不用星号是否能够匹配，如果不用就可以匹配那就无需使用，如果不用就无法匹配了，那就必须使用，因此最终<code>dp[i][j] = dp[i-1][j] || dp[i][j-1]</code></p>
</li>
</ul>
<p>然后是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，那么只有模式串为星号才能匹配，因此模式串开头是星号的位置$dp[0][j]&#x3D;true$，其他位置都为$false$</li>
</ul>
<p>这样一来就问题就解决了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span> || s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本题用贪心法也可以，并且不需要额外的空间，具体可以查看<a href="https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/">官方题解方法二</a>，但还是以理解动态规划方法为主。</p>
<h5 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h5><blockquote>
<p>问题描述：</p>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<p>其中：<code>&#39;.&#39;</code> 可以匹配任何单个字符；<code>&#39;*&#39;</code> 可以匹配零个或多个前面的那一个元素。</p>
</blockquote>
<p>这道题是通配符匹配的进阶版，因此我们可以完全按照通配符匹配的思路来分析这道题，再去解决特殊的情况。</p>
<p>状态定义同样是 $dp[i][j]$，表示字符串 s 以 i 结尾的子串和字符模式 p 以 j 结尾的子串能否成功匹配。</p>
<p>s中只包含小写字母，p中包含小写字母、点和星号，因此状态转移对应的就是三种情况：</p>
<ul>
<li><p>s[i] 和 p[j] 都是字母：此时 <code>dp[i][j] = dp[i-1][j-1] &amp;&amp; s[i] == p[j]</code></p>
</li>
<li><p>p[j] 是点：此时 s[i] 一定匹配，因此 <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>p[j] 是星号：这时情况要比通配符更复杂一些，因为星号代表的是零个或多个前面的那一个元素，因此我们要判断 s[i] 和 p[j-1] 是否匹配：</p>
<ul>
<li><p>如果匹配，那么我们把 p[j-1] 和 p[j] 看成一个整体，此时这两个字符组成的整体的作用和通配符匹配中星号的作用完全一样，只不过是一个占用两个位置的星号，因此我们可以选择消耗掉星号来匹配s[i] ，或者不消耗掉星号，继续往后匹配，此时状态转移方程和通配符匹配中一致，不过记得这次星号占两位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] || dp[i][j-2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不匹配，同样把 p[j-1] 和 p[j] 看成一个整体相当于一个通配符中的星号，但是此时星号无作用，相当于匹配了一个空字符，直接丢掉即可，此时状态转移就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-2]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>接下来是边界条件：</p>
<ul>
<li>$dp[0][0]$ 表示两个空串，可以匹配，所以 $dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 表示模式串为空，那么字符串无论如何都无法匹配，因此 $dp[i][0] &#x3D; false$</li>
<li>$dp[0][j]$ 表示字符串为空，至于能否和模式串匹配，需要用上面的状态转移流程去判断，因此我们不需要专门去初始化，只要遍历字符串 s 时从 0 开始即可。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//判断两个位置是否匹配</span></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//动态规划推导</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">matches</span>(i, j - <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-其他双串问题"><a href="#3-其他双串问题" class="headerlink" title="3 其他双串问题"></a>3 其他双串问题</h4><h5 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a></h5><blockquote>
<p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>两个字符串 s 和 t 交错的定义与过程如下，其中每个字符串都会被分割成若干非空子字符串：</p>
<p>s &#x3D; s1 + s2 + … + sn<br>t &#x3D; t1 + t2 + … + tm<br>|n - m| &lt;&#x3D; 1<br>交错是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …<br>注意：a + b 意味着字符串 a 和 b 连接。</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s1 以 i 结尾的子串和字符串 s2 以 j 结尾的子串能否交错形成 s3 以 i+j-1 结尾的子串。</p>
<p>状态转移只有两种情况：</p>
<ul>
<li>如果 $s1[i] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s2[j] &#x3D;&#x3D; s3[i+j-1]$，那么 $dp[i][j] &#x3D; dp[i][j-1]$</li>
</ul>
<p>边界条件:</p>
<ul>
<li>$dp[0][0]&#x3D;true$</li>
<li>$dp[i][0]$ 和 $dp[0][j]$ 都相当于在和 s3 做字符串匹配，因此直接在循环中从 0 开始遍历两个字符串即可</li>
</ul>
<p>由于 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i][j-1]$ 有关，因此只需使用一维数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>(), k = s3.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m + n != k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] &amp;= (s1[i<span class="number">-1</span>] == s3[t]);	<span class="comment">//相当于dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1] == s3[t]</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] |= (s2[j<span class="number">-1</span>] == s3[t] &amp;&amp; dp[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h5><blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
</blockquote>
<p>定义状态 $dp[i][j]$ 表示字符串 s 以 i 结尾的子串中，字符串 t 以 j 结尾的子串出现的次数。</p>
<p>考虑状态转移：</p>
<ul>
<li>如果 $s[i] \neq t[j]$，则 $dp[i][j] &#x3D; dp[i-1][j]$</li>
<li>如果 $s[i] &#x3D; t[j]$，分为两种情况：<ul>
<li>使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j-1]$</li>
<li>不使用 s[i] 和 t[j] 匹配，此时 $dp[i][j] &#x3D; dp[i-1][j]$</li>
</ul>
</li>
</ul>
<p>边界条件：</p>
<ul>
<li>$dp[0][0] &#x3D; 1$，空串是任何串的子串</li>
<li>$dp[i][0] &#x3D; 1$，理由同上</li>
<li>$dp[0][j] &#x3D; 0$，空串中不包含任何一个非空子串</li>
</ul>
<p>同时考虑到，如果 t 的长度大于 s 的长度，直接返回 0 即可，因此遍历 j 的时候也只需要遍历到比 i 小即可，因为 j 大于 i 时 $dp[i][j]$ 也一定为 0.</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用unsigned long long是为了通过一些阴间用例</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, n); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] != t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/solution/">扰乱字符串</a></h5><p>有余力可以了解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（九）几何</title>
    <url>/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h2 id="几何（Geometry）"><a href="#几何（Geometry）" class="headerlink" title="几何（Geometry）"></a>几何（Geometry）</h2><p>图形学中几何是最最重要的部分之一，但同时也是极其复杂的一个课题，这一节只是对计算机图形学中几何的一些最基本的概念、算法做介绍，更加深入的图形学几何知识我们之后再去涉及。这部分内容主要包括几何的表示方式、贝塞尔曲线、分段贝塞尔曲线、B样条、贝塞尔曲面、曲面细分的几种算法和曲面简化的基本原理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-几何表示方法"><a href="#1-几何表示方法" class="headerlink" title="1 几何表示方法"></a>1 几何表示方法</h3><p>几何讨论的实际上就是计算机中如何去描述曲线或者曲面这样的几何图形，比如下图这样复杂的曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124337862.png" alt="image-20220313124337862"></p>
<p>再比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124437599.png" alt="image-20220313124437599"></p>
<p>这样复杂的物体我们几乎不可能通过建模去完成，因此需要一些方法对几何进行有效的表示。</p>
<p>几何表示方法大体分为两大类，<strong>隐式表示</strong>和<strong>显式表示</strong>。</p>
<p>隐式表示是指我们无法通过通过给定的表示方法直接知道它表示的是什么图形或者什么物体，比如我们非常熟悉的代数方程，给出一个方程我们无法直接知道这个方程表示的是什么，也很难知道哪些点在这个方程表示的物体上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313124958116.png" alt="image-20220313124958116"></p>
<p>只根据这个代数方程我们很难知道哪些点在这个物体上，但是给定任意一个点，我们根据方程可以很容易的判断它是否在这个物体上，或者在这个物体内部还是外部。</p>
<p>而显式表示是指直接给定这个几何图形上的所有点，或者给定一种参数映射规则，根据规则我们可以很容易得出哪些点在这个几何物体上，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125440581.png" alt="image-20220313125440581"></p>
<p>我们可以把二维上的点通过某种规则映射到三维形成我们要表示物体，此时我们只需要根据规则把二维坐标带入就可以得到三维物体上每一个点的坐标了，对于刚才的例子，它的一种显式表示如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313125620781.png" alt="image-20220313125620781"></p>
<p>我们只需要把某个范围内的二维坐标带入，就可以得到这个物体上每个点的三维坐标了。但是如果我们想要判断某个点是否在物体上，或者在物体的内部还是外部的时候，显式表示就没有很便捷方法能够做这样的判断了。</p>
<p>因此，隐式表示和显式表示各有优劣，在实际任务中使用什么样的表示，完全取决于我们的需求，根据不同的需求选择具有不同特性的表示方法，再利用这种表示完成我们想要的效果，这也正是几何之所以非常困难的原因。</p>
<p>接下来分别简单介绍几种隐式表示和显式表示方法。</p>
<h4 id="1-1-一些隐式表示方法"><a href="#1-1-一些隐式表示方法" class="headerlink" title="1.1 一些隐式表示方法"></a>1.1 一些隐式表示方法</h4><ul>
<li>代数表示：最常见的隐式表示方法，但是表示特别复杂的物体时会非常困难</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130323647.png" alt="image-20220313130323647"></p>
<ul>
<li>构造实体几何（Constructive Solid Geometry）：通过对一些基本几何图形进行运算操作，比如交、并、差等操作，得到复杂的几何图形</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130432128.png" alt="image-20220313130432128"></p>
<ul>
<li>距离函数（Distance Functions）：距离函数是隐式表示中非常强大的一种表示方式，所谓距离函数是指通过定义空间中任何一个点到离它最近的物体表面的距离，来定义一个物体。这样做的好处是便于不同物体之间的融合，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130703036.png" alt="image-20220313130703036"></p>
<p>两个小球的融合如果用上面的一些表示方法是没有办法表示的这么平滑的，但是距离函数可以做到。我们可以先把两个小球用距离函数表示，然后把它们的距离函数做一个融合，融合之后的新的距离函数还原为模型，就得到了平滑的融合模型。融合的过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313130910020.png" alt="image-20220313130910020"></p>
<p>A和B中阴影部分都代表某一个物体，阴影和空白的分界线自然就是这个物体的表面，因为距离函数的定义是空间中任意一点到离它最近的物体表面的距离，因此所谓两个物体的融合，其实也是两个物体表面的融合。根据距离函数的定义，A 和 B 的距离函数就是下面的 SDF(A) 和 SDF(B) 所示的样子，“o“ 代表距离为0，也就是这个物体的表面，那么当这两个距离函数融合之后，A的距离函数原本应该取正值的部分（表面的右边），会和 B 的距离函数原本取负值的部分（表面的左边）叠加起来，这样就会形成一个新的 0 平面，这个新的 0 平面就是两个物体融合后新的表面，再还原为物体自然就得到了平滑融合后的新的物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131530880.png" alt="image-20220313131530880"></p>
<ul>
<li>水平集（Level Set）：水平集也是在图像分割领域广泛应用的一种隐式表示方法，比如下图中水的涟漪就是用水平集建模表示的。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313131901065.png" alt="image-20220313131901065"></p>
<ul>
<li>自相似（Fractals）：自相似就是用自身组成自身，类似于递归</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132021023.png" alt="image-20220313132021023"></p>
<p>最后总结一下隐式表示的优缺点：</p>
<p>优点是隐式表示对简单的物体能够表示的非常准确，并且容易做内外侧的判断，也便于光线与表面关系的计算，还可以很容易的进行拓扑变换，比如流体的模拟。但缺点也很明显就是很难去对复杂的模型进行表示。</p>
<h4 id="1-2-一些显式表示方法"><a href="#1-2-一些显式表示方法" class="headerlink" title="1.2 一些显式表示方法"></a>1.2 一些显式表示方法</h4><ul>
<li>点云（Point Cloud）：最直接的显式表示方法，可以很容易地表示任何几何图形，因此目前也应用广泛。</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132554300.png" alt="image-20220313132554300"></p>
<ul>
<li>几何片面（Polygon Mesh）：图形学中使用最广泛的表示方式，也就是我们之前接触到的用三角形或者四边形片面组成一个模型：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132811559.png" alt="image-20220313132811559"></p>
<p>提供给我们的是模型上每一个片面的顶点以及它的一些属性（纹理坐标、法向量等等），还有这些顶点的组合方式，哪几个顶点组成一个片面。下面是一个模型文件（.obj）的内容：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313132918667.png" alt="image-20220313132918667"></p>
<p>其中 v就是顶点坐标，vt 是纹理坐标，vn 是法向量， f 是顶点组合方式，比如第36行的组合方式表示用第 5 个、第 1 个和第 4 个顶点组成一个三角形，三个顶点分别使用第 1 个、第 2 个、第 3 个纹理坐标，都使用第 1 个平面的法向量。</p>
<p>了解了几何的表示方式，我们接下来开始具体讨论曲线和曲面。</p>
<h3 id="2-曲线"><a href="#2-曲线" class="headerlink" title="2 曲线"></a>2 曲线</h3><p>曲线在图形学中非常重要，比如动画中摄像机的运动轨迹，我们运镜时要先定义好一个曲线，然后让相机在这个曲线上运动来拍出我们想要的效果；或者空间中一个物体运动的轨迹，我们也要事先把这个轨迹定义好。因此我们就需要有一种方法能够表示空间中任意形状的曲线，图形学中最基本的曲线表示方法就是贝塞尔曲线（Bézier Curves）。</p>
<h4 id="2-1-贝塞尔曲线（Bezier-Curves）"><a href="#2-1-贝塞尔曲线（Bezier-Curves）" class="headerlink" title="2.1 贝塞尔曲线（Bézier Curves）"></a>2.1 贝塞尔曲线（Bézier Curves）</h4><p>贝塞尔曲线就是根据给定的控制点去唯一的确定一条曲线，比如下图所示的贝塞尔曲线，给定了四个控制点 $p_0$ 、 $p_1$ 、 $p_2$ 、 $p_3$ </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313140742928.png" alt="image-20220313140742928"></p>
<p>那么所确定的这条曲线要满足几个条件：</p>
<ul>
<li>过第一个和最后一个控制点</li>
<li>曲线起始的切线方向沿 $\vec {p_1 p_0}$ 方向</li>
<li>曲线末尾的切线方向沿 $\vec {p_3 p_2}$ 方向</li>
</ul>
<p>这样就确定出了一条贝塞尔曲线。那么我们怎么样快速的根据给定的控制点确定一条贝塞尔曲线呢？</p>
<h4 id="2-2-de-Casteljau-算法"><a href="#2-2-de-Casteljau-算法" class="headerlink" title="2.2 de Casteljau 算法"></a>2.2 de Casteljau 算法</h4><p>de Casteljau 算法用来根据给定的控制点得到曲线上的点。首先我们先考虑三个控制点的情况，此时的贝塞尔曲线称为<strong>二阶贝塞尔曲线</strong>：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141409889.png" alt="image-20220313141409889"></p>
<p>对于给定的三个控制点 $b_0$​、$b_1$、$b_2$，我们将他们相邻的两两连接起来形成两条线段，假设在线段 $b_0 b_1$ 上 有一个点 $b_0^1$ 在沿着线段移动，那么这个点会把线段分为两个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313141700501.png" alt="image-20220313141700501"></p>
<p>假设线段长度为 1，那么我们可以用一个在 0 到 1 之间的系数 t 来表示点 $b_0^1$ 在线段上移动了多少，也可以理解为 t 这个时刻点 $b_0^1$ 在线段上的位置，同样我们在线段 $b_1 b_2$ 上找一个 点 $b_1^1$ ，也移动了 t 距离：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142123630.png" alt="image-20220313142123630"></p>
<p>然后连接这两个点形成线段 $b_0^1 b_1^1$，然后在这条线段上继续寻找移动了 t 距离的点 $b_0^2$</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142250287.png" alt="image-20220313142250287"></p>
<p>此时这个点无法再形成线段，那么这个点就是由这三个控制点形成的曲线上在 t 时刻的点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142400258.png" alt="image-20220313142400258"></p>
<p>于是对于任意一个 $t \in [0,1]$，都可以确定一个曲线上的点，这相当于定义了一种参数转换规则来描述这个曲线，因此贝塞尔曲线是一种显示的几何表示方法。</p>
<p>那么同样对于三阶贝塞尔曲线，有四个控制点，按照同样的方法就可以得到曲线上的点了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313142543570.png" alt="image-20220313142543570"></p>
<p>下面的动图很好地展示了这一过程（来自<a href="https://acko.net/files/fullfrontal/fullfrontal/wdcode/online.html">Making things with Maths (acko.net)</a>）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/BezierCurve.gif" alt="BezierCurve"></p>
<h4 id="2-3-贝塞尔曲线的代数表示"><a href="#2-3-贝塞尔曲线的代数表示" class="headerlink" title="2.3 贝塞尔曲线的代数表示"></a>2.3 贝塞尔曲线的代数表示</h4><p>实际上通过de Casteljau 算法，我们可以很容易写出贝塞尔曲线的代数表示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143701807.png" alt="image-20220313143701807"></p>
<p>每一个中间点都相当于线段两个端点做了一次线性插值，直到最终得到一个点，这个点就是曲线上的点。再以刚才的二阶贝塞尔曲线为例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313143831050.png" alt="image-20220313143831050"></p>
<p>可以看到 $b_0^2$ 的表达式系数就是一个完全平方展开，刚好是 $[(1-t) + t]^2$ 的展开，也就相当于 1 的二阶展开项。</p>
<p>那么我们可以写出贝塞尔曲线的一般形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144402420.png" alt="image-20220313144402420"></p>
<p>对于 n 阶贝塞尔曲线上的点，实际上是就是所有 n + 1 个控制点的加权和，加权系数是伯恩斯坦多项式，其实就是二项式系数。</p>
<p>比如对于一个三阶贝塞尔曲线，我们给定了 4 个控制点的坐标，那么根据伯恩斯坦多项式就可以确定出曲线上的点的坐标满足的关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144711137.png" alt="image-20220313144711137"></p>
<p>关于伯恩斯坦多项式，实际上就是 1 的 n 阶展开，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144740011.png" alt="image-20220313144740011"></p>
<p>在任意时刻 t，各阶伯恩斯坦多项式的值和都为 1 . </p>
<h4 id="2-4-贝塞尔曲线的性质"><a href="#2-4-贝塞尔曲线的性质" class="headerlink" title="2.4 贝塞尔曲线的性质"></a>2.4 贝塞尔曲线的性质</h4><p>贝塞尔曲线有如下的一些性质，以三阶贝塞尔曲线为例：</p>
<ul>
<li>过第一个和最后一个控制点：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313144949539.png" alt="image-20220313144949539"></p>
<ul>
<li>切线方向：这里的系数 3 是因为我们是三阶贝塞尔曲线，更高阶的系数就不一定是 3 了</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145008375.png" alt="image-20220313145008375"></p>
<ul>
<li>仿射不变性：一条贝塞尔曲线经过任意仿射变换相当于控制点经过任意仿射变换，因此我们要对贝塞尔曲线进行仿射变换无需对去线上的所有点变换，只要对控制点变换即可，但只有仿射变换满足这个性质，投影变换不满足</li>
<li>凸包性：贝塞尔曲线一定在所有控制点形成的凸包内，所谓凸包就是能涵盖所有点的最小凸多边形，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313145423691.png" alt="image-20220313145423691"></p>
<h4 id="2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）"><a href="#2-5-分段贝塞尔曲线（Piecewise-Bezier-Curves）" class="headerlink" title="2.5 分段贝塞尔曲线（Piecewise Bézier Curves）"></a>2.5 分段贝塞尔曲线（Piecewise Bézier Curves）</h4><p>贝塞尔曲线也有一定的缺点，比如对于一个 10 阶贝塞尔曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150200076.png" alt="image-20220313150200076"></p>
<p>可以看到这个曲线并没有想象中那么扭曲，而是相对平缓，这是因为高阶的贝塞尔曲线我们很难通过控制点去改变曲线的形状，因此人们发明了分段贝塞尔曲线。</p>
<p>既然高阶不好控制，那我们可以把曲线分段，每一段用一个低阶的贝塞尔曲线（通常就是 3 阶）表示，最后再把他们连接起来，就可以形成各种复杂的曲线了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150417136.png" alt="image-20220313150417136"></p>
<p>这里还有一个<a href="https://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html">demo网页</a>可以帮助我们理解分段贝塞尔曲线，可以通过拖动每一个控制点改变曲线。</p>
<p>那既然曲线连接起来了，就存在一个问题，就是两段曲线之间的连续性，比如上图中就有很多尖点显然是不连续的，但实际工程中我们希望很多复杂的曲线要严格连续，因此要定义两个贝塞尔曲线的连续性。</p>
<ul>
<li>$C^0$ 连续：前一段曲线的最后一个控制点就是后一段曲线的第一个控制点，就称两条曲线满足 $C^0$ 连续</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150812525.png" alt="image-20220313150812525"></p>
<ul>
<li>$C^1$ 连续：两段曲线的连接点是两条曲线倒数第二个控制点和第二个控制点连线的中点，实际上就是第一段曲线结尾的切线方向和第二段曲线开始的切线方向相同，也就是一阶导数严格相等。<img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313150933957.png" alt="image-20220313150933957"></li>
</ul>
<p>虽然许多时候 $C^1$ 连续已经能满足我们的要求，但有些时候我们需要更严格连续，这时就要满足 $C^2$ 或者更高阶的连续，也就是二阶导数或者更高阶导数相等。</p>
<h4 id="2-6-B样条（B-splines）"><a href="#2-6-B样条（B-splines）" class="headerlink" title="2.6 B样条（B-splines）"></a>2.6 B样条（B-splines）</h4><p>通过上面对贝塞尔曲线的了解，我们发现贝塞尔曲线有两个关键的缺点：一是改变任何一个控制点的位置，会对整条曲线产生影响，但很多时候我们并不希望如此，我们只希望在局部改变曲线形状，当然这可以由分段贝塞尔曲线来解决；另一方面就是虽然分段贝塞尔曲线能够解决局部性问题，但是改变了某一段的贝塞尔曲线，就可能会影响和这条曲线相连接的部分的曲线连续性，可能会导致曲线连续性降低。B样条就可以完美地解决这两个问题。</p>
<p>B样条实际上是贝塞尔曲线的一般化，简单来说样条就是指由一组控制点控制的曲线，B样条是 basis splines 的缩写，也就是由basis函数组成的样条，basis函数就是基函数，因此B样条就是由一组基函数表示的样条曲线。</p>
<p>对于给定的 n + 1 个控制点，贝塞尔曲线一定是 n 阶的，但是B样条并非如此，因此B样条相比于贝塞尔曲线更加灵活。具体来说，B样条可以把一个控制点的改变对于曲线形状的影响控制在一定范围内，这样就方便我们去做局部的调整了。并且B样条天然具备高阶连续性，且不必定义在固定区间 [0,1] 上，这给曲线的表征带来了极大的方便。</p>
<p>但是B样条无法表示一些基本曲线，比如圆，因此又引入了<strong>非均匀有理B样条（NURBS）</strong>，具体关于B样条的内容可以查看本篇的<strong>更多</strong>部分内容。</p>
<h3 id="3-曲面"><a href="#3-曲面" class="headerlink" title="3 曲面"></a>3 曲面</h3><h4 id="3-1-贝塞尔曲面（Bezier-Surface）"><a href="#3-1-贝塞尔曲面（Bezier-Surface）" class="headerlink" title="3.1 贝塞尔曲面（Bézier Surface）"></a>3.1 贝塞尔曲面（Bézier Surface）</h4><p>把贝塞尔曲线推广到三维，就是贝塞尔曲面，因此贝塞尔曲面同样是显式的几何表示方法。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154416556.png" alt="image-20220313154416556"></p>
<p>比如一个双三阶贝塞尔曲面，有16个控制点，我们先把每四个控制点所确定的贝塞尔曲线画出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154540370.png" alt="image-20220313154540370"></p>
<p>然后在这四条曲线上取四个点作为新的控制点就能确定一条新的贝塞尔曲线，四个新的控制点不停的移动就构建出了一个曲面。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154857224.png" alt="image-20220313154857224"></p>
<p>因此我们只要给定 $[0,1]^2$ 范围内的一个平面坐标 $(u,v)$，就可以对应到一个曲面上的点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313154817496.png" alt="image-20220313154817496"></p>
<h4 id="3-2-曲面操作"><a href="#3-2-曲面操作" class="headerlink" title="3.2 曲面操作"></a>3.2 曲面操作</h4><p>很多时候对于一个给定的模型，我们需要对模型上的曲面进行一些操作，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155114023.png" alt="image-20220313155114023"></p>
<ul>
<li>曲面细分：有时候模型上的曲面不够细时，我们想要使得模型更平滑更细节，就要对曲面进行细分，比如游戏中我们希望离我们近的模型细节更好，因此曲面要更多，离我们远的物体不需要太好的细节，就可以曲面少一些，减少性能消耗</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155628632.png" alt="image-20220313155628632"></p>
<ul>
<li>曲面简化：刚才说的不需要太好的细节的时候就可以把曲面减少一些，也就是曲面简化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155639640.png" alt="image-20220313155639640"></p>
<ul>
<li>曲面规范化：有时候我们希望模型上的三角形的差异不要那么大，都把这些三角形规范化成近似等边的三角形，会方便我们进行一些操作，这时就需要曲面规范化</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313155652970.png" alt="image-20220313155652970"></p>
<h4 id="3-3-曲面细分（Mesh-Subdivision）"><a href="#3-3-曲面细分（Mesh-Subdivision）" class="headerlink" title="3.3 曲面细分（Mesh Subdivision）"></a>3.3 曲面细分（Mesh Subdivision）</h4><h5 id="3-3-1-Loop细分"><a href="#3-3-1-Loop细分" class="headerlink" title="3.3.1 Loop细分"></a>3.3.1 Loop细分</h5><p>Loop细分（不是循环细分，是发明这个算法的人家族名字叫Loop）是一种广泛使用的曲面细分算法，但它只能对三角形曲面进行细分。如下图，细分后的曲面会变得更平滑，因此细分不是简单的把三角形拆成更多的三角形，还要调整这些小三角形的位置使得整个模型发生变化，变得如我们希望的一般平滑。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160108916.png" alt="image-20220313160108916"></p>
<p>Loop细分分为两步：</p>
<p>1、创建更多的三角形：我们取每一个三角形三条边的中点并把它们连接起来就把一个三角形分成了4个小三角形，同时也获得了三个新的顶点</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160024777.png" alt="image-20220313160024777"></p>
<p>2、调整顶点位置：在经过第一步之后所有表面的顶点被分成了两类，一类是原本就有的顶点，另一类是新创造的顶点，对于这两类顶点我们用不同的方法去调整他们的位置。</p>
<ul>
<li><p>对于新顶点，一定在原来的两个三角形公共边的中点处，于是我们用这两个三角形的四个顶点对新顶点位置进行更新，离新顶点近的两个原顶点权值更高：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160353029.png" alt="image-20220313160353029"></p>
</li>
<li><p>对于原来的顶点，既要参考周围其他点的位置，也要参考自己本身的位置，毕竟自己也是货真价实的一个顶点，因此对于任意一个原来的顶点，该点的度为 n （顶点的度就是和顶点相连的线段有几条，下图中顶点的度为 6 ），我们希望原顶点周围的顶点越多的时候，这个顶点对于自身位置的影响也就越不重要，因此顶点的更新规则为：</p>
</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313160631125.png" alt="image-20220313160631125"></p>
<h5 id="3-3-2-Catmull-Clark-细分"><a href="#3-3-2-Catmull-Clark-细分" class="headerlink" title="3.3.2 Catmull-Clark 细分"></a>3.3.2 Catmull-Clark 细分</h5><p>图灵奖得主Ed Catmull 最知名的算法之一。上面的Loop细分只能处理三角形曲面，而 Catmull-Clark 细分可以处理更一般的情况。比如既有四边形曲面又有三角形曲面的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161512896.png" alt="image-20220313161512896"></p>
<p>Catmull-Clark 细分把曲面分为四边形面和非四边形面，把顶点分为奇异点和非奇异点，所谓奇异点是指顶点的度不为 4 的点，上图中紫色的点就是奇异点。</p>
<p>Catmull-Clark 细分算法同样是先细分，再调整位置：</p>
<p>1、细分：我们每次细分时，找到每个曲面的边的中点，以及每个曲面的中心点，把这些点连接起来</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313161857299.png" alt="image-20220313161857299"></p>
<p>可以看到经过一次细分之后，对于四边形面，就是细分成了4个更小的四边形，而对三角形面，一个三角形被分成了 3 个小的四边形，也就是说<strong>经过一次细分后，就不再存在非四边形面了</strong>，同时我们注意到，原本有两个奇异点，经过一次细分后，新增加了两个奇异点，换句话说<strong>经过一次细分，所有的非四边形面都变成了一个奇异点</strong>，这样就不再存在非四边形面了，并且<strong>之后再进行细分也不会再增加奇异点个数了</strong>。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162317511.png" alt="image-20220313162317511"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162341322.png" alt="image-20220313162341322"></p>
<p>2、调整顶点位置：Catmull-Clark 细分把顶点分为三类，一类是在平面内的点（Face Point），另一类是在平面边上的点（Edge Point），最后一类是原本的顶点（Vertex point），对于这三类点的更新都是利用周围的点进行一个加权平均。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162639731.png" alt="image-20220313162639731"></p>
<h4 id="3-4-曲面简化（Mesh-Simplification）"><a href="#3-4-曲面简化（Mesh-Simplification）" class="headerlink" title="3.4 曲面简化（Mesh Simplification）"></a>3.4 曲面简化（Mesh Simplification）</h4><p>曲面简化就是减少曲面的数量，这是一个比曲面细分更复杂的问题，因为我们得保证减少了曲面数量后，模型还有原本的形状特征，而不是单纯的合并曲面。比如下面的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313162848709.png" alt="image-20220313162848709"></p>
<p>30000个三角形简化到300个三角形后丢失了很多细节但形状特征还在，如果简化到30个就完全丢失形状特征了。</p>
<p>曲面简化用到的方法叫做<strong>边缘坍缩（Edge Collapsing）</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163051056.png" alt="image-20220313163051056"></p>
<p>我们去掉一条边之后和这条边有关的两个曲面就消失了，其他曲面就会坍缩在一起，这样就达到了简化的效果，当然这个过程存在一个非常关键的问题，那就是我们选哪条边坍缩呢？肯定要选择坍缩后对原本模型的形状特征影响最小的边，也就是对周围平面的相对关系影响最小的边，那么如何衡量这种影响呢？</p>
<p>这里要用到<strong>二次误差度量（Quadric Error Metrics）</strong>，我们可以计算这条边到周围平面的L2距离，也就是距离的平方和作为这条边的分数，然后我们按照分数从小到大对边进行排序，每次都选择分数最小的边进行坍缩，也就是贪心算法的思想，当然每次坍缩完之后所有边的分数要重新计算，也就是说我们每次都要能在 O(1) 时间内找到分数最小的边，同时还能对所有边的分数进行动态更新，显然优先队列或者堆非常适合来完成这个任务。</p>
<p>下面是曲面简化的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/image-20220313163822209.png" alt="image-20220313163822209"></p>
<p>可以看到下边的小牛头部原本比较平坦，因此坍缩的边也更多，简化后形成了更大的曲面，而相对复杂的部分比如头和身体的连接处就没有进行过多的坍缩，因为这部分的边的二次度量误差一定更大，所以这里的曲面不会优先被合并。</p>
<h3 id="4-更多"><a href="#4-更多" class="headerlink" title="4 更多"></a>4 更多</h3><ul>
<li><p><a href="acko.net">Steven Wittens - Hackery, math &amp; design</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Neo11111/article/details/107922900?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&utm_relevant_index=7">B-Spline样条曲线及其性质</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/49aff913104c">B-样条曲线(B-spline Curve)总结</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_40597317/article/details/81155571">B样条曲线</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_42284263/article/details/107093255">贝塞尔曲线，B-样条，非均匀有理B样条梳理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（四）线性动态规划之矩阵和无串问题</title>
    <url>/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="1-矩阵问题"><a href="#1-矩阵问题" class="headerlink" title="1 矩阵问题"></a>1 矩阵问题</h3><p>除了数组和字符串外，矩阵也是一种线性结构，很多一维数组或字符串的问题可以推广到二维，因此矩阵上也有一些经典的动态规划问题，矩阵上的动态规划问题，基本的状态设计就是用二维变量 (i, j) 共同表示以 (0, 0) 为左上角，(i, j) 为右下角的子问题。因此矩阵问题的状态定义和双串 $dp[i][j]$ 类似，状态的推导方向以及推导公式与双串相同，但是物理意义不一样，且求解时所需的子问题的变化相对更多。</p>
<p><em><span id="more"></span></em></p>
<h4 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
</blockquote>
<p>题目中都写出来状态该如何转移了，这里就不赘述了，主要讲一下优化的思路。先观察正常思路的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp = triangle;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i) dp[i][j] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] += dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>) dp[i][j] += <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[n<span class="number">-1</span>].<span class="built_in">begin</span>(), dp[n<span class="number">-1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出 $dp[i][j]$ 只与 $dp[i-1][j]$ 和 $dp[i-1][j-1]$ 有关，因此可以利用滚动数组优化，我们只需要一个 n 大小的数组，n是三角形的层数，然后一定需要一个变量记录 $dp[i-1][j-1]$，每次$dp[j]$更新时， $dp[i-1][j]$ 就是当前的更新的位置$dp[j]$，同时需要把没更新之前的$dp[j]$记下来，作为下一次更新时的 $dp[i-1][j-1]$。对于两个特殊位置：每一次层的开头要直接把 $dp[j]$ 记下来作为下一次的$dp[i-1][j-1]$；每一层的结尾不需要记录任何数直接更新即可。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> last = dp[<span class="number">0</span>];   <span class="comment">//记录dp[i-1][j-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span>(j == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j] = triangle[i][j] + last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    last = dp[j];</span><br><span class="line">                    dp[j] = triangle[i][j] + dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> temp = dp[j];</span><br><span class="line">                    dp[j] =  triangle[i][j] + <span class="built_in">min</span>(dp[j], last);</span><br><span class="line">                    last = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">下降路径最小和</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。</p>
<p>下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。</p>
</blockquote>
<p>类似于三角路经最小和，思路不赘述。<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/">下降路径最小和 II</a>是本题的进阶版本，难度不大，但优化起来比较困难，可以了解。</p>
<p>优化时的细节：可以申请数组长度为n+2，这样可以免去边界的判断，同时要注意变量的更新顺序。优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, <span class="number">0</span>)</span></span>;	<span class="comment">//第一层全初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从第二层开始辅助位置都要设为最大值，不能还是0了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[<span class="number">0</span>] = dp[n+<span class="number">1</span>] = INT_MAX;</span><br><span class="line">            <span class="comment">//每一层起始记录dp[i-1][j-1]、dp[i-1][j]、dp[i-1][j+1]</span></span><br><span class="line">            <span class="type">int</span> left = dp[<span class="number">0</span>], mid = dp[<span class="number">1</span>], right = dp[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//之后每次更新，dp[i-1][j+1]就是dp[j+1]</span></span><br><span class="line">                right = dp[j+<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> choose = <span class="built_in">min</span>(left, <span class="built_in">min</span>(mid, right));</span><br><span class="line">                dp[j] = matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] + choose;</span><br><span class="line">                <span class="comment">//当前的mid是下一个位置的left，当前的right是下个位置的mid</span></span><br><span class="line">                left = mid;</span><br><span class="line">                mid = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时注意不要包含辅助的位置，取中间n个数求最小值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp.<span class="built_in">begin</span>()+<span class="number">1</span>, dp.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><blockquote>
<p>问题描述：</p>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
</blockquote>
<p>最经典的矩阵动态规划问题，难度不大，直接给出优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = grid[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="built_in">min</span>(dp[j<span class="number">-1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/">地下城游戏</a></h4><blockquote>
<p>问题描述：</p>
<p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
</blockquote>
<p>这是一道非常巧妙的题。按照最小路径和的思路我们定义状态 $dp[i][j]$ 表示从左上角到 $(i,j)$ 所需的最低初始生命，初始值为1，至少要有1点初始生命，之后每到一个格子只要用$dp[i-1][j]$和$dp[i][j-1]$中的最小值减去当前格子的值就可以，这个思路对于一般情况似乎没什么问题，但是如果我们在某一个格子恢复了大量生命，减去当前的格子的值再取最小那么当前格子的状态$dp[i][j]$就会是负数，这不符合我们的状态定义，这说明我们要么状态转移错了，要么状态定义错了。</p>
<p>显然按照上面的状态定义，我们的状态转移没有问题，但是计算出的值不对，说明我们的状态定义有问题。这是因为在这个问题中我们不止要考虑每一个格子上原问题的解（最低初始生命），还要考虑我们走到这个格子的时候的当前生命值，也就是路径总和，回复大量生命值的时候我们的初始最低生命还是那么多，但是当前生命值增加了，意味着下一个格子我们可能不需要增加初始最低生命就可以到达，但是按照上面的状态定义，我们无法同时考虑初始最低生命和当前生命值，也就无法向下一状态正确传递信息。</p>
<p>上面的解释比较抽象，下面我们举个例子来说明，就用题目的示例：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/15/20220315-%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E5%92%8C%E6%97%A0%E4%B8%B2/image-20220314142502341.png" alt="image-20220314142502341"></p>
<p>如果按照上面的状态定义，当我们到左下角 10 这个格子的时候，这个格子的状态 $dp[2][0] &#x3D; 8 - 10&#x3D;-2$，那么下一次到 30 格子的时候就会变成 -32，最终到达右下角的时候最低初始生命就会是-27，显然是不合理的。正确的情况是到达左下角格子 10 的时候虽然恢复了很多生命值，但是我们想要到达这里也至少还是需要8点初始生命值，那如果直接传递 8 这个状态，到右下角的时候通过-2、-5、10、30这条路径的最低初始生命值就是 8 - (-5) &#x3D; 13，依然是错误的，通过这条路径到达 右下角所需的初始最低生命就应该是8.</p>
<p>因此这样的状态定义是不对的，无法正确传递有效信息，这是因为有两个同样重要的参数在影响后一步的选择：一个是最低初始生命，一个是当前生命（路径总和），而这不符合动态规划的<strong>无后效性</strong>，因此不能使用这样的状态定义。</p>
<p>那如果改变一下定义，状态 $dp[i][j]$ 表示从 $(i,j)$ 到右下角所需的最低初始生命，我们从终点往起点推，这时我们的每一步都已经保证能到达终点，也就不需要考虑当前生命值了，只要关注从当前位置到终点的最低初始生命值即可。这时当我们再遇到回复大量生命值的格子，计算出的值是负的，这说明从这个格子到终点的生命值已经足够多了，只要我们在这个格子的时候是活着的（生命值为1）就能到达终点，因此直接将当前各自状态置 1 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dungeon.<span class="built_in">size</span>(), m = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> minn = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上一节双串问题中，状态 $dp[i][j]$ 无论表示从 0 到 i 和 j 的状态还是表示从 i 和 j 到 n - 1 的状态，都可以得出答案，但通过这道题我们发现，有时这两种状态定义并不等价，当从前往后推导无法解决问题时，可以试试从后向前推导。</p>
<h4 id="统计全为-1-的正方形子矩阵"><a href="#统计全为-1-的正方形子矩阵" class="headerlink" title="统计全为 1 的正方形子矩阵"></a><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵</a></h4><blockquote>
<p>题目描述：<br>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 子矩阵的个数。</p>
</blockquote>
<p>我们用 $dp[i][j]$ 表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值，假设这个值为 a ，同时这个值也是以 (i, j) 为右下角，且只包含 1 的正方形的个数（边长为1，2，…，a）的正方形各一个。因此算出所有 $dp[i][j]$ 后累加起来就是全部子矩阵个数。</p>
<p>那么如何计算 $dp[i][j]$ 中的每个元素值呢？对于每个位置 (i, j)，检查在矩阵中该位置的值：</p>
<ul>
<li><p>如果该位置的值是 0，则 $dp[i][j]&#x3D;0$，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li><p>如果该位置的值是 1，则 $dp[i][j]$ 的值由其上方、左方和左上方的三个相邻位置的 $dp$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：<br>$$<br>dp[i][j] &#x3D; min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1<br>$$</p>
</li>
</ul>
<p>关于这个状态转移方程的推导和证明比较复杂，可以参考<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/">统计全为 1 的正方形子矩阵官方题解</a>。</p>
<p>边界条件，如果 i 和 j 中至少有一个为 0，则以位置 (i, j) 为右下角的最大正方形的边长只能是 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSquares</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h4><blockquote>
<p>问题描述：</p>
<p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <strong>正方形</strong> 的最大面积。</p>
</blockquote>
<p>这是上一题的简化版，直接给出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-无串线性问题"><a href="#2-无串线性问题" class="headerlink" title="2 无串线性问题"></a>2 无串线性问题</h3><p>线性动态规划有一类问题是没有显式的数组或字符串的。但在计算中依然可以分成若干子问题，且有动态规划的三条性质。因此也可以用动态规划来解。</p>
<h4 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">只有两个键的键盘</a></h4><p>其实是质因数分解，用动态规划也不难，但需要额外空间。</p>
<h4 id="丑数-II"><a href="#丑数-II" class="headerlink" title="丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">丑数 II</a></h4><p>比较奇特的动态规划，很巧妙。也可以用优先队列（堆）去做，但空间复杂度更高</p>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4><p>之前用广搜做过，但广搜太暴力，空间复杂度也高，这次试试动态规划，实际上核心思路和广搜一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-j*j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h4><p>和完全平方数思路差不多，转移时要考虑的情况稍微复杂一点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[j] * (i - j), j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这是最直观暴力的动态规划做法，还有进一步优化的空间，以及时空复杂度都只需要 O(1) 的数学方法，具体可看<a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">官方题解</a>。</p>
<h3 id="3-线性动态规划总结"><a href="#3-线性动态规划总结" class="headerlink" title="3 线性动态规划总结"></a>3 线性动态规划总结</h3><p>到此为止线性动态规划的几大类就都整理完了，线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最优子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。</p>
<ul>
<li>最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li>
<li>重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）<br>线性动态规划是动态规划中变化最多的一类。</li>
</ul>
<p>首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。</p>
<p>其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。</p>
<p>例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 state，这里面变化就很多了，比如有的题目在 state 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。</p>
<p>除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。</p>
<p>如此多的变化仅仅这几篇中列举的题目是远远不够的，因此还要多见多练多记。</p>
<p>下一篇开始讨论动态规划另一大类问题：前缀和。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十一）Whitted 风格光线追踪</title>
    <url>/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>从这一节开始我们将了解图形学中的光线追踪（Ray Tracing）技术，包括经典的 Whitted 风格光线追踪技术和效果更好的路径追踪技术。并且在之后的高质量实时渲染专题中还会进一步学习最新的工业界实时光线追踪技术。</p>
<p><em><span id="more"></span></em></p>
<h2 id="Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）"><a href="#Whitted-风格光线追踪（Whitted-Style-Ray-Tracing）" class="headerlink" title="Whitted 风格光线追踪（Whitted-Style Ray Tracing）"></a>Whitted 风格光线追踪（Whitted-Style Ray Tracing）</h2><h3 id="1-为什么需要光线追踪？"><a href="#1-为什么需要光线追踪？" class="headerlink" title="1 为什么需要光线追踪？"></a>1 为什么需要光线追踪？</h3><p>之前我们学习了光栅化渲染的基本原理，光栅化中，一开始就假设了光源是点光源且光线只弹射一次，但在大多数实际场景中并不是这样的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317153639301.png" alt="image-20220317153639301"></p>
<p>Glossy 反射是指这种半磨砂材质的反射，这种材质用光栅化技术无法渲染的非常逼真，另外就是一些间接光照的场景，比如右边的图没有直接光源，但是因为光线在场景中弹射了许多次，所以我们可以看到整个场景中的各个物体。另外，上一节中我们学习了阴影映射，阴影映射生成的只能是边界清晰的硬阴影，无法生成更为逼真地软阴影。而光线追踪就可以解决以上这些问题，光线追踪尽可能地模拟光线的传播过程，对整个场景进行光照计算。</p>
<p>但并不是说光线追踪就比光栅化好，现在的大多数游戏中还是使用实时光栅渲染，因为光栅渲染的快速高效是光线追踪无法比拟的，比如 PUBG超大的地图，为了保证游戏正常运行只能使用光栅渲染，并且牺牲一些图像细节：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317154826589.png" alt="image-20220317154826589"></p>
<p>光线追踪能带来更好的画面细节，但速度慢，开销大，对硬件要求高，所以大多数情况下用来离线渲染一些动画、视频等，近些年游戏中的实时光线追踪技术我们将在另外一个专题更进一步讨论。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317155015560.png" alt="image-20220317155015560"></p>
<h3 id="2-基础光线追踪算法"><a href="#2-基础光线追踪算法" class="headerlink" title="2 基础光线追踪算法"></a>2 基础光线追踪算法</h3><p>为了之后讨论光线追踪算法更方便，我们要先对光线做一个图形学上的定义，注意这里的图形学定义大多数都不符合物理学和光学规律，但一定是符合我们人类的直觉的。我们规定：</p>
<ul>
<li>光是沿直线传播的</li>
<li>光线在发生交叉的时候不会产生碰撞，也就是光线传播互相不会产生影响</li>
<li>我们能看到物体是因为光线从光源经过一系列反射、折射达到了人的眼睛</li>
</ul>
<p>虽然上面这些定义都不一定符合物理事实，但却为我们的光线追踪算法提供了很重要的思路，尤其是最后一条，也就是我们能看到的光线一定是达到了我们眼睛的光线。</p>
<h4 id="2-1-光线投射"><a href="#2-1-光线投射" class="headerlink" title="2.1 光线投射"></a>2.1 光线投射</h4><p>根据上面的核心思想，我们能看到的光线一定是达到了我们眼睛的光线，那么我们可以从眼睛投射出一条“光线”到物体上，把这条“光线”称为视线（Eye Ray），视线将会和场景中的物体相交，把交点和光源相连就构成了一条光路，于是就说明存在一条光路使光线从光源经过物体上的这个点射进我们的眼睛。这就是光线投射的思想。</p>
<p>我们把这个思想应用到渲染过程中，我们要把场景渲染到屏幕上才能被眼睛看到，因此我们就从眼睛透过屏幕上的每一个像素向场景中投射一条视线，这条视线会与场景中的物体存在很多交点，如下图，那么肯定离屏幕最近的交点才是我们能看到的点，也就是能显示在屏幕上的点，这一步相当于把屏幕上的像素所显示的场景中的点找到，并且顺便完成了深度测试。（注意体会和光栅化的区别）</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160506856.png" alt="image-20220317160506856"></p>
<p>然后连接交点和光源，这样一来，我们相当于拥有了光线入射方向，平面法线方向和观察方向三个方向向量，那就可以计算这一点的着色了，计算完成后把这个着色显示在像素上，之后对每个像素都这么做就完成了整个渲染过程。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317160857804.png" alt="image-20220317160857804"></p>
<p>这只是光线投射的基本思想，到现在为止光线还是只弹射了一次，还谈不上“追踪”，要更真实的模拟光的传播就需要考虑光线的多次反射和折射，这就是 Whitted 风格光线追踪算法。</p>
<h4 id="2-2-Whitted风格光线追踪"><a href="#2-2-Whitted风格光线追踪" class="headerlink" title="2.2 Whitted风格光线追踪"></a>2.2 Whitted风格光线追踪</h4><p>Whitted 风格光追是按照光线投射的思路递归地进行计算，具体过程如下：</p>
<p>还是从眼睛透过屏幕上的每一个像素向场景中投射一条视线，找到与场景中的物体最近的一个交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161755801.png" alt="image-20220317161755801"></p>
<p>然后我们假设光线的反射是完美反射，也就是朝镜面反射方向传播，因此我们可以计算出反射后光线的方向，继续计算反射光线和其他物体的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317161853335.png" alt="image-20220317161853335"></p>
<p>当然如果物体是透明的，那光线不止发生反射，还会发生折射，我们还可以计算折射光线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162005677.png" alt="image-20220317162005677"></p>
<p>算出这些光线的交点之后，把这些交点全部和光源连接起来，那么这个示例场景中就形成了四条光路：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162056511.png" alt="image-20220317162056511"></p>
<p>这些光路都是可以到达我们的眼睛的，因此我们计算每个点的着色，然后全部加起来给到这个像素上作为它显示的像素值。当然这里一定不是简单的累加，光线在传播过程中会有能量损失，具体到一个物体表面会有多少能量被反射，多少能量被折射是与材质有关的，我们只要知道把这些着色值全部作为像素显示的一部分就可以了，因为这些都是可以被看到的部分。下面是光线追踪渲染的一个效果图，可以看到透明球体的折射也显示出来了，并且透明球体的阴影也要比实心球体暗一些。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317162620685.png" alt="image-20220317162620685"></p>
<p>那么了解了基本原理接下来就是解决具体的实现问题了，上面的流程中第一个要解决的问题就是如何计算视线和场景中物体的交点。</p>
<h3 id="3-光线和平面的交点"><a href="#3-光线和平面的交点" class="headerlink" title="3 光线和平面的交点"></a>3 光线和平面的交点</h3><h4 id="3-1-光线的数学定义"><a href="#3-1-光线的数学定义" class="headerlink" title="3.1 光线的数学定义"></a>3.1 光线的数学定义</h4><p>这里的光线是广义的，就是指空间中一条射线，自然也可以是视线，定义很简单，空间中只要给定一个出发点和一个发射方向（单位向量）就可以唯一确定一条射线，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163243206.png" alt="image-20220317163243206"></p>
<p>那么光线在时刻 t 所在的位置就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163324324.png" alt="image-20220317163324324"></p>
<h4 id="3-2-隐式表示求交点"><a href="#3-2-隐式表示求交点" class="headerlink" title="3.2 隐式表示求交点"></a>3.2 隐式表示求交点</h4><p>有了光线的数学定义，如果我们有物体的隐式表示，比如代数方程，那么很容易可以求出光线和物体表面的交点。以球面为例，对于空间中以 $c$ 为球心，$R$ 为半径的球面上的任意一点 $p$，代数形式可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163459536.png" alt="image-20220317163459536"></p>
<p>我们要求光线和球面的交点，也就是联立两个方程求光线传播时间 t ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163725129.png" alt="image-20220317163725129"></p>
<p>整理一下可以得到一个关于 t 的一元二次方程，剩下的就是高中数学知识：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317163840878.png" alt="image-20220317163840878"></p>
<p>这里要特别强调的是 t 的物理意义，t 表示光线传播的时间，因此 t 需要大于0，并且必须是实数，所以要得到光线和物体表面离屏幕最近的一个交点就相当于解方程求一个最小的正实根。这个方法自然也可以推广到任意用隐式方程表示的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164210883.png" alt="image-20220317164210883"></p>
<p>至于有些方程非常难解这个不需要我们担心，计算机本身也是用数值方法求解方程，所以无论多复杂都一定可以求出满足条件的解，关于复杂方程的数值求解方法这不是我们讨论的重点。</p>
<h4 id="3-3-显示表示求交点"><a href="#3-3-显示表示求交点" class="headerlink" title="3.3 显示表示求交点"></a>3.3 显示表示求交点</h4><p>上面说的隐式方程求交点是我们早就了解的数学知识，只是应用到了这里，但通过之前的学习我们知道，图形学中更常用的表示方法是显式表示，并且计算光照、阴影等都要用显式表示去计算，因此计算光线和显式表示的交点是必须要解决的问题，并且解决了这个问题还可以顺便解决之前我们提到的，显式表示不好判断一个点是否在物体内部的问题。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317164516672.png" alt="image-20220317164516672"></p>
<p>先说明如何通过光线和物体的交点判断一个点是否在物体内部。我们可以从空间中任意一点向任意方向发出一条射线，如果这条射线和物体表面有奇数个交点，那么它就在物体内部，如果有偶数个交点就一定在物体外部。可以在二维中验证这一理论。</p>
<p>接下来具体讨论如何计算光线和显式表示的物体表面的交点。最简单的方法就是和每一个三角形计算交点，全算完之后就可以得到和物体的交点，但这显然太慢了，屏幕上每个像素投射一条视线，然后每条视线和场景中每个三角形计算一次交点，并且还要计算光线反射和折射之后的其他交点，对于下图这样的复杂场景，有两千万个三角形，如果是一张 4K 的图，那这个计算量无法被接受的，因此一定需要做加速，具体如何加速我们之后再看，在这之前要先了解怎么计算光线和一个三角形的交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165225656.png" alt="image-20220317165225656"></p>
<p>直接求光线和三角形的交点是不容易想到的，那我们可以分两步进行，先求光线和三角形所在平面的交点，再判断交点是否在三角形内部即可，而这两步计算都是很简单的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165740827.png" alt="image-20220317165740827"></p>
<p>先考虑空间中对一个平面的定义，只要给定空间中一个点和一个法向量就可以唯一确定一个平面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317165932411.png" alt="image-20220317165932411"></p>
<p>于是平面上任意一点就可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170007930.png" alt="image-20220317170007930"></p>
<p>那么求光线和平面的交点同样联立解方程即可，这次的方程还更加简单：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170239867.png" alt="image-20220317170239867"></p>
<p>至于算出交点后如何判断在否三角形内部就不多说了。</p>
<p>上面是分了两步计算光线和三角形交点，那能不能直接计算呢？当然是可以的，这个计算的方法叫做 <strong>MT 算法（Möller Trumbore Algorithm）</strong>，实际上也很简单。</p>
<p>回顾之前学过的三角形重心坐标，利用三角形的重心坐标可以表示三角形所在平面上的任意一点，因此光线和平面的交点一定满足：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170625760.png" alt="image-20220317170625760"></p>
<p>还是解方程，这里有三个未知数 $t、b_1、b_2$，而所有的坐标也都是三维坐标，所以这个关系式实际上表示的是一个三元一次方程组，利用克莱默法则可以快速求出解向量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317170849910.png" alt="image-20220317170849910"></p>
<p>当然还是要保证解出来的 t 为正才有意义，同时也可以直接判断交点是否在三角形内部，因为三角形内部的点重心坐标非负。</p>
<p>知道了如何计算光线和三角形的交点，接下来就是一个更麻烦的问题，既然不可能每个三角形都算一次交点，那么如何加速？</p>
<h3 id="4-交点计算加速"><a href="#4-交点计算加速" class="headerlink" title="4 交点计算加速"></a>4 交点计算加速</h3><p>加速实际上就是减少计算交点的三角形个数，那么首先想到的就是把一个物体看作整体，先判断和物体有交点再去一个一个三角形具体计算交点在哪。</p>
<h4 id="4-1-包围体（Bounding-Volumes）"><a href="#4-1-包围体（Bounding-Volumes）" class="headerlink" title="4.1 包围体（Bounding Volumes）"></a>4.1 包围体（Bounding Volumes）</h4><p>类似于Bounding Box ，我们用简单的几何体把物体包围起来，然后计算光线和这个几何体是否存在交点。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171519659.png" alt="image-20220317171519659"></p>
<p>最常用的包围体自然是长方体，并且为了方便计算我们用的一般是<strong>轴对齐包围体（Axis-Aligned<br>Bounding Box）</strong>，简称为 AABB ，所谓轴对齐包围体就是指包围体每个平面的法向量都和坐标系三个坐标轴对其，通俗的说就是一个“横平竖直”的长方体。然后为了便于理解，我们把空间中的长方体理解为是<strong>由三对平面的交集形成的</strong>几何体。也就是把六个平面想成无限大，这个立方体就是这六个平面相交的部分形成的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171756933.png" alt="image-20220317171756933"></p>
<p>那么计算光线和立方体的交点就是计算光线和六个平面的交点，再加以判断即可。首先我们从简单的二维情况开始，先计算一条光线和一个长方形的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317171924483.png" alt="image-20220317171924483"></p>
<p>首先计算光线和长方形两条垂直边的交点，两条垂直边可以理解为一对平面 $x_0$ 和 $x_1$，可以得到一条线段，如上图左；</p>
<p>同理计算光线和长方形两条水平边的交点，两条水平边可以理解为一对平面 $y_0$ 和 $y_1$，可以得到另一条线段，如上图中，这里我们先假设光线是直线而不是射线，可以向两边延长，因此得到的 $t_{min}$ 可以为负数；</p>
<p>然后将得到的两条线段取交集就是光线在长方形内部的部分。</p>
<p>接下来推广到三维的情况，首先根据二维情况可以整理出两个关键的信息：</p>
<ul>
<li>光线必须进入所有三对平面才代表光线进入了整个立方体</li>
<li>光线只需要离开任意一对平面就代表光线离开了整个立方体</li>
</ul>
<p>基于上面关键信息，我们分别计算光线和立方体三对平面交点，得到三个 $t_{min}$ 和 $t_{max}$，那么光线在立方体中的部分就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173004886.png" alt="image-20220317173004886"></p>
<p>如果 $t_{enter} &lt; t_{exit}$，那么就说明光线在这段时间是在立方体中的。接下来考虑几个特殊情况，刚才我们把光线当成了直线去计算交点，因此计算出来的  $t_{min}$ 和 $t_{max}$ 有正有负，所以最终得到的 $t_{enter}$ 和 $t_{exit}$ 也会有正有负：</p>
<ul>
<li>如果 $t_{exit} &lt; 0$，代表光线离开立方体的时间是负的，说明立方体在光线后面，因此光线不会和立方体有交点</li>
<li>如果 $t_{enter} &lt; 0$ 且 $t_{exit} \geq 0$，代表光线起点就在立方体内，因此光线和立方体有交点</li>
</ul>
<p>综上，光线和立方体有交点，当且仅当 $t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} \geq 0$.</p>
<p>回顾计算直线和平面的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173735804.png" alt="image-20220317173735804"></p>
<p>正常情况下我们要带入三维向量去计算，但是因为这里使用的是 AABB ，每个平面都和坐标平面平行，因此我们计算每对平面的交点时，只要用一个维度的坐标代入计算即可：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317173915726.png" alt="image-20220317173915726"></p>
<p>这也是使用轴对齐包围盒的原因之一，可以大幅减低计算量，使得计算光线和立方体的交点成为一个时间复杂度非常低的过程，为后续的优化奠定基础。</p>
<h4 id="4-2-均匀空间划分（Uniform-Spatial-Partitions）"><a href="#4-2-均匀空间划分（Uniform-Spatial-Partitions）" class="headerlink" title="4.2 均匀空间划分（Uniform Spatial Partitions）"></a>4.2 均匀空间划分（Uniform Spatial Partitions）</h4><p>上面说了计算光线和三角形的交点不容易，但计算光线和立方体的交点非常方便，因此我们加速要尽量多做立方体判断以减少三角形计算。一种方法是对场景进行均匀空间划分，把给定的场景均匀的分成许多个小立方体，具体过程如下：</p>
<ul>
<li>首先找到整个场景中所有物体的 bounding box;</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174601165.png" alt="image-20220317174601165"></p>
<ul>
<li>然后把把场景划分成均匀的网格：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174632633.png" alt="image-20220317174632633"></p>
<ul>
<li>然后看哪些网格中包含了物体的表面，在这个网格中把这个物体存下来：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174721424.png" alt="image-20220317174721424"></p>
<ul>
<li>光线射入的时候计算光线经过的每个立方体，如果这个立方体内有物体，就计算光线和这个立方体内存储的所有物体的交点，至于光线经过了哪些立方体，可以用类似于光栅化中画直线的方法，就不多说了：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317174848937.png" alt="image-20220317174848937"></p>
<p>均匀空间划分的方法对于网格划分的密度很敏感，网格太小会导致效率很低：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175104056.png" alt="image-20220317175104056"></p>
<p>因此需要一个好的划分细度，人们根据经验得出一般把场景划分为 27 倍的物体数量个网格：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175217016.png" alt="image-20220317175217016"></p>
<p>回顾均匀空间划分的方法我们发现对于物体很密集的场景，比如之前的草地，可以得到很好的效果，但是如果场景非常空旷，比如一个体育场中间有一个茶壶，那光线还是要经过许多次立方体的判断才能到达茶壶所在的立方体再去计算交点，因此我们希望空间划分不要非常均匀，很大一片没有物体的地方就可以划分成一个立方体，这样只要一次判断就能到达茶壶所在的立方体。</p>
<h4 id="4-3-非均匀空间划分"><a href="#4-3-非均匀空间划分" class="headerlink" title="4.3 非均匀空间划分"></a>4.3 非均匀空间划分</h4><p>非均匀空间划分是一个经典的问题，有许多非常成熟的方法，图形学中只是拿来应用，常见的有以下几种方法：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317175644386.png" alt="image-20220317175644386"></p>
<ul>
<li>Oct树也叫八叉树，每次把立方体均匀的分成八块，上图是一个立方体的侧视图，然后看分开的每个空间内物体的密度，如果没有物体或者只有很少个就不用继续分了，否则按照这种方法继续划分，这样划分出来的区域就有大有小</li>
<li>KD树是八叉树的改良，八叉树在四维的时候就会变成十六叉树，更高维会呈指数增长，并且每次都是平均分，并不灵活。KD树每次只切一刀把立方体分成两部分，比如第一次沿 x 轴切，分成两部分，下一次在两个区域中沿 y 轴切，再下一次每个区域都沿 z 轴切，这样每次都只把一个区域分成两块，且划分方向交替进行，也保证了相对均衡，因此在图形学中KD树更为合适</li>
<li>BSP树类似于KD树，只是划分方向可以是任意方向，但因为我们图形学中用的是轴对齐包围盒所以这种方法不适用</li>
</ul>
<p>接下来我们按照上面说的KD树的思路我们来看KD树是如何工作的。</p>
<p>首先是构造KD树，我们先把一个场景划分一次，形成两个子区域：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180635314.png" alt="image-20220317180635314"></p>
<p>然后对每个子区域继续划分又分别得到两个子区域，这里我们只划分了绿色的子区域，实际上蓝色的也应该继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180753152.png" alt="image-20220317180753152"></p>
<p>然后继续划分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317180810286.png" alt="image-20220317180810286"></p>
<p>这样我们得到了一个KD树，KD树中的节点分为两类：</p>
<ul>
<li>中间节点：代表一个大区域，中间节点不存储物体信息，只存储这个区域下一次的划分方向（沿 x，y，z轴），划分的位置（这里都是从中间划分，实际可以根据物体位置计算划分位置）以及孩子节点</li>
<li>叶子节点：叶子节点存储在这个区域中所有的物体列表</li>
</ul>
<p>当我们预处理好了一个场景的 KD 树，在进行光线追踪时，每一条光线射入场景，先从 KD 树的根节点开始计算：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181216719.png" alt="image-20220317181216719"></p>
<p>得到光线和区域 A 有交点，那么开始遍历它的孩子节点，计算和蓝色区域的相交情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181321483.png" alt="image-20220317181321483"></p>
<p>也有交点，并且这是一个叶子节点，那就计算光线这个区域中所有的物体的交点，然后继续计算和 B 区域的交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181418447.png" alt="image-20220317181418447"></p>
<p>存在交点继续遍历：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181441618.png" alt="image-20220317181441618"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181454581.png" alt="image-20220317181454581"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181513717.png" alt="image-20220317181513717"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317181546050.png" alt="image-20220317181546050"></p>
<p>直到找到和物体的最近的交点，当然这只是一个示例情况，光线和所有区域都相交，实际过程中KD树显然可以大幅降低光线和立方体判断交点的次数，自然也就进一步降低了和三角形计算交点的次数。</p>
<p>但是 KD 树也存在缺陷，每个叶子节点要存储在这个区域内的所有物体，那么如何判断一个物体在这个立方体中呢？这是非常困难的，但也不是不能克服，不过还有一个问题就像上图所示，有的物体会同时在好几个区域中，那么这几个区域的叶子节点就都要存储这个物体的信息，会有大量重复，因此 KD 树不是最好的划分方法。</p>
<h4 id="4-4-物体划分和BVH（Bounding-Volume-Hierarchy）"><a href="#4-4-物体划分和BVH（Bounding-Volume-Hierarchy）" class="headerlink" title="4.4 物体划分和BVH（Bounding Volume Hierarchy）"></a>4.4 物体划分和BVH（Bounding Volume Hierarchy）</h4><p>最好的办法就是不对空间进行划分，而是对空间中的所有物体进行划分，类似于KD树，我们把空间中所有物体的 Bounding Box 找到，作为根节点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182135200.png" alt="image-20220317182135200"></p>
<p>然后把物体分成两堆，并且重新计算这两堆物体的 Bounding Box ：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182212919.png" alt="image-20220317182212919"></p>
<p>接下来继续这个过程，直到每个区域中都有我们希望的数量的物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182321796.png" alt="image-20220317182321796"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317182336400.png" alt="image-20220317182336400"></p>
<p>可以看到 BVH 构建过程和 KD 树类似，只是每次划分是对物体进行划分然后重新计算 Bounding Box ，这样就可以保证每个叶子节点存储的物体不重复，并且还免去了判断物体是否在 Bounding Box 内的麻烦，是一个非常优秀的方法，因此 BVH 也是目前使用最广泛的方法。</p>
<p>至于每次对物体如何划分，当然可以和 KD 树一样按照维度轮换划分，也可以用其他各种方法，比如：</p>
<ul>
<li>永远选择最长的那一个维度划分，有时可能场景是一个走廊之类的长条形状，那么其中的物体也一定是按这样排列的，如果还按照维度轮换划分，划分出来一定是不够均衡的，因此可以每次计算当前 Bounding Box 最长的那一维，就从最长维度划分，就可以保证相对均匀</li>
<li>可以选择中间的物体划分，为了保证每个叶子节点存储的物体数量差不多，我们可以把物体的中心坐标排序取中位数，然后按照中间这个物体所在位置划分成两个区域，这样每个区域中物体数量都相当</li>
</ul>
<p>BVH 的数据结构中存储的内容和 KD 树类似，中间节点存储 Bounding Box 和孩子节点，叶子节点中存储 Bounding Box 和所有物体列表，当光线射入场景时，从根节点开始计算即可，下面是 BVH 的伪代码：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183317587.png" alt="image-20220317183317587"></p>
<h4 id="4-5-空间划分-VS-物体划分"><a href="#4-5-空间划分-VS-物体划分" class="headerlink" title="4.5 空间划分 VS 物体划分"></a>4.5 空间划分 VS 物体划分</h4><p>对比 KD 树和 BVH，一个是空间划分，一个是物体划分，空间划分的 Bounding Box 不会重合但是物体会重复，而物体划分 Bounding Box 可能重合但物体不会重复，显然物体划分更符合我们的需求。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/image-20220317183536848.png" alt="image-20220317183536848"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>以上就是 Whitted 风格光线追踪的基本原理和优化结构，从每个像素投射一条视线到场景中，利用 BVH 找到和场景中物体最近的交点，然后利用同样的方法计算反射和折射光线与其他物体的交点，最后计算所有交点的着色作为这个像素的颜色显示。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机图形学】（十三）路径追踪</title>
    <url>/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h3 id="路径追踪（Path-Tracing）"><a href="#路径追踪（Path-Tracing）" class="headerlink" title="路径追踪（Path Tracing）"></a>路径追踪（Path Tracing）</h3><p>这一节我们正式开始学习路径追踪技术，首先我们要利用上一节的辐射度量学基础理解双向反射分布函数并推导出反射方程和渲染方程，然后利用渲染方程理解全局光照，之后简单复习一下蒙特卡洛积分的相关内容，最后通过解渲染方程来构建路径追踪算法。这一节内容可能非常硬核，涉及物理、微积分、概率论等多方面的知识，但这也是迈向真正的<strong>现代</strong>图形学大门的第一步。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-双向反射分布函数（BRDF）"><a href="#1-双向反射分布函数（BRDF）" class="headerlink" title="1 双向反射分布函数（BRDF）"></a>1 双向反射分布函数（BRDF）</h4><p>在学习路径追踪之前我们还需要一系列的前置知识，第一个就从双向反射分布函数（Bidirectional Reflectance Distribution Function）开始。</p>
<p>我们假设一个平面 dA 从某个方向 $\omega_i$ 接收到的 Radiance 会被转化成这个平面上的能量 $E(\omega_i)$ ，然后这些能量又会从 dA 向四面八方反射出去，但一般情况下不会全部反射出去，而是会有一部分能量被保留，另外的能量被反射出去，假设在某个方向 $\omega_r$ 反射出去的能量是 $L_r(\omega_r)$，那么在平面 dA 从方向 $\omega_i$ 接收到的能量 $E(\omega_i)$ 中有多少能量会被反射到 $\omega_r$ 方向成为 $L_r(\omega_r)$，这二者之间存在一个关系，这个关系就叫做双向反射分布函数。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320141430022.png" alt="image-20220320141430022"></p>
<p>可以看到 BRDF 就是 $L_r(\omega_r)$ 和 $E(\omega_i)$ 的比值，它描述的就是一个平面从某个方向接收到的能量会往另外某个方向反射多少。</p>
<p>从物理意义上来说，  BRDF 描述的其实就是物体表面的材质属性，物体之所以在我们看来会显示出不同的材质，就是因为它的表面对光的吸收能力不同，反射能力不同，BRDF 描述的正是一个表面的这种反射光的能力，因此我们说 BRDF 本质上表示的是表面的材质。</p>
<h4 id="2-反射方程"><a href="#2-反射方程" class="headerlink" title="2 反射方程"></a>2 反射方程</h4><p>有了 BRDF，现在我们考虑一个着色点 $p$，回顾上一节最后我们说的 Radiance 和 Irradiance 的联系，$p$ 点的 Irradiance 就是 Radiance 在各个方向上的积分，那么现在我们从一个方向 $\omega_r$ 去观察点 $p$，也就相当于去计算 $p$ 点从各个方向接收到的能量在 $\omega_r$ 方向总共能反射出多少，那不就是点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来就可以了吗。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320142742653.png" alt="image-20220320142742653"></p>
<p>上面的公式表达的意思就是刚才说的，点 $p$ 从每个方向 $\omega_i$ 接收到的能量 $L_i(p,\omega_i)$ 乘以 $\omega_i$ 方向到 $\omega_r$ 方向的 BRDF 再全部积分起来，就得到了一个着色点从四面八方接收到的能量往观察方向反射了多少。这个公式就叫做反射方程。</p>
<h4 id="3-渲染方程"><a href="#3-渲染方程" class="headerlink" title="3 渲染方程"></a>3 渲染方程</h4><p>反射方程计算的是一个表面从外界接收到的光，能被我们看到多少，如果这个物体本身就会发光呢？那它本身也会向我们的观察方向 $\omega_r$ 发出能量，因此我们可以在反射方程上加上一个自发光项 $L_e(p,\omega_o)$：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320143225898.png" alt="image-20220320143225898"></p>
<p>这样就得到了能描述更一般情况的渲染方程，上式中 $L_o(p,\omega_o)$ 就是 $p$ 点在 $\omega_o$ 方向反射出的总能量， $L_e(p,\omega_o)$ 是 $p$ 点自身在 $\omega_o$ 方向放射出的能量，球面积分就是 $p$ 点从四面八方接收到的光反射到 $\omega_o$ 方向的总能量，$\Omega^+$代表上半球面，$f_r(p,\omega_i,\omega_o)$ 表示点 $p$ 从 $\omega_i$ 方向到 $\omega_o$ 方向的 BRDF，这里的余弦同样用向量点乘表示，因为所有这些向量也都是指示方向的单位向量，并且都是和布林冯模型中一样，从点 $p$ 指向外边的。</p>
<h4 id="4-全局光照"><a href="#4-全局光照" class="headerlink" title="4 全局光照"></a>4 全局光照</h4><p>渲染方程就可以描述我们之前经常说到的全局光照，这也是光栅化不好去解决的问题（不代表不能解决），因为光栅化中光线只弹射一次，而全局光照正是因为光线会弹射很多次使得本来光线达到不了的地方能被照亮。</p>
<p>接下来我们就从简单情况开始，理解渲染方程为什么能表示全局光照。首先考虑只有一个点光源的情况，也是之前我们讨论的最多的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145641378.png" alt="image-20220320145641378"></p>
<p>这时的渲染方程就可以写成上面的形式，相当于只有一个方向有入射的 Radiance ，那如果现在有多个点光源：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145827348.png" alt="image-20220320145827348"></p>
<p>渲染方程也很简单，就是把全部的点光源反射加起来。接下来如果点光源变成了面光源，相当于从离散到连续：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320145952914.png" alt="image-20220320145952914"></p>
<p>我们也能理解，离散的求和就是连续的积分，这也是我们刚才得到的最一般的渲染方程。</p>
<p>到此为止我们讨论的都是光源照射到物体上，也就是直接光照的情况，那对于一个物体表面，他接收到的光不全是从光源来的，还可能是从其他物体表面反射出来的光：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320150319277.png" alt="image-20220320150319277"></p>
<p>比如上图中的 $X’$ 是其他物体的表面，反射出的光同样会被我们的观察点接收到，这时着色点 $x$ 接收到的从平面 $X’$ 反射来的光相当于我们从点 $x$ 沿着 $-\omega_i$ 方向观察平面 $X’$ 得到的结果，因此着色点 $x$ 接收到的从平面 $X’$ 反射来的光就是上面式子中的 $L_r(X’,-\omega_i)$，从这个渲染方程我们可以看出整个过程是一个递归的过程，当前物体反射的光不仅取决于光源，还取决于其他物体反射的光，其他物体反射的光又取决于光源和别的物体，这也正是渲染方程能够表示全局光照的原因。</p>
<p>我们继续观察上面的渲染方程，我们要求解的未知数也包含在积分中，所以这是一个积分方程，并且这个看似复杂的积分方程实际上是一个经典的积分方程，叫做<strong>弗雷德霍姆积分方程（Fredholm Integral Equation）</strong>，这个方程可以简化的写成如下形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151450998.png" alt="image-20220320151450998"></p>
<p>这满足第二类弗雷德霍姆积分方程的一般形式，其中 $K(u,v)dv$ 被称为光线传播算子，表示的是光线 $l(v)$ 经过光线传播算子就传播到了 光线 $l(u)$ 上，这和我们之前说的一个点吸收的光再反射出去的概念其实是一样的。</p>
<p>接下来我们再进一步简化，把这个方程写成矩阵形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320151703670.png" alt="image-20220320151703670"></p>
<p>至于积分怎么写成矩阵形式，这里不展开讨论，这对我们来说也不重要，总之写成这样的形式之后，我们就可以进一步操作，移项之后再左乘对应的逆矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153406232.png" alt="image-20220320153406232"></p>
<p>然后根据二项式定理，对于矩阵也存在类似泰勒展开的形式， $(I-K)^{-1}$ 的泰勒展开就类似于 $\frac{1}{1-x}$ 的泰勒展开，于是上式可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153729678.png" alt="image-20220320153729678"></p>
<p>我们把这个式子展开进行分析：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320153751936.png" alt="image-20220320153751936"></p>
<p>先明确这里面各个字母代表什么，在他们没变成这样之前，$L$ 是各个平面反射出的光（可能是我们观察的平面，也可能是其他平面），$E$ 是来自于光源的光，$K$ 是光线传播算子，所以直接来自于光源的光 $E$ 每乘一次光线传播算子 $K$ 就代表光线弹射了一次，所以 $KE$ 表示直接光照，也就是光线只在观察表面弹射了一次进入我们的眼睛，$K^nE$ 表示在多个表面弹射了 n 次之后进入我们的眼睛，我们观察到的光是所有这些光线的总和。 </p>
<p>换句话说，渲染方程表示：我们看到的光是直接来自于光源的光和经过若干次反射后达到我们眼睛的光的总和。这显然是符合物理世界本身的规律的。而之前的光栅化着色过程，相当于只有前两项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155016764.png" alt="image-20220320155016764"></p>
<p>因此渲染方程可以表示全局光照，因为它考虑了整个场景中经过若干次弹射的光线。</p>
<p>下图是只有直接光照渲染出来的图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155133357.png" alt="image-20220320155133357"></p>
<p>可以看到因为只计算了直接光照，也就是光线只弹射一次，所以没有光线直接照射到的地方，比如点 $p$ 就是全黑的。下面是计算了一次全局光照渲染出来的图，一次全局光照是指光线额外弹射了一次：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155335268.png" alt="image-20220320155335268"></p>
<p>点 $p$ 可以被看到了，但是注意房顶上的吊灯，此时它还是黑色的，下面是计算了四次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155447163.png" alt="image-20220320155447163"></p>
<p>点 $p$ 变得更清晰了更亮了，而且房顶上的吊灯也变得透明了，因为它是玻璃材质，透射的光进入它的内部在只计算一次额外弹射的情况下是无法被反射出去被我们看到的，所以经过多次弹射后就会显示出来，这也是合理的。下面是计算了十六次全局光照的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320155738534.png" alt="image-20220320155738534"></p>
<p>可以看到整个画面已经没有太大的变化了，这说明光线弹射的次数越多并不会使画面越亮，而是会逐渐收敛到一个状态，因为光线弹射的越多能量衰减的也越多，这也是和现实世界完全一致的，因此整个渲染方程非常科学的描述了整个场景中光线的传播，所以用渲染方程渲染出的画面自然也就更加接近真实世界。</p>
<h4 id="5-蒙特卡洛积分"><a href="#5-蒙特卡洛积分" class="headerlink" title="5 蒙特卡洛积分"></a>5 蒙特卡洛积分</h4><p>彻底理解了渲染方程之后，我们就要开始用渲染方程构建图像渲染算法了，但对于我们编码来说，只有这个渲染方程是不够的，因为我们要能够解出这个方程，得到一个计算便捷的表达式，才能去写代码，而我们知道计算机解方程使用的是数值的方法，尤其是对于这样复杂的积分方程，所以我们先简单复习一下计算定积分的常用数值方法——蒙特卡洛积分。</p>
<p>一般来说计算定积分，我们会先把不定积分算出来，然后再把区间端点代入相减就得到了区间上的定积分，但是对于形态比较复杂的函数来说，我们不容易求出它的不定积分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320161415261.png" alt="image-20220320161415261"></p>
<p>这时就要用数值方法去求积分了，我们知道积分就是面积，经典的黎曼积分就是在区间内取无数个小的长条把他们的面积加起来，而蒙特卡洛积分则是结合了概率论的方法，在区间 $(a,b)$ 内以某种概率分布随机的取一个点，把这个点的函数值作为矩形的高，然后区间长度作为矩形的宽，求出一个矩形面积，随着采样次数增多，把所有的矩形面积取平均就得到了整个区间的近似积分，采样点越多，结果自然也就越接近真实结果。</p>
<p>所以假设我们要计算定积分：<br>$$<br>\int_{a}^{b}f(x)dx<br>$$<br>我们以一个概率分布 $p(x)$ 在区间 $(a,b)$ 内随机的选取采样点 $X_i$，概率论告诉我们 $p(x)$ 叫做概率密度函数（pdf），则该定积分的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>以均匀分布为例，区间 $(a,b)$ 上的均匀分布的概率密度函数就是：<br>$$<br>X_i \sim p(x) &#x3D; \frac{1}{b-a}<br>$$<br>于是利用均匀分布采样的蒙特卡洛估计为：<br>$$<br>F_N &#x3D; \frac{b-a}{N}\sum_{i&#x3D;1}^{N}f(X_i)<br>$$</p>
<h4 id="6-路径追踪"><a href="#6-路径追踪" class="headerlink" title="6 路径追踪"></a>6 路径追踪</h4><p>有了前面所有的前置知识，现在我们来正式学习路径追踪。学习一个方法的时候，要学习的第一件事就是为什么要学习这个方法？</p>
<p>我们之前学习 Whitted 风格光线追踪是为了解决光栅化渲染中的不足，所以路径追踪自然是为了解决 Whitted 风格光线追踪的不足。现在来回顾 Whitted 风格光线追踪有哪些问题。</p>
<p>首先，在一开始学习 Whitted 风格光线追踪时我们就假设了，所有光线的反射都是完美的镜面反射，也就是只沿着镜面反射方向传播，这显然是不合理的，比如我们之前也提到过的 Glossy 反射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320163435750.png" alt="image-20220320163435750"></p>
<p>不过之前我们没有说 Glossy 反射为什么会呈现出这样的效果，这就是因为它的表面没有那么光滑，不足以使光线完美的沿着镜面反射方向传播，而是使光线在镜面反射方向附近一定范围内散射出去，所以呈现出来就是这样模糊的效果。因此 Whitted 风格光线追踪不好处理 Glossy 反射。</p>
<p>其次，光线遇到漫反射就会停下来。在之前的布林冯光照模型中，只有直接光照会使物体表面显示出颜色，而且这个颜色在之后的传播中也不会继续传播，所以相当于光线遇到漫反射就不再弹射了，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320164359977.png" alt="image-20220320164359977"></p>
<p>这是一个只有漫反射的场景，左图是只有直接光照的效果，所以天花板没有光源直接照射就是黑的，并且长的立方体左表面也是黑的；而右图是全局光照的效果，可以看到长的立方体左表面是红色的，这是因为左边的墙是红色的，显然右边的图更接近真实场景，这个真实场景也是存在的，后面我们会看到。</p>
<p>综上， Whitted 风格光线追踪实际上是错误的，因为它并不符合现实世界的物理规律，而之前我们推导的渲染方程是绝对符合物理规律的正确的光线计算方式。而要使用渲染方程来渲染图像，就要解方程，接下来我们从最简单的情况来分析如何求解渲染方程。</p>
<p>先考虑只有直接光照的情况，我们只考虑一个着色点，场景中只有一个<strong>面光源</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165056742.png" alt="image-20220320165056742"></p>
<p>我们的观察方向是 $\omega_o$，不考虑着色点本身发射的光，于是可以得到一个渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165220430.png" alt="image-20220320165220430"></p>
<p>现在用蒙特卡洛积分来解这个方程，回顾蒙特卡洛估计的一般形式：<br>$$<br>F_N &#x3D; \frac{1}{N}\sum_{i&#x3D;1}^{N}\frac{f(X_i)}{p(X_i)},\ X_i \sim p(x)<br>$$<br>我们只要知道被积函数 $f(x)$ 和概率密度函数 $p(x)$ 就可以了，在这里被积函数 $f(x)$ 显然就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165509284.png" alt="image-20220320165509284"></p>
<p>概率密度函数 $p(x)$ 我们就取均匀分布，但现在是一个半球面上的积分，半球面的均匀分布自然是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165552391.png" alt="image-20220320165552391"></p>
<p>于是我们的渲染方程就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320165624306.png" alt="image-20220320165624306"></p>
<p>我们把积分转化成了求和的形式，这意味着我们可以写代码了，根据这个求和表达式，就能写出一个计算着色的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>OK，现在我们考虑更复杂一点的情况，如果场景中有其他物体，那么公式中的来自各个方向的光就不一定是来自于光源了，也就是说我们从着色点打出一条光线可能不是达到光源，而是到达其他物体表面：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170432437.png" alt="image-20220320170432437"></p>
<p>这时就按我们之前的递归做法，把着色点 P 当成观察点，然后计算 Q 点的着色，所以我们的代码只要加上另一个 if 判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf		//随机的选择N个方向，服从某个概率密度函数pdf的分布，这里是均匀分布</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi		</span><br><span class="line">        Trace a ray r(p, wi) 		//对每一个方向从着色点打出一条光线</span><br><span class="line">        If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">        Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>这样似乎就完成了一个像素的着色，但这样可以吗？一定是不行的，因为这样去追踪光线会导致计算量爆炸，下面的图说明了这种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320170839308.png" alt="image-20220320170839308"></p>
<p>假设我们每次随机采样就选了 100 个方向，那么我们就要追踪 100 条光线，每一条光线如果打到其他物体表面又会采样出 100 条光线，这样经过两次弹射我们就要追踪 100 万条光线，这显然是不能接受的，因此我们就要考虑怎么样才能不让光线数量爆炸，因为这是呈指数增长的，所以只有当光线数量为 1 的时候，不管怎么弹射，它都还是一条光线。于是我们就随机采样一条光线，只跟踪这一条光线，那循环也不需要了，我们的代码就可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) </span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>上面的代码就是路径追踪的基本思路，只跟踪一条光线，就叫做<strong>路径追踪</strong>。</p>
<p>显然，这样的方法计算出来的着色会有非常大的噪声，说白了这个着色算出来是多少全靠运气，没关系，我们可以透过一个像素投射出多条视线，然后把所有视线计算出的 Radiance 平均起来作为这个像素的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320171940751.png" alt="image-20220320171940751"></p>
<p>因此我们可以再写一个生成视线的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel	//在每个像素内选择N个采样点</span><br><span class="line">    pixel_radiance = 0.0</span><br><span class="line">    For each sample in the pixel</span><br><span class="line">        Shoot a ray r(camPos, cam_to_sample) 	//每个采样点投射出一根光线</span><br><span class="line">        If ray r hit the scene at p		//如果光线打到了着色点就调用着色函数</span><br><span class="line">            pixel_radiance += 1 / N * shade(p, sample_to_cam) </span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure>

<p>这样就OK了，如果这时候代码都写完了而且能正确运行了，我们会发现渲染一张图片还是迟迟渲染不出来，这回绝不是因为效率太低，而是因为我们的着色函数是递归调用的，<strong>但是没有递归结束的条件</strong>。因此我们需要设定一个结束条件，最简单的就是规定弹射多少次就不再计算了，毕竟之前我们也看过渲染效果，弹射 4 次和弹射 16 次渲染出来的效果不会差太多，但是给定弹射次数太少会直接切断能量的传播，如果给定次数太多又有很多计算没有意义，因此这里要用一种相对妥善的解决方案，叫做<strong>俄罗斯轮盘赌（Russian Roulette ）</strong>，简称 <strong>RR</strong>，这类似于左轮手枪装弹后，再把弹匣一转，这时候打出子弹的概率如果是 P，那么打不出子弹的概率就是 1 - P，我们借鉴这样的方法，给定一个生存概率 P，每次还是按照正常流程计算 Lo，并且以 P 的概率返回 Lo &#x2F; P，以 1 - P 的概率返回 0 ，这样当返回 0 的时候递归就终止了，也就是递归每次会有 1 - P 的概率中止。</p>
<p>可是为什么这样做呢？这是因为这样做可以<strong>保证我们最终计算出的 Lo 的期望是正确的</strong>。上面的方法相当于就是一个最简单的二值分布，那么它的期望就是：<br>$$<br>E &#x3D; P * \frac{Lo}{P} + (1-P)*0 &#x3D; Lo<br>$$<br>也就是说按照 RR 的方法我们既能保证中止递归，还能期望得到正确的 Lo ，非常巧妙！</p>
<p>体现在代码上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Manually specify a probability P_RR		//给定一个生存概率</span><br><span class="line">    Randomly select ksi in a uniform dist. in [0, 1] 	//随机生成一个[0,1]之间的数</span><br><span class="line">    If (ksi &gt; P_RR) return 0.0;		//如果这个数大于生存概率，直接返回0，对应1-P的情况</span><br><span class="line">    //否则和之前一样，但是要记得除以生存概率</span><br><span class="line">    Randomly choose 1 direction wi~pdf		//随机的选择1个方向	</span><br><span class="line">    Trace a ray r(p, wi) 		//从这个方向打出一条光线</span><br><span class="line">    If ray r hit the light		//如果这个光线能到达光源，就按照公式计算着色</span><br><span class="line">        Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Else If ray r hit an object at q	//如果达到了其他物体表面，就递归地计算</span><br><span class="line">        Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>

<p>现在我们就基本得到了一个正确版本的路径追踪算法。当然这个算法还有问题，那就是我们对一个像素投射出多条光线，可又该投射多少呢？如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174112743.png" alt="image-20220320174112743"></p>
<p>对每个像素的采样数量简称为 SPP，SPP 低的时候得到的结果噪声会很大，这很好理解；而 SPP 高的时候效果很好但是效率又非常低，前人大佬们自然是不能容忍这样的问题存在的，那能不能既快效果又好呢，一定是可以的。</p>
<p>考虑我们现在的方法，只跟踪一条光线，这条光线再朝哪个方向投射光线是完全随机的，对于下面几种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320174506545.png" alt="image-20220320174506545"></p>
<p>如果场景的光源面积很大，那投射出的光线到达光源的概率就高，可能每 5 条光线就有 1 条能打到光源上，就能计算出一个值；可如果光源面积很小，可能我们投射出了很多光线，但都没有打到光源上，那么这些光线就是没用的，对我们的计算结果没有任何影响，完全浪费掉了，可我们明明知道光源在哪，为什么还要随机选择投射方向呢？</p>
<p>我们完全可以直接对面光源进行采样，直接在光源上进行采样，这样就能保证每一条光线都能打到光源上，一个都不浪费，但是蒙特卡洛积分要求，对谁积分就得对谁采样，因此我们要对光源平面 $dA$ 采样，就得把渲染方程对 $d\omega$ 的积分改写成对 $dA$ 的积分，实际上就是积分变量替换，只要找到 $dA$ 和 $d\omega$ 的关系就可以了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-2022-03-20175206.png" alt="屏幕截图 2022-03-20 175206"></p>
<p>我们知道 $d\omega$ 是立体角，立体角的定义是从球心向球面上投射出的一块区域的面积和球半径平方的比值，那么 dA 的立体角就是 dA 在球心方向的投影的面积除以到球心的距离的平方，而立体角是指示方向的，所以 dA 的立体角和 $d\omega$ 表示的是一样的，因此二者相等，所以可以得到：<br>$$<br>d\omega &#x3D; \frac{dA \ cos\theta’}{| x’ - x |^2}<br>$$<br>于是渲染方程就可以改写为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180100174.png" alt="image-20220320180100174"></p>
<p>同时，对于一个面光源 A，均匀采样的概率密度函数就是：<br>$$<br>pdf &#x3D; \frac{1}{A}<br>$$<br>这样也就可以用蒙特卡洛积分解方程了。</p>
<p>因此路径追踪的算法又要改一下，现在我们一个着色点从其他地方入射来的 Radiance 就分为两部分：</p>
<ul>
<li>一部分来自光源，这部分直接对光源采样，按照上面的改写后的积分计算结果即可，并且不需要 RR 控制终止</li>
<li>另一部分来自其他物体表面反射，按照原来的积分计算结果，并需要 RR 控制终止</li>
</ul>
<p>于是现在的路径追踪算法的伪代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    //来自于光源的部分</span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = 1 / A)	//在光源平面采样</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light		//计算着色</span><br><span class="line">	</span><br><span class="line">    //来自其他的部分</span><br><span class="line">    L_indir = 0.0</span><br><span class="line">    Test Russian Roulette with probability P_RR</span><br><span class="line">    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi) </span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit a non-emitting object at q		//这里判断要改成光线打到非光源上才计算，不然就和上面重复了</span><br><span class="line">        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR </span><br><span class="line">    </span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>

<p>到此为止我们就得到了一个完全正确的路径追踪算法。</p>
<p>还有最后一个小问题，如何判断在光源平面采样的光线和着色点之间是否有阻挡？</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320180717009.png" alt="image-20220320180717009"></p>
<p>只需要从着色点再打出一条光线看能不能达到光源就可以了，如果有阻挡，这条打出去的光线就会碰到其他物体。</p>
<p>现在可以说路径追踪的全部<strong>入门</strong>内容就彻底结束了！</p>
<p>最后来看看路径追踪的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/03/20/20220320-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/image-20220320181219602.png" alt="image-20220320181219602"></p>
<p>左边是一张真实的相机拍摄的图片，右边是路径追踪算法渲染出来的图片，可以看到渲染的非常真实，可以说是无限接近真实场景，这就是路径追踪的强大之处。</p>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h4><p>以上就是路径追踪的全部基础内容，看似已经非常细节了，但实际上还有无数的细节问题没有讨论到，比如：</p>
<ul>
<li>如何对一个球面均匀采样？</li>
<li>蒙特卡洛积分采样的概率分布是不是应该根据渲染的场景来选择合适的分布才能达到更好的效果，均匀采样只是最简单的一种；</li>
<li>随机数的质量直接影响渲染效果，如何生成分布均匀概率准确的高质量随机数？</li>
<li>是不是可以把着色点的方向采样和光源平面采样结合起来以达到更好的效果？</li>
<li>渲染方程计算出来的就是最终显示在像素上的颜色吗？当然不是的，还要经过伽马矫正等一系列操作才能转变为颜色，而颜色这部分还涉及到颜色空间，HDR之类的问题……</li>
</ul>
<p>所以我们看似搞懂了路径追踪，其实最多也只能算是刚刚入门，还有太多的东西没有了解到。这一路过来可以说整个路径追踪的流程非常复杂，光是最基础的理论推导都如此困难，那想把代码写对就更是难上加难，并且永远不要忘了我们还只是在学习前人留下的经验。这节课最后闫令琪老师说的话对我的启发非常大：“我学了十年渲染，至今还觉得我什么都不会”。更何况你我呢？</p>
<p>敬畏科学，学无止境。</p>
]]></content>
      <categories>
        <category>GAMES101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（六）区间动态规划</title>
    <url>/LycTechStack.github.io/2022/03/25/20220325-%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>区间动态规划一般用在单串问题上，以区间 [i, j] 为单位思考状态的设计和转移。一般是定义 <code>dp[i][j]</code>，表示考虑 [i..j] 范围内的元素，原问题的解，增加 i或减小 j 都可以得到更小规模的子问题。它与线性动态规划在状态设计和状态转移上都有明显的不同，但由于这两个方法都经常用在单串问题上，导致我们拿到一个单串的问题时，经常不能快速反映出应该用哪种方法。这是区间动态规划的难点之一，但是这个难点也是好解决的，就是做一定数量的练习题，因为区间动态规划的题目比线性动态规划少很多，并且区间动态规划的状态设计和转移都比较朴素，变化也比线性动态规划少很多，所以通过不多的题目数量就可以把区间动态规划常见的方法和变化看个大概了。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-回文相关问题"><a href="#1-回文相关问题" class="headerlink" title="1 回文相关问题"></a>1 回文相关问题</h3><p>回文系列问题是区间动态规划的典型问题，这里整理了一系列与回文有关的问题。</p>
<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<p>因为题目要求返回回文串，而不是长度，因此我们需要定义状态 $dp[i][j]$ 表示区间 s[i, j] 是否是回文串，状态转移非常简单：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code>，<code>dp[i][j] = dp[i+1][j-1]</code></li>
<li>如果 <code>s[i] != s[j]</code>，<code>dp[i][j] = false</code></li>
</ul>
<p>边界条件：任意一个字母都是回文串，因此 <code>dp[i][i] = true</code>。</p>
<p>编码时我们不好同时枚举左边界和右边界，考虑到我们一定是从长度较短的回文串推导出长度较长的回文串，所以可以枚举子串长度，对每一个长度枚举左边界，自然就可以确定右边界了，其他编码的细节见代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>, maxlen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L = <span class="number">2</span>; L &lt;= n; ++L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">                dp[i][j] = L &lt; <span class="number">3</span> ? s[i] == s[j] : dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    beg = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(beg, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题比较简单，用动态规划无论是时间还是空间开销都比较大，但是观察上面的动态规划过程我们会发现，所有的状态都是从边界条件转移而来的并且是唯一的，因此我们只要枚举所有边界情况，然后从这个边界状态开始扩展，直到无法继续扩展就得到了一个回文子串，最后返回最长的一个即可。</p>
<p>边界情况对应的就是长度为 1 和 2 的子串，这些子串作为回文中心，可以不断向两边扩展，直到不是回文串就停止扩展，因此我们只要枚举所有的回文中心并向两边扩展即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i); 	<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); <span class="comment">//长度为2的回文中心</span></span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">回文子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中回文子串的数目。</p>
</blockquote>
<p>上一题的简化版本，不多赘述，直接用中心扩展方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i); 		<span class="comment">//长度为1的回文中心</span></span><br><span class="line">            <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>); 	<span class="comment">//长度为2的回文中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列</a></h4><blockquote>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
</blockquote>
<p>这是区间动态规划最经典的问题了，按照最常规的思路去做就可以。定义状态 $dp[i][j]$ 表示 s[i, j] 区间内最长回文子序列长度，状态转移：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code> ，<code>dp[i][j] = dp[i+1][j-1] + 2</code></li>
<li>如果 <code>s[i] != s[j]</code> ，<code>dp[i][j] = max(dp[i+1][j], max(dp[i][j-1], dp[i+1][j-1]))</code>，由于<code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code>是包含 <code>dp[i+1][j-1]</code> 的，这与我们的状态定义有关，因此只需要取 <code>dp[i+1][j]</code> 和 <code>dp[i][j-1]</code> 之间的最大值即可。</li>
</ul>
<p>边界条件同样是 <code>dp[i][i] = 1</code>，遍历时记得要从较短的子串开始遍历，因此我们从后向前遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == s[i]) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">让字符串成为回文串的最少插入次数</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
</blockquote>
<p>这也是一道典型的区间动态规划问题，但相对困难。动态规划定义依然是 $dp[i][j]$ 表示使得 s[i, j] 成为回文串的最小操作次数。我们可以从外向内推导，因为如果最外层两个字符相等，那么最外层就已经是回文了，不需要额外操作，只要保证内层也是回文即可，因此 <code>dp[i][j] = dp[i+1][j-1]</code>；而如果最外层两个字母不相等，要使 s[i, j] 成为回文串，要么在右边插入一个 s[i] ，要么在左边插入一个 s[j] ，所以此时 <code>dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)</code>。</p>
<p>边界条件还是 <code>dp[i][i] = 0</code>，单个字符本身就形成回文，不需要额外操作。</p>
<p>遍历时和之前一样，可以通过枚举长度和左边界的方式确定右边界。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minInsertions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> span = <span class="number">2</span>; span &lt;= n; ++span) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - span; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + span - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外本题还可以用线性动态规划解决，具体可看<a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution/rang-zi-fu-chuan-cheng-wei-hui-wen-chuan-de-zui--2/">官方题解方法一</a>，但没有区间动态规划容易理解，也不好想到。</p>
<h4 id="段式回文"><a href="#段式回文" class="headerlink" title="段式回文"></a><a href="https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition/">段式回文</a></h4><blockquote>
<p>你会得到一个字符串 $text$ 。你应该把它分成 $k$ 个子字符串 $(subtext_1, subtext_2, …,subtext_k)$ ，要求满足:</p>
<ul>
<li>$subtext_i$ 是非空字符串</li>
<li>所有子字符串的连接等于 $text$ ( 即$subtext_1 + subtext_2 + … + subtext_k &#x3D;&#x3D; text$ )</li>
<li>$subtext_i &#x3D;&#x3D; subtext_{k - i + 1},\  1 \leq i \leq k$</li>
</ul>
<p>返回 $k$ 可能最大值。</p>
</blockquote>
<p>题目的意思是把一个字符串分成多段，所有段之间满足回文关系，比如：</p>
<blockquote>
<p>输入：text &#x3D; “ghiabcdefhelloadamhelloabcdefghi”<br>输出：7<br>解释：我们可以把字符串拆分成 “(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)”。</p>
</blockquote>
<p>这道题用动态规划做比较困难，但用贪心的思想非常简单，因为首尾两端字符串回文意味着他们相等，因此它们的长度也必须相等，那么我们遍历所有长度，也就是从 1 到 text.szie() &#x2F; 2，然后判断首尾这么长的字符串是否相等，如果相等就把这两段剪掉，剩下的字符串继续这么判断，这样最终得到的分段数就是最大分段数 k。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">int</span> i1, <span class="type">int</span> i2, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i1+i] != text[i2+i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相当于 if (text.substr(0, i) == text.substr(n-i, n))</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEqual</span>(text, <span class="number">0</span>, n-i, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">longestDecomposition</span>(text.<span class="built_in">substr</span>(i, n - (i&lt;&lt;<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果一个都不相等就返回1，相当于不分段</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有时候贪心算法解决一些困难问题非常好用，后面我们会专门总结贪心算法。</p>
<h4 id="统计不同回文子序列"><a href="#统计不同回文子序列" class="headerlink" title="统计不同回文子序列"></a><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/">统计不同回文子序列</a></h4><blockquote>
<p>给定一个字符串 s，返回  s 中不同的非空「回文子序列」个数 。</p>
<p>通过从 s 中删除 0 个或多个字符来获得子序列。</p>
<p>字符串仅包含 <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code> 或 <code>&#39;d&#39;</code> 。</p>
<p>注意：结果可能很大，你需要对 $10^9 + 7$ 取模 。</p>
</blockquote>
<p>这道题非常困难，有余力可以参照官方题解去理解。</p>
<h3 id="2-其他区间动态规划问题"><a href="#2-其他区间动态规划问题" class="headerlink" title="2 其他区间动态规划问题"></a>2 其他区间动态规划问题</h3><p>除了回文串之外，区间动态规划还有许多经典问题，通过这些题目可以掌握另一种状态转移形式。</p>
<h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">戳气球</a></h4><blockquote>
<p>有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p>
<p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p>
<p>求所能获得硬币的最大数量。</p>
</blockquote>
<p>这是一道经典的区间动态规划问题，且状态转移依赖区间内的 O(n) 个子问题，上面的回文系列中都是依赖 O(1) 个子问题。这道题的状态转移思路就是这类依赖 O(n) 个子问题的常规思路，一定要完全理解。</p>
<p>当然这道题最难的部分不是动态规划，而是问题转化，很多困难的题目都是这样，题目本身不难，只是我们想不到把问题转化为好解决的形式，因此只能多做多积累。</p>
<p>我们按照正常的动态规划思路去做会发现，这道题不满足无后效性，因为每次戳破一个气球，都会改变气球之间的相邻与不相邻的关系，因此我们不能按正常思路去想这个问题。官方题解的思路是不要去想每次戳破一个气球，而是要思考每次往区间内添加一个气球，直到把区间填满所能获得的最大分数，这和每次戳破一个气球是等价的。可能这比较抽象，不太容易想明白为什么戳破和添加是等价的。</p>
<p>另一种理解方法是对于每一个区间 [i, j] 我们先考虑最后戳破哪个气球 k，而不是先戳破哪个气球，这样一来区间 [i , j] 所能获得的最大分数就是 nums[i] * nums[k] * nums[j] 加上之前戳破的气球的分数总和，那么之前戳破的气球的分数总和怎么计算呢？气球 k 把区间 [i, j] 分成了两个子区间 [i ,k] 和 [k, j]，在这两个区间中用同样的方法计算最后戳破哪个气球，最终得到的结果就是整个区间 [i ,j] 能获得的最大分数。</p>
<p>按照上面的思路，我们自然想到递归，枚举每一个 k，然后递归地计算 [i ,k] 和 [k, j]，为了避免重复计算，可以把递归过程中的结果存起来，以减少时间复杂度，这也是递归的常规优化思路，同时为了方便计算，我们可以把左右边界的数值为 1 的气球加上，重新构造一个数组 val 来存放气球，并且子区间都为开区间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rec;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += <span class="built_in">solve</span>(left, i) + <span class="built_in">solve</span>(i, right);</span><br><span class="line">            rec[left][right] = <span class="built_in">max</span>(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        val.<span class="built_in">resize</span>(n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec.<span class="built_in">resize</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这并不是动态规划，而是类似于深搜的记忆化搜索，动态规划怎么做呢？记忆化搜索是从整个区间开始自顶向下的递归计算，那我们从最小的区间开始自底向上计算，最终得到最大区间的结果，这不就是动态规划的形式吗，因此我们可以按照区间动态规划的一般遍历方法，从后向前遍历每一个位置，对每一个位置再遍历不同长度的子区间，相当于找到一个子问题，对于每个子区间就可以枚举分界点 k 进行计算，因此状态转移方程可以写出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j]</span><br></pre></td></tr></table></figure>

<p>边界条件是如果 <code>i &gt;= j</code> 说明区间内没有气球（因为区间为开区间），能得到的最大分数为 0 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += dp[i][k] + dp[k][j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/">多边形三角剖分的最低得分</a></h4><blockquote>
<p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（顺时针顺序）。</p>
<p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p>
<p>返回多边形进行三角剖分后可以得到的最低分 。</p>
</blockquote>
<p>这是上面题目的简化版，是一个典型的模板题目，给定的数组是多边形顺时针的顶点，因此对于一个区间 [i , j] 存储的是从顶点 i 到顶点 j 顺时针遍历的每一个中间顶点，我们可以遍历每一个中间顶点，这样连接顶点 i 和 k，k 和 j，这样多边形就会被分为三个部分，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/TechStack\Blogs\lz328\source_posts\20220325-区间动态规划\4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI.jpg" alt="4995bcc09ad24872a23c0847c8e1d9993aebabc4fbdfb5ec523951736d3a405f-Inked图形_LI"></p>
<p>一部分是区间 [i, k] 表示的多边形，一部分是区间 [k, j]  表示的多边形，一部分是三角形 ikj，这三部分的分数和最小的就是当前区间 [i, j] 的答案。</p>
<p>因为至少要有一个三角形，因此区间长度至少为 3 ，小于 3 的区间得分都是 0 ，这也是动态规划的边界条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = values.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; ++len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = dp[i][k] + dp[k][j] + values[i] * values[k] * values[j];</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的打印机"><a href="#奇怪的打印机" class="headerlink" title="奇怪的打印机"></a><a href="https://leetcode-cn.com/problems/strange-printer/">奇怪的打印机</a></h4><blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 同一个字符 组成的序列。</li>
<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
</blockquote>
<p>这也是一个经典的区间动态规划模板题，打印区间 [i, j] 时如果 <code>s[i] == s[j]</code>，则不需要考虑 s[j] ，因为打印 s[i] 时可以顺便打印 s[j] ，所以此时 <code>dp[i][j] = dp[i][j-1]</code>，如果二者不相等，则要分别打印，这时枚举中间位置 k ，考虑两个区间分别打印的最小次数之和即可，即 <code>dp[i][j] = min(dp[i][k] + dp[k+1][j])</code>，其中 k 是 i 和 j 的是中间位置。</p>
<p>边界条件是 <code>dp[i][i] = 1</code>，一个字母需要单独打印一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strangePrinter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></h4><blockquote>
<p>给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p>
<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p>
<p>如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<p>这是一个很有意思的区间动态规划问题，当然也可以用递归的思路做，但会存在大量重复计算，因此动态规划更好，定义 $dp[i][j]$ 为在区间 nums[i … j] 上两人分数的最大差值，状态转移就是两种情况：</p>
<ul>
<li>当前玩家拿 nums[i]，此时 <code>dp[i][j] = nums[i] - dp[i+1][j]</code></li>
<li>当前玩家拿 nums[j]，此时 <code>dp[i][j] = nums[j] - dp[i][j-1]</code></li>
</ul>
<p>因为每次玩家都选择最优情况，因此 <code>dp[i][j]</code> 取二者中较大值。</p>
<p>边界条件是对于只有一个数字的区间就只能拿这个数字，因此 <code>dp[i][i] = nums[i]</code>，其他 i &gt; j 的区间都为 0 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; (n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然可以优化空间，改为一维数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></h4><blockquote>
<p>Alice 和 Bob 用几堆石子在做游戏。一共有<strong>偶数堆</strong>石子，排成一行；每堆都有正整数颗石子，数目为 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是<strong>奇数</strong> ，所以没有平局。</p>
<p>Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜 。</p>
<p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。</p>
</blockquote>
<p>这是上一题的一种特殊情况，数组长度为偶数且总分为奇数，因此自然可以用上一题的方法解决，当然通过数学推导也可以得出这种情况下先手玩家总能获胜，因此可以直接返回 true。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编码最短长度的字符串"><a href="#编码最短长度的字符串" class="headerlink" title="编码最短长度的字符串"></a><a href="https://leetcode-cn.com/problems/encode-string-with-shortest-length/">编码最短长度的字符串</a></h4><blockquote>
<p>给定一个非空字符串，将其编码为具有最短长度的字符串。</p>
<p>编码规则是：k[encoded_string]，其中在方括号 encoded_string 中的内容重复 k 次。</p>
<p>注：</p>
<ul>
<li>k 为正整数</li>
<li>如果编码的过程不能使字符串缩短，则不要对其进行编码。如果有多种编码方式，返回任意一种即可。</li>
</ul>
</blockquote>
<p>这是一道非常新颖的区间动态规划问题，状态定义是不容易想到的，值得反复琢磨。</p>
<p>这道题最难的地方不是在动态规划，而是如何找到字符串中的连续重复子串，这是另一道题<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a>中讨论的问题，可以使用暴力法，也可以使用 KMP 算法，最简单的方法是使用 一行代码 <code>(s + s).find(s, 1)</code>，关于这个方法的解释和正确性证明，可以查看重复子字符串的官方题解，总之我们可以得到 <code>p = (s + s).find(s, 1)</code>，也就是将两个字符串拼接起来从 1 的位置开始查找原本的字符串第一次出现的位置，如果 <code>p &gt;= s.size()</code> 说明没有重复子字符串，否则存在重复子字符串，且连续重复子串是 <code>s.substr(0, p-1)</code>，重复次数为 <code>s.size() / p</code>。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = ”aabcaabc” </span><br><span class="line">则 s + s = “aabcaabcaabcaabc”</span><br><span class="line">p = (s + s).find(s, 1) = 4</span><br><span class="line">因此连续重复子串是 s.substr(0, 4 - 1) = ”aabc”，重复次数为 8 / 4 = 2 次。</span><br></pre></td></tr></table></figure>

<p>利用这个性质我们可以定义状态 <code>dp[i][j]</code> 表示子字符串 <code>s.substr(i, j)</code> 的最短编码串，对于长度小于 5 的子字符串，无需编码，因此长度小于 5 的区间的状态 <code>dp[i][j]</code> 就等于这个子字符串，长度大于 5 时，最短编码串有两种情况：</p>
<ul>
<li>找到最小重复子串，然后进行编码</li>
<li>枚举区间内的分界点 k ，取两个子区间 [i, k]  和 [k+1, j] 的最短编码串长度总和最小的情况</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;string&gt;(s.<span class="built_in">size</span>(), <span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len &lt;= s.<span class="built_in">size</span>(); ++len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i + len - <span class="number">1</span> &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = s.<span class="built_in">substr</span>(i, len);</span><br><span class="line">                <span class="keyword">if</span>(len &gt;= <span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> p = (dp[i][j] + dp[i][j]).<span class="built_in">find</span>(dp[i][j], <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(p &lt; len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">to_string</span>(dp[i][j].<span class="built_in">size</span>() / p) + <span class="string">&quot;[&quot;</span> + dp[i][i+p<span class="number">-1</span>] + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][k].<span class="built_in">size</span>() + dp[k+<span class="number">1</span>][j].<span class="built_in">size</span>() &lt; dp[i][j].<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j] = dp[i][k] + dp[k+<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/">合并石头的最低成本</a></h4><blockquote>
<p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p>
<p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p>
<p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p>
</blockquote>
<p>这是一道比较困难的题目，但思路还是比较容易理解的，具体思路和优化过程可以看<a href="https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/solution/c-acde-di-1000ti-xian-gei-di-1000ti-jing-ecs9/">题解</a>。</p>
<h4 id="移除盒子"><a href="#移除盒子" class="headerlink" title="移除盒子"></a><a href="https://leetcode-cn.com/problems/remove-boxes/">移除盒子</a></h4><blockquote>
<p>给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。</p>
<p>你将经过若干轮操作去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k &gt;&#x3D; 1），这样一轮之后你将得到 k * k 个积分。</p>
<p>返回你能获得的最大积分和 。</p>
</blockquote>
<p>这是一个更加复杂的问题，在区间的基础上还要增加一个额外维度 k 来记录消掉区间右边连续的 k 个数字，具体思路和代码参考<a href="https://leetcode-cn.com/problems/remove-boxes/solution/yi-chu-he-zi-by-leetcode-solution/">官方题解</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（一）基础光照</title>
    <url>/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p>从这一节开始用图形学知识学习 Shader 编写，虽然 Unity Shader 不完全等同于 Shader，但 Unity 提供了更方便的 Shader 编写环境，提供了大量的内置函数和变量，并且支持 GLSL , HLSL 和 CG 语言，是练习 Shader 编程的很好的平台。这一节我们从最简单的布林冯光照模型开始，学习如何用 Shader 渲染物体。</p>
<p><em><span id="more"></span></em></p>
<h4 id="1-实现漫反射光照模型"><a href="#1-实现漫反射光照模型" class="headerlink" title="1 实现漫反射光照模型"></a>1 实现漫反射光照模型</h4><p>回顾布林冯模型中漫反射的计算公式：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})\ max(0, \vec n ·\vec I)<br>$$<br>其中 $c_{light}$ 是光线颜色，$m_{diffuse}$ 是物体漫反射颜色。</p>
<h5 id="1-1-逐顶点漫反射"><a href="#1-1-逐顶点漫反射" class="headerlink" title="1.1 逐顶点漫反射"></a>1.1 逐顶点漫反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;    <span class="comment">//定义和上面的属性一样名字一样类型的变量才能得到属性的值</span></span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// fixed3 ambient = (0.0, 0.0, 0.0);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算漫反射，saturate函数将其中的值截断到[0,1]，相当于max(0, dot(worldNormal, worldLight))</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;    <span class="comment">//如果平台无法运行Pass中的代码，将会使用默认的Diffuse Shader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-逐片元漫反射"><a href="#1-2-逐片元漫反射" class="headerlink" title="1.2 逐片元漫反射"></a>1.2 逐片元漫反射</h5><p>在上面的代码基础上稍作修改即可，关于法线是先变换后插值还是先插值后变换，是没有影响的，得到的效果完全一样。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Diffuse Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                <span class="comment">//先不进行归一化，插值后再归一</span></span><br><span class="line">                o.normal = mul(v.normal, (float3x3)unity_WorldToObject);    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                float3 worldnormal = <span class="built_in">normalize</span>(i.normal);</span><br><span class="line">                <span class="comment">// 计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldnormal, worldLight));</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-半兰伯特（Half-Lambert）模型"><a href="#1-3-半兰伯特（Half-Lambert）模型" class="headerlink" title="1.3 半兰伯特（Half Lambert）模型"></a>1.3 半兰伯特（Half Lambert）模型</h5><p>在上面的光照模型中，光线无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化，这会使模型的背光区域看起来就像一个平面一样，失去了模型细节表现。实际上我们可以通过添加环境光来得到非全黑的效果，但即便这样仍然无法解决背光面明暗一样的缺点。为此，有一种改善技术被提出来，这就是半兰伯特 (Half Lambert) 光照模型。</p>
<p>相对的，前面使用的模型叫做兰伯特光照模型，因为它符合兰伯特余弦定理，半兰伯特模型是对兰伯特模型的简单修改，公式如下：<br>$$<br>c_{diffuse} &#x3D; (c_{light}\ m_{diffuse})(\alpha(\vec n ·\vec I)+ \beta)<br>$$<br>可以看出半兰伯特模型不再限定光线和法线夹角余弦要大于 0 ，而是对余弦进行一个 $\alpha$ 倍的缩放再加上一个偏移量 $\beta$，绝大多数情况下，$\alpha$ 和 $\beta$ 都是 0.5。通过这样的方式，我们可以把 $\vec n ·\vec I$ 的结果范围从 [-1, 1] 映射到 [0, 1] 范围内。也就是说，对于模型的背光面，在原兰伯特光照模型中点积结果将映射到同一个值，即 0；而在半兰伯特模型中，背光面也可以有明暗变化，不同的点积结果会映射到不同的值上。</p>
<p>需要注意的是，半兰伯特是没有任何物理依据的，它仅仅是一个视觉加强技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Half Lambert&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    <span class="comment">//材质的漫反射颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;    <span class="comment">//要定义正确的LightMode才能在后面得到正确的光照方向和强度值</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 顶点从模型空间到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 法线变换，将模型空间法线变换到世界空间，使用原变换矩阵的逆转置矩阵变换法线</span></span><br><span class="line">                <span class="comment">// 原变换矩阵是unity_ObjectToWorld，逆矩阵就是unity_WorldToObject，右乘变左乘相当于转置，因为是对向量变换所以只需使用3x3矩阵</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));    </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 得到世界空间下的光源方向</span></span><br><span class="line">                fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 计算半兰伯特漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * (<span class="number">0.5</span> * <span class="built_in">dot</span>(i.normal, worldLight) + <span class="number">0.5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种模型渲染的最终效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181148410.png" alt="image-20220402181148410"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402181122407.png" alt="image-20220402181122407"></p>
<p>可以看到兰伯特模型背光部分也有明暗变化。而在明暗交接处顶点着色有明显的锯齿，片元着色则非常平滑。</p>
<h4 id="2-实现高光反射光照模型"><a href="#2-实现高光反射光照模型" class="headerlink" title="2 实现高光反射光照模型"></a>2 实现高光反射光照模型</h4><p>首先回顾高光反射计算公式（Phong光照模型）：<br>$$<br>c_{specular} &#x3D; (c_{light}\ m_{specular})\ max(0, \vec v ·\vec r)^{m_{gloss}}<br>$$<br>其中，其中 $c_{light}$ 是光线颜色，$m_{specular}$ 是物体高光反射系数，$\vec v$是视线方向，$\vec r$ 是镜面反射方向，$\vec r$ 可以由法线方向和光照方向计算得到：<br>$$<br>\vec r &#x3D; \vec I - 2(\vec n · \vec I)\vec n<br>$$<br>CG 提供了计算反射方向的函数 reflect。</p>
<h5 id="2-1-逐顶点高光反射"><a href="#2-1-逐顶点高光反射" class="headerlink" title="2.1 逐顶点高光反射"></a>2.1 逐顶点高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Vertex-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line">                                 </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-逐片元高光反射"><a href="#2-2-逐片元高光反射" class="headerlink" title="2.2 逐片元高光反射"></a>2.2 逐片元高光反射</h5><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Specular Fragment-Level&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">//由于要计算世界空间下的观察方向，因此需要把世界空间的顶点坐标也传给片元着色器</span></span><br><span class="line">                float3 worldpos : TEXCOORD0;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 计算世界空间下的顶点坐标</span></span><br><span class="line">                o.worldpos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 计算裁剪空间下的顶点坐标</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 计算世界空间下的法线</span></span><br><span class="line">                o.normal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));             </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(i.normal, worldLightDir));</span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir, i.normal));</span><br><span class="line">                <span class="comment">// 获得世界空间下的观察方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldpos);                </span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + diffuse + specular;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-Blinn-Phong-光照模型"><a href="#2-3-Blinn-Phong-光照模型" class="headerlink" title="2.3 Blinn-Phong 光照模型"></a>2.3 Blinn-Phong 光照模型</h5><p>Blinn-Phong 光照模型用半程向量和法线的夹角替代反射方向和视线方向的夹角。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 得到世界空间的光线反射反向，注意要取光线方向的反方向才是入射方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// 计算世界空间的半程向量</span></span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                <span class="comment">// 计算高光项</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种方式最终渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/02/20220402-Shader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220402195954499.png" alt="image-20220402195954499"></p>
<p>可以看出最左边的逐顶点高光有明显的不平滑，这主要是因为高光反射部分的计算是非线性的，而在顶点着色器中计算光照再进行插值的过程是线性的，破坏了原计算的非线性关系，就会出现较大的视觉问题。最右边 Blinn-Phong 光照模型的高光反射部分看起来更大、更亮一些。在实际渲染中，绝大多数情况我们都会选择 Blinn-Phong 光照模型。需要再次提醒的是，这两种光照模型都是经验模型，也就是说，我们不应该认为 Blinn-Phong 模型是对“正确的” Phong 模型的近似。</p>
<h4 id="3-使用Unity内置函数实现-Blinn-Phong-光照"><a href="#3-使用Unity内置函数实现-Blinn-Phong-光照" class="headerlink" title="3 使用Unity内置函数实现 Blinn-Phong 光照"></a>3 使用Unity内置函数实现 Blinn-Phong 光照</h4><p>Unity 有许多内置函数可以直接得到我们需要的光照方向、视线方向等，免去了我们自己计算的麻烦。尤其是光照方向，如果处理更复杂的光源，比如聚光灯，我们上面的光照方向就会是错误的，因此我们的代码中还需要判断光源类型，而 Unity 的内置函数已经帮我们完成了这些判断。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">6</span>/Blinn-Phong Use Built-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">1.0</span>, <span class="number">500</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float4 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityObjectToWorldNormal将法线从模型空间变换到世界空间，没有归一化</span></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceLightDir获得世界空间下的光线方向，记得归一化</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 使用内置函数UnityWorldSpaceViewDir获得世界空间下的视线方向，记得归一化</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】二分查找</title>
    <url>/LycTechStack.github.io/2022/03/28/20220328-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找是一个常见的面试主题，也是计算机科学中最基本的算法思想之一，虽然二分查找比较简单，大部分专门考察二分查找的题目在实际机试中也几乎不会出现，但二分查找是许多困难题目中必不可少的一个步骤，因此值得单独花一定时间将其彻底掌握。这一节将学习三个不同的二分查找模板并在对应的题目上进行实践和巩固，这之中也不乏之前做过的题目，顺便复习一下。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-模板-1"><a href="#1-模板-1" class="headerlink" title="1 模板 #1"></a>1 模板 #1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最标准的也是最简单的二分查找模板，是二分查找的最基本的形式，只要注意循环停止条件即可。</p>
<p>利用模板 #1 可以解决许多简单的二分查找问题：</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></p>
<p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">猜数字大小</a></p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a>：在不排序的情况下用二分查找，先判断左右两个区间哪个有序，因为分成两个区间一定有一个有序一个无序，我们在有序区间内很容易判断目标值是否在区间内，如果不在有序区间，那么目标值就在无序区间，再对另外的无序区间继续以上步骤，直到查找到目标值或跳出循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])    <span class="comment">//左半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果目标值在该区间内，就在该区间查找</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[<span class="number">0</span>] &amp;&amp; target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则在另外一半区间查找</span></span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//右半部分有序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-模板-2"><a href="#2-模板-2" class="headerlink" title="2 模板 #2"></a>2 模板 #2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #2 是二分查找的高级模板。它用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件，因此循环结束条件是小于而不是小于等于，这样能保证区间中有至少两个元素，同时 <code>right = mid</code> 而不是 <code>mid - 1</code> ，最后还要做后处理判断最后一个元素是否满足条件。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本</a>：模板题</p>
<p><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a>：实际上跟使用的模板无关，都可以做对，这道题关键在于能想到“一直往上爬总能到山顶”</p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a>：因为本身就是要寻找最小值，所以必须是 <code>right = mid</code>，如果 <code>right = mid - 1</code> 可能会把最小值跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-模板-3"><a href="#3-模板-3" class="headerlink" title="3 模板 #3"></a>3 模板 #3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要访问当前索引及其在数组中的直接左右邻居索引的元素或条件。显然，和模板 #2 的区别是每次循环保证区间至少有三个元素，循环结束的条件是区间只剩两个元素。</p>
<p>可以用这类模板的题目有：</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>：普通二分 + 中心扩展，但时间复杂度高于 O(logn) ；也可以两次二分，一次查找大于等于target的第一个下标，一次查找大于target的第一个下标，这样时间复杂度保证在 O(logn) ，在数组中 target 值很多的情况下显然两次二分更好。</p>
<p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">找到 K 个最接近的元素</a>：如果 x 在数组范围内，则二分查找先找到大于等于 x 的第一个下标，然后双指针从该下标开始向左右两边查找 k 次；如果 x 不在数组范围内则情况很简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; arr[<span class="number">0</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>]) ans.<span class="built_in">assign</span>(arr.<span class="built_in">end</span>() - k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span>&#123;	<span class="comment">//在数组范围内则二分 + 双指针</span></span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)	<span class="comment">//先找到大于等于 x 的第一个下标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr[mid] &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = mid;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = t - <span class="number">1</span>, right = t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)		<span class="comment">//开始向左右扩展寻找 k 次</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(left &lt; <span class="number">0</span>)	<span class="comment">//如果左指针已经到头了就直接向右扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; arr.<span class="built_in">size</span>() - <span class="number">1</span>)		<span class="comment">//同上，右指针到头直接向左扩展</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x - arr[left] &lt;= arr[right] - x) --left;</span><br><span class="line">                <span class="keyword">else</span> ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>() + left + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>二分查找最重要的是思想，一般在给定的数组是有序的情况下，一定可以用二分查找优化时间，上面的模板只是相对牵强的做一个总结，并不需要也不应该去记忆，只要能理解算法思想，实际题目中用什么样的二分查找，循环结束条件如何，怎样收缩区间，都要根据题目本身去确定。</p>
<h3 id="5-更多练习"><a href="#5-更多练习" class="headerlink" title="5 更多练习"></a>5 更多练习</h3><h4 id="最接近的二叉搜索树值"><a href="#最接近的二叉搜索树值" class="headerlink" title="最接近的二叉搜索树值"></a><a href="https://leetcode-cn.com/problems/closest-binary-search-tree-value/">最接近的二叉搜索树值</a></h4><blockquote>
<p>给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。</p>
<p>注意：</p>
<ul>
<li>给定的目标值 target 是一个浮点数</li>
<li>题目保证在该二叉搜索树中只会存在一个最接近目标值的数</li>
</ul>
</blockquote>
<p>二叉搜索树的中序遍历可以得到递增序列，因此最简单的方法就是中序遍历再查找，但是更高效的方法是直接判断目标值和当前节点的大小，如果比当前节点大说明最接近的值一定在当前节点的右子树，因此向右遍历，否则向左遍历，每次遍历记录最小差值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="type">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = root-&gt;val;</span><br><span class="line">        <span class="type">double</span> minsub = DBL_MAX;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> sub = <span class="built_in">abs</span>(target - root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(sub &lt;= minsub)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = root-&gt;val;</span><br><span class="line">                minsub = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            root = (target &gt;= root-&gt;val ? root-&gt;right : root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="搜索长度未知的有序数组"><a href="#搜索长度未知的有序数组" class="headerlink" title="搜索长度未知的有序数组"></a><a href="https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size/">搜索长度未知的有序数组</a></h4><blockquote>
<p>这是一个交互问题。</p>
<p>您有一个升序整数数组，其长度未知。您没有访问数组的权限，但是可以使用 ArrayReader 接口访问它。你可以调用 ArrayReader.get(i) 返回数组第 i 个索引**(0-indexed)**处的值(即secret[i])，如果 i 超出了数组的边界，则返回 <code>INT_MAX</code></p>
<p>你也会得到一个整数 target，如果存在secret[k] &#x3D;&#x3D; target，请返回索引 k 的值；否则返回 -1。</p>
<p>你必须写一个时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<p>关键在于确定二分边界，我们可以每次把边界扩大一倍，确定边界后就直接二分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> ArrayReader&amp; reader, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(reader.<span class="built_in">get</span>(right) &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            right = right &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(reader.<span class="built_in">get</span>(mid) &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h4><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p>
</blockquote>
<p>这是一道经典的问题，快速幂问题最好的做法就是分治，也算是二分的推广，我们每次计算 $x^{\frac{n}{2}}$，返回 $x^{\frac{n}{2}}$ 的平方，直到 $x^0 &#x3D; 1$，这样就可以递归地快速算出答案，当然如果每次递归中 $n$ 是奇数，还需要额外乘一个 x，具体看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>递归需要额外系统栈空间，因此最好改成迭代，关于迭代的推导可以查看<a href="https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/">官方题解</a>，非常容易理解，将幂指数二进制分解，对应的二进制位是 1 就将结果乘到最终结果上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快速幂问题非常重要，之后还会遇到类似的问题。</p>
<h4 id="有效的完全平方数"><a href="#有效的完全平方数" class="headerlink" title="有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">有效的完全平方数</a></h4><blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>不要使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<p>简单二分，可以看一下<a href="https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/">官方题解方法四</a>的牛顿迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(s == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s &gt; num) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">寻找比目标字母大的最小字母</a></h4><blockquote>
<p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<ul>
<li>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">nextGreatestLetter</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; letters, <span class="type">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = letters.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ans = letters[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r -l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[m] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = letters[m];</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="寻找旋转排序数组中的最小值-II"><a href="#寻找旋转排序数组中的最小值-II" class="headerlink" title="寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值 II</a></h4><blockquote>
<p>给你一个可能<strong>存在重复元素值</strong>的数组 nums ，它原来是一个升序排列的数组，并进行了多次旋转。请你找出并返回数组中的最小元素。你必须尽可能减少整个过程的操作步骤。</p>
</blockquote>
<p>这是寻找旋转排序数组中最小值的进阶版，区别在于有重复元素，因此会存在特殊情况，就是重复的部分被旋转了，此时判断 <code>nums[mid]</code> 和 <code>nums[right]</code> 的关系可能存在二者相等的情况，这时整个数组的分布可能有下面两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">2 2     2 2 2 2 2</span><br><span class="line">      1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在左半区间，另一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        3</span><br><span class="line">2 2 2 2     2 2 2</span><br><span class="line">          1 </span><br></pre></td></tr></table></figure>

<p>这时最小值在右半区间，因此我们无法判断下一次在哪边区间查找，但无论哪种情况，我们只要不停收缩右边界，直到 <code>nums[mid] != nums[right]</code> 或者 <code>right == mid</code> ，最小值一定在区间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == nums[r]) --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; nums[r]) l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">两个数组的交集</a></h4><blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。我们可以<strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<p>简单的排序 + 双指针问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>() != nums1[p1]) ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]) ++p2;</span><br><span class="line">            <span class="keyword">else</span> ++p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">两个数组的交集 II</a></h4><blockquote>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
</blockquote>
<p>同上，甚至更简单，无需重复判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] == nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                ++p1, ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2]) ++p1;</span><br><span class="line">            <span class="keyword">else</span> ++p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></h4><blockquote>
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入只对应唯一的答案 ，而且你不可以重复使用相同的元素，并且你所设计的解决方案必须只使用常量级的额外空间。</p>
</blockquote>
<p>之前在双指针部分做过，这道题自然双指针解法也更好，但也可以对于每一个数在它的右侧区间二分的进行查找，只是时间复杂度高于双指针法，因此也更推荐双指针做法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] == target) <span class="keyword">return</span> &#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target) ++left;</span><br><span class="line">            <span class="keyword">else</span> --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-用二分法解决困难题目"><a href="#6-用二分法解决困难题目" class="headerlink" title="6 用二分法解决困难题目"></a>6 用二分法解决困难题目</h3><h4 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">寻找重复数</a></h4><blockquote>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回这个重复的数 。</p>
<p>你设计的解决方案必须<strong>不修改</strong>数组 nums 且只用<strong>常量级 O(1)</strong> 的额外空间。</p>
</blockquote>
<p>这道题看似不难，但其实是非常巧妙的一道题，值得反复琢磨。</p>
<p>首先看看为什么这道题没那么简单，第一，不允许修改数组使得我们不能对原数组排序；第二，必须使用 O(1) 额外空间使得我们也不能复制数组或者用哈希表，因此还是有一定难度的。</p>
<p>这道题很难想到用二分法，要想用二分法得基于一个很巧妙的性质：对于数组中的任何一个数 nums[i] ，如果用 cnt[i] 表示数组中小于等于  nums[i] 的数字的个数，那么如果 nums[i] 比重复数字 target 小，则一定满足 <code>cnt[i] &lt;= i</code> ，反之如果 nums[i] 比重复数字 target 大，那么一定满足<code>cnt[i] &gt; i</code>，这是一个一目了然的性质，但却很难想到。</p>
<p>因此我们可以二分的查找第一个满足 <code>cnt[i] &gt; i</code> 的下标，即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;	<span class="comment">//统计cnt[mid]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面二分法的时间复杂度是 O(nlogn)，那能否在 O(n) 时间内完成呢？</p>
<p>回顾之前链表部分做过的环形链表问题，当时我们用到了快慢指针，慢指针每次走一步，快指针每次走两步，二者同时出发，如果链表有环，则快慢指针一定会相遇，相遇后慢指针回到起点，和快指针同时每次走一步前进，二者再次相遇处就是环的入口。</p>
<p>这道题完全可以利用快慢指针的思想，我们可以把整个数组建立一张图，数组中每个数字 x 指向 nums[x] ，这样一来如果有重复的数字 target，那么一定有两个或者多个 target 指向 nums[target]，此时相当于图中有环，我们利用快慢指针就可以找到环的入口，环的入口就是重复的数字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快慢指针的时间复杂度只有 O(n).</p>
<h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度必须为 O(log (m+n)) 。</p>
</blockquote>
<p>这是一道很经典的二分题目。因为规定了时间复杂度，因此不能使用合并+排序的方法，看到 log 也很容易想到二分，但是这道题即便是知道要用二分法也无从下手。</p>
<p>核心思想是：找到两个数组的中位数相当于找到两个数组中第 k 大的数，因此在两个数组中分别找到第 k &#x2F; 2 大的数进行比较，较小的数所在的数组可以直接把前 k &#x2F; 2 个数去掉，同时更新 k 的大小，这样每次就减小了一半的查找范围。</p>
<p>具体的细节和推导可以查看<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">官方题解</a>，代码中的细节也很多，这道题值得反复琢磨。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> offset1 = <span class="number">0</span>, offset2 = <span class="number">0</span>;   <span class="comment">//记录数组偏移</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (offset1 == m) &#123; <span class="comment">//数组 1 遍历完了，直接返回数组 2 第 k 大的数</span></span><br><span class="line">                <span class="keyword">return</span> nums2[offset2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (offset2 == n) &#123; <span class="comment">//同上</span></span><br><span class="line">                <span class="keyword">return</span> nums1[offset1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;   	<span class="comment">//k为1则直接返回两个数组首元素最小值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[offset1], nums2[offset2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(offset1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(offset2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - offset1 + <span class="number">1</span>;</span><br><span class="line">                offset1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - offset2 + <span class="number">1</span>;</span><br><span class="line">                offset2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="找出第-k-小的距离对"><a href="#找出第-k-小的距离对" class="headerlink" title="找出第 k 小的距离对"></a><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">找出第 k 小的距离对</a></h4><blockquote>
<p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p>
</blockquote>
<p>这也是一道比较困难的二分查找题目。第 k 小的距离一定在 [0, max(nums) - min(nums)] 之间，因此我们可以在这个区间上二分查找，然后统计 nums 中小于等于距离 mid 的数对的个数，如果小于等于距离 mid 的数对个数比 k 大，说明 mid 较大，在左区间查找，反之在右区间查找。注意这里的二分查找要用模板 #2，因为如果小于等于距离 mid 的数对个数比 k 大，第 k 个最小距离也可能就是 mid，因此右边界 <code>right = mid</code>。</p>
<p>至于如何统计 nums 中小于等于距离 mid 的数对的个数，最简单的方法可以暴力遍历，但是为了提高效率我们可以先对数组排序，然后双指针统计即可，具体方法见代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回距离比mid小的数对的个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[r] - nums[l] &gt; mid) l++;</span><br><span class="line">            res += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) - *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(nums, mid) &gt;= k) r = mid;  <span class="comment">//如果个数比k大，则说明mid比较大，在mid的左边寻找</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;                 <span class="comment">//如果个数比k小，则说明mid比较小，在mid的右边寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p>
</blockquote>
<p>这道题在动态规划中遇到过，但是用动态规划时空复杂度较高。最好的方法是二分 + 贪心，实际上思路和上一题很相似，我们可以确定答案的范围，然后通过二分查找去“猜”答案是什么。具体推导可以查看<a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[i] &gt; x) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; nums[i]) &#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(nums, mid, m)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（三）透明效果</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>透明是游戏中经常要使用的一种效果。这一节我们学习透明效果是如何实现的。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-透明效果的原理"><a href="#1-透明效果的原理" class="headerlink" title="1 透明效果的原理"></a>1 透明效果的原理</h3><p>在实时渲染中要实现透明效果，通常会在渲染模型时控制它的透明通道（Alpha Channel）。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度。当透明度为 1 时，表示该像素是完全不透明的，而当其为 0 时，则表示该像素完全不会显示。</p>
<p>Unity 中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试（Alpha Test）</strong>，这种方法其实无法得到真正的半透明效果；另一种是<strong>透明度混合（Alpha Blending）</strong>。</p>
<h4 id="1-1-透明度测试"><a href="#1-1-透明度测试" class="headerlink" title="1.1 透明度测试"></a>1.1 透明度测试</h4><p>透明度测试的原理是：只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p>
<h4 id="1-2-透明度混合"><a href="#1-2-透明度混合" class="headerlink" title="1.2 透明度混合"></a>1.2 透明度混合</h4><p>在之前的学习中，我们从没有强调过渲染顺序的问题。也就是说，当场景中包含很多模型时，我们并没有考虑是先渲染 A，再渲染 B，最后再渲染 C，还是按照其他的顺序来渲染。事实上，对于不透明 (opaque) 物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲 z-buffer 的存在。但如果想要实现透明效果，事情就不那么简单了，这是因为， 当使用透明度混合时，我们关闭了深度写入 (ZWrite) 。</p>
<p>透明度混合可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。</p>
<h4 id="1-3-渲染顺序"><a href="#1-3-渲染顺序" class="headerlink" title="1.3 渲染顺序"></a>1.3 渲染顺序</h4><p>那么我们为什么要关闭深度写入呢？如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。但是，我们由此就破坏了深度缓冲的工作机制，而这是一个非常非常非常（重要的事情要讲3遍）糟糕的事情， 尽管我们不得不这样做。关闭深度写入导致渲染顺序将变得非常重要。</p>
<p>我们来考虑最简单的情况。假设场景里有两个物体A和B，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171332205.png" alt="image-20220403171332205"></p>
<p>其中 A 是半透明物体，而 B 是不透明物体。我们来考虑不同的渲染顺序会有什么结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么由于不透明物体开启了深度测试和深度写入，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比 A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 的颜色进行混合，得到正确的半透明效果；</li>
<li>第二种情况，我们先渲染 A，再渲染 B。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现，”咦，深度缓存中还没有人来过，那我就放心地写入颜色缓冲了！“   结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。、</li>
</ul>
<p>从这个例子可以看出， 当关闭了深度写入后， 渲染顺序是多么重要。 由此我们知道， 我们应该在不透明物体渲染完之后再渲染半透明物体。那么，如果都是半透明物体，渲染顺序还重要吗？答案是肯定的。还是假设场景里有两个物体 A 和 B ，如下图，其中 A 和 B 都是半透明物体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403171748283.png" alt="image-20220403171748283"></p>
<p>我们还是考虑不同的渲染顺序有什么不同结果：</p>
<ul>
<li>第一种情况，我们先渲染 B，再渲染 A。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。</li>
<li>第二种情况，我们先渲染 A，再渲染 B。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面， 得到的就是错误的半透明结果。</li>
</ul>
<p>因此半透明物体之间也是要符合一定的渲染顺序的。基于这两点，渲染引擎一般都会先对物体进行排序，再渲染。常用的方法是：</p>
<ol>
<li>先渲染所有不透明物体，并开启它们的深度测试和深度写入</li>
<li>把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入</li>
</ol>
<p>现在的问题是如何排序？我们在学习 Z-Buffer 时遇到过循环遮挡的现象，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172326037.png" alt="image-20220403172326037"></p>
<p>深度是对于每一个像素而言的，但对于一个物体我们怎么确定它的深度值呢？这种时候，我们可以选择把物体拆分成两个部分，然后再进行正确的排序。但是将物体分成两个部分还会存在物体的网格之间互相遮挡的现象，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403172554846.png" alt="image-20220403172554846"></p>
<p>上图中代表了两个网格，红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点，由于一个物体的网格结构往往占据了空间中的某一块区域，也就是说，这个网格上每一个点的深度值可能都是不一样的， 我们选择哪个深度值来作为整个物体的深度值和其他物体进行排序呢？对于上图中的情况，选择哪个深度值都会得到错误的结果，我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。这种问题的解决方法通常也是再对网格进行分割。</p>
<p>尽管结论是，总是会有一些情况打乱我们的阵脚，但由于上述方法足够有效并且容易实现，因此大多数游戏引擎都使用了这样的方法。为了减少错误排序的情况，我们可以尽可能让模型是凸面体，并且考虑将复杂的模型拆分成可以独立排序的多个子模型等。其实就算排序错误结果有时也不会非常糟糕，如果我们不想分割网格，可以试着让透明通道更加柔和，使穿插看起来并不是那么明显。</p>
<p>在 Unity 中，提供了渲染队列（render queue）来解决渲染顺序问题。我们可以使用 SubShader 的 Queue 标签来决定我们的模型将归于哪个渲染队列。Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。下表给出了这 5 个提前定义的渲染队列以及它们的描述：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403173042420.png" alt="image-20220403173042420"></p>
<h3 id="2-实现透明度测试"><a href="#2-实现透明度测试" class="headerlink" title="2 实现透明度测试"></a>2 实现透明度测试</h3><p>我们使用的纹理是一张透明纹理，每个方格的透明度都不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175423766.png" alt="image-20220403175423766"></p>
<p>通常，我们会在片元着色器中使用 clip 函数来进行透明度测试。clip 是 CG 中的一个函数，它的定义如下：</p>
<blockquote>
<p><strong>函数：</strong>void clip (float4 x);  void clip (float3 x);  void clip (float2 x);  void clip (float1 x);  void clip (float x);<br><strong>参数：</strong>裁剪时使用的标量或矢量条件。<br><strong>描述：</strong>如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色。它等同于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void clip (float4 x)</span><br><span class="line">&#123;</span><br><span class="line"> if (any(x &lt; 0)) discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>透明度测试的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Test&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制透明度测试阈值的属性，范围在 [0,1]，因为纹理像素的透明度就是在此范围内</span></span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度测试的Shader要使用AlphaTest渲染队列</span></span><br><span class="line">        <span class="comment">// IgnoreProjector设置为True, 这意味着这个Shader不会受到投影器(Projectors)的影响</span></span><br><span class="line">        <span class="comment">// RenderType标签可以让Unity 把这个Shader 归入到提前定义的组(这里就是TransparentCutout组)中，以指明该Shader是一个使用了透明度测试的Shader</span></span><br><span class="line">        <span class="comment">// 通常，使用了透明度测试的Shader都应该在SubShader中设置这三个标签</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 进行透明度测试</span></span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                <span class="comment">// 上面的一行相当于</span></span><br><span class="line"><span class="comment">//                if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line"><span class="comment">//                    discard;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阈值 Alpha Cutoff &#x3D; 0.55 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175744418.png" alt="image-20220403175744418"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.7 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175811916.png" alt="image-20220403175811916"></p>
<p>阈值 Alpha Cutoff &#x3D; 0.9 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403175824478.png" alt="image-20220403175824478"></p>
<p>可以看出，透明度测试得到的透明效果很“极端”一一要么完全透明，要么完全不透明，它的效果往往像在一个不透明物体上挖了一个空洞。而且，得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。为了得到更加柔滑的透明效果，就应该使用透明度混合。</p>
<h3 id="3-实现透明度混合"><a href="#3-实现透明度混合" class="headerlink" title="3 实现透明度混合"></a>3 实现透明度混合</h3><p>透明度混合的实现要比透明度测试复杂一些，这是因为我们在处理透明度测试时，实际上跟对待普通的不透明物体几乎是一样的，只是在片元着色器中增加了对透明度判断并裁剪片元的代码。而想要实现透明度混合就没有这么简单了。我们回顾之前提到的透明度混合的原理：它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>
<p>为了进行混合，我们需要使用 Unity 提供的混合命令 Blend，Blend 是 Unity 提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合，混合时使用的函数就是由该指令决定的。下表给出了 Blend 命令的语义：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403180134386.png" alt="image-20220403180134386"></p>
<p>透明度混合的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Alpha Scale &#x3D; 1 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181200047.png" alt="image-20220403181200047"></p>
<p>Alpha Scale &#x3D; 0.5 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181244334.png" alt="image-20220403181244334"></p>
<p>Alpha Scale &#x3D; 0.2 时的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181300024.png" alt="image-20220403181300024"></p>
<h3 id="4-开启深度写入的半透明效果"><a href="#4-开启深度写入的半透明效果" class="headerlink" title="4 开启深度写入的半透明效果"></a>4 开启深度写入的半透明效果</h3><p>当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会有各种各样因为排序错误而产生的错误的透明效果，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403181435245.png" alt="image-20220403181435245"></p>
<p>之前提到解决这样问题的方案是分割网格，但很多情况下这是不切实际的。这时，我们可以想办法重新利用深度写入，让模型可以像<br>半透明物体一样进行淡入淡出。</p>
<p>一种解决方案是，使用两个 Pass 来渲染模型：第一个 Pass 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中；第二个 Pass 进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。但这种方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。</p>
<p>为了使一个 Pass 中不输出任何颜色，需要用到一个渲染指令 ColorMask，在 ShaderLab 中， ColorMask 用于设置颜色通道的写掩码（write mask），它的语义如下：</p>
<blockquote>
<p>ColorMask  RGB   I  A  I  0  I   其他任何 R、G、B、A 的组合</p>
</blockquote>
<p>当 ColorMask 设为 0 时，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。这正是我们需要的，该 Pass 只需写入深度缓存即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//_AlphaScale 用于在透明纹理的基础上控制整体透明度</span></span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 使用透明度混合的Shader要使用Transparent渲染队列</span></span><br><span class="line">        <span class="comment">// 渲染类型也是Transparent，这时会将Shader归入Transparent组中</span></span><br><span class="line">        <span class="comment">// 同样开启IgnoreProjector</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个 Pass 不做任何操作，只把模型的深度信息写入深度缓存</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 打开深度写入</span></span><br><span class="line">            ZWrite On</span><br><span class="line">            <span class="comment">// ColorMask用于设置颜色通道的写掩码，0则不写入任何颜色通道</span></span><br><span class="line">            ColorMask <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二个 Pass 和正常的透明度混合一样</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 设置混合状态，SrcAlpha表示原纹理中的透明度，OneMinusSrcAlpha表示 1 - SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将原纹理中的透明度SrcAlpha作为源颜色因子，1 - SrcAlpha作为目标颜色因子</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 修改了返回颜色中的透明通道的值，使用纹理的透明通道和透明系数的乘积</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启深度写入的透明度混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403194318704.png" alt="image-20220403194318704"></p>
<p>相比于之前的结果，我们得到了正确的透明关系。</p>
<h3 id="5-混合命令"><a href="#5-混合命令" class="headerlink" title="5 混合命令"></a>5 混合命令</h3><p>之前我们已经用过了 ShaderLab 提供的混合命令。实际上，混合还有很多其他用处，不仅仅是用于透明度混合。因此我们有必要更加详细地了解混合中的细节问题。</p>
<p>我们首先来看一下混合是如何实现的。当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关：源颜色（source color）和目标颜色（destination color）。源颜色我们用 S 表示，指的是由片元着色器产生的颜色值；目标颜色我们用 D 表示，指的是从颜色缓冲中读取到的颜色值。对它们进行混合后得到的输出颜色，我们用 O 表示，它会重新写入到颜色缓冲中。需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了 RGBA 四个通道的值，而并非仅仅是 RGB 通道。</p>
<p>想要使用混合，我们必须首先开启它。在 Unity 中，当我们使用 Blend (Blend Off 命令除外）命令时，除了设置混合状态外也开启了混合。但是，在其他图形 API 中我们是需要手动开启的。例如在 OpenGL 中，我们需要使用 glEnable(GL_BLEND) 来开启混合。但在 Unity 中，它已经在背后为我们做了这些工作。</p>
<p>我们之前设置混合因子只使用了两个因子 SrcFactor 和 DstFactor，这意味着对于 RGBA 四个通道使用相同的因子混合：<br>$$<br>O_{RGBA} &#x3D; SrcFactor * S_{RGBA} +DstFactor * D_{RGBA}<br>$$<br>我们当然也可以单独设置 A 通道的混合因子。所有这些混合因子可取的值包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>One</td>
<td>因子为 1</td>
</tr>
<tr>
<td>Zero</td>
<td>因子为 0</td>
</tr>
<tr>
<td>SrcColor</td>
<td>因子为源颜色值。当用于混合 RGB 的混合等式时，使用 SrcColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 SrcColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>SrcAlpha</td>
<td>因子为源颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>DstColor</td>
<td>因子为目标颜色值。当用于混合 RGB 的混合等式时，使用 DstColor 的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用 DstColor 的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>DstAlpha</td>
<td>因子为目标颜色的透明度值（A 通道）</td>
</tr>
<tr>
<td>OneMinusSrcColor</td>
<td>因子为 (1 - 源颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusSrcAlpha</td>
<td>因子为 (1 - 源颜色的透明度值）</td>
</tr>
<tr>
<td>OneMinusDstColor</td>
<td>因子为 (1 - 目标颜色）。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子：当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子。</td>
</tr>
<tr>
<td>OneMinusDstAlpha</td>
<td>因子为 (1 - 目标颜色的透明度值）</td>
</tr>
</tbody></table>
<p>上面的混合等式默认使用的是加操作，实际上还支持其他的混合操作，我们可以使用 ShaderLab 的 <code>BlendOp BlendOperation</code> 命令， 即混合操作命令来设置。支持的操作有：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Add</td>
<td>将混合后的源颜色和混合后的目标颜色相加。默认的混合操作。</td>
</tr>
<tr>
<td>Sub</td>
<td>用混合后的源颜色减去混合后的目标颜色。</td>
</tr>
<tr>
<td>RevSub</td>
<td>用混合后的目标颜色减去混合后的源颜色。</td>
</tr>
<tr>
<td>Min</td>
<td>使用源颜色和目标颜色中较小的值，是逐分量比较的。</td>
</tr>
<tr>
<td>Max</td>
<td>使用源颜色和目标颜色中较大的值，是逐分量比较的。</td>
</tr>
<tr>
<td>其他逻辑操作</td>
<td>仅在 DirectX 11.1 以上支持</td>
</tr>
</tbody></table>
<p>使用 Min 和 Max 混合操作时混合因子没有作用。</p>
<p>常用的不同混合操作设置如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的透明度混合</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柔和相加，Soft Additive</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正片叠底，即相乘，Multiply</span></span><br><span class="line">Blend DstColor Zero</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两倍相乘，2x Multiply</span></span><br><span class="line">Blend DstColor SrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变暗，Darken</span></span><br><span class="line">BlendOp Min</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变亮，Lighten</span></span><br><span class="line">BlendOp Max</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滤色，Screen</span></span><br><span class="line">Blend OneMinusDstColor One</span><br><span class="line"><span class="comment">// 另一种滤色</span></span><br><span class="line">Blend One OneMinusSrcColor</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性减淡，Linear Dodge</span></span><br><span class="line">Blend One One</span><br></pre></td></tr></table></figure>

<p>各种混合效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201017357.png" alt="image-20220403201017357"></p>
<h3 id="6-双面渲染的透明效果"><a href="#6-双面渲染的透明效果" class="headerlink" title="6 双面渲染的透明效果"></a>6 双面渲染的透明效果</h3><p>在现实生活中，如果一个物体是透明的，意味着我们不仅可以透过它看到其他物体的样子，也可以看到它内部的结构。但在前面实现的透明效果中，无论是透明度测试还是透明度混合，我们都无法观察到正方体内部及其背面的形状，导致物体看起来就好像只有半个一样。这是因为，默认情况下渲染引擎剔除了物体背面（相对于摄像机的方向）的渲染图元，而只渲染了物体的正面。如果我们想要得到双面渲染的效果，可以使用 Cull 指令来控制需要剔除哪个面的渲染图元。在 Unity 中， Cull 指令的语法如下：</p>
<blockquote>
<p>Cull  Back  I   Front  I   Off</p>
</blockquote>
<p>如果设置为 Back，那么那些背对着摄像机的渲染图元就不会被渲染，这也是默认情况下的剔除状态；如果设置为 Front，那么那些朝向摄像机的渲染图元就不会被渲染；如果设置为 Off，就会关闭剔除功能，那么所有的渲染图元都会被渲染，但由于这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，例如这里的双面渲染的透明效果，通常情况是不会关闭剔除功能的。</p>
<p>我们在之前的透明度测试代码的 Pass 中加上一句：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭图元剔除</span></span><br><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<p> 得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403201750670.png" alt="image-20220403201750670"></p>
<p>此时可以透过透明部分看到正方体内部的图元了。</p>
<p>和透明度测试相比，想要让透明度混合实现双面渲染会更复杂一些，这是因为透明度混合需要关闭深度写入，因此渲染顺序很重要。如果直接关闭剔除功能，那么我们就无法保证同一个物体的正面和背面图元的渲染顺序，就有可能得到错误的半透明效果。为此，我们选择把双面渲染的工作分成两个 Pass ——第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">8</span>/Alpha Blend With Both Side&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一个 Pass 渲染背面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除正面图元</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个 Pass 渲染正面</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 剔除背面图元</span></span><br><span class="line">            Cull Back</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前一样的代码</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终得到的透明度混合的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20220403202712663.png" alt="image-20220403202712663"></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（六）动画</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>在本节中，我们将会学习如何向 Unity Shader 中引入时间变量，以实现各种动画效果。并分别学习纹理动画和顶点动画，并动手实现一些简单的动画效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-Shder-中的内置时间变量"><a href="#1-Unity-Shder-中的内置时间变量" class="headerlink" title="1 Unity Shder 中的内置时间变量"></a>1 Unity Shder 中的内置时间变量</h3><p>动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我们方便地在 Shader 中访问运行时间，实现各种动画效果。下表给出了这些内置的时间变量：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_Time</td>
<td>float4</td>
<td>t 是自该场景加载开始所经过的时间，4 个分量的值分别是 (t&#x2F;20, t, 2t, 3t)</td>
</tr>
<tr>
<td>_SinTime</td>
<td>float4</td>
<td>t 是时间的正弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td>
</tr>
<tr>
<td>_CosTime</td>
<td>float4</td>
<td>t 是时间的余弦值，4 个分量的值分别是(t&#x2F;8, t&#x2F;4, t&#x2F;2, t)</td>
</tr>
<tr>
<td>unity_DeltaTime</td>
<td>float4</td>
<td>dt 是时间增量，4 个分量的值分别是 (dt, 1&#x2F;dt, smoothDt, 1&#x2F;smoothDt)</td>
</tr>
</tbody></table>
<h3 id="2-纹理动画"><a href="#2-纹理动画" class="headerlink" title="2 纹理动画"></a>2 纹理动画</h3><p>纹理动画在游戏中的应用非常广泛。尤其在各种资源都比较局限的移动平台上，我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p>
<h4 id="2-1-序列帧动画"><a href="#2-1-序列帧动画" class="headerlink" title="2.1 序列帧动画"></a>2.1 序列帧动画</h4><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样，因此，要制作一张出色的序列帧纹理所需要的美术工程狱也比较大。</p>
<p>要想实现序列帧动画，我们先要提供一张包含了关键帧图像的图像。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom.png" alt="boom"></p>
<p>上述图像包含了 8 x 8 张关键帧图像，它们的大小相同，而且播放顺序为从左到右、从上到下。要序列帧动画的精髓在于，我们需要在每个时刻计算该时刻下应该播放的关键帧的位置，并对该关键桢进行纹理采样。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Image Sequence Animation&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 包含了所有关键帧图像的纹理</span></span><br><span class="line">        _MainTex (&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 该纹理在水平和垂直方向上包含的关键帧图像的个数</span></span><br><span class="line">        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">        <span class="comment">// 控制动画播放速度</span></span><br><span class="line">        _Speed (&quot;Speed&quot;, Range(<span class="number">1</span>, <span class="number">100</span>)) = <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 由于序列帧图像通常是透明纹理，我们需要设置 Pass 的相关状态，以渲染透明效果</span></span><br><span class="line">        <span class="comment">// 由于序列帧图像通常包含了透明通道， 因此可以被当成是一个半透明对象</span></span><br><span class="line">        <span class="comment">// 因此这里的标签设置使用半透明标配设置</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            <span class="comment">// 半透明标配设置，关闭深度写入，开启颜色混合</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">              </span><br><span class="line">            struct a2v &#123;  </span><br><span class="line">                float4 vertex : POSITION; </span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;  </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;  </span><br><span class="line">                v2f o;  </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// _Time.y 就是该场景加载后所经过的时间，和速度相乘得到模拟时间，向下取整</span></span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed); </span><br><span class="line">                <span class="comment">// 对关键帧纹理采样相当于得到当前时间下关键帧图像所在的行列位置</span></span><br><span class="line">                <span class="comment">// 使用时间除以水平方向关键帧数量得到行索引</span></span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount);</span><br><span class="line">                <span class="comment">// 余数为列索引</span></span><br><span class="line">                <span class="type">float</span> column = time - row * _HorizontalAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用行列索引值来构建真正的采样坐标</span></span><br><span class="line">                <span class="comment">// 由于序列帧图像包含了许多关键帧图像，这意味着采样坐标需要映射到每个关键帧图像的坐标范围内</span></span><br><span class="line">                <span class="comment">// 因此我们先把原纹理坐标 i.uv 按行数和列数进行等分，得到每个子图像内的纹理坐标范围：</span></span><br><span class="line"><span class="comment">//                half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount);</span></span><br><span class="line">                <span class="comment">// 然后使用当前的行列数对上面的结果进行偏移，得到当前子图像的纹理坐标：</span></span><br><span class="line"><span class="comment">//                uv.x += column / _HorizontalAmount;</span></span><br><span class="line">                <span class="comment">// 要注意对竖直方向坐标偏移要用减法，因此纹理坐标竖直方向的顺序是从下到上增大</span></span><br><span class="line">                <span class="comment">// 而序列帧纹理中播放顺序是从上到下的</span></span><br><span class="line"><span class="comment">//                uv.y -= row / _VerticalAmount;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将上面的过程整合起来可以写成下面的代码：</span></span><br><span class="line">                half2 uv = i.uv + half2(column, -row);</span><br><span class="line">                uv.x /=  _HorizontalAmount;</span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用纹理坐标采样</span></span><br><span class="line">                fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">                c.rgb *= _Color;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/boom-16493016674141.gif" alt="boom"></p>
<h4 id="2-2-滚动背景"><a href="#2-2-滚动背景" class="headerlink" title="2.2 滚动背景"></a>2.2 滚动背景</h4><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层（layers）来模拟一种视差效果。而这些背景的实现往往就是利用了纹理动画。接下来我们将实现一个包含了两层的无限滚动的 2D 游戏背景。纹理资源来自 <a href="http://opengameart.org/">OpenGameArt</a>  网站。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Scrolling Background&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 第一层纹理（较远的）</span></span><br><span class="line">        _MainTex (&quot;Base Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 第二层纹理（）较近的</span></span><br><span class="line">        _DetailTex (&quot;<span class="number">2</span>nd Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 两层纹理的水平滚动速度</span></span><br><span class="line">        _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Scroll2X (&quot;<span class="number">2</span>nd layer Scroll Speed&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 控制纹理整体亮度</span></span><br><span class="line">        _Multiplier (&quot;Layer Multiplier&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _DetailTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _DetailTex_ST;</span><br><span class="line">            <span class="type">float</span> _ScrollX;</span><br><span class="line">            <span class="type">float</span> _Scroll2X;</span><br><span class="line">            <span class="type">float</span> _Multiplier;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 先得到原本的纹理坐标，然后使用 _Time.y 在水平方向上对纹理坐标进行偏移</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 使用偏移后的纹理坐标采样</span></span><br><span class="line">                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用第二层纹理的透明通道混合两张纹理</span></span><br><span class="line">                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line">                c.rgb *= _Multiplier;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/rollbg.gif" alt="rollbg"></p>
<h3 id="3-顶点动画"><a href="#3-顶点动画" class="headerlink" title="3 顶点动画"></a>3 顶点动画</h3><p>如果一个游戏中所有的物体都是静止的，这样枯燥的世界恐怕很难引起玩家的兴趣。顶点动画可以让我们的场景变得更加生动有趣。在游戏中，我们常常使用顶点动画来模拟飘动的旗帜、湍流的小溪等效果。</p>
<h4 id="3-1-流动的河流"><a href="#3-1-流动的河流" class="headerlink" title="3.1 流动的河流"></a>3.1 流动的河流</h4><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Water&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于控制水流波动幅度</span></span><br><span class="line">        _Magnitude (&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 用于控制波动频率</span></span><br><span class="line">         _Frequency (&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span></span><br><span class="line">         <span class="comment">// 波长的倒数，值越大，波长越小</span></span><br><span class="line">         _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = <span class="number">10</span></span><br><span class="line">         <span class="comment">// 水流速度</span></span><br><span class="line">         _Speed (&quot;Speed&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失</span></span><br><span class="line">        <span class="comment">// 我们需要在物体的模型空间下对顶点位置进行偏移，因此，在这里需要取消对该Shader的批处理操作</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 关闭剔除模式，为了让模型的每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert </span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot; </span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 在模型空间计算顶点位移量，只对顶点的x方向进行位移</span></span><br><span class="line">                float4 <span class="keyword">offset</span>;</span><br><span class="line">                <span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                <span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">                <span class="comment">// 把位移量加到模型定点上，再转换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);</span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/water.gif" alt="water"></p>
<h4 id="3-2-广告牌"><a href="#3-2-广告牌" class="headerlink" title="3.2 广告牌"></a>3.2 广告牌</h4><p>另一种常见的顶点动画就是广告牌技术（Billboarding）。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p>
<p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要 3 个基向量。广告牌技术使用的基向量通常就是表面法线（normal）、指向上的方向（up）以及指向右的方向（right）。除此之外，我们还需要指定一个锚点（anchor location），这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。</p>
<p>广告牌技术的难点在于，如何根据需求来构建 3 个相互正交的基向量。计算过程通常是，我们首先会通过初始计算得到目标的表面法线（例如就是视角方向）和指向上的方向，而两者往往是不垂直的。但是，两者其中之一是固定的，例如当模拟草丛时，我们希望广告牌的指向上的方向永远是 (0, 1, 0)，而法线方向应该随视角变化；而当模拟粒子效果时，我们希望广告牌的法线方向是固定的，即总是指向视角方向，指向上的方向则可以变化。</p>
<p>我们假设法线是固定的，首先，根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向：<br>$$<br>right &#x3D; up \times normal<br>$$<br>对其归一化后，再有法线方向和指向右的方向计算出正交的指向上的方向：<br>$$<br>up’&#x3D;noraml \times right<br>$$<br>这样就可以得到用于旋转的 3 个正交基了，下图描述了上面的过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407151550507.png" alt="image-20220407151550507"></p>
<p>如果指向上的方向是固定的，计算过程也是类似的。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Billboard&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度</span></span><br><span class="line">        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 我们需要使用物体的模型空间下的位置来作为铀点进行计算</span></span><br><span class="line">        <span class="comment">// 因此同样要关闭批处理</span></span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            <span class="comment">// 同样关闭剔除使每个面都能显示</span></span><br><span class="line">            Cull Off</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _VerticalBillboarding;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 模型空间的原点作为锚点</span></span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 获取模型空间下的视线位置</span></span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 视线方向作为法线方向</span></span><br><span class="line">                float3 normalDir = viewer - center;</span><br><span class="line">                <span class="comment">// 用_VerticalBillboarding控制垂直方向上的约束度</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为1，意味着法线方向固定为视线方向</span></span><br><span class="line">                <span class="comment">// 如果_VerticalBillboarding为0，意味着向上方向固定为(0,1,0)，因此法线方向y坐标置0</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                <span class="comment">// 最后对法线进行归一化</span></span><br><span class="line">                normalDir = <span class="built_in">normalize</span>(normalDir);</span><br><span class="line">                <span class="comment">// 得到粗略的向上方向，为了防止法线方向和向上方向平行，加一个判断</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 按照上面的公式计算，right方向计算完后别忘了归一化</span></span><br><span class="line">                float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));</span><br><span class="line">                upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据顶点位置相对于锚点的偏移量和三个正交基计算新的顶点位置</span></span><br><span class="line">                float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//最后把模型空间顶点变换到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Vertical Restraints 设置为 1 时，相当于法线方向固定为视线方向，因此我们看到的星星都是正对我们的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407152955176.png" alt="image-20220407152955176"></p>
<p>当 Vertical Restraints 设置为 0 时，相当于固定向上方向为（0, 1, 0），可以看出，广告牌虽然最大限度地面朝摄像机，但其指向上的方向并未发生改变：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%8A%A8%E7%94%BB/image-20220407153107919.png" alt="image-20220407153107919"></p>
<p>需要说明的是，在上面的例子中，我们使用的是 Unity 自带的四边形 (Quad) 来作为广告牌，而不能使用自带的平面 (Plane) 。这是因为，我们的代码是建立在一个竖直摆放的多边形的基础上的，也就是说，这个多边形的项点结构需要满足在模型空间下是竖直排列的。只有这样，我们才能使用 v.vertex 来计算得到正确的相对于中心的位置偏移量。</p>
<h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><p>顶点动画虽然非常灵活，但有一些事情需要格外注意：</p>
<ul>
<li>如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。这时，我们可以通过 SubShader 的 DisableBatching 标签来强制取消对该 Unity Shader 的批处理。然而，取消批处理会带来一定的性能下降，增加了 Draw Call,  因此我们应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算。在上面的广告牌的例子中，为了避免显式使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</li>
<li>如果我们想要对包含了顶点动画的物体添加阴影，像之前一样使用内置的 Diffuse 等包含的阴影 Pass 来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，我们讲过 Unity 的阴影绘制需要调用一个 ShadowCaster Pass, 而如果直接使用这些内置的 ShadowCaster Pass，这个 Pass 中并没有进行相关的顶点动画，因此 Unity 会仍然按照之前的顶点计算阴影，所以此时需要我们自己提供计算阴影的 Pass，在这个 Pass 中，我们将进行同样的顶点变换过程。需要注意的是，在前面的其他动画实现中，涉及半透明物体我们使用的 FallBack 都是 Transparent&#x2F;VertexLit ，而 Transparent&#x2F;VertexLit 没有定义 ShadowCaster Pass, 因此也就不会产生阴影。</li>
</ul>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（五）高级纹理</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>之前我们学习过关于基础纹理的内容，这些纹理包括法线纹理、渐变纹理和遮罩纹理等。这些纹理尽管用处不同，但它们都属于低维（ 一维或二维）纹理。这一节我们将学习一些更复杂的纹理，但都是我们曾经在图形学中学到过的。包括使用立方体纹理（Cubemap）实现环境映射，以及强大的渲染纹理（Render Texture），最后学习程序纹理（Procedure Texture）。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-立方体纹理"><a href="#1-立方体纹理" class="headerlink" title="1 立方体纹理"></a>1 立方体纹理</h3><p>在图形学中我们已经学过环境映射，使用的就是展开的立方体纹理，在 Unity 中，立方体纹理可以通过直接而导入获得，也可以通过脚本生成获得。获得环境的立方体纹理之后，就可以使用该纹理对物体进行渲染，使得物体能够反射周围环境。</p>
<h4 id="1-1-反射"><a href="#1-1-反射" class="headerlink" title="1.1 反射"></a>1.1 反射</h4><p>想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Reflection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制反射颜色</span></span><br><span class="line">        _ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 控制材质的反射程度</span></span><br><span class="line">        _ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 环境映射纹理</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _ReflectColor;</span><br><span class="line">            fixed _ReflectAmount;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                <span class="comment">// 计算世界空间下的反射方向</span></span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));        </span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);        </span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用反射方向对立方体纹理采样</span></span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用lerp函数混合漫反射颜色和环境反射颜色</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406210422338.png" alt="image-20220406210422338"></p>
<h4 id="1-2-折射"><a href="#1-2-折射" class="headerlink" title="1.2 折射"></a>1.2 折射</h4><p>我们也可以用环境贴图模拟折射，虽然对于透明物体，折射应该是两次，一次是光线进入物体内部，另一次是光线从物体内部出去，这样才能被我们所看到，但模拟两次折射比较复杂并且会大幅降低 Shader 性能，因此大多数情况下在实时渲染中我们只模拟一次折射，虽然这是不对的，但是渲染效果看起来并不差，在实时渲染中，“只要看起来它是对的，那么它就是对的”，因此我们可以用一次折射来得到想要的效果。</p>
<p>类似于反射，我们只要用光线折射方向对环境纹理采样即可，折射方向的计算我们也在图形学中学过，可以利用折射率和角度的关系得到。和反射一样，我们也可以通过计算折射的函数直接得到折射方向。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractColor (&quot;Refraction Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractAmount (&quot;Refraction Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 介质的透射比，即两种介质的折射率的比值</span></span><br><span class="line">        _RefractRatio (&quot;Refraction Ratio&quot;, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _RefractColor;</span><br><span class="line">            <span class="type">float</span> _RefractAmount;</span><br><span class="line">            fixed _RefractRatio;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用refract函数计算世界空间下的折射方向</span></span><br><span class="line">                <span class="comment">// 第一个参数是入射光方向，第二个参数是表面法线，都要归一化</span></span><br><span class="line">                <span class="comment">// 第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值</span></span><br><span class="line">                o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用折射方向对环境纹理采样</span></span><br><span class="line">                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将漫反射和折射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211252780.png" alt="image-20220406211252780"></p>
<h4 id="1-3-菲涅尔效果"><a href="#1-3-菲涅尔效果" class="headerlink" title="1.3 菲涅尔效果"></a>1.3 菲涅尔效果</h4><p>在图形学中我们已经学过菲涅尔效应，菲涅尔项的物理计算非常复杂，但在图形学中有一个著名的近似公式，回顾当时学习的对菲涅尔项的近似公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406211852604.png" alt="image-20220406211852604"></p>
<p>其中 $cos\theta$ 是视线和表面法线的夹角余弦，也可以写成点积形式，这一节我们用该公式进行菲涅尔项的渲染。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Fresnel&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 菲涅尔反射系数，相当于公式中的R0</span></span><br><span class="line">        _FresnelScale (&quot;Fresnel Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _FresnelScale;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                  fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                  fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                  fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                  SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔项</span></span><br><span class="line">                fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 将菲涅尔项和漫反射、反射颜色混合</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当菲涅尔系数为 1 时，得到的就是完整的环境反射效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212521693.png" alt="image-20220406212521693"></p>
<p>当菲涅尔系数为 0 时，就会得到一个具有边缘光照效果的漫反射物体：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406212617407.png" alt="image-20220406212617407"></p>
<h3 id="2-渲染纹理"><a href="#2-渲染纹理" class="headerlink" title="2 渲染纹理"></a>2 渲染纹理</h3><p>在之前的学习中， 一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即渲染目标纹理（Render Target Texture, RTT），而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是多重渲染目标（Multiple Render Target, MRT），这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p>
<p>Unity 为渲染目标纹理定义了一种专门的纹理类型——渲染纹理（Render Texture）。在 Unity 中使用渲染纹理有两种方式：</p>
<ul>
<li>一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。 使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性。</li>
<li>另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderimage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，之后我们可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</li>
</ul>
<h4 id="2-1-镜子效果"><a href="#2-1-镜子效果" class="headerlink" title="2.1 镜子效果"></a>2.1 镜子效果</h4><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。</p>
<p>我们搭建的场景如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214409944.png" alt="image-20220406214409944"></p>
<p>白色部分是一个镜子，现在我们还没有使用渲染纹理渲染镜子，要想让镜子显示场景信息，我们要在镜子上安一个虚拟摄像机，并新建一个渲染纹理叫做 Mirror Texture，然后将该摄像机的渲染目标改为渲染纹理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214616872.png" alt="image-20220406214616872"></p>
<p>然后编写 Shader，用渲染纹理渲染镜子，是一个非常简单的二维平面渲染：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Mirror&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="comment">// 水平翻转 x</span></span><br><span class="line">                o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为该材质选择渲染纹理，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220406214900520.png" alt="image-20220406214900520"></p>
<h4 id="2-2-玻璃效果"><a href="#2-2-玻璃效果" class="headerlink" title="2.2 玻璃效果"></a>2.2 玻璃效果</h4><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass 。当我们在 Shader 中定义了一个 GrabPass 后， Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p>
<p>需要注意的是，在使用 GrabPass 的时候，我们需要额外小心物体的渲染队列设置。正如之前所说， GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即”Queue”&#x3D;”Transparent”）。这样才可以保证当渲染该物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p>
<p>在本节中，我们将会使用 GrabPass 来模拟一个玻璃效果。我们首先使用一张法线纹理来修改模型的法线信息，然后使用了之前的反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用了 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Glass Refraction&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;    <span class="comment">//玻璃的材质纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;    <span class="comment">//玻璃的法线纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;    <span class="comment">//环境纹理</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span>            <span class="comment">//用于控制模拟折射时图像的扭曲程度</span></span><br><span class="line">        <span class="comment">//用于控制折射程度，值为0时该玻璃只包含反射，值为1时该玻璃只包含折射</span></span><br><span class="line">        _RefractAmount (&quot;Refract Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 一定要在设置为透明队列</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个抓取屏幕的Pass</span></span><br><span class="line">        <span class="comment">// 字符串表示抓取得到的屏幕图像将会被存入哪个纹理中，后需要使用这个名字</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        <span class="comment">// 渲染玻璃所需的 Pass</span></span><br><span class="line">        Pass &#123;        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            <span class="type">float</span> _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            <span class="comment">// 对应上面抓取屏幕存入的纹理名称</span></span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            <span class="comment">// 得到该纹理的纹素大小，用于对屏幕图像的采样坐标进行偏移</span></span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float2 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 通过顶点在裁剪空间下的坐标计算被抓取的屏幕图像空间的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag (v2f i) : SV_Target &#123;        </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取切线空间的法线</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));    </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用法线坐标和_Distortion属性以及纹素大小计算对屏幕图像采样坐标的偏移</span></span><br><span class="line">                <span class="comment">// _Distortion属性的值越大，偏移就越大，玻璃背后的物体的扭曲程度也就越大</span></span><br><span class="line">                <span class="comment">// 另外，使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反映顶点局部空间下的法线方向</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 使用偏移和之前计算的屏幕图像空间的采样坐标获得校正后的的屏幕图像空间采样坐标</span></span><br><span class="line">                <span class="comment">// 乘以z分量是为了让变形程度随着摄像机距离而发生变化，显得更加真实</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 对屏幕图像空间采样坐标做透视除法之后得到真正的屏幕坐标，再对屏幕图像采样得到折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将切线空间法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 计算反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-worldViewDir, bump);</span><br><span class="line">                <span class="comment">// 主纹理采样</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                <span class="comment">// 环境纹理采样并混合主纹理颜色得到反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;</span><br><span class="line">                <span class="comment">// 最终颜色是反射颜色和折射颜色和线性组合，线性系数由之前定义的折射程度控制</span></span><br><span class="line">                fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407101029198.png" alt="image-20220407101029198"></p>
<h3 id="3-程序纹理"><a href="#3-程序纹理" class="headerlink" title="3 程序纹理"></a>3 程序纹理</h3><p>程序纹理（Procedural Texture）指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素， 例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p>
<h4 id="3-1-实现简单的程序纹理"><a href="#3-1-实现简单的程序纹理" class="headerlink" title="3.1 实现简单的程序纹理"></a>3.1 实现简单的程序纹理</h4><p>我们使用一个 C# 脚本生成波点纹理：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了让脚本能在编辑器模式下运行</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个材质，这个材质将使用该脚本生成的程序纹理</span></span><br><span class="line">    <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该程序纹理的各种参数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">    <span class="comment">// 纹理尺寸</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 背景颜色    </span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 波点颜色</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">    <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模糊因子，用于模糊圆形波点的边界</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个Texture2D的纹理变量用于保存生成的纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断材质是否为空，如果为空就从该脚本所在的物体上获取材质</span></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            material = renderer.sharedMaterial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用_UpdateMaterial()函数生成程序纹理</span></span><br><span class="line">        _UpdateMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保材质不为空，然后生成程序纹理并设置为该物体的材质的主纹理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">            material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">        Color mixColor = Color.white;</span><br><span class="line">        mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">        mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">        mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">        mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">        <span class="keyword">return</span> mixColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成程序纹理</span></span><br><span class="line">    <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">        Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义圆与圆之间的距离</span></span><br><span class="line">        <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">        <span class="comment">// 圆的半径</span></span><br><span class="line">        <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">        <span class="comment">// 边缘模糊系数</span></span><br><span class="line">        <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">                <span class="comment">// 计算每个像素的颜色，初始化为背景颜色</span></span><br><span class="line">                Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 画 9 个园</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// 计算当前圆的圆心</span></span><br><span class="line">                        Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算当前像素和圆心的距离</span></span><br><span class="line">                        <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 模糊边界</span></span><br><span class="line">                        Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 混合颜色</span></span><br><span class="line">                        pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proceduralTexture.Apply();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在定义属性时，每个属性都使用了 get&#x2F;set 的方法，为了在面板上修改属性时仍可以执行 set 函数，还需要使用一个开源插件 SetProperty ，这使得当我们修改了材质属性时，可以执行_UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p>
<p>SetPropertyAttribute.cs 文件很简单：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2014 Luminary LLC</span></span><br><span class="line"><span class="comment">// Licensed under The MIT License (See LICENSE for full text)</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetPropertyAttribute</span> : <span class="title">PropertyAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetPropertyAttribute</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将该脚本赋给一个立方体，在该立方体的属性面板中会出现调整我们之前定义的程序纹理属性的组件：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103059433.png" alt="image-20220407103059433"></p>
<p>我们调整这些参数就可以生成不同的程序纹理，Shader 使用之前的单张纹理 Shader，不同参数得到的纹理效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103158038.png" alt="image-20220407103158038"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407103455297.png" alt="image-20220407103455297"></p>
<h4 id="3-2-Unity-的程序材质"><a href="#3-2-Unity-的程序材质" class="headerlink" title="3.2 Unity 的程序材质"></a>3.2 Unity 的程序材质</h4><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做程序材质 (Procedural Materials) 。这类材质和我们之前使用的那些材质在本原上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 Substance Designer 的软件在 Unity 外部生成的。</p>
<p>Substance Designer 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。 我们可以从 Unity 的资源商店或网络中获取到很多免费或付费的 Substance 材质。这些材质都是以 sbsar 为后缀的，我们可以直接把这些材质像其他资源一样拖入 Unity 项目中。然后生成各种各样的程序纹理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/image-20220407104339828.png" alt="image-20220407104339828"></p>
<p>可以看出，程序材质的自由度很高，而且可以和 Shader 配合得到非常出色的视觉效果，它是一种非常强大的材质类型。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（九）非真实感渲染</title>
    <url>/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>尽管游戏渲染一般都是以照相写实主义（photorealism）作为主要目标，但也有许多游戏使用了非真实感渲染（Non-Photorealistic Rendering,  NPR）的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-卡通风格的渲染"><a href="#1-卡通风格的渲染" class="headerlink" title="1 卡通风格的渲染"></a>1 卡通风格的渲染</h3><p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等。</p>
<p>要实现卡通渲染有很多方法，其中之一就是使用**基于色调的着色技术 (tone-based shading)**。实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，我们在之前的渐变纹理中实现过这样的效果。卡通风格的高光效果也和我们之前学习的光照不同。在卡通风格中，模型的高光往往是一块块分界明显的纯色区域。</p>
<p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。在前两节我们曾使用屏幕后处理技术对屏幕图像进行描边。在本节，我们将会使用基于模型的描边方法，这种方法的实现更加简单，而且在很多情况下也能得到不错的效果。</p>
<h4 id="1-1-渲染轮廓线"><a href="#1-1-渲染轮廓线" class="headerlink" title="1.1 渲染轮廓线"></a>1.1 渲染轮廓线</h4><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近 20 年来，有许多绘制模型轮廓线的方法被先后提出来，在《RTR3》中作者将这些方法分为了 5 类：</p>
<ul>
<li>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</li>
<li>过程式几何轮廓线渲染。这种方法的核心是使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样的平整模型。</li>
<li>基于图像处理的轮廓线渲染。我们之前使用的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</li>
<li>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：</li>
</ul>
<p>$$<br>(\vec n_0·\vec v&gt;0) \neq (\vec n_1·\vec v&gt;0)<br>$$</p>
<p>其中 $\vec n_0$ 和 $\vec n_1$ 是两个相邻三角面片的法向量，$\vec v$ 是从视角到该边上任意顶点的方向。上述公式本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器 (Geometry Shader) 的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</p>
<ul>
<li>最后一个种类就是混合了上述的几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</li>
</ul>
<p>在本节中，我们将会在 Unity 中使用过程式几何轮廓线渲染的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure>

<p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">viewNormal.z = <span class="number">-0.5</span>;</span><br><span class="line">viewNormal = <span class="built_in">normalize</span>(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * Outline;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-添加高光"><a href="#1-2-添加高光" class="headerlink" title="1.2 添加高光"></a>1.2 添加高光</h4><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。类似于 Blinn-Phong 光照的高光计算，我们先计算法线和半程向量的点积，但不进行指数计算，而是将点积结果和一个阈值对比，如果小于该阈值，则高光系数为 0，否则高光系数为 1。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = <span class="built_in">step</span>(threshold, spec);</span><br></pre></td></tr></table></figure>

<p>step 函数是 CG 的内置函数，它比较参考值和给定值的大小，如果给定值大于参考值返回 1，否则返回 0。</p>
<p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如下图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409173101155.png" alt="image-20220409173101155"></p>
<p>出现这种问题的原因在于，高光区域的边缘不是平滑渐变的，而是由 0 突变到 1 。要想对其进行抗锯齿处理，我们可以在边界处很小一块区域内进行平滑处理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec - threshold));</span><br></pre></td></tr></table></figure>

<p>smoothstep 函数是 CG 的内置函数，其中 w 是一个很小的值，当 spec - threshold 小于 -w 时返回 0，当 spec - threshold 大于 w 时返回 1，在 [-w, w] 之间时，在 0 到 1 之间插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界附近，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在下面的实现中，我们选择使用邻域像素之间的近似导数值，这可以通过 CG 的 fwidth 函数来得到。</p>
<h4 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h4><p>实现代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制漫反射色调的渐变纹理</span></span><br><span class="line">        _Ramp (&quot;Ramp Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">//用于控制轮廓线宽度，</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _OutlineColor (&quot;Outline Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//计算高光反射时的阈值</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//描边在非真实感渲染中很常用，方便后面调用</span></span><br><span class="line">            NAME &quot;OUTLINE&quot;</span><br><span class="line">            <span class="comment">//剔除掉正面的部分，只渲染背面</span></span><br><span class="line">            Cull Front</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;; </span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//模型空间下的顶点和法线变换到视角空间下，为了让描边再观察空间达到最好的效果</span></span><br><span class="line">                float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);  </span><br><span class="line">                <span class="comment">//扩张顶点位置</span></span><br><span class="line">                normal.z = <span class="number">-0.5</span>;</span><br><span class="line">                pos = pos + float4(<span class="built_in">normalize</span>(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">                <span class="comment">//变换到裁剪空间下</span></span><br><span class="line">                o.pos = mul(UNITY_MATRIX_P, pos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                <span class="comment">//用轮廓线颜色渲染整个背面</span></span><br><span class="line">                <span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>);               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算光照的Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//剔除背面</span></span><br><span class="line">            Cull Back</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">        </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _Ramp;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            fixed _SpecularScale;</span><br><span class="line">        </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;; </span><br><span class="line">        </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;</span><br><span class="line">                float3 worldPos : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert (a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 worldHalfDir = <span class="built_in">normalize</span>(worldLightDir + worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//阴影和衰减</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">                fixed diff =  <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line">                <span class="comment">//半兰伯特漫反射系数乘以阴影值得到最终的漫反射系数</span></span><br><span class="line">                diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">                <span class="comment">//利用漫反射系数对渐变纹理采样并计算漫反射颜色</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">                <span class="comment">//按照公式计算高光</span></span><br><span class="line">                fixed spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">                fixed w = <span class="built_in">fwidth</span>(spec) * <span class="number">2.0</span>;</span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * <span class="built_in">step</span>(<span class="number">0.0001</span>, _SpecularScale);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409180228375.png" alt="image-20220409180228375"></p>
<h3 id="2-素描风格的渲染"><a href="#2-素描风格的渲染" class="headerlink" title="2 素描风格的渲染"></a>2 素描风格的渲染</h3><p>另一个非常流行的非真实感渲染是素描风格的渲染。微软研究院的 Praun 等人在 2001 年的 SIGGRAPH 上发表了一篇非常著名的论文。在这篇文章中，他们使用了提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个色调艺术映射 (Tonal Art Map, TAM), 如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409191551680.png" alt="image-20220409191551680"></p>
<p>从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理 (MipMaps) 。这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果。</p>
<p>本节将会实现简化版的论文中提出的算法，我们不考虑多级渐远纹理的生成，而直接使用 6 张素描纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Hatching&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 纹理的平铺系数，值越大模型上素描线条越密</span></span><br><span class="line">        _TileFactor (&quot;Tile Factor&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">        _Hatch0 (&quot;Hatch <span class="number">0</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch1 (&quot;Hatch <span class="number">1</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch2 (&quot;Hatch <span class="number">2</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch3 (&quot;Hatch <span class="number">3</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch4 (&quot;Hatch <span class="number">4</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Hatch5 (&quot;Hatch <span class="number">5</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//渲染轮廓线</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading/OUTLINE&quot;</span><br><span class="line">        <span class="comment">//渲染素描效果</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _TileFactor;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch0;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch1;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch2;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch3;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch4;</span><br><span class="line">            <span class="type">sampler2D</span> _Hatch5;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float3 normal : NORMAL; </span><br><span class="line">                float2 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储混合六张纹理的权重</span></span><br><span class="line">                fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line">                float3 worldPos : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//根据_TileFactor得到纹理坐标</span></span><br><span class="line">                o.uv = v.texcoord.xy * _TileFactor;</span><br><span class="line">                <span class="comment">//计算逐顶点光照，使用漫反射系数计算混合不同纹理的权重</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">//权重初始化为0</span></span><br><span class="line">                o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//把diff缩放到[0,7]</span></span><br><span class="line">                <span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;</span><br><span class="line">                <span class="comment">//把[0,7]均匀的分成七个子区间，判断hatchFactor所处的区间，以决定混合权重</span></span><br><span class="line">                <span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Pure white, do nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">                    o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">                    o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">                    o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">                    o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;            </span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line">                <span class="comment">//留白</span></span><br><span class="line">                fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line">                </span><br><span class="line">                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                                </span><br><span class="line">                <span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/image-20220409192908015.png" alt="image-20220409192908015"></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（十）噪声纹理</title>
    <url>/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>很多时候，向规则的事物里添加一些“杂乱无章”的效果往往会有意想不到的效果。而这些“杂乱无章”的效果来源就是噪声。在本节中，我们将会学习如何使用噪声来模拟火焰消融、波光粼粼、云雾飘渺等各种特效。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-消融效果"><a href="#1-消融效果" class="headerlink" title="1 消融效果"></a>1 消融效果</h3><p><strong>消融 (dissolve)</strong> 效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。消融效果的原理非常简单，概括来说就是噪声纹理＋透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了图中被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的结果。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Dissolve&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制消融程度，值为1时物体完全消融</span></span><br><span class="line">        _BurnAmount (&quot;Burn Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span></span><br><span class="line">        <span class="comment">// 模拟烧焦效果时的线宽，值越大，火焰边缘的蔓延范围越广</span></span><br><span class="line">        _LineWidth(&quot;Burn Line Width&quot;, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span></span><br><span class="line">        <span class="comment">// 主纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 法线纹理</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 火焰边缘的两种颜色值</span></span><br><span class="line">        _BurnFirstColor(&quot;Burn First Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 噪声纹理</span></span><br><span class="line">        _BurnMap(&quot;Burn Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭剔除，因为模型消融会使内部构造显现出来</span></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            fixed _LineWidth;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            fixed4 _BurnFirstColor;</span><br><span class="line">            fixed4 _BurnSecondColor;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            </span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uvMainTex : TEXCOORD0;</span><br><span class="line">                float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">                float3 lightDir : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;</span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                <span class="comment">// 光线从模型空间变换到切线空间，因为用到了法线纹理，要在切线空间计算光照</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                  o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                  <span class="comment">// 为了得到阴影信息，计算世界空间下的顶点位置以及阴影纹理的采样坐标</span></span><br><span class="line">                  o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 对噪声纹理采样</span></span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                <span class="comment">// 采样值和控制消融程度的参数相减传递给clip函数</span></span><br><span class="line">                <span class="comment">// 当结果小于0时该像素会被剔除，从而不显示到屏幕上</span></span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 切线空间的光照方向</span></span><br><span class="line">                float3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                <span class="comment">// 对法线纹理采样</span></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">                <span class="comment">// 反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">                <span class="comment">// 环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 在切线空间计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算烧焦的颜色，要在宽度为_LineWidth范围内模拟一个烧焦的颜色变化</span></span><br><span class="line">                <span class="comment">// 首先计算混合系数t，如果t的值为1说明位于消融的边界，t为0时像素为正常的模型颜色</span></span><br><span class="line">                fixed t = <span class="number">1</span> - <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 使用t混合两种烧焦颜色</span></span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line">                <span class="comment">// 使用pow对结果进行处理得到最终的烧焦颜色</span></span><br><span class="line">                burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>);</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="comment">// 再次使用t来混和光照颜色和烧焦颜色，使用step函数保证_BurnAmount为0时不显示任何消融效果</span></span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * <span class="built_in">step</span>(<span class="number">0.0001</span>, _BurnAmount));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 投射阴影的Pass</span></span><br><span class="line">        <span class="comment">// 因为用到了透明度测试，因此不能用默认的阴影投射Pass，不然被剔除的部分也会投射阴影造成穿帮</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 正确设置tags</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            <span class="comment">// 对应的编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            <span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                <span class="comment">// 使用Unity内置宏定义投射阴影需要的变量，已经包含了各种需要用到的变量</span></span><br><span class="line">                V2F_SHADOW_CASTER;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用Unity内置的宏来计算阴影需要一些特定的输入</span></span><br><span class="line">            <span class="comment">// 比如TRANSFER_SHADOW_CASTER_NORMALOFFSET会使用名称v作为输入结构体，v中需要包含顶点位置和顶点法线</span></span><br><span class="line">            <span class="comment">// 内置的appdata_base结构体提供了这些必要的变量</span></span><br><span class="line">            v2f vert(appdata_base v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 使用内置的宏填充上面声明的各种变量</span></span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line">                <span class="comment">// 剔除片元后，使用内置的宏计算阴影投射</span></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来编写一个 cs 脚本来随着时间控制材质的 _BurnAmount 属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BurnHelper</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.01f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> burnSpeed = <span class="number">0.3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> burnAmount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponentInChildren&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer != <span class="literal">null</span>) &#123;</span><br><span class="line">                material = renderer.material;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, <span class="number">0.0f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        burnAmount = Mathf.Repeat(Time.time * burnSpeed, <span class="number">1.0f</span>);</span><br><span class="line">        material.SetFloat(<span class="string">&quot;_BurnAmount&quot;</span>, burnAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/burn.gif" alt="burn"></p>
<h3 id="2-水波效果"><a href="#2-水波效果" class="headerlink" title="2 水波效果"></a>2 水波效果</h3><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射＋折射计算，得到最后的水面波动效果。在本节中，我们将会使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅耳反射的水面效果。</p>
<p>首先我们定义一个平面作为水面，类似于之前我们利用反射和折射实现透明玻璃的效果，我们使用一张立方体纹理 (Cubemap) 作为环境纹理，模拟反射；使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。但与之前的实现不同，水波的法线纹理是由一张噪声纹理生成而得，而且会随着时间不断平移变化，模拟波光粼粼的效果。此外，我们没有使用一个定值来混合反射和折射的颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数，我们使用如下公式计算菲涅尔系数：<br>$$<br>fresnel &#x3D; pow(1-max(0,\vec v ·\vec n),4)<br>$$<br>其中 $\vec v$ 和 $\vec n$ 分别对应了视角方向和法线方向，他们之间的夹角越小，得到的菲涅尔系数就越小，反射越弱，折射越强。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Water Wave&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 用于控制水面颜色</span></span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 水面波纹材质纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 噪声纹理生成的法线纹理</span></span><br><span class="line">        _WaveMap (&quot;Wave Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 环境纹理</span></span><br><span class="line">        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 控制法线纹理再x和y方向上的平移速度</span></span><br><span class="line">        _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">        <span class="comment">// 控制模拟折射时的扭曲程度</span></span><br><span class="line">        _Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 透明队列，在所有不透明物体之后渲染</span></span><br><span class="line">        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取屏幕图像作为渲染纹理</span></span><br><span class="line">        GrabPass &#123; &quot;_RefractionTex&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _WaveMap;</span><br><span class="line">            float4 _WaveMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            fixed _WaveXSpeed;</span><br><span class="line">            fixed _WaveYSpeed;</span><br><span class="line">            <span class="type">float</span> _Distortion;    </span><br><span class="line">            <span class="type">sampler2D</span> _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 根据裁剪空间坐标计算被抓取的屏幕图像的采样坐标</span></span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos);</span><br><span class="line">                <span class="comment">// 纹理坐标转换</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的变换矩阵，并存储世界空间下的顶点坐标</span></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界坐标</span></span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                <span class="comment">// 根据世界坐标计算世界空间的视角方向</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                <span class="comment">// 计算法线纹理当前在x和y方向的偏移量</span></span><br><span class="line">                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理采样两次，为了得到两层交叉的水面波动效果</span></span><br><span class="line">                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">                <span class="comment">// 两次采样结果相加并归一化得到切线空间下的法线方向</span></span><br><span class="line">                fixed3 bump = <span class="built_in">normalize</span>(bump1 + bump2);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 利用切线空间的法线方向计算对屏幕图像的采样坐标偏移</span></span><br><span class="line">                float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                <span class="comment">// 偏移量乘以z分量是为了得到深度越大折射程度越大的效果</span></span><br><span class="line">                i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">// 经过透视除法后对屏幕图像采样得到模拟的折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 法线转换到世界空间</span></span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                <span class="comment">// 采样得到水波颜色，也要随时间偏移</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">                <span class="comment">// 根据世界空间下的法线方向和视线方向计算得到反射方向</span></span><br><span class="line">                fixed3 reflDir = <span class="built_in">reflect</span>(-viewDir, bump);</span><br><span class="line">                <span class="comment">// 利用反射方向对环境贴图采样，并结合水波颜色得到最终的反射颜色</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 计算菲涅尔系数</span></span><br><span class="line">                fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(<span class="built_in">dot</span>(viewDir, bump)), <span class="number">4</span>);</span><br><span class="line">                <span class="comment">// 利用菲涅尔系数结合反射颜色和折射颜色</span></span><br><span class="line">                fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不要投射阴影，因此关掉FallBack</span></span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了用噪声纹理生成法线纹理，我们在该噪声纹理的属性面板中把纹理类型改为 Normal map，并勾选 Create from grayscale，使其从灰度值生成法线纹理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/image-20220410161026859.png" alt="image-20220410161026859"></p>
<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water.gif" alt="water"></p>
<p>此时我们的视线方向和水面法线夹角大，反射强，折射弱，我们更容易看到水面的颜色，而水面的颜色是环境反射颜色和水波本身颜色的结合；当我们减小视线方向和水面法线夹角时，效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/water2.gif" alt="water2"></p>
<p>此时反射弱，折射强，我们不容易看到水面本身的颜色，更容易透过水面看到折射后的扭曲的地面。</p>
<h3 id="3-再谈全局雾效"><a href="#3-再谈全局雾效" class="headerlink" title="3 再谈全局雾效"></a>3 再谈全局雾效</h3><p>我们之前学习了如何使用深度纹理来实现一种基于屏幕后处理的全局雾效。我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色。这样实现的效果在同一高度下雾的浓度是相同的，但很多时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，这就可以通过使用噪声纹理来实现。</p>
<p>大部分代码和之前的全局雾效一样，只不过加入了噪声相关的参数和属性，并在 Shader 的片元着色器中对雾效混合系数的计算添加了噪声的影响。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithNoise</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义噪声纹理的变量</span></span><br><span class="line">    <span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line">    <span class="comment">// 噪声纹理在x和y方向的移动速度，模拟飘渺的效果</span></span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    <span class="comment">// 控制噪声程度，值为0代表不应用噪声，得到和之前一样的均匀雾效</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脚本可用时，摄像机生成深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            </span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            </span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line">            </span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">            </span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Fog With Noise&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _NoiseTex (&quot;Noise Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = <span class="number">0.1</span></span><br><span class="line">        _NoiseAmount (&quot;Noise Amount&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        <span class="type">sampler2D</span> _NoiseTex;</span><br><span class="line">        half _FogXSpeed;</span><br><span class="line">        half _FogYSpeed;</span><br><span class="line">        half _NoiseAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 还原像素对应的点在世界空间的位置</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 计算采样坐标偏移</span></span><br><span class="line">            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);</span><br><span class="line">            <span class="comment">// 利用偏移量对噪声纹理采样，结果减去0.5并乘以控制噪声程度的属性得到最终的噪声值</span></span><br><span class="line">            <span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount;</span><br><span class="line">            <span class="comment">// 利用噪声计算雾效混合系数</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise));</span><br><span class="line">            <span class="comment">// 利用雾效混合系数混合雾效颜色和原颜色</span></span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;              </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/10/20220410-Shader-%E5%99%AA%E5%A3%B0%E7%BA%B9%E7%90%86/fog-16495801644531.gif" alt="fog"></p>
<h3 id="4-噪声纹理从何而来"><a href="#4-噪声纹理从何而来" class="headerlink" title="4 噪声纹理从何而来"></a>4 噪声纹理从何而来</h3><p>噪声纹理一般属于程序纹理，它们都是由计算机利用某些算法生成的。<a href="https://en.wikipedia.org/wiki/Perlin%E2%80%94noise">Perlin 噪声</a>和<a href="https://en.wikipedia.org/wiki/Worley_noise">Worley 噪声</a>是两种最常使用的噪声类型，上面的全局雾效使用的噪声纹理就是由 Perlin 噪声生成而来。 Perlin 噪声可以用于生成更自然的噪声纹理，而 Worley 噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。更多关于噪声纹理的内容可以查看 <a href="http://adrianb.io/2014/08/09/perlinnoise.html">Understanding Perlin Noise</a> 以及其他博客。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（四）漫反射材质</title>
    <url>/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<p>现在我们已经有了光线和物体，接下来可以实现一些看起来更加真实的效果，从漫反射材质开始。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-简单的漫反射材质"><a href="#1-简单的漫反射材质" class="headerlink" title="1 简单的漫反射材质"></a>1 简单的漫反射材质</h3><p>回顾漫反射的形成原理，光线打到物体表面后一部分光会折射进入物体，并在物体内部发生各种次表面散射后从物体表面的某个方向再折射出去，因此漫反射的颜色主要取决于环境光颜色，并用物体自身的颜色去调节这些来自环境的光线，因此也可以认为漫反射反映了物体自身的颜色。从宏观来看漫反射就像是光线向各个方向均匀散射，而在我们的简单实现中可以认为光线在物体表面的反射方向是随机的，比如三根光线打到两个物体的夹缝处，他们可能产生完全不同的行为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.08-light-bounce.jpg" alt="fig-1.08-light-bounce"></p>
<p>因此要模拟漫反射材质，我们首先要能够随机生成漫反射弹射光线。可以使用如下方法生成：</p>
<ul>
<li>光线与物体表面相交于一点 $p$</li>
<li>在 $p + \vec n$ 处构造一个与点 $p$ 相切的单位球体，其中 $\vec n$ 是点 $p$ 处的法线</li>
<li>随机在单位球体中选择一点 $s$ ，漫反射弹射光线的方向就是 $s - p &#x3D; \vec{ps}$</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/fig-1.09-rand-vec.jpg" alt="fig-1.09-rand-vec"></p>
<p>为此我们要先增加一些工具函数用于在单位球体内生成随机点，由于直接生成单位球体内的点并不是很方便实现，我们可以先生成单位立方体内的点，即三个维度的坐标都在 [-1, 1] 范围内，然后判断该点是否在球体内，如果不在球体内就重新随机选择，直到满足条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//utilities.h</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[0,1]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(), <span class="built_in">random_double</span>(), <span class="built_in">random_double</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成分量在[min,max]之间的随机向量</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_vec</span><span class="params">(<span class="type">double</span> min, <span class="type">double</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vec3</span>(<span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max), <span class="built_in">random_double</span>(min, max));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成单位球体内随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> point3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">length_squared</span>() &gt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以递归的计算光线弹射多次所得到的漫反射颜色了。</p>
<h3 id="2-限制光线弹射次数"><a href="#2-限制光线弹射次数" class="headerlink" title="2 限制光线弹射次数"></a>2 限制光线弹射次数</h3><p>上面的实现中，没有递归结束的条件，也就是限制光线弹射的次数，因此需要加一个递归深度来限制光线的弹射次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 限制弹射次数</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 只有0.5的光线发生下一次弹射，其他的被吸收</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world, depth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Diffuse.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_depth = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), <span class="number">0.5</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-100.5</span>, <span class="number">-1</span>), <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, max_depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到如下效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/Diffuse.png" alt="Diffuse"></p>
<p>使用固定弹射次数会导致很多没用的计算，仅仅渲染上面这样一张图就要用掉近三分钟，效率非常低，并且固定弹射次数会影响最终渲染效果。之前在图形学中我们学习过，更好的限制光线弹射次数的方法是使用俄罗斯轮盘赌算法（RR），该算法在保证期望正确的情况下大幅提高了渲染效率，因此我们用 RR 算法来限制光线弹射次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 计算漫反射颜色</span></span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 随机选择漫反射光线弹射方向</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="comment">// 要记得除以生存概率才能得到正确的期望</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中之前做的修改可以 Ctrl + Z 了，现在无需做任何修改，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRR.png" alt="DiffuseRR"></p>
<p>渲染这张图只用了不到 20 秒，效率大幅提升并且渲染效果更好。</p>
<h3 id="3-伽马校正"><a href="#3-伽马校正" class="headerlink" title="3 伽马校正"></a>3 伽马校正</h3><p>在上面的例子中我们设置了一半的光线被吸收，一半的光线被反射，在现实中这个球体看起来应该更亮一些，呈现灰色，但上面的渲染结果中球体颜色非常暗，尤其是球体下的阴影处，这是因为我们没有进行<strong>伽马校正（Gamma Correction）</strong>。</p>
<p>伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下：<br>$$<br>L_{out} &#x3D; L_{in}^\gamma<br>$$<br>其中指数部分的发音就是伽马。最开始的时候，人们使用伽马曲线来对拍摄的图像进行伽马编码。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可以简化为，把进入到镜头内的光线亮度编码成图像中的像素。如果采集到的亮度是 0，像素就是 0，亮度是 1，像素就是 1，亮度是 0.5，像素就是 0.5。如果我们只用 8 位空间来存储像素的每个通道的话，这意味着 0~1 区间可以对应 256 种不同的亮度值。但是，后来人们发现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/image-20220415161441639.png" alt="image-20220415161441639"></p>
<p>颜色越暗，我们就感觉从左到右的变化越明显。<strong>所以亮度上的线性变化对人眼的感知来说是非均匀的。</strong></p>
<p>另一个例子可以说明这个现象，当一个屋子的光照由一盏灯增加到两盏灯的时候，人眼对这种亮度变化的感知性要远远大于从 101 盏灯增加到 102 盏灯的变化，但是从物理上来说这两种变化基本是相同的。</p>
<p>所以，如果使用 8 位空间来存储每个通道的话，我们仍然把 0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费。一种更好的方法是，我们应该把把更多的空间来存储更多的暗部区域，这样存储空间就可以被充分利用起来了。摄影设备如果使用了 8 位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5，而大约为 0.22。这是因为：<br>$$<br>0.5 \approx 0.22^{0.45}<br>$$<br>如上所见，对拍摄图像使用的伽马编码使得我们可以充分利用图像的存储空间。但当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p>
<p>这时，人们发现了一个奇妙的巧合—— CRT 显示器本身几乎已经自动做了这个解码操作。在早期，CRT（Cathode Ray Tube，阴极射线管）几乎是唯一的显示设备。这类设备的显示机制是，使用一个电压轰击它屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但 CRT 显示器有一个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为**显示伽马 (diplay gamma)**。非常巧合的是，CRT 的显示伽马值大约就是编码伽马的倒数。CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线。虽然现在 CRT 设备很少见了，并且后来出现的显示设备有着不同的伽马响应曲线，但是，人们仍在硬件上做了调整来提供兼容性。</p>
<p>随后，微软联合爱普生、惠普提供了 sRGB 颜色空间标准，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 $2.2 \times 0.45 \approx 1$ ）。绝大多数的摄像机、 PC 和打印机都使用了上述的 sRGB 标准。</p>
<p>对于我们的渲染来说，如果我们直接输出渲染结果而不做任何处理，在经过显示器的显示伽马处理后，就会导致颜色偏暗的现象。因此我们在计算像素颜色时有必要进行伽马校正。</p>
<p>为了简化计算我们假设显示伽马为 2.0，因此我们的编码伽马为 0.5，在写入像素的时候对像素的最终颜色值进行伽马编码，就可以让颜色显示正常了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入的color是[0,1]范围的</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write_color</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*&amp; p, color pixel_color, <span class="type">int</span> samples_per_pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = pixel_color.<span class="built_in">x</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = pixel_color.<span class="built_in">y</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = pixel_color.<span class="built_in">z</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scale = <span class="number">1.0</span> / samples_per_pixel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 伽马校正，假设显示gamma=2.0</span></span><br><span class="line">    r = <span class="built_in">sqrt</span>(scale * r);</span><br><span class="line">    g = <span class="built_in">sqrt</span>(scale * g);</span><br><span class="line">    b = <span class="built_in">sqrt</span>(scale * b);</span><br><span class="line"></span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(r, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(g, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">    *p++ = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">256</span> * <span class="built_in">clamp</span>(b, <span class="number">0.0</span>, <span class="number">0.999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过伽马矫正后的渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/DiffuseRRGammaCorrect.png" alt="DiffuseRRGammaCorrect"></p>
<h3 id="4-True-Lambertian-Reflection"><a href="#4-True-Lambertian-Reflection" class="headerlink" title="4 True Lambertian Reflection"></a>4 True Lambertian Reflection</h3><p>现在回顾上面在<strong>单位球体内</strong>选取随机点的实现。这样的实现会使得选取到的随机反射方向大概率接近法线，而以很小的概率接近掠射角方向，这是因为整个球体中大部分位置和表面交点的连线都接近法线方向，只有很小一部分接近掠射角方向，这代表我们随机选取的反射方向不是均匀分布的，但这似乎是合理的，因为越接近掠射角代表光线越接近该交点的切线方向，所以对最终颜色的贡献也更小。</p>
<p>而 True Lambertian Reflection 并不是这样的， True Lambertian Reflection 的随机方向更均匀，因为它是在<strong>单位球面上</strong>随机取点并构成反射方向，这样显然随机选取的反射方向会更加均匀。</p>
<p>我们可以通过先在球面内随机取点，并将其单位化，以得到球面上随机一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成单位球面上随机一点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_unit_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这次使用球面上的随机点</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        point3 target = rec.p + rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/TrueLambertianReflection.png" alt="TrueLambertianReflection"></p>
<p>可以注意到和之前的结果中两个不同的视觉变化：</p>
<ul>
<li>阴影变得不那么明显了</li>
<li>物体变得稍微亮了一点</li>
</ul>
<p>这两种变化都是由于光线散射更均匀，向法线附近散射的光线更少而产生的。对于漫反射物体，它们会显得更亮是因为更多的光线会反射到相机上。对于阴影，因为向法线附近散射的光线更少，所以大球体表面和上面的小球体的夹缝处就会有更多的光线散射出去，而不是在夹缝处一直弹射。</p>
<h3 id="5-另一种散射方法"><a href="#5-另一种散射方法" class="headerlink" title="5 另一种散射方法"></a>5 另一种散射方法</h3><p>除了上面的在球体内随机取点和在球面上随机取点之外，还有一种随机散射的方法。在之前的方法中我们选取了一个单位球，这个单位球的球心相比于光线和表面的交点偏移了一个法线，但很难解释我们为什么这么做。一个更直观的方法是不进行法线偏移，在单位球体内随机取一点作为光线和物体的交点 p 的偏移，然后用偏移后的点 p 和原来的点 p 构成随机反射方向。这相当于以 p 为球心，在一个半球上随机取点构成反射方向，在实现中要注意如果偏移后的点 p 落入了下半球，意味着反射光线指向了物体内部，这是错误的，此时要对偏移量取反，以保证反射光线和该点的法线在同一个半球。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在半球内随机取点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">random_in_hemisphere</span><span class="params">(<span class="type">const</span> vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    vec3 in_unit_sphere = <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">    <span class="comment">// 判断该偏移量是否落入了下半球，如果落入下半球则偏移量应该取反</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dot</span>(in_unit_sphere, normal) &gt; <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">return</span> in_unit_sphere;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -in_unit_sphere;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体内部随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_in_unit_sphere();</span></span><br><span class="line">        <span class="comment">// 在法线偏移的单位球体表面随机取一点得到反射方向</span></span><br><span class="line">        <span class="comment">//point3 target = rec.p + rec.normal + random_unit_vector();</span></span><br><span class="line">        <span class="comment">// 在以交点为球心的半径为 1 的半球内随机取一点得到反射方向</span></span><br><span class="line">        point3 target = rec.p + <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        ray bounce = <span class="built_in">ray</span>(rec.p, target - rec.p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">ray_color</span>(bounce, world) / RR;</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/15/20220415-RayTracer-%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8/RandomInHemisphere.png" alt="RandomInHemisphere"></p>
<p>以上三种散射方法没有对错之分，在后面场景变得越来越复杂之后，可以通过尝试切换这三种漫反射渲染器来观察不同的方法对渲染效果的影响。</p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（五）金属材质</title>
    <url>/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<p>这一节开始实现金属材质，为了使不同的物体能拥有不同的材质，我们需要先实现一个材质类。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-材质抽象类"><a href="#1-材质抽象类" class="headerlink" title="1 材质抽象类"></a>1 材质抽象类</h3><p>材质简单来说需要做两件事情：</p>
<ul>
<li>描述光现在材质表面如何散射（或者说如何被吸收）</li>
<li>如果发生散射描述光线如何衰减</li>
</ul>
<p>因此对于所有材质都要有一个产生散射光线的函数。所以我们可以先定义一个材质抽象类，然后让具体的材质去实现不同的产生散射光线的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATERIAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATERIAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">material</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>之后我们的渲染流程变为，投射光线到场景中计算和场景中所有物体最近的交点并记录下来，这个记录要有交点的位置、法线等信息，现在还要加上物体的材质信息，这样在之后才能利用该材质产生散射光线，然后计算颜色。因此我们先修改记录交点的结构体，并将该结构体移入 <code>material.h</code> 头文件中避免循环引用，在结构体声明之前加上 <code>class material</code> 告诉该结构体 material 这个类，不然会找不到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">material</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hit_record</span> &#123;</span><br><span class="line">    point3 p;           <span class="comment">//交点</span></span><br><span class="line">    vec3 normal;        <span class="comment">//交点法线</span></span><br><span class="line">    <span class="type">double</span> t;           <span class="comment">//交点t值</span></span><br><span class="line">    <span class="type">bool</span> front_face;    <span class="comment">//交点是否在物体的正面</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">//物体材质</span></span><br><span class="line">    <span class="comment">// 如果交点在物体的背面，则法线应该取反方向，以用于计算光照</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">set_face_normal</span><span class="params">(ray&amp; r, vec3&amp; outward_normal)</span> </span>&#123;</span><br><span class="line">        front_face = <span class="built_in">dot</span>(r.<span class="built_in">direction</span>(), outward_normal) &lt; <span class="number">0</span>;</span><br><span class="line">        normal = front_face ? outward_normal : -outward_normal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改物体类，为每个物体也加上材质，并在 <code>hit</code> 函数中把材质传递给上面的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    球体类sphere，派生于基类hittable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SPHERE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPHERE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 球体类以hittable抽象类为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sphere</span> : <span class="keyword">public</span> hittable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sphere</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">sphere</span>(point3 cen, <span class="type">double</span> r, shared_ptr&lt;material&gt; m) : <span class="built_in">center</span>(cen), <span class="built_in">radius</span>(r), <span class="built_in">mat_ptr</span>(m) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    point3 center;                  <span class="comment">// 球心</span></span><br><span class="line">    <span class="type">double</span> radius;                  <span class="comment">// 半径</span></span><br><span class="line">    shared_ptr&lt;material&gt; mat_ptr;   <span class="comment">// 物体材质</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sphere::hit</span><span class="params">(ray&amp; r, <span class="type">double</span> t_min, <span class="type">double</span> t_max, hit_record&amp; rec)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec3 oc = r.<span class="built_in">origin</span>() - center;</span><br><span class="line">    <span class="keyword">auto</span> a = r.<span class="built_in">direction</span>().<span class="built_in">length_squared</span>();</span><br><span class="line">    <span class="keyword">auto</span> half_b = <span class="built_in">dot</span>(oc, r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> c = oc.<span class="built_in">length_squared</span>() - radius * radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> discriminant = half_b * half_b - a * c;</span><br><span class="line">    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> sqrtd = <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到满足条件的最近的交点</span></span><br><span class="line">    <span class="keyword">auto</span> root = (-half_b - sqrtd) / a;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root) &#123;</span><br><span class="line">        root = (-half_b + sqrtd) / a;</span><br><span class="line">        <span class="keyword">if</span> (root &lt; t_min || t_max &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该交点的相关信息</span></span><br><span class="line">    rec.t = root;</span><br><span class="line">    rec.p = r.<span class="built_in">at</span>(rec.t);</span><br><span class="line">    <span class="comment">// 法线记得归一化</span></span><br><span class="line">    vec3 outward_normal = (rec.p - center) / radius;</span><br><span class="line">    <span class="comment">// 判断交点在正面还是背面，并设置正确的法线方向</span></span><br><span class="line">    rec.<span class="built_in">set_face_normal</span>(r, outward_normal);</span><br><span class="line">    <span class="comment">// 记录材质</span></span><br><span class="line">    rec.mat_ptr = mat_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-实现漫反射材质"><a href="#2-实现漫反射材质" class="headerlink" title="2 实现漫反射材质"></a>2 实现漫反射材质</h3><p>现在可以实现各种材质派生类了，先把上一节中的漫反射材质封装在类中，首先是 Lambertian 材质，可以理解为它以发生散射并以反射率 R 衰减，也可以理解为发生散射但不衰减，只是吸收了 1-R 的光线，上一节中我们把反射率直接固定了 rgb 都等于 0.5 ，但在材质类中反射率应该可以自定义。我们直接把上一节中的实现拿来组织成一个类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的实现中还有一个问题，如果随机生成的方向和法线方向刚好相反，这两个向量的和将为 0 ，这将会导致散射方向为 0 ，进而使渲染出来的场景出现问题。因此我们需要阻止这种情况发生，我们在 <code>vec3</code> 类中增加一个判断向量是否接近 0 的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vec3</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">near_zero</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有维度都接近 0 则返回 true</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> s = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">fabs</span>(e[<span class="number">0</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">1</span>]) &lt; s) &amp;&amp; (<span class="built_in">fabs</span>(e[<span class="number">2</span>]) &lt; s);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在材质类中的散射函数中增加判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambertian材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里省略了rec.p + rec.normal + random_unit_vector() - rec.p中的rec.p;</span></span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_unit_vector</span>();</span><br><span class="line">        <span class="comment">// 如果散射方向为0，则取法线方向作为散射方向</span></span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后顺便实现另外两种散射方法的漫反射材质，在半球采样不需要考虑散射方向为 0 的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单位球体内部采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_insphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_insphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = rec.normal + <span class="built_in">random_in_unit_sphere</span>();</span><br><span class="line">        <span class="keyword">if</span> (scatter_direction.<span class="built_in">near_zero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            scatter_direction = rec.normal;</span><br><span class="line">        &#125;</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在半球采样得到散射方向的材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambertian_hemisphere</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lambertian_hemisphere</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> scatter_direction = <span class="built_in">random_in_hemisphere</span>(rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, scatter_direction);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现金属材质"><a href="#3-实现金属材质" class="headerlink" title="3 实现金属材质"></a>3 实现金属材质</h3><h4 id="3-1-镜面反射"><a href="#3-1-镜面反射" class="headerlink" title="3.1 镜面反射"></a>3.1 镜面反射</h4><p>金属材质因为足够光滑，因此光线会在表面发生完美的镜面反射，因此金属材质的散射方向就是入射光线的镜面反射方向，首先我门要考虑如何求镜面反射方向，这在图形学中已经学过，但在我们的实现稍微有些不同，我们的代码中入射光线（从像素投射的光线）是指向表面的（之前都是从表面向外指的）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.11-reflection.jpg" alt="fig-1.11-reflection"></p>
<p>入射光线方向为 $\vec v$ ，法线为 $\vec n$，则反射方向为 $\vec v + 2\vec b$，$\vec b$ 和法线同方向，长度为 $\vec v$ 在法线方向的投影，因此镜面反射光线为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 镜面反射方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">reflect</span><span class="params">(<span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="number">2</span> * <span class="built_in">dot</span>(-v, n) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设传入该函数的都是单位向量，所以 $\vec v$ 在法线方向的投影就可以表示成点乘。</p>
<p>然后就可以定义金属材质类了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a) : <span class="built_in">albedo</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected);</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>ray_color</code> 函数，让它使用材质类计算颜色：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌的生存概率</span></span><br><span class="line">    <span class="keyword">auto</span> RR = <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 以一定概率停止弹射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主函数，向场景中加入各种材质的物体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;Metal.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Metal.png" alt="Metal"></p>
<p>随着场景变得复杂，我们现在的算法又暴露出一个小问题，噪声过大，这是因为使用了俄罗斯轮盘赌算法，我们现在的生存概率是 0.8，也就说当光线第一次打到物体上的时候就会有 0.2 概率返回 0 颜色，所以会产生很多噪点。因此我们可以先让光线至少弹射几次，之后再应用俄罗斯轮盘赌算法终止递归。为了方便之后修改，可以将生存概率和最少弹射次数作为可修改参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到光线颜色</span></span><br><span class="line"><span class="function">color <span class="title">ray_color</span><span class="params">(ray&amp; r, <span class="type">const</span> hittable&amp; world, <span class="type">int</span> depth, <span class="type">double</span> RR)</span> </span>&#123;</span><br><span class="line">    hit_record rec;</span><br><span class="line">    <span class="comment">// 这里的t的下界设为0.001是为了防止一些光线弹射到物体上得到的t非常接近0，比如可能出现0.000001这样的值</span></span><br><span class="line">    <span class="keyword">if</span> (world.<span class="built_in">hit</span>(r, <span class="number">0.001</span>, infinity, rec)) &#123;</span><br><span class="line">        <span class="comment">// 光线弹射指定次数后开始用RR算法终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (depth &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">random_double</span>() &gt;= RR) <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据物体材质得到光线传播方向和反射率</span></span><br><span class="line">        ray scattered;</span><br><span class="line">        color attenuation;</span><br><span class="line">        <span class="keyword">if</span> (rec.mat_ptr-&gt;<span class="built_in">scatter</span>(r, rec, attenuation, scattered))</span><br><span class="line">            <span class="keyword">return</span> attenuation * <span class="built_in">ray_color</span>(scattered, world, depth - <span class="number">1</span>, RR) / RR;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vec3 unit_direction = <span class="built_in">normalize</span>(r.<span class="built_in">direction</span>());</span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">0.5</span> * (unit_direction.<span class="built_in">y</span>() + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> - t) * <span class="built_in">color</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * <span class="built_in">color</span>(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中设定最少弹射次数为 3 次，生存概率为 0.9，渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/MetalDenoise.png" alt="MetalDenoise"></p>
<h4 id="3-2-Glossy-反射"><a href="#3-2-Glossy-反射" class="headerlink" title="3.2 Glossy 反射"></a>3.2 Glossy 反射</h4><p>可以看到金属球上的倒影是完美的镜面反射，接下来我们可以向金属材质中添加 Glossy 反射，在镜面反射方向找一个小的球体对镜面反射方向进行扰动，使得光线朝着镜面反射方向周围一定范围散射：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/fig-1.12-reflect-fuzzy.jpg" alt="fig-1.12-reflect-fuzzy"></p>
<p>我们可以在材质类中定义一个扰动球半径，扰动球半径越大，模糊越严重，扰动球半径为 0 就是完美的镜面反射，同时扰动球半径不能大于 1 ，否则光线可能被扰动到物体内部，所以如果给定的扰动球半径大于 1 ，我们要截断到 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金属材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">metal</span> : <span class="keyword">public</span> material &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">metal</span>(<span class="type">const</span> color&amp; a, <span class="type">const</span> <span class="type">double</span> f) : <span class="built_in">albedo</span>(a), <span class="built_in">fuzz</span>(f &lt; <span class="number">1</span> ? f : <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ray&amp; r_in, <span class="type">const</span> hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入镜面反射函数都是单位向量</span></span><br><span class="line">        vec3 reflected = <span class="built_in">reflect</span>(<span class="built_in">normalize</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        scattered = <span class="built_in">ray</span>(rec.p, reflected + fuzz * <span class="built_in">random_in_unit_sphere</span>());</span><br><span class="line">        attenuation = albedo;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(scattered.<span class="built_in">direction</span>(), rec.normal) &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    color albedo;   <span class="comment">//反射率</span></span><br><span class="line">    <span class="type">double</span> fuzz;    <span class="comment">//Glossy反射扰动系数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在创建材质的时候可以赋予不同的扰动系数，是的物体产生不同的表现，修改主函数创建两种不同扰动系数的金属材质：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hittable_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sphere.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;camera.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/****图片保存，保存为png格式****/</span></span><br><span class="line">    std::string SavePath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\Ray Tracing in One Weekend Series\\Results\\&quot;</span>;</span><br><span class="line">    std::string filename = <span class="string">&quot;MetalDenoise.png&quot;</span>;</span><br><span class="line">    std::string filepath = SavePath + filename;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*******图片属性*******/</span> </span><br><span class="line">    <span class="comment">// 宽高比</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> aspect_ratio = <span class="number">16.0</span> / <span class="number">9.0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_width = <span class="number">400</span>;</span><br><span class="line">    <span class="comment">// 使用static_cast可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</span></span><br><span class="line">    <span class="comment">// 也可以让阅读程序的其他程序员明确你转换的目的而不是由于疏忽</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> image_height = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(image_width / aspect_ratio);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> channel = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 每个像素的采样数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> samples_per_pixel = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 光线至少弹射次数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> min_bounce = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 俄罗斯轮盘赌算法生存概率</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> RR = <span class="number">0.9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建相机*******/</span></span><br><span class="line">    camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*******创建场景*******/</span></span><br><span class="line">    hittable_list world;</span><br><span class="line">    <span class="keyword">auto</span> material_ground = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.0</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_center = <span class="built_in">make_shared</span>&lt;lambertian&gt;(<span class="built_in">color</span>(<span class="number">0.7</span>, <span class="number">0.3</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="keyword">auto</span> material_left = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>), <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">auto</span> material_right = <span class="built_in">make_shared</span>&lt;metal&gt;(<span class="built_in">color</span>(<span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.2</span>), <span class="number">1.0</span>);</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">-100.5</span>, <span class="number">-1.0</span>), <span class="number">100.0</span>, material_ground));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_center));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_left));</span><br><span class="line">    world.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(<span class="built_in">point3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>), <span class="number">0.5</span>, material_right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******渲染部分*****/</span></span><br><span class="line">    <span class="comment">// 3通道图像存在一维数组中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* odata = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(image_width * image_height * channel);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = odata;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = image_height - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">        <span class="comment">// 标准错误流显示进度信息，单行刷新显示</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;\rScanlines remaining: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; std::flush;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; image_width; ++i) &#123;</span><br><span class="line">            <span class="function">color <span class="title">pixel_color</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">                <span class="comment">// 在像素内部随机采样</span></span><br><span class="line">                <span class="keyword">auto</span> u = (i + <span class="built_in">random_double</span>()) / (image_width - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">auto</span> v = (j + <span class="built_in">random_double</span>()) / (image_height - <span class="number">1</span>);</span><br><span class="line">                ray r = cam.<span class="built_in">get_ray</span>(u, v);</span><br><span class="line">                pixel_color += <span class="built_in">ray_color</span>(r, world, min_bounce, RR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">write_color</span>(p, pixel_color, samples_per_pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), image_width, image_height, channel, odata, <span class="number">0</span>);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;\nDone.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E9%87%91%E5%B1%9E%E6%9D%90%E8%B4%A8/Glossy.png" alt="Glossy"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【RayTracer】（十二）Perlin噪声</title>
    <url>/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/</url>
    <content><![CDATA[<p>噪声在游戏领域的应用极为广泛，能帮助我们产生更加真实的纹理、特效等。之前在 Shader 的学习中，我们就使用过噪声纹理，并在最后提到了这些噪声纹理来自于哪里，著名的 Perlin 噪声就是其中之一。Perlin 噪声由于计算量小，效果好而被广泛应用，它的发明者 Ken Perlin 凭借这一算法还获得了当年的奥斯卡科技成果奖。这一节我们在光线追踪器中自己实现 Perlin 噪声。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Perlin-噪声原理"><a href="#1-Perlin-噪声原理" class="headerlink" title="1 Perlin 噪声原理"></a>1 Perlin 噪声原理</h3><p>Perlin 噪声的产生是由于，如果我们用完全随机的噪声，比如白噪声，生成的纹理或者效果会显得非常不自然，因为很多真实世界中看似没有规律的事物，实际上是存在一定规律的，只是看起来是杂乱无章的。因此 Perlin 噪声诞生了，Perlin 噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影、动画等多媒体领域广泛应用。在游戏领域，Perlin 噪声可以用于生成波形，起伏不平的材质或者纹理。Perlin 噪声绝大部分应用在二维，三维层面上，但某种意义上也能拓展到四维。Perlin 噪声在一维层面上可用于卷轴地形、模拟手绘线条等，在二维或三维上用于生成随机地形，火焰燃烧特效，水和云等等。如果将 Perlin 噪声拓展到四维层面，即 w 轴代表时间，就能利用 Perlin 噪声生成动画。</p>
<p>Perlin噪声实现需要三个步骤：</p>
<ul>
<li>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量。所谓“伪随机”是指，对于给定的输入得到的值是一样的，因此并不是真正的随机。但并不影响效果，因为只要相同的值离得足够远，就看不出来是伪随机。对于二维的 Perlin 噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</li>
<li>输入一个点（二维的话就是二维坐标，三维就是三维坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到二维下 4 个，三维下 8 个点乘结果。</li>
<li>使用缓和曲线（ease curves）来计算它们的权重和。在原始的 Perlin 噪声实现中，缓和曲线是 $s(t)&#x3D;3t^2−2t^3$，在2002年的论文中，Perlin 改进为 $s(t)&#x3D;6t^5−15t^4+10t^3$。</li>
</ul>
<blockquote>
<p>这里简单解释一下，为什么不直接使用线性插值，即 $s(t) &#x3D; t$。直接使用的线性插值的话，它的一阶导在晶格顶点处（即 t &#x3D; 0 或 t &#x3D; 1）不为 0，会造成明显的不连续性。 $s(t)&#x3D;3t^2−2t^3$ 在一阶导满足连续性， $s(t)&#x3D;6t^5−15t^4+10t^3$ 在二阶导上仍然满足连续性。</p>
</blockquote>
<p>下图描述了前两个步骤：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/20151218110535114.png" alt="20151218110535114"></p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><p>我们从简到繁一步一步实现 Perlin 噪声，首先实现一个简化版本。Perlin 噪声函数实际上就是对于一个给定的输入点，输出一个 double 类型的噪声值，这个值是伪随机的，也就是说对于相同的给定点，得到的值会是一样的。因此我们实现一个 Perlin 噪声类，在类中根据以上步骤计算噪声值。</p>
<p>在具体实现中，我们使用 256 个晶格，但是先不去计算每个晶格顶点的随机梯度向量，也不去计算给定的点和周围八个晶格顶点的距离向量和随机梯度向量的点乘，我们直接随机生成这些点乘结果存在一个查找表中（只是这样理解，因为点乘也只是一个数字而已，但实际上这是一种并不正确的简化，之后会正确的实现），然后根据给定点的坐标去查找点乘结果，然后将这些点乘结果利用三线性插值结合起来。</p>
<p>在查找的时候，我们预先计算一个随机排列数组 P[n]，P[n] 里面存储的是打乱后的 0-255 的排列值，然后我们根据给定点的坐标作为索引，到 P[n] 中找到一个 0-255 的下标，用这个下标取到查找表中对应的点乘结果。对于三维空间，我们要分别计算三个维度的 P[n] 数组，然后将三个下标值加起来并限制在  0~255 的范围，再去查找对应的点乘结果，作为一个顶点的点乘，这样查找八次即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机点乘结果</span></span><br><span class="line">        ranfloat = <span class="keyword">new</span> <span class="type">double</span>[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranfloat[i] = <span class="built_in">random_double</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranfloat;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">        <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranfloat[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span>* ranfloat;   <span class="comment">// 存储随机点乘结果的查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">trilinear_interp</span><span class="params">(<span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                    accum += (i * u + (<span class="number">1</span> - i) * (<span class="number">1</span> - u)) *</span><br><span class="line">                    (j * v + (<span class="number">1</span> - j) * (<span class="number">1</span> - v)) *</span><br><span class="line">                    (k * w + (<span class="number">1</span> - k) * (<span class="number">1</span> - w)) * c[i][j][k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-测试效果"><a href="#3-测试效果" class="headerlink" title="3 测试效果"></a>3 测试效果</h3><p>然后我们创建一个 Perlin 噪声纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再创建一个新场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;();</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改主函数部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        world = <span class="built_in">random_scene</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        aperture = <span class="number">0.1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        world = <span class="built_in">two_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        world = <span class="built_in">two_perlin_spheres</span>();</span><br><span class="line">        lookfrom = <span class="built_in">point3</span>(<span class="number">13</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        lookat = <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        vfov = <span class="number">20.0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise.png" alt="PerlinNoise"></p>
<h3 id="4-改进实现"><a href="#4-改进实现" class="headerlink" title="4 改进实现"></a>4 改进实现</h3><p>接下来我们改进上面的简化版实现，首先是插值系数，我们使用 $s(t)&#x3D;6t^5−15t^4+10t^3$ 来改进插值系数，在 Perlin 类中加一个 <code>fade</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>noise</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离，作为插值的系数</span></span><br><span class="line">    <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">    <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">    <span class="comment">// 使用fade函数修改插值系数</span></span><br><span class="line">    u = <span class="built_in">fade</span>(u);</span><br><span class="line">    v = <span class="built_in">fade</span>(v);</span><br><span class="line">    w = <span class="built_in">fade</span>(w);</span><br><span class="line">    <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">    <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">    <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">    <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">    <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量和到该点的距离向量的点乘结果</span></span><br><span class="line">    <span class="type">double</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 到查找表中查找八个点乘结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                c[di][dj][dk] = ranfloat[</span><br><span class="line">                perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">            ];</span><br><span class="line">    <span class="comment">// 对八个点乘结果三线性插值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">trilinear_interp</span>(c, u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise2-16503697126921.png" alt="PerlinNoise2"></p>
<p>可以看出一些随机效果，但是频率太低了，我们可以为纹理加上一个频率属性，控制随机的频率，这可以通过对传入 <code>noise</code> 函数的顶点值 p 进行缩放实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">noise</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后修改场景中的纹理，给定一个缩放系数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声测试场景</span></span><br><span class="line"><span class="function">hittable_list <span class="title">two_perlin_spheres</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hittable_list objects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pertext = <span class="built_in">make_shared</span>&lt;noise_texture&gt;(<span class="number">4</span>);</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">-1000</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1000</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line">    objects.<span class="built_in">add</span>(<span class="built_in">make_shared</span>&lt;sphere&gt;(</span><br><span class="line">        <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="built_in">point3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2</span>, <span class="built_in">make_shared</span>&lt;lambertian&gt;(pertext)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise3.png" alt="PerlinNoise3"></p>
<p>最后我们来实现真正的 Perlin 噪声函数，现在只要将随机生成的点乘结果，变为随机生成梯度向量，然后和点 p 到八个晶格顶点的距离向量做点乘，再利用三线性插值融合点乘结果即可。为此我们需要修改 Perlin 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Perlin噪声类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PERLIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERLIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utilities.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">perlin</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="comment">// 生成随机梯度向量</span></span><br><span class="line">        ranvec = <span class="keyword">new</span> vec3[point_count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; point_count; ++i) &#123;</span><br><span class="line">            ranvec[i] = <span class="built_in">normalize</span>(<span class="built_in">random_vec</span>(<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成三个维度的P[n]数组</span></span><br><span class="line">        perm_x = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_y = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">        perm_z = <span class="built_in">perlin_generate_perm</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">perlin</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ranvec;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_x;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_y;</span><br><span class="line">        <span class="keyword">delete</span>[] perm_z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perlin 噪声函数，给定三维空间一点，返回噪声值</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">noise</span><span class="params">(<span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个维度坐标的小数部分相当于到一个单位立方体各个维度的距离</span></span><br><span class="line">        <span class="keyword">auto</span> u = p.<span class="built_in">x</span>() - <span class="built_in">floor</span>(p.<span class="built_in">x</span>());</span><br><span class="line">        <span class="keyword">auto</span> v = p.<span class="built_in">y</span>() - <span class="built_in">floor</span>(p.<span class="built_in">y</span>());</span><br><span class="line">        <span class="keyword">auto</span> w = p.<span class="built_in">z</span>() - <span class="built_in">floor</span>(p.<span class="built_in">z</span>());</span><br><span class="line">        <span class="comment">// 三个维度坐标的整数部分，用于到P[n]数组中找到查找表下标</span></span><br><span class="line">        <span class="keyword">auto</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">x</span>()));</span><br><span class="line">        <span class="keyword">auto</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">y</span>()));</span><br><span class="line">        <span class="keyword">auto</span> k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">floor</span>(p.<span class="built_in">z</span>()));</span><br><span class="line">        <span class="comment">// 存储离该点最近的八个晶格顶点的随机梯度向量</span></span><br><span class="line">        vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 到查找表中查找八个随机梯度向量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">2</span>; di++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dj = <span class="number">0</span>; dj &lt; <span class="number">2</span>; dj++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dk = <span class="number">0</span>; dk &lt; <span class="number">2</span>; dk++)</span><br><span class="line">                    <span class="comment">// 异或是不进位加法，相当于把三个P[n]数组中的下标加起来并限制在0~255之间，避免下标越界</span></span><br><span class="line">                    c[di][dj][dk] = ranvec[</span><br><span class="line">                        perm_x[(i + di) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_y[(j + dj) &amp; <span class="number">255</span>] ^</span><br><span class="line">                            perm_z[(k + dk) &amp; <span class="number">255</span>]</span><br><span class="line">                    ];</span><br><span class="line">        <span class="comment">// 用八个梯度向量和距离向量点乘并线性插值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">perlin_interp</span>(c, u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> point_count = <span class="number">256</span>;</span><br><span class="line">    vec3* ranvec;       <span class="comment">// 存储随机梯度向量查找表</span></span><br><span class="line">    <span class="type">int</span>* perm_x;        <span class="comment">// x维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_y;        <span class="comment">// y维度的P[n]数组</span></span><br><span class="line">    <span class="type">int</span>* perm_z;        <span class="comment">// z维度的P[n]数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成从 0 到 point_count - 1 的乱序数组</span></span><br><span class="line">    <span class="comment">// 思路是先生成顺序的数组，然后使用洗牌算法打乱</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span>* <span class="title">perlin_generate_perm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">int</span>[point_count];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; perlin::point_count; i++)</span><br><span class="line">            p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">permute</span>(p, point_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法打乱数组，从后向前遍历数组，每次随机挑一个下标和当前下标交换</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">permute</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> target = <span class="built_in">random_int</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span> tmp = p[i];</span><br><span class="line">            p[i] = p[target];</span><br><span class="line">            p[target] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将八个顶点的梯度向量和点p到八个顶点的距离向量点乘，并做三线性插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">perlin_interp</span><span class="params">(vec3 c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="type">double</span> u, <span class="type">double</span> v, <span class="type">double</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过改进的线性插值系数</span></span><br><span class="line">        <span class="keyword">auto</span> uu = <span class="built_in">fade</span>(u);</span><br><span class="line">        <span class="keyword">auto</span> vv = <span class="built_in">fade</span>(v);</span><br><span class="line">        <span class="keyword">auto</span> ww = <span class="built_in">fade</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    <span class="function">vec3 <span class="title">weight_v</span><span class="params">(u - i, v - j, w - k)</span></span>;</span><br><span class="line">                    accum += (i * uu + (<span class="number">1</span> - i) * (<span class="number">1</span> - uu))</span><br><span class="line">                        * (j * vv + (<span class="number">1</span> - j) * (<span class="number">1</span> - vv))</span><br><span class="line">                        * (k * ww + (<span class="number">1</span> - k) * (<span class="number">1</span> - ww))</span><br><span class="line">                        * <span class="built_in">dot</span>(c[i][j][k], weight_v);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓和曲线，用于缓和线性插值系数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">fade</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x * x * (x * (x * <span class="number">6</span> - <span class="number">15</span>) + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>按照这样的实现，由于向量点乘可能为负，因此 <code>noise</code> 函数输出的值可能为负，这样得到的颜色值就可能为负，最后进行伽马校正的时候我们要开根号，就会得到不正确的值。所以我们要在纹理类中将得到的噪声值从 [-1, 1] 映射到 [0, 1]：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到的noise值范围是[-1,1]，防止颜色为负，映射到[0,1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1.0</span> + noise.<span class="built_in">noise</span>(scale * p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后看一下真正的 Perlin 噪声的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise4.png" alt="PerlinNoise4"></p>
<h3 id="5-Turbulence"><a href="#5-Turbulence" class="headerlink" title="5 Turbulence"></a>5 Turbulence</h3><p>将多个不同频率的噪声混合起来得到的噪声称为 Turbulence，利用 Turbulence 可以实现许多随机纹理，我们可以通过多次调用 <code>noise</code> 函数并将结果融合来得到 Turbulence。在 Perlin 类中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个noise组合形成turbulence</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">turb</span><span class="params">(<span class="type">const</span> point3&amp; p, <span class="type">int</span> depth = <span class="number">7</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> accum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> temp_p = p;</span><br><span class="line">    <span class="keyword">auto</span> weight = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">        accum += weight * <span class="built_in">noise</span>(temp_p);</span><br><span class="line">        weight *= <span class="number">0.5</span>;</span><br><span class="line">        temp_p *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(accum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改噪声纹理类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于turb函数对最终融合的噪声取了绝对值，这里不需要再做任何映射</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * noise.<span class="built_in">turb</span>(scale * p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise5.png" alt="PerlinNoise5"></p>
<h3 id="6-大理石纹理"><a href="#6-大理石纹理" class="headerlink" title="6 大理石纹理"></a>6 大理石纹理</h3><p>一般来说，Turbulence 不会像上面那样直接使用。而是会作为一个随机扰动来生成不同的纹理，比如大理石纹理。我们可以让点 p 的某一维度和三角函数成正比，这样就可以模拟大理石的裂痕曲线，但是为了不让曲线有规律，我们使用 Turbulence 来改变三角函数的相位，这样就可以实现一个随机的大理石纹理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Perlin噪声纹理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noise_texture</span> : <span class="keyword">public</span> texture &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">noise_texture</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">noise_texture</span>(<span class="type">double</span> sc) : <span class="built_in">scale</span>(sc) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> color <span class="title">value</span><span class="params">(<span class="type">double</span> u, <span class="type">double</span> v, <span class="type">const</span> point3&amp; p)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大理石纹理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * <span class="number">0.5</span> * (<span class="number">1</span> + <span class="built_in">sin</span>(scale * p.<span class="built_in">z</span>() + <span class="number">10</span> * noise.<span class="built_in">turb</span>(p)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    perlin noise;</span><br><span class="line">    <span class="type">double</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise6.png" alt="PerlinNoise6"></p>
<p>如果我们把点 p 和三角函数成正比的维度改为 y 轴，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/19/20220419-RayTracer-Perlin%E5%99%AA%E5%A3%B0/PerlinNoise7.png" alt="PerlinNoise7"></p>
]]></content>
      <categories>
        <category>RayTracer</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>C++</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++对象模型】（二）关于构造函数</title>
    <url>/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>《深度探索C++对象模型》第二章重点梳理。主要内容包括：</p>
<ul>
<li>默认构造函数的构建操作</li>
<li>拷贝构造函数的构建操作</li>
<li>使用列表进行初始化的背后工作</li>
</ul>
<p><em><span id="more"></span></em></p>
<h2 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1 默认构造函数"></a>1 默认构造函数</h2><p>有一种常见的说法是，如果定义一个类的时候没有显式的为其声明构造函数，那么编译器将会自动生成默认的构造函数，但一般来说编译器生成的默认构造函数对于程序而言是没有任何用处的，编译器生成默认构造函数完全是为了满足编译器的需要，而不是我们所编写的程序的需要。但在一些情况下，编译器生成的默认构造函数是有用的，下面将讨论这些情况。</p>
<h3 id="1-1-带有默认构造函数的类对象成员"><a href="#1-1-带有默认构造函数的类对象成员" class="headerlink" title="1.1 带有默认构造函数的类对象成员"></a>1.1 带有默认构造函数的类对象成员</h3><p>如果一个类没有显式声明构造函数，但包含一个声明了构造函数的类对象成员，那么这个类的默认构造函数就是有用的。编译器会为这个类生成一个默认构造函数，但这个生成操作只在构造函数真正需要被调用的时候才进行。</p>
<p>例如，有下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; <span class="keyword">public</span>: <span class="built_in">Foo</span>(), <span class="built_in">Foo</span>(<span class="type">int</span>)... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123; <span class="keyword">public</span>: Foo foo; <span class="type">char</span> *str; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">if</span>(str) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 Bar 中包含一个对象成员 foo，该对象有显式声明的构造函数，因此编译器会为 Bar 生成默认构造函数，这个默认构造函数会调用 Foo 的构造函数来初始化对象成员 foo，但不会初始化 Bar 的 str 成员，因为初始化对象成员是编译器需要的，编译器必须为每个对象分配内存，而初始化一个字符指针对于编译器来说不需要。所以编译器生成的默认构造函数看起来就是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器自动生成的构造函数、析构函数、拷贝构造、assignment 等都被指定为内联函数，如果函数太复杂不适合做成内联，就会生成一个显式的非内联静态（explicit non-inline static）函数实体。</p>
<p>为了让程序正确运行，我们需要把 str 成员也初始化，但这不能指望编译器来生成，需要手动实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;str = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>这时，虽然显式声明了构造函数，但这个构造函数没有初始化对象成员 foo，所以也还是没有满足编译器的需求，因此编译器还是会自动生成构造函数，但这时编译器不会单独生成一个函数了，而是会在用户定义的构造函数上进行扩展，加入编译器需要的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bar::<span class="built_in">Bar</span>() &#123;</span><br><span class="line">    foo.Foo::<span class="built_in">Foo</span>();   <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    str = <span class="number">0</span>;          <span class="comment">// 用户定义的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类中有多个对象成员，这些成员都有显式定义的构造函数，那么编译器自动生成构造函数时会按照对象成员的声明顺序调用他们的构造函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span> &#123; <span class="keyword">public</span>: <span class="built_in">Dopey</span>(); ...);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span> &#123; <span class="keyword">public</span>: <span class="built_in">Sneezy</span>(<span class="type">int</span>); <span class="built_in">Sneezy</span>(); ...); </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span> &#123; <span class="keyword">public</span>: <span class="built_in">Bashful</span>(); ...) ;</span><br><span class="line">               </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy; </span><br><span class="line">    Bashful bashful;</span><br><span class="line">    <span class="comment">// 显式定义的构造函数</span></span><br><span class="line">    <span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mumble = <span class="number">2048</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mumble; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时编译器自动扩展后的构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 编译器加入的代码</span></span><br><span class="line">    dopey.Dopey::<span class="built_in">dopey</span>();</span><br><span class="line">    sneezy.Sneezy::<span class="built_in">sneezy</span>(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::<span class="built_in">bashful</span>();</span><br><span class="line">    <span class="comment">// 用户定义的代码</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-带有默认构造函数的基类"><a href="#1-2-带有默认构造函数的基类" class="headerlink" title="1.2 带有默认构造函数的基类"></a>1.2 带有默认构造函数的基类</h3><p>如果一个没有显式定义构造函数的类派生于一个有显式构造函数的基类，那么这个派生类的默认构造函数是有用的。派生类自动生成的默认构造函数将调用上一层基类的默认构造函数（根据声明次序）。</p>
<p>如果程序员为这个派生类声明了多个构造函数，但就是没有默认构造函数，那么编译器会扩展程序员声明的所有构造函数，将调用所有必要的默认构造函数的代码加入这些构造函数中，这些必要的默认构造函数就包括其父类的默认构造函数，以及其对象成员的默认构造函数。</p>
<h3 id="1-3-带有虚函数的类"><a href="#1-3-带有虚函数的类" class="headerlink" title="1.3 带有虚函数的类"></a>1.3 带有虚函数的类</h3><p>对于以下两种情况，默认构造函数也是有用的：</p>
<ul>
<li>带有虚函数的类</li>
<li>该类派生自一个继承链，这个继承链中有一个或多个带有虚函数的基类</li>
</ul>
<p>这两种情况下编译器将会在默认构造函数中加入对虚函数表的操作，因此是有用的。</p>
<p>例如有下图的继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505163329344.png" alt="image-20220505163329344"></p>
<p>执行下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.<span class="built_in">flip</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">flip</span>(b);</span><br><span class="line">    <span class="built_in">flip</span>(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间，编译器会进行如下两个扩展操作：</p>
<ol>
<li>编译器会产生一张虚函数表 vtbl，其中存放类的虚函数地址</li>
<li>每一个类对象中，编译器会生成一个额外的指针成员 vptr，指向类的虚函数表</li>
</ol>
<p>此外，<code>widget.flip()</code> 的虚拟引发（virtual invocation）操作会被重新改写，以使用 widget 的 vptr 和 vtbl 中的 flip() 条目：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*widget.vptr[<span class="number">1</span>]) (&amp;widget)</span><br></pre></td></tr></table></figure>

<p>其中 1 表示 flip() 在虚函数表中的索引，<code>&amp;widget</code> 表示要交给被调用的某个 flip() 函数实体的 this 指针。</p>
<p>为了让这个机制发挥功效，编译器必须为每一个 Widget （或其派生类）的对象的 vptr 设定初值，放置适当的 virtual table 地址。对于 class 所定义的每一个构造函数，编译器会安插一些代码来做这样的事情。对于那些未声明任何构造函数的类，编译器会为它们生成一个默认构造函数，以便正确地初始化每一个 class object 的 vptr。</p>
<h3 id="1-4-继承于虚拟基类的类"><a href="#1-4-继承于虚拟基类的类" class="headerlink" title="1.4 继承于虚拟基类的类"></a>1.4 继承于虚拟基类的类</h3><p>虚拟继承的实现方法在不同的编译器之间有极大的差异，但是每一种实现方法都必须保证虚拟基类（virtual base class）子对象（subobject）在其每一个派生类对象中的位置能够在执行期准备妥当。例如有如下继承关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220505165553286.png" alt="image-20220505165553286"></p>
<p>有下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;<span class="keyword">public</span>: <span class="type">int</span> i;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">int</span> j;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;<span class="keyword">public</span>: <span class="type">double</span> d;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;<span class="keyword">public</span>: <span class="type">int</span> k;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译期决定 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> A);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="keyword">new</span> C);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译期间编译器无法确定函数 foo 中 <code>pa-&gt;X::i</code> 的实际位置，因为 pa 的类型可以改变，其中包含的基类子对象的位置并不确定，因此编译器必须改变<strong>对虚拟基类成员进行存取操作的代码</strong>（例如上面的 <code>pa-&gt;i = 1024</code> 就是在对虚拟基类的成员进行存取操作），使得 <code>pa-&gt;X::i</code> 可以延迟到执行期才确定下来。</p>
<p>编译器通过在派生类对象中添加一个指向虚拟基类的指针来完成上述操作，任何对虚拟基类成员的存取操作都可以通过该指针完成，比如上面的代码会被编译器改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>__vbcX</code> 是编译器为派生类对象生成的指向 virtual base class X 的指针。 <code>__vbcX</code> 是在对象构造期间产生的，对于类中声明的每一个构造函数，编译器都会加入构建 <code>__vbcX</code> 的代码，如果类中没有声明任何构造函数，那么编译器会生成一个默认构造函数来完成这件事。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>以上四种情况，会导致 C++ 编译器必须为没有显式声明构造函数的类生成（合成）一个默认构造函数。C++ 将这些默认构造函数称为 implicit nontrivial default constructors。</p>
<p>被生成（合成）出来的 constructor 只能满足编译器（而非程序）的需要，这样的构造函数之所以被称为 nontrivial ，是因为他们完成了一些对编译器来说必要的工作：</p>
<ul>
<li>调用对象成员的构造函数</li>
<li>调用基类的构造函数</li>
<li>为对象初始化指向虚函数表的指针</li>
<li>为对象初始化其 virtual base class 的指针</li>
</ul>
<p>至于不存在这四种情况而又没有显式声明构造函数的类，我们说它拥有的是 implicit trivial default constructors，这样的构造函数没有任何用处，实际上也不会被生成出来。</p>
<p>在生成（合成）的构造函数中，只有基类子对象和对象成员会被初始化，其他所有的非静态成员变量，如 int，*int，int[] 等，都不会被初始化，因为这些初始化或许对程序而言有用，但对编译器来说并不必要。</p>
<p><strong>因此，以下两种常见说法是完全错误的：</strong></p>
<ul>
<li>任何没有显式声明默认构造函数的类都会由编译器产生一个默认构造函数</li>
<li>编译器生成的默认构造函数会将类中所有成员明确初始化</li>
</ul>
<h2 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2 拷贝构造函数"></a>2 拷贝构造函数</h2><p>有三种情况，会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>使用一个对象对另一个对象进行初始化：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;...&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// 明确以一个对象对另一个对象初始化</span></span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象作为函数参数传递：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(X x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 以对象作为函数参数</span></span><br><span class="line">    <span class="built_in">foo</span>(xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象作为函数返回值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序员在类中明确定义了一个拷贝构造函数（copy constructor），即以本类型作为参数的构造函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::<span class="built_in">X</span>(<span class="type">const</span> X&amp; X);</span><br><span class="line">Y::<span class="built_in">Y</span>(<span class="type">const</span> Y&amp; y, <span class="type">int</span> = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>那么在上述情况下，拷贝构造函数将被调用。但如果类中没有用户显式定义的拷贝构造函数，编译器将如何完成拷贝操作呢？</p>
<h3 id="2-1-Default-Memberwise（逐成员的）-Initialization"><a href="#2-1-Default-Memberwise（逐成员的）-Initialization" class="headerlink" title="2.1 Default Memberwise（逐成员的） Initialization"></a>2.1 Default Memberwise（逐成员的） Initialization</h3><p>当用户没有显式定义拷贝构造函数时，编译器内部是以 Default Memberwise Initialization（默认逐成员初始化） 方法完成该操作的。也就是把每一个内建的或派生的成员变量（指针或其他变量）的值，从某个对象拷贝到另一个对象身上，但它并不会拷贝其中的类对象成员（member class object），而是以递归的方式进行 Memberwise Initialization。</p>
<p>例如，有一个字符串类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们把一个字符串对象作为另一个对象的初值时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line">String verb = noun;</span><br></pre></td></tr></table></figure>

<p>Default Memberwise Initialization 将会像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">verb.str = noun.str;</span><br><span class="line">verb.len = noun.len;</span><br></pre></td></tr></table></figure>

<p>如果一个 String 对象作为另一个类的成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...没有定义拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _occurs;</span><br><span class="line">    String _word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 word 对象的 Default Memberwise Initialization 将会直接拷贝成员 <code>_occurs</code>，然后在 <code>_word</code> 身上递归的进行 Memberwise Initialization，即递归的调用 String 对象的 Default Memberwise Initialization。</p>
<p>一个类对象可以从两种方式复制得到，一种是被初始化（即我们现在讨论的），另一种是被指定（assignment），将会之后的章节讨论。这两个操作分别是以 copy constructor 和 copy assignment operator 完成的。拷贝构造函数和上一节的默认构造函数一样，只在必要的时候才由编译器产生出来，因此“如果一个 class 未定义出 copy constructor，编译器就自动为它自动生成一个”这句话是不对的。并且拷贝构造函数也被分为有用的（nontrivial）和无用的（trivial），只有 nontrivial 的拷贝构造函数才会被生成或者合成到现有代码中，而决定一个拷贝构造函数是否是 nontrivial 的标准在于这个类是否展现出所谓的 “bitwise copy semantics”。</p>
<h3 id="2-2-bitwise-copy-semantics（逐位次拷贝语义）"><a href="#2-2-bitwise-copy-semantics（逐位次拷贝语义）" class="headerlink" title="2.2 bitwise copy semantics（逐位次拷贝语义）"></a>2.2 bitwise copy semantics（逐位次拷贝语义）</h3><p>现有下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;word.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">word <span class="title">noun</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    word verb = noun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然 verb 是根据 noun 来初始化的，但是在没有看过 word 类的声明之前，我们无法预测这个初始化操作的程序行为，如果 word 类的设计者定义了一个拷贝构造函数，verb 的初始化就会调用它，但如果没有显式定义的拷贝构造函数，编译器是否会为 word 类生成一个拷贝构造函数呢？这就得视 word 类是否展现出 “bitwise copy semantics” 而定。</p>
<p>举例说明，比如 word 类有如下定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    ~<span class="built_in">word</span>() &#123;<span class="keyword">delete</span> [] str;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下并不需要合成出一个拷贝构造函数，因为上面的声明展现出了 default copy semantics，于是 verb 的初始化也就不需要以一个函数调用进行。但如果 word 类的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下声明没有展现 bitwise copy semantics</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>(<span class="type">const</span> String&amp;);</span><br><span class="line">    ~<span class="built_in">word</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    String str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 String 类显式声明了拷贝构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*);</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp;);    <span class="comment">//显式声明了拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个情况下，编译器必须合成出一个拷贝构造函数，以便调用对象成员的拷贝构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">word::word</span><span class="params">(<span class="type">const</span> word&amp; wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str.String::<span class="built_in">String</span>(wd.str);</span><br><span class="line">    cnt = wd.cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到生成出来的拷贝构造函数也会将非对象成员进行复制。</p>
<p>一个类在四种情况下不会展现出 bitwise copy semantics，即会由编译器生成拷贝构造函数：</p>
<ul>
<li>当 class 中包含一个对象成员而后者的类声明有一个拷贝构造函数时（这个拷贝构造函数可以是被用户显式声明的，就像前面的 String 那样，也可以是被编译器合成的，像 word 那样）</li>
<li>当 class 继承自一个 base class 而后者存在有一个 copy constructor 时（同样可以是用户定义的，也可以是编译器生成的）</li>
<li>当 class 声明了一个或多个 virtual functions 时</li>
<li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时</li>
</ul>
<p>前两种情况中，编译器必须将对象成员或基类的拷贝构造函数调用代码安插到生成的拷贝构造函数中，而后两种情况较为复杂，下面具体讨论。</p>
<h3 id="2-3-重新设定-Virtual-Table-指针"><a href="#2-3-重新设定-Virtual-Table-指针" class="headerlink" title="2.3 重新设定 Virtual Table 指针"></a>2.3 重新设定 Virtual Table 指针</h3><p>首先是第三种情况。当类中声明了虚函数时，编译器会为类生成一个虚函数表，并在每一个类对象中增加一个指向虚函数表的指针 vptr，因此在拷贝构造函数中必须要对对象的 vptr 进行正确的赋值，否则后果不堪设想，所以这种情况下编译器必须生成拷贝构造函数。</p>
<p>假设有下面的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bear</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Bear</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ZooAnimal 对象以另一个 ZooAnimal 对象作为初值，或者 Bear 对象以另一个 Bear 对象作为初值都可以直接靠 bitwise copy semantics 来完成，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bear yogi;</span><br><span class="line">Bear winnie = yogi;</span><br></pre></td></tr></table></figure>

<p>yogi 会被 Bear 的默认构造函数初始化，在构造函数中，yogi 的 vptr 被设定指向 Bear 类的虚函数表（靠编译器安插代码完成），因此直接把 yogi 的 vptr 值复制给 winnie 是完全没问题的，二者的关系如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506105047329.png" alt="image-20220506105047329"></p>
<p>但是当一个基类对象以一个派生类对象作为初值进行初始化时，其 vptr 复制操作就不是这么简单了，如果直接把派生类对象的 vptr 复制给基类对象，就会发生严重错误。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ZooAnimal franny = yogi;</span><br><span class="line">franny.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure>

<p>如果 franny 的 vptr 被复制为 yogi 的 vptr，那么相当于一个 ZooAnimal 类的对象会调用 Bear 派生类的函数实体，这就会发生严重错误。因此编译器必须保证在拷贝构造函数中为基类对象设定正确的 vptr 值。</p>
<p>事实上，上述代码执行的会是 ZooAnimal 的 draw 方法，因为 franny 是一个 ZooAnimal 对象，yogi 中的 Bear 部分已经在 franny 初始化时被切割（sliced）掉了，如果 franny 被声明为一个指针或者引用，那么 <code>franny.draw()</code> 才会调用 Bear 的 draw 方法。</p>
<p>也就是说，编译器自动生成的拷贝构造函数会明确设定基类对象的 vptr 指向基类的虚函数表，而不是直接从派生类中复制 vptr 的值。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110202874.png" alt="image-20220506110202874"></p>
<h3 id="2-4-处理-Virtual-Base-Class-Subobject"><a href="#2-4-处理-Virtual-Base-Class-Subobject" class="headerlink" title="2.4 处理 Virtual Base Class Subobject"></a>2.4 处理 Virtual Base Class Subobject</h3><p>接下来讨论第四种情况。一个类对象以另一个对象作为初值，而后者有一个 virtual base class subobject，那么也会使 bitwise copy semantics 失效，从而编译器必须生成拷贝构造函数。</p>
<p>之前学习过，编译器必须保证 virtual base class subobject 在其每一个派生类对象中的位置能够在执行期准备妥当，但 bitwise copy semantics 可能会破坏这个位置，所以编译器必须生成一个拷贝构造函数来处理这一事件。</p>
<p>比如有下面的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Raccoon</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">Raccoon</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类之间的继承关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506110945550.png" alt="image-20220506110945550"></p>
<p>显然，编译器首先会安插一些代码在 Raccoon 的构造函数中，包括：调用基类 ZooAnimal 的默认构造函数，设定 Raccoon 的 vptr 值，定位出 Raccoon 中 ZooAnimal 子对象的位置等。</p>
<p>虽然 Raccoon 类中含有一个虚拟基类子对象，但当我们用 Raccoon 对象初始化另一个 Raccoon 对象时，也不会出现额外的问题，只依靠 bitwise copy 即可。问题在于“用派生类对象初始化一个基类对象”，比如现在有一个 RedPanda 类继承于 Raccoon 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedPanda</span>() &#123;...&#125;</span><br><span class="line">    <span class="built_in">RedPanda</span>(<span class="type">int</span> val) &#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">//一些必要的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类继承关系如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506111610997.png" alt="image-20220506111610997"></p>
<p>使用一个 RedPanda 对象初始化 Raccoon 对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RedPanda little_red;</span><br><span class="line">Raccoon little_critter = little_red;</span><br></pre></td></tr></table></figure>

<p>这时，只依靠 bitwise copy 就不够了，编译器必须明确的将 little_critter 的 virtual base class subobject 指针初始化，以指出 virtual base class subobject 在哪。</p>
<p>这种情况下，为了正确完成 little_critter 的初值设定，编译器必须生成一个拷贝构造函数，安插一些代码以设定 virtual base class subobject 指针的初值，对每一个成员执行必要的逐成员初始化，以及其他内存相关工作。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20220506112328821.png" alt="image-20220506112328821"></p>
<h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>我们已经讨论过所有四种情况，这四种情况实际上和上一节默认构造函数的四种情况一致。在这些情况下，类不再保持 bitwise copy semantics，并且默认拷贝构造函数未被声明的话，会被视为 nontrivial，于是编译器为了正确处理“以一个对象作为另一个对象初值”的情况，必须生成或合成一个拷贝构造函数。</p>
<h2 id="3-使用列表初始化成员"><a href="#3-使用列表初始化成员" class="headerlink" title="3 使用列表初始化成员"></a>3 使用列表初始化成员</h2><p>C++ 中书写构造函数有一种特殊的写法，就是使用列表对类成员进行初始化，这一节来了解使用列表对成员进行初始化的背后发生了什么。</p>
<p>首先来看这样的一个类的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">word</span> &#123;</span><br><span class="line">    <span class="comment">//不声明访问权限默认为private</span></span><br><span class="line">    String _name;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">word</span>() &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样写构造函数自然没有问题，但效率很低，编译器会先产生一个临时的 String 对象，然后将它初始化，再以一个 assigment 运算符将临时的对象指定给 <code>_name</code> 成员，最后再摧毁临时对象。所以经过编译器扩展后的代码看起来就是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//调用String的默认构造函数</span></span><br><span class="line">    _name.String::<span class="built_in">String</span>();</span><br><span class="line">    <span class="comment">//产生临时对象</span></span><br><span class="line">    String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//降临时对象指定给_name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    <span class="comment">//摧毁临时对象</span></span><br><span class="line">    temp.String::~<span class="built_in">String</span>();</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果我们把构造函数写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会将代码扩展成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word::<span class="built_in">word</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以使用列表是较好的方式，因此最好坚持列表初始化的代码习惯：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">word::<span class="built_in">word</span>() : _name(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但有时我们不得不在函数体中指定成员初始值，比如要用一个成员初始化另一个成员，这时我们需要了解列表初始化背后到底发生了什么。</p>
<p>编译器会逐个操作初始化列表，以适当的次序将代码安插在构造函数体内，并且安插的代码会在用户定义的代码之前。这里的“适当的次序”是指成员变量在类中声明的次序，而不是初始化列表中书写的顺序。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里看起来是用 val 初始化 j，再用 j 初始化 i，但实际上列表初始化会按照成员声明次序扩展代码，因此会先为 i 赋值，但此时 j 还没有被赋值，因此会得到错误的结果。这时我们可以将构造函数写成这样，来避免问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val) &#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为编译器扩展的代码会在用户定义代码之前，所以会先为 j 赋值，再为 i 赋值。</p>
<p>总结一下，当存在以下情况时，尽量选择使用列表队成员进行初始化：</p>
<ul>
<li>初始化一个 reference 成员时</li>
<li>初始化一个 const 成员时</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时</li>
<li>当调用一个对象成员的构造函数，而它拥有一组参数时</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>最后总结构造函数的执行过程：</p>
<ol>
<li>在派生类构造函数中，所有虚基类和上一层基类的构造函数首先会按顺序被调用，以生成基类子对象</li>
<li>上述完成后，对象的 vptr 会被初始化，指向正确的虚函数表</li>
<li>如果有成员初始化列表的话，将在 vptr 被设定后扩展开来，以免其中调用了虚函数</li>
<li>如果有对象成员且其有构造函数，调用对象成员的构造函数</li>
<li>最后执行程序员提供的初始化代码</li>
</ol>
]]></content>
      <categories>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】图形渲染管线</title>
    <url>/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中图形渲染管线的相关知识进行概括总结。主要内容包括：</p>
<ul>
<li>图形渲染管线整体架构</li>
<li>图形渲染管线各阶段工作</li>
<li>思维导图</li>
</ul>
<p><em><span id="more"></span></em></p>
<h2 id="1-知识总结"><a href="#1-知识总结" class="headerlink" title="1 知识总结"></a>1 知识总结</h2><h3 id="1-1-图形渲染管线架构"><a href="#1-1-图形渲染管线架构" class="headerlink" title="1.1 图形渲染管线架构"></a>1.1 图形渲染管线架构</h3><p>在概念上可以将图形渲染管线分为三个阶段：</p>
<ul>
<li>应用程序阶段（The Application Stage）</li>
<li>几何阶段（The Geometry Stage）</li>
<li>光栅化阶段（The Rasterizer Stage）</li>
</ul>
<p>如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152034788.png" alt="image-20220512152034788"></p>
<p>图形渲染管线的每个阶段也可能是一条管线，比如上图中几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的光栅化阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</p>
<h3 id="1-2-应用程序阶段"><a href="#1-2-应用程序阶段" class="headerlink" title="1.2 应用程序阶段"></a>1.2 应用程序阶段</h3><p>应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。</p>
<p>正因应用程序阶段是软件方式实现，因此不能像几何和光栅化阶段那样继续分为若干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在 CPU 设计上，称这种形式为超标量体系（superscalar）结构，因为它可以在同一阶段同一时间做不同的几件事情。</p>
<p><strong>应用程序阶段通常实现的方法</strong>有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p>
<p><strong>应用程序阶段的主要任务</strong>：在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元，rendering primitives，如点、线、矩形等）输入到绘制管线的下一个阶段。</p>
<p>对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段——几何阶段。</p>
<h3 id="1-3-几何阶段"><a href="#1-3-几何阶段" class="headerlink" title="1.3 几何阶段"></a>1.3 几何阶段</h3><p>几何阶段主要负责大部分多边形操作和顶点操作。可以将这个阶段进一步划分成如下几个功能阶段：</p>
<ul>
<li>模型视点变换 Model &amp; View Transform</li>
<li>顶点着色 Vertex Shading</li>
<li>投影 Projection</li>
<li>裁剪 Clipping</li>
<li>屏幕映射 Screen Mapping</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512152716026.png" alt="image-20220512152716026"></p>
<p>几个注意点：</p>
<ul>
<li>根据具体实现，这些阶段可以和管线阶段等同，也可以不等同。在一些情况下，一系列连续的功能阶段可以形成单个管线阶段（和其他管线阶段并行运行）。在另外情况下，一个功能阶段可以划分成其他更细小的管线阶段。</li>
<li>几何阶段执行的是计算量非常高的任务，在只有一个光源的情况下，每个顶点大约需要 100 次左右的精确的浮点运算操作。</li>
</ul>
<h4 id="1-3-1-模型和视图变换"><a href="#1-3-1-模型和视图变换" class="headerlink" title="1.3.1 模型和视图变换"></a>1.3.1 模型和视图变换</h4><p>在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中。<strong>模型变换的变换对象一般是模型的顶点和法线</strong>。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p>
<p>为了便于投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向 Z 轴负方向，y 轴指向上方,x 轴指向右边。在视点变换后，实际位置和方向就依赖于当前的 API。我们称上述空间为相机空间或者观察空间。</p>
<p>下图显示了模型和视图变换的过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512153245093.png" alt="image-20220512153245093"></p>
<p>在左图中，摄像机根据用户指定的位置进行放置和定位。在右图中，视点变换从 原点沿着 Z 轴负方向对相机重新定位，这样可以使裁剪和投影操作更简单、更快速。可视范围是一个平截椎体，因此可以认为它是透视模式。</p>
<p><strong>【总结】</strong>模型和视图变换阶段分为模型变换和视图变换。模型变换的目的是将模型变换到适合渲染的空间当中，而视图变换的目的是将摄像机放置于坐标原点，方便后续步骤的操作。</p>
<h4 id="1-3-2-顶点着色"><a href="#1-3-2-顶点着色" class="headerlink" title="1.3.2 顶点着色"></a>1.3.2 顶点着色</h4><p>为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些描述。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p>
<p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shading equation）。通常，这些计算中的一部分在几何阶段期间在模型的顶点上执行（vertex shading），而其他计算可以在逐像素光栅化（per-pixel rasterization）期间执行。可以在每个顶点处存储各种属性数据，诸如顶点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。<strong>顶点着色的结果（可以是颜色，向量，纹理坐标或任何其他种类的着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</strong></p>
<p>着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型空间、观察空间、法线空间等）并在那里执行计算，也可以得到正确的结果。这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p>
<p><strong>【总结】</strong>顶点着色阶段的目的在于确定模型上顶点处材质的光照效果。</p>
<h4 id="1-3-3-投影"><a href="#1-3-3-投影" class="headerlink" title="1.3.3 投影"></a>1.3.3 投影</h4><p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是 (-1,- 1,-1) 和 (1,1,1) 的单位立方体（unit cube）内，这个单位立方体通常也被称为规范立方体（Canonical View Volume，CVV）。</p>
<p>目前，主要有两种投影方法，即：</p>
<ul>
<li>正交投影（orthographic projection，或称  parallel projection）</li>
<li>透视投影（perspective projection）</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512154019834.png" alt="image-20220512154019834"></p>
<p>正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。而在透视投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</p>
<p>正交投影和透视投影都可以通过 4 x 4 的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。</p>
<p><strong>【总结】</strong>投影的目的在于将模型顶点变换到归一化的设备坐标系中，便于后续处理。</p>
<h4 id="1-3-4-裁剪"><a href="#1-3-4-裁剪" class="headerlink" title="1.3.4 裁剪"></a>1.3.4 裁剪</h4><p>只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。</p>
<p>不难理解，一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p>
<ul>
<li>当图元完全位于视体内部，那么它可以直接进行下一个阶段</li>
<li>当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染</li>
<li>当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理</li>
</ul>
<p>裁剪的过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512160053289.png" alt="image-20220512160053289"></p>
<p>投影变换后，只对单位立方体内的图元（相应的是视锥内可见图元）继续进行处理，因此，将单位立方体之外的图元剔除掉，保留单位立方体内部的图元，同时沿着单位立方体将与单位立方体相交的图元裁剪掉，于是就会产生新的图元，同时舍弃旧的图元。</p>
<p><strong>【总结】</strong>裁剪阶段的目的，就是对部分位于视体内部的图元进行裁剪操作以只保留在视体内的部分。</p>
<h4 id="1-3-5-屏幕映射"><a href="#1-3-5-屏幕映射" class="headerlink" title="1.3.5 屏幕映射"></a>1.3.5 屏幕映射</h4><p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的 x 和 y 坐标变换到了屏幕坐标系中，屏幕坐标系连同 z 坐标一起称为窗口<br>坐标系。<br>假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2， y2），其中  x1 &lt; x2，y1 &lt; y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中 z 坐标不受影响。新的 x 和 y 坐标称为屏幕坐标系，与 z 坐标一起（-1 ≦ z ≦ 1）进入光栅化阶段。<br>屏幕映射过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163021922.png" alt="image-20220512163021922"></p>
<p><strong>【总结】</strong>屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p>
<h3 id="1-4-光栅化阶段"><a href="#1-4-光栅化阶段" class="headerlink" title="1.4 光栅化阶段"></a>1.4 光栅化阶段</h3><p>给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。这个过个过程叫光珊化（rasterization）或扫描变换（scan conversion），即从二维顶点所处的屏幕空间（所有顶点都包含 Z 值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。</p>
<p>与几何阶段相似，该阶段细分为几个功能阶段：</p>
<ul>
<li>三角形设定（Triangle Setup）阶段</li>
<li>三角形遍历（Triangle Traversal）阶段</li>
<li>像素着色（Pixel Shading）阶段</li>
<li>融合（Merging）阶段</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/image-20220512163755234.png" alt="image-20220512163755234"></p>
<h4 id="1-4-1-三角形设定"><a href="#1-4-1-三角形设定" class="headerlink" title="1.4.1 三角形设定"></a>1.4.1 三角形设定</h4><p>三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。<strong>该过程在专门为其设计的硬件上执行</strong>。</p>
<h4 id="1-4-2-三角形遍历"><a href="#1-4-2-三角形遍历" class="headerlink" title="1.4.2 三角形遍历"></a>1.4.2 三角形遍历</h4><p>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成<strong>片元（fragment）</strong>。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。<strong>每个片元的属性均由三个三角形顶点的数据插值而生成，这些属性包括片元的深度，以及来自几何阶段的着色数据等。</strong><br><strong>【总结】</strong>找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。</p>
<h4 id="1-4-3-像素着色"><a href="#1-4-3-像素着色" class="headerlink" title="1.4.3 像素着色"></a>1.4.3 像素着色</h4><p><strong>所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。</strong>纹理贴图操作就是在这阶段进行的。像素着色阶段是在可编程 GPU 内执行的，在这一阶段有大量的技术可以使用，其中最常见，<br>最重要的技术之一就是纹理贴图（Texturing），将会在之后进行总结。</p>
<p><strong>【总结】</strong>像素着色阶段的主要目的是计算所有需逐像素操作的过程。</p>
<h4 id="1-4-4-融合"><a href="#1-4-4-融合" class="headerlink" title="1.4.4 融合"></a>1.4.4 融合</h4><p>每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。<strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。</strong>不像其它着色阶段，通常运行该阶段的 GPU 子单元并非完全可编程的，但其高度可配置，可支持多种特效。</p>
<p>此外，这个阶段还负责可见性问题的处理。对于大多数图形硬件来说，这个过程是通过 <strong>Z 缓冲（Z-Buffer）</strong>算法来实现的。Z 缓冲算法非常简单，具有 O(n) 复杂度（n 是需要绘制的像素数量），只要对每个图元计算出相应的像素 z 值，就可以使用这种方法，大概内容是：Z 缓冲器和颜色缓冲器形状大小一样，每个像素都存储着一个 z 值，这个 z 值是从相机到最近图元之间的距离。每次将一个图元绘制为相应像素时，需要计算像素位置处图元的 z 值，并与同一像素处的 z 缓冲器内容进行比较。如果新计算出的 z 值，远远小于 z 缓冲器中的 z 值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近。这样，像素的 z 值和颜色就由当前图元对应的值和颜色进行更新。反之，若计算出的 z 值远远大于 z 缓冲器中的 z 值，那么 z 缓冲器和颜色缓冲器中的值就无需改变。</p>
<p>除了颜色缓冲器用来存储颜色，z 缓冲器用来存储每个像素的  z 值，还有其他缓冲器可以用来过滤和捕获片段信息：</p>
<ul>
<li><strong>alpha 通道（alpha channel）</strong>和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值。 可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片断未能通过测试，它将不再进行进一步的处理。alpha 测试经常用于不影响深度缓存的全透明片段的处理。</li>
<li><strong>模板缓冲器（stencil buffer）</strong>是用于记录所呈现图元位置的离屏缓存。每个像素通常与占用 8 个位。图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和 Z 缓存的渲染。举个例子，假设在模板缓冲器中绘制出了一个实心圆形，那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个 mask 的操作。模板缓冲器是制作特效的强大工具。而在管线末端的所有这些功能都叫做光栅操作（raster operations ，ROP）或混合操作（blend operations）。</li>
<li><strong>帧缓冲器（frame buffer）</strong>通常包含一个系统所具有的所有缓冲器，但有时也可以认为是颜色缓冲器和 z 缓冲器的组合。</li>
<li><strong>累计缓冲器（accumulation buffer）</strong>，是 1990 年，Haeberli 和 Akeley 提出的一种缓冲器，是对帧缓冲器的补充。这个缓冲器可以用一组操作符对图像进行累积。例如，为了产生运动模糊（motion blur），可以对一系列物体运动的图像进行累积和平均。此外，其他的一些可产生的效果包括景深（e depth of field），反走样（antialiasing）和软阴影（soft shadows）等。</li>
</ul>
<p>而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了<strong>双缓冲（double buffering）</strong>机制，这意味着屏幕绘制是在一个后置缓冲器（backbuffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换。注意，只有当不影响显示的时候，才进行交换。</p>
<p><strong>【总结】</strong>融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。此外，融合阶段还负责可见性问题（Z 缓冲相关）的处理。</p>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>图形渲染管线的主要功能就是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。在概念上可以将图形渲染管线分为三个阶段：应用程序阶段、几何阶段、光栅化阶段。</p>
<p><strong>应用程序阶段</strong>的主要任务，是将需要绘制图元输入到绘制管线的下一个阶段，以及实现一些软件方式来实现的方法。主要方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法。对于被渲染的每一帧，应用程序阶段将摄像机位置，光照和模型的图元输出到管线的下一个主要阶段，即几何阶段。</p>
<p><strong>几何阶段</strong>首先对模型的顶点和法线进行矩阵变换，并将模型置于观察空间中（模型和视图变换），然后根据材质、纹理、以及光源属性进行顶点光照的计算（顶点着色阶段），接着将该模型投影变换到一个单位立方体内，并舍弃所有立方体之外的图元（投影阶段），而为了得到所有位于立方体内部的图元，接下来对与单位立方体相交的图元进行裁剪（裁剪阶段），然后将顶点映射到屏幕上的窗口中（屏幕映射阶段）。在对每个多边形执行完这些操作后，将最终数据传递到光栅，这样就来到了管线中的最后一个阶段，光栅化阶段。</p>
<p><strong>光栅化阶段</strong>中，所有图元会被光栅化，进而转换为屏幕上的像素。首先，计算三角形表面的差异和三角形表面的其他相关数据（三角形设定阶段），然后，找到哪些采样点或像素在三角形中（三角形遍历阶段），接着计算所有需逐像素计算操作（像素着色阶段），然后，合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，可见性问题可通过 Z 缓存算法解决，随同的还有可选的 alpha 测试和模版测试（融合阶段）。所有对象依次处理，而最后的图像显示在屏幕上。</p>
<h2 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2 思维导图"></a>2 思维导图</h2><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/12/20220512-RTR-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg" alt="图形渲染管线思维导图"></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】纹理总结</title>
    <url>/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中纹理相关知识进行概括总结。主要内容包括：</p>
<ul>
<li><p>纹理管线（Texture Pipeline）</p>
</li>
<li><p>纹理缓存（Texture Caching）</p>
</li>
<li><p>纹理压缩（Texture Compression）</p>
</li>
<li><p>体纹理（Volume Texture）</p>
</li>
<li><p>立方体贴图（Cube Map）</p>
</li>
<li><p>程序纹理（Procedural Texturing）</p>
</li>
<li><p>凹凸贴图（Bump Mapping）及其改进</p>
</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-纹理管线"><a href="#1-纹理管线" class="headerlink" title="1 纹理管线"></a>1 纹理管线</h3><p>简单来说，纹理（Texturing）是一种针对物体表面属性进行“建模”的高效技术。图像纹理中的像素通常被称为纹素（Texels），以区别于屏幕上的像素。根据 Kershaw 的术语，通过将投影方程（projector function）运用于空间中的点 ，从而得到一组称为参数空间值（parameter-spacevalues）的关于纹理的数值。这个过程就称为贴图（Mapping，也称映射 ）,也就是纹理贴图（Texture Mapping，也称纹理映射 ）这个词的由来。纹理贴图可以用一个通用的纹理管线来进行描述。<strong>纹理贴图过程的初始点是空间中的一个位置。这个位置可以基于世界空间，但是更常见的是基于模型空间。因为若此位置是基于模型空间的，当模型移动时，其纹理才会随之移动。</strong></p>
<p>下图展示了单个纹理的通用管线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515094736104.png" alt="image-20220515094736104"></p>
<ul>
<li>第一步。通过将投影方程（projector function）运用于空间中的点   ，从而得到一组称为参数空间值（parameter-space values）的关于纹理的数值，即 uv 坐标，在（0, 1）范围内。</li>
<li>第二步。在使用这些新值访问纹理之前，可以使用一个或者多个映射函数（corresponder function）将参数空间值（parameter-space values  ）转换到纹理空间，即对 uv坐标进行平移和缩放以映射到纹理空间中。</li>
<li>第三步。使用这些纹理空间值（texture-space locations）从纹理中获取相应的值（obtain value）。例如，可以使用图像纹理的数组索引来检索像素值。</li>
<li>第四步。再使用值变换函数（value transform function）对检索结果进行值变换，最后使用得到的新值来改变表面属性，如材质或者着色法线等等。</li>
</ul>
<p>下图通过一个例子描述了上述过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095022930.png" alt="image-20220515095022930"></p>
<h4 id="1-1-投影函数"><a href="#1-1-投影函数" class="headerlink" title="1.1 投影函数"></a>1.1 投影函数</h4><p>作为纹理管线的第一步，<strong>投影函数的功能就是将空间中的三维点转化为纹理坐标，也就是获取表面的位置并将其投影到参数空间中。</strong></p>
<p>在常规情况下，投影函数通常在美术建模阶段使用，并将投影结果存储于顶点数据中。也就是说，在软件开发过程中，我们一般不会去用投影函数计算得到投影结果，而是直接使用在美术建模过程中，已经存储在模型顶点数据中的投影结果。</p>
<h4 id="1-2-映射函数"><a href="#1-2-映射函数" class="headerlink" title="1.2 映射函数"></a>1.2 映射函数</h4><p><strong>映射函数（The Corresponder Function）的作用是将参数空间坐标（parameter-space coordinates）转换为纹理空间位置（texture space locations）。</strong>我们知道图像会出现在物体表面的 (u,v) 位置上，且  uv 值的正常范围在 [0, 1) 范围内。超出这个值域的纹理，其显示方式便可以由映射函数（The Corresponder Function）来决定。</p>
<p>在  OpenGL 中，这类映射函数称为“封装模式（Warapping Mode）”，在 Direct3D 中，这类函数叫做“寻址模式（Texture Addressing Mode）”。最常见的映射函数有以下几种：</p>
<ul>
<li>重复寻址模式，wrap (DirectX)，repeat (OpenGL)。图像在表面上重复出现。</li>
<li>镜像寻址模式，mirror。图像在物体表面上不断重复，但每次重复时对图像进行镜像或者反转。</li>
<li>夹取寻址模式，clamp (DirectX)，clamp to edge (OpenGL)。夹取纹理寻址模式将纹理坐标夹取在 [0.0, 1.0] 之间，也就是说，在[0.0, 1.0] 之间就是把纹理复制一遍，然后对于 [0.0, 1.0] 之外的内容，将边缘的内容沿着 u 轴和 v 轴进行延伸。</li>
<li>边框颜色寻址模式，border (DirectX)，clamp to border (OpenGL)。边框颜色寻址模式就是在 [0.0, 1.0] 之间绘制纹理，然后 [0.0, 1.0] 之外的内容就用边框颜色填充。</li>
</ul>
<p>下图展示了上述四种寻址模式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515095836855.png" alt="image-20220515095836855"></p>
<p>另外，每个纹理轴可以使用不同的映射函数。例如在 u 轴使用重复寻址模式，在 v 轴使用取寻址模式。</p>
<h3 id="2-纹理缓存"><a href="#2-纹理缓存" class="headerlink" title="2 纹理缓存"></a>2 纹理缓存</h3><p>一个复杂的应用程序可能需要相当数量的纹理。快速纹理存储器的数量因系统而异，但你会发现它们永远不够用。于是有了各种各样的纹理缓存（texture caching）技术，但我们一直在上传纹理到内存的开销和纹理单次消耗的内存量之间寻求一个好的平衡点。比如，一个由纹理贴图的多边形对象，初始化在离相机很远的位置，程序也许会只加载 mipmap 中更小的子纹理，就可以很完美的完成这个对象的显示了。</p>
<p>一些基本的建议是——<strong>保持纹理在不需要放大再用的前提下尽可能小，并尝试基于多边形将纹理分组。</strong>即便所有纹理都一直存储在内存中，这种预防措施也可能会提高处理器的缓存性能。</p>
<p>常见的缓存策略有以下几种，许多都和操作系统中的缓存策略一致：</p>
<ul>
<li><strong>最近最少使用策略（Least Recently Used ,LRU）</strong>。LRU 是纹理缓存方案中常用的一种策略，其原理为：加载到图形加速器的内存中的每个纹理都被给出一个时间戳，记录最后一次访问以渲染图像的时间。当需要空间来加载新的纹理时，首先卸载最旧时间戳的纹理。一些 API 还允许为每个纹理设置一个优先级：如果两个纹理的时间戳相同，则优先级较低的纹理首先被卸载。 设置优先级可以帮助避免不必要的纹理交换。</li>
<li><strong>最近最常使用策略（Most Recently Used，MRU）</strong>。MRU 如其名称一样，总是替换掉使用的最少的纹理缓存。鉴于如果在当前帧中载入纹理，会发生抖动（Thrashing）的情况。所谓抖动就是纹理数据集远大于缓存空间，这样就会出现频繁替换纹理缓存的现象，就称为抖动。这时，LRU 策略是一种非常不好的策略，因为在每帧画面中会对每张纹理图像进行交换。在这种情况下，可以采用 MRU 策略，直到在画面中没有纹理交换时为止，再然后切换回 LRU。</li>
<li><strong>预取策略（Prefetching）</strong>。加载纹理花费显着的时间，特别是在需将纹理转换为硬件原生格式时。 纹理加载在每个框架可以有很大的不同。在单个帧中加载大量纹理使得难以保持恒定的帧速率。一种解决方案是使用预取（prefetching），在将来需要预期的情况下，预计未来的需求然后加载纹理，将加载过程分摊在多帧中。</li>
<li><strong>裁剪图策略（Clipmap）</strong>。对于飞行模拟和地型模拟系统，图像数据集可能会非常巨大。传统的方法是将这些图像分解成更小的硬件可以处理的瓦片地图（tiles）。Tanner 等人提出了一种一种称为裁剪图（clipmap）的改进数据结构。其思想是，将整个数据集视为一个 mipmap，但是对于任何特定视图，只需要 mipmap 的较低级别的一小部分即可。支持  DirectX 10 的  GPU 就能够实现 clipmap 技术。</li>
</ul>
<h3 id="3-纹理压缩"><a href="#3-纹理压缩" class="headerlink" title="3 纹理压缩"></a>3 纹理压缩</h3><p>直接解决内存和带宽问题和缓存问题的一个解决方案是固定速率纹理压缩（Fixed-rate Texture Compression）。通过硬件解码压缩纹理，纹理可以需要更少的纹理内存，从而增加有效的高速缓存大小。至少这样的纹理使用起来更高效，因为他们在访问时消耗更少的内存带宽。</p>
<p>纹理压缩算法种类繁多，但基本的共同点是：把纹理按 4x4 个单元（纹素）大小划分为块。每个块对应一张四色查找表，表中存有两个标准 RGB565 格式表示的 16 位颜色，另外使用标准插入算法在插入两个新的颜色值，由此构成四色查找表。4x4 大小的纹理块中每个单元（像素点）用两个 bit 表示，每一个都代表四色查找表中的一种颜色。<strong>可以看出，实质上是利用每个单元（像素点）中的两个 bit 来索引四色查找表中的颜色值。</strong></p>
<p>这些压缩技术可以应用于立方体或体积图，以及二维纹理。<strong>而其主要缺点是它们是有损的压缩。</strong> 也就是说，原始图像通常不能从压缩版本检索。 仅使用四个或八个内插值来表示 16 个像素。 如果一个瓦片贴图有更大的数值，相较压缩前就会有一些损失。 在实践中，如果正常使用这些压缩方案，一般需给出可接受的图像保真度。</p>
<h3 id="4-体纹理"><a href="#4-体纹理" class="headerlink" title="4 体纹理"></a>4 体纹理</h3><p>体纹理（volume texture），也称为三维纹理（3D texture），是传统二维纹理（2D texture）在逻辑上的扩展。二维纹理是一张简单的位图图片，用于为三维模型提供表面点的颜色值；而<strong>一个三维纹理，可以被认为由很多张 2D 纹理组成，用于描述三维空间数据的图片。</strong>三维纹理通过三维纹理坐标进行访问。</p>
<p>虽然体纹理具有更高的储存要求，并且滤波成本更高，但它们具有一些独特的优势：</p>
<ul>
<li>使用体纹理，可以跳过为三维网格确定良好二维参数的复杂过程，因为三维位置可以直接用作纹理坐标，从而避免了二维参数化中通常会发生的变形和接缝问题。</li>
<li>体纹理也可用于表示诸如木材或大理石的材料的体积结构。使用三维纹理实现出的这些模型，看起来会很逼真，浑然天成。</li>
</ul>
<p>体纹理的缺点也很明显：</p>
<ul>
<li>使用体纹理作为表面纹理会非常低效，因为三维纹理中的绝大多数样本都没起到作用。</li>
</ul>
<h3 id="5-立方体贴图"><a href="#5-立方体贴图" class="headerlink" title="5 立方体贴图"></a>5 立方体贴图</h3><p>立方体贴图（cube map）也称立方体纹理（cube texture），是一种特殊的纹理技术，它用 6 幅二维纹理图像构成一个以原点为中心的纹理立方体，这每个 2D 纹理是一个立方体（cube）的一个面。对于每个片段，<strong>纹理坐标 (s, t, r) 被当作方向向量看待，每个纹素(texel)都表示从原点所看到的纹理立方体上的图像。</strong></p>
<p>下图以两种方式展示了立方体贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100701571.png" alt="image-20220515100701571"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515100722640.png" alt="image-20220515100722640"></p>
<p><strong>可以使用三分量纹理坐标向量来访问立方体贴图中的数据，该矢量指定了从立方体中心向外指向的光线的方向。</strong>选择具有最大绝对值的纹理坐标对应的相应的面。例如给定矢量（-3.2, 5.1, -8.4），选择绝对值最大的 -8.4 所在的 -Z 面，然后将其他两维除以最大的绝对值，就映射到了（-1, 1），然后再映射到（0, 1）范围就可以在 -Z 面上得到一个纹理坐标了。</p>
<h3 id="6-程序纹理"><a href="#6-程序纹理" class="headerlink" title="6 程序纹理"></a>6 程序纹理</h3><p>给定纹理空间位置，进行图像查找是生成纹理值的一种方法。另一种方法是对函数进行求值，从而得到一个程序贴图纹理（procedural texture）。</p>
<p>程序贴图纹理也称为过程纹理，是用计算机算法生成的，旨在创建用于纹理映射的自然元素（例如木材，大理石，花岗岩，金属，石头等）的真实表面或三维物体而创建的纹理图像。通常，会使用分形噪声（fractal noise）和湍流扰动函数（turbulence functions）这类“随机性”的函数来生成程序贴图纹理。</p>
<p>程序纹理通常用于离线渲染应用程序，而图像纹理在实时渲染中更为常见。这是由于在现代 GPU 中的图像纹理硬件有着极高效率，其可以在一秒钟内执行数十亿个纹理访问。然而，GPU 架构正在朝着更便宜的计算能力和（相对）更昂贵的存储器访问而发展。这将使程序纹理在实时应用程序中更常见，尽管它们不可能完全替代图像纹理。</p>
<p>关于程序纹理中常见的噪声，之后有专门的文章总结。</p>
<h3 id="7-凹凸贴图及其改进"><a href="#7-凹凸贴图及其改进" class="headerlink" title="7 凹凸贴图及其改进"></a>7 凹凸贴图及其改进</h3><p>与凹凸贴图相关的改进技术包括：位移贴图、法线贴图、视差贴图、浮雕贴图等，除了位移贴图方法以外，其他的几种改进一般都是通过修改每像素着色方程来实现，关键思想是访问纹理来修改表面的法线，而不是改变光照方程中的颜色分量。物体表面的几何法线保持不变，我们修改的只是着色方程中使用的法线值。他们比单独的纹理有更好的三维感官，但是显然还是比不上实际的三维几何体。下面将分别说明这几种方法。</p>
<h4 id="7-1-凹凸贴图"><a href="#7-1-凹凸贴图" class="headerlink" title="7.1 凹凸贴图"></a>7.1 凹凸贴图</h4><p><strong>凹凸贴图是通过改变表面光照方程的法线，而不是表面的几何法线，或对每个待渲染的像素在计算照明之前都要加上一个从高度图中找到的扰动，来模拟凹凸不平的视觉特征</strong>，如褶皱、波浪等等。<br>Blinn 于 1978 年提出了凹凸贴图方法。使用凹凸贴图，是为了给光滑的平面，在不增加顶点的情况下，增加一些凹凸的变化。他的原理是通过法向量的变化，来产生光影的变化，从而产生凹凸感。<strong>实际上并没有几何顶点上的变化。</strong>所以下图中球体边缘还是光滑的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515104558734.png" alt="image-20220515104558734"></p>
<h4 id="7-2-位移贴图"><a href="#7-2-位移贴图" class="headerlink" title="7.2 位移贴图"></a>7.2 位移贴图</h4><p>移位贴图（Displacement Mapping）也有人称为置换贴图，或称高度纹理贴图（Heightfield Texturing）。这种方法类似于法线贴图，<strong>移位贴图的每一个纹素中存储了一个向量，这个向量代表了对应顶点的位移。</strong>注意，此处的纹素并不是与像素一一对应，而是与顶点一一对应，因此，纹理的纹素个数与网格的顶点个数是相等的。在 Vertex Shader 阶段，获取每个顶点对应的纹素中的位移向量，施加到局部坐标系下的顶点上，然后进行世界视点投影变换即可。<strong>位移贴图真正改变了顶点位置。</strong></p>
<h4 id="7-3-法线贴图"><a href="#7-3-法线贴图" class="headerlink" title="7.3 法线贴图"></a>7.3 法线贴图</h4><p>法线贴图（Normal mapping）是凸凹贴图（Bump mapping）技术的一种应用。简单来说，<strong>Normal Map 直接将正确的 Normal 值保存到一张纹理中去，那么在使用的时候直接从贴图中取即可。</strong>为了使法线贴图能应用于不同的物体，所以法线贴图中存储的法线值一般是表面顶点切线空间下的法线值，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，相比于存储模型空间下的法线值，切线空间下的法线值是一个相对值，可以应用到不同的模型上而不至于出错。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105351266.png" alt="image-20220515105351266"></p>
<p>上图展示了基于法线贴图的凹凸映射，左侧为法线贴图，每个颜色通道实际上是表面法线坐标。红色通道是 x 偏差; 红色越多，正常点越多。 绿色是 y 偏差，蓝色是 z。 右边是使用法线贴图生成的图像。 请注意立方体顶部的扁平外观，<strong>法线贴图显然没有改变几何形状。</strong></p>
<h4 id="7-4-视差贴图"><a href="#7-4-视差贴图" class="headerlink" title="7.4 视差贴图"></a>7.4 视差贴图</h4><p>视差贴图（Parallax Mapping），又称为 Offset Mapping，或 virtual displacement mapping，视差贴图是一种改进的 Bump Mappin 技术，相较于普通的凹凸贴图，视差贴图技术得到凹凸效果得会更具真实感（如石墙的纹理将有更明显的深度）。<strong>视差贴图是通过替换渲染多边形上的顶点处的纹理坐标来实现的</strong>，而这个替换依赖于一个关于切线空间中的视角（相对于表面法线的角度）和在该点上的高度图的方程。简单来说，Parallax Mapping 利用  Height Map 进行了近似的  Texture Offset。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515105943878.png" alt="image-20220515105943878"></p>
<h4 id="7-5-浮雕贴图"><a href="#7-5-浮雕贴图" class="headerlink" title="7.5 浮雕贴图"></a>7.5 浮雕贴图</h4><p>浮雕贴图（Relief Mapping），有人把它誉为凹凸贴图的极致。我们知道，Parallax Mapping 是针对  Normal Mapping 的改进，利用  HeightMap 进行了近似的 Texture Offset。而 Relief Mapping 是精确的 Texture Offset，所以在表现力上比较完美。</p>
<p>Parallax Mapping 能够提供比 Bump Mapping 更多的深度，尤其相比于小视角下，但是如果想提供更深的深度，Parallax Mapping 就无能为力了，Relief Mapping 则可以很好的胜任。相较于 Parallax Mapping，浮雕贴图可以实现更深的凹凸深度，并且还可以做出自阴影和闭塞效果。当然算法也稍稍有点复杂，具体细节可以参考这篇中文文献：<a href="https://www.ixueshu.com/document/3dc4369a761ca0d6318947a18e7f9386.html">Relief mapping：凹凸贴图的极致</a>，而如果要用一句话概括  Relief Mapping，将会是：“在 Shader 里做光线追踪”。</p>
<p>下图是法线贴图和浮雕贴图的对比，浮雕贴图可以实现自阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110338598.png" alt="image-20220515110338598"></p>
<p>下图是视差贴图和浮雕贴图的对比，浮雕贴图可以实现更深的凹凸深度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/15/20220515-RTR-%E7%BA%B9%E7%90%86%E6%80%BB%E7%BB%93/image-20220515110121700.png" alt="image-20220515110121700"></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】延迟渲染总结</title>
    <url>/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中延迟渲染相关知识进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>延迟渲染的概念、G-buffer、延迟渲染的过程</li>
<li>延迟渲染 vs 正向渲染、延迟渲染 vs Z-Prepass</li>
<li>延迟渲染的优缺点、延迟渲染透明物体、延迟渲染与 MSAA</li>
<li>延迟渲染的改进：延迟光照（Light Pre-Pass &#x2F; Deferred Lighting）、分块延迟渲染（Tile-Based Deferred Rendering）</li>
<li>延迟渲染 vs 延迟光照</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-延迟渲染（Deferred-Rendering）"><a href="#1-延迟渲染（Deferred-Rendering）" class="headerlink" title="1 延迟渲染（Deferred Rendering）"></a>1 延迟渲染（Deferred Rendering）</h3><p>在计算机图形学中，延迟渲染（Deferred Rendering），又称延迟着色（Deferred Shading），是将着色计算延迟到深度测试之后进行处理的一种渲染方法。<strong>延迟渲染技术的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给我们渲染拥有大量光源的场景提供了很多可能性。</strong></p>
<p>我们知道，正向渲染（Forward Rendering），或称正向着色（Forward Shading），是渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。</p>
<p>传统的正向渲染思路是，先进行着色，再进行深度测试。其主要缺点就是光照计算跟场景复杂度和光源个数有很大关系。假设有 n 个物体，m 个光源，且每个每个物体受所有光源的影响，那么复杂度就是 O(m*n)。</p>
<p>正向渲染简单直接，也很容易实现，但是同时它对程序性能的影响也很大，因为对每一个需要渲染的物体，程序都要对每个光源下每一个需要渲染的片元进行迭代，如果旧的片元完全被一些新的片元覆盖，最终无需显示出来，那么其着色计算花费的时间就完全浪费掉了。</p>
<p>而延迟渲染的提出，就是为了解决上述问题而诞生（尤其是在场景中存在大量光源的情况下）。延迟渲染给我们优化拥有大量光源的场景提供了很多可能性，因为它能够在渲染拥有成百上千光源的场景的同时还能够保持能让人接受的帧率。下面这张图展示了一个基于延迟着色渲染出的场景，这个场景中包含了 1000 个点光源，对于目前的硬件设备而言，用传统的正向渲染来实现将是极其耗时的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516150601199.png" alt="image-20220516150601199"></p>
<p><strong>可以将延迟渲染理解为先将所有物体都绘制到屏幕空间的缓冲（即  G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元的着色而产⽣的不必要的开销。</strong>也就是说延迟渲染基本思想是，先执行深度测试，再进行着色计算，将本来在物空间（三维空间）进行的光照计算放到了像空间（二维空间）处理。相较于正向渲染 O(m*n) 的复杂度，经典的延迟渲染复杂度为 O(n+m)。</p>
<h3 id="2-几何缓冲区（G-buffer）"><a href="#2-几何缓冲区（G-buffer）" class="headerlink" title="2 几何缓冲区（G-buffer）"></a>2 几何缓冲区（G-buffer）</h3><p>G-Buffer，全称 Geometric Buffer，几何缓冲区。它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用的材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。下图展示了一个典型的 G-Buffer 布局：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151041625.png" alt="image-20220516151041625"></p>
<p>下图是一帧中 G-Buffer 中存储的部分内容可视化结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151116425.png" alt="image-20220516151116425"></p>
<p>G-Buffer 是一个宏观的概念，并不是一整个缓冲区，而是由多个缓冲区共同组成，或者由多张纹理共同组成，比如后文会提到的 MRT，就是将不同的信息渲染到多个纹理，这些纹理被称为渲染目标（Render Targte，RT），这些 RT 共同组成了 G-Buffer。</p>
<h3 id="3-延迟渲染的过程"><a href="#3-延迟渲染的过程" class="headerlink" title="3 延迟渲染的过程"></a>3 延迟渲染的过程</h3><p>可以将延迟渲染理解为两个 Pass 的过程：</p>
<p>1、<strong>几何处理阶段（Geometry Pass）</strong>。这个阶段中，我们获取对象的各种几何信息，并将第二步（也就是渲染）所需的各种数据储存到多个渲染目标中；</p>
<p>2、<strong>光照处理阶段（Lighting Pass）</strong>。在这个 pass 中，我们只需渲染出一个屏幕大小的二维矩形，使用第一步在 G-buffer 中存储的数据对此矩阵的每一个片元计算场景的光照；光照计算的过程还是和正向渲染一样，只是现在我们需要从对应的 G-buffer 而不是顶点着色器（和一些 uniform 变量）那里获取输入变量了。</p>
<p>下图展示了延迟渲染的过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516151507237.png" alt="image-20220516151507237"></p>
<p>延迟渲染方法一个很大的好处就是能保证在 G-buffer 中的片元和在屏幕上呈现的像素所包含的片元信息是一样的，因为深度测试已经最终将这里的片元信息作为最顶层的片元。这样保证了对于在光照处理阶段中处理的每一个像素都只处理一次，所以我们能够省下很多无用的渲染调用。除此之外，延迟渲染还允许我们做更多的优化，从而渲染更多的光源。</p>
<p>在几何处理阶段中填充 G-buffer 非常高效，因为我们直接储存位置，颜色，法线等对象信息到帧缓冲中，这个过程几乎不消耗处理时间。</p>
<p>对于多个光源的情况，不同的光源对场景的影响不同，所以 G-Buffer 中存储的片元信息也可能不同，因此我们可以对每个光源创建一个屏幕空间包围矩形，然后用光照 shader 渲染这个矩形，最后融合起来即可。</p>
<p>而在此基础上使用多渲染目标（Multiple Render Targets, MRT）技术，我们可以在一个 Pass 之内完成所有渲染工作。渲染目标就是指纹理，也就是将渲染结果存到纹理中而不是输出到屏幕上，之后再用这些纹理进行各种后处理，在 Unity Shader 部分中我们早就已经这样做过了，这也是极其常见的做法。多渲染目标就是指将各种信息（位置、法线、反射率等）分别存入一张纹理中，然后结合多张纹理的信息进行着色计算，实际上和 G-Buffer 的效果一样，也可以说这些纹理组成了 G-Buffer，而且存入纹理中的信息还可以反复使用，用来实现各种更高级的效果。</p>
<h3 id="4-延迟渲染-vs-正向渲染"><a href="#4-延迟渲染-vs-正向渲染" class="headerlink" title="4 延迟渲染 vs 正向渲染"></a>4 延迟渲染 vs 正向渲染</h3><p>这是一个经常被问起的话题，因此这里对二者的特性做一个总结。</p>
<h4 id="4-1-正向渲染"><a href="#4-1-正向渲染" class="headerlink" title="4.1 正向渲染"></a>4.1 正向渲染</h4><ul>
<li>正向渲染（Forward Rendering），先执行着色计算，再执行深度测试</li>
<li>正向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n*m)</li>
<li>正向渲染中光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景</li>
<li>Forward Rendering 的核心伪代码可以表示为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each light:</span><br><span class="line">	For each object affected by the light: </span><br><span class="line">		framebuffer += object * light</span><br></pre></td></tr></table></figure>

<ul>
<li>Forward Rendering 的管线流程如下图所示：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516152551865.png" alt="image-20220516152551865"></p>
<h4 id="4-2-延迟渲染"><a href="#4-2-延迟渲染" class="headerlink" title="4.2 延迟渲染"></a>4.2 延迟渲染</h4><ul>
<li>延迟渲染（Deferred Rendering），先执行深度测试，再执行着色计算</li>
<li>延迟渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O(n+m)</li>
<li>Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化</li>
<li>Deferred Rendering 的核心伪代码可以表示如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each object:</span><br><span class="line">    Render to multiple render targets </span><br><span class="line">For each light:</span><br><span class="line">    Apply light as a 2D postprocess</span><br></pre></td></tr></table></figure>

<ul>
<li>Deferred Rendering 的管线流程如图所示：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516152925120.png" alt="image-20220516152925120"></p>
<h4 id="4-3-延迟渲染-vs-Z-Prepass"><a href="#4-3-延迟渲染-vs-Z-Prepass" class="headerlink" title="4.3 延迟渲染 vs Z-Prepass"></a>4.3 延迟渲染 vs Z-Prepass</h4><p>延迟渲染和之前学过的 Early-Z 非常相似，二者的区别可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/">【Real-Time Rendering】模板测试和深度测试</a>的最后部分。</p>
<h3 id="5-延迟渲染的优缺点"><a href="#5-延迟渲染的优缺点" class="headerlink" title="5 延迟渲染的优缺点"></a>5 延迟渲染的优缺点</h3><p>总结一下延迟渲染的优缺点。</p>
<h4 id="5-1-延迟渲染的优点"><a href="#5-1-延迟渲染的优点" class="headerlink" title="5.1 延迟渲染的优点"></a>5.1 延迟渲染的优点</h4><ul>
<li>Deferred Rendering 最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化</li>
<li>复杂度仅 O(n+m)</li>
<li>只渲染可见的像素，节省计算量</li>
<li>用更少的 shader</li>
<li>对后处理支持良好</li>
<li>在大量光源的场景优势尤其明显</li>
</ul>
<h4 id="5-2-延迟渲染的缺点"><a href="#5-2-延迟渲染的缺点" class="headerlink" title="5.2 延迟渲染的缺点"></a>5.2 延迟渲染的缺点</h4><ul>
<li>内存开销大</li>
<li>读写 G-buffer 的内存带宽用量是性能瓶颈</li>
<li>对透明物体的渲染存在问题，在这点上需要结合正向渲染。后面细说。</li>
<li>对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好。后面细说。</li>
</ul>
<h3 id="6-延迟渲染透明物体"><a href="#6-延迟渲染透明物体" class="headerlink" title="6 延迟渲染透明物体"></a>6 延迟渲染透明物体</h3><p>延迟渲染要渲染透明物体需要与前向渲染结合。首先，我们需要明确一个问题，为什么延迟渲染不适用于透明物体？</p>
<p>因为延迟渲染只计算了离视野最近的物体像素，并对其进行光照计算和着色。因此，这会导致：</p>
<ul>
<li>透明物体和不透明物体重叠，且透明物体在后时，仅渲染不透明物体，效果正确</li>
<li>透明物体和不透明物体重叠，且透明物体在前时，仅渲染透明物体，效果错误，看不到透明物体后面的物体</li>
<li>透明物体之间重叠时，仅渲染最前面的透明物体，效果错误</li>
</ul>
<p>解决以上问题一个常见的思路是：<strong>使用延迟渲染的框架，分别渲染不透明物体，透明物体背面，透明物体正面，再把三者按照 alpha 合并。</strong></p>
<p>在这种情况下，我们可以基本保证第二种情况的正确；而对于第三种情况，由于延迟渲染仅对离相机最近的像素进行光照&#x2F;着色计算，我们依然只能计算（特别地，若最近的像素透明度为0，我们忽略这一像素）最近的透明物体的光照。<strong>对于这种情况，采取的解决方案是写入 G-Buffer 时仅混合物体颜色，在延迟渲染过程中，依然只计算最近物体的光照，但把混合后的颜色作为最近物体的基本颜色进行光照计算。</strong></p>
<h3 id="7-延迟渲染与-MSAA"><a href="#7-延迟渲染与-MSAA" class="headerlink" title="7 延迟渲染与 MSAA"></a>7 延迟渲染与 MSAA</h3><p>为什么延迟渲染中不支持 MSAA？这又是一个经常被问起的话题，延迟渲染不支持 MSAA 的说法实际上并不准确，准确的说是延迟渲染对 MSAA 的支持并不好，或者说在延迟渲染中做 MSAA 不方便。</p>
<p>首先来回顾 MSAA 的原理，MSAA 是在 SSAA 的基础上发展来的硬件抗锯齿技术。SSAA 是理论上效果最好的抗锯齿方案，以 4x 为例（下同），4xSSAA 对于每个像素计算 4 个子像素，将 4 个子像素的颜色求平均值，便能获得抗锯齿后的颜色。实际上 SSAA 等于暴力渲染了 4 倍分辨率的图像，在目前的硬件条件下这种性能开销是不可接受的，因此在 SSAA 的基础上发展出了 MSAA。</p>
<p>MSAA 与 SSAA 的区别在于像素着色器（Pixel Shader）的运行次数。MSAA 同样对于每个像素进行了 4 次子采样（Sample），但是只在像素中心位置运行一次像素着色，然后根据有多少 Sample 被三角形覆盖而对颜色进行一个加权处理，也就是像素中有多少子像素被三角形覆盖，就用该像素的颜色乘以被覆盖的子像素的比例，相比于 SSAA 每个子像素单独计算颜色，效率大幅提升。</p>
<p>下面以一个例子来看 MSAA 的具体过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516161128767.png" alt="image-20220516161128767"></p>
<p>在前向渲染中，三角形的绘制是依次进行的。绘制蓝色三角形时，MSAA 的具体执行步骤如下：</p>
<ol>
<li>光栅化阶段，对四个 X 位置的 Sample 执行三角形覆盖判断，在一个四倍分辨率大小的 coverage mask 中记录每个 Sample 被覆盖的情况；</li>
<li>像素着色阶段，在像素中心圆点处执行像素着色器。该点的位置、深度、法线、纹理坐标等信息由三角形三个顶点重心插值得到。图中计算得到像素颜色为紫色；</li>
<li>对四个 Sample 执行模板测试与深度测试，并将测试通过的 Sample 数据写入四倍分辨率的模板缓冲与深度缓冲。每个 Sample 都拥有自己的深度值，依然是重心插值得到；</li>
<li>上图中左下两个 Sample 通过了深度测试，并且 coverage mask 为 1，因此将紫色复制到这两个 Sample 对应的颜色缓冲中（依然是每个 Sample 一个颜色，颜色缓冲也需要四倍大小）。其他两个 Sample 暂为背景色；</li>
<li>重复上述流程绘制第二个黄色三角形，将像素着色获得的黄色复制到右上角的 Sample 中；</li>
<li>所有绘制结束之后，通过一个对高层透明的 pass，将四个 Sample 的颜色混合获得最终输出的像素颜色。</li>
</ol>
<p>可以看到在 MSAA 流程中所使用的所有缓冲区都变成了原来的四倍大小，这也是为什么 MSAA 增加了非常多的显存和带宽消耗。上述流程中第 4 步如果改成对每个 Sample 单独进行像素着色，MSAA 就变成了 SSAA。</p>
<p>理通了 MSAA 的具体流程，接下来回答问什么延迟渲染不好做 MSAA：</p>
<p>延迟渲染的光照计算阶段使用的输入是 G-Buffer，如果还像前向渲染一样，在光照计算以后执行 MSAA，会得到错误的结果。具体来说，使用单倍 G-Buffer 来进行计算，会因为得不到三角形的覆盖信息而无法判定应该将该像素的颜色值复制到哪几个子 Sample 上，也不会出现同一个像素的子 Sample 会被不同面片覆盖的情况，因为 G-Buffer 就是一张图，已经不知道该点被几个三角形覆盖了。而使用多倍大小的 G-Buffer 的话，又无法通过顶点插值获取中心处原始像素的位置、深度、法线、纹理坐标等数据，因为原始三个顶点的信息已经没有了。更重要的是，在多倍大小的 G-Buffer 上我们是没办法判断哪几个子 Sample 是与中心像素在同一三角形上的，如果试图使用四个子 Sample 的数据插值获得中心像素，对深度和法线进行插值会导致意料之外的后果。上面两个原因综合起来，就是“丢失的其他像素信息导致无法使用 MSAA” 这种说法的来源了。</p>
<p><strong>总结起来，延迟渲染对 MSAA 支持不友好的原因在于：</strong></p>
<ul>
<li>MSAA 本质上是一种发生在光栅化阶段的技术，也就是几何阶段后，着色阶段前，用这个技术需要用到场景中的几何信息</li>
<li>延迟渲染因为需要节省光照计算的原因，事先把所有信息都放在了 G-Buffer 上，着色计算的时候已经丢失了几何信息</li>
</ul>
<p>如果要在延迟渲染中使用 MSAA，需要将 G 缓存的 MRT 以多重采样的形式保存使得每个样本的信息不被丢失从而可以进行解析操作。而如果直接对 G 缓存中的属性比如法线和深度进行解析的话则可能产生错误结果，比如说如果一个给定像素中的样本在 G 缓存中有着不同的深度值，那么取均值后的结果可能和场景真实的几何信息无关，法线同理。正确的做法是对每个样本进行光照计算后再解析，对每个样本的光照结果取均值。因此需要保证像素着色器逐样本执行然后将每个样本输出写入多重采样RT。如下图所示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516162715482.png" alt="image-20220516162715482"></p>
<p>事实上，从 DirectX 10 开始就已经允许在高达 8 个 MRT 的情况下使用 MSAA 了。</p>
<h3 id="8-延迟渲染的改进"><a href="#8-延迟渲染的改进" class="headerlink" title="8 延迟渲染的改进"></a>8 延迟渲染的改进</h3><p>上文提到过，延迟渲染的性能瓶颈在于读写 G-buffer 的内存带宽，因此延迟渲染的改进也主要是从这方面入手，下面简单介绍一些降低延迟渲染存取带宽的改进方案。最简单也是最容易想到的就是将存取的 G-Buffer 数据结构最小化，这也就衍生出了 Light Pre-Pass，即延迟光照（Deferred Lighting）方法。另一种方式是将多个光照组成一组，然后一起处理，这种方法衍生出了分块延迟渲染（Tile-Based Deferred Rendering）。</p>
<h4 id="8-1-延迟光照"><a href="#8-1-延迟光照" class="headerlink" title="8.1 延迟光照"></a>8.1 延迟光照</h4><p>Light Pre-Pass 即 Deferred Lighting（延迟光照），旨在减少传统 Defferred Rendering 使用 G-buffer 时占用的过多开销，延迟光照的具体的思路是：</p>
<ol>
<li>渲染场景中不透明（opaque ）的几何体。将法线向量 n 和镜面扩展因子（specular spread factor）m 写入缓冲区。这个 n&#x2F;m-buffer 缓冲区是一个类似 G-Buffer 的缓冲区，但包含的信息更少，更轻量，可以用单个输出颜色缓冲区存储，因此不需要 MRT 支持。</li>
<li>渲染光照。计算漫反射和镜面着色方程，并将结果写入不同的漫反射和镜面反射累积缓冲区。这个过程可以在一个单独的 pass 中完成（使用 MRT），或者用两个单独的 pass。环境光照明可以在这个阶段使用一个 full-screen pass 进行计算。</li>
<li>对场景中的不透明几何体进行第二次渲染。从纹理中读取漫反射和镜面反射值，对前面步骤中漫反射和镜面反射累积缓冲区的值进行调制，并将最终结果写入最终的颜色缓冲区。若在上一阶段没有处理环境光照明，则在此阶段应用环境光照明。</li>
<li>使用非延迟渲染方法渲染半透明几何体。</li>
</ol>
<p>总结来说相当于把每个像素的光照计算结果也存入纹理中，最后着色时对光照结果进行调制或者后处理。相对于传统的 Deferred Render，使用 Light Pre-Pass 可以对每个不同的几何体使用不同的 shader 进行渲染，所以每个物体的 material properties 将有更多变化。</p>
<p>传统的 Deferred Render 的第二步是遍历每个光源，这样就增加了光源设置的灵活性，而 Light Pre-Pass 第三步使用的其实是 forward rendering，所以可以对每个 mesh 设置其材质，这两者是相辅相成的，有利有弊。</p>
<p>另一个 Light Pre-Pass 的优点是在使用 MSAA 上很有利。虽然并不是完全使用上了 MSAA（除非使用 DX10 以上的特性），但是由于使用了 Z 值和 Normal 值，就可以很容易找到边缘，并进行采样。</p>
<h4 id="8-2-分块延迟渲染"><a href="#8-2-分块延迟渲染" class="headerlink" title="8.2 分块延迟渲染"></a>8.2 分块延迟渲染</h4><p>作为传统 Defferred Rendering 的另一种主要改进，分块延迟渲染（Tile-Based Deferred Rendering，TBDR）旨在合理分摊开销。实验数据表明 TBDR 在大量光源存在的情况下明显优于上述的 Light Pre-Pass。</p>
<p>我们知道，延迟渲染的瓶颈在于读写 G-buffer，在大量光源下，具体的瓶颈将会在于每个光源对 G-buffer 的读取及与颜色缓冲区混合。这里的问题是，每个光源，即使它们的影响范围在屏幕空间上有重叠，因为每个光源是在不同的绘制中进行，所以会重复读取 G-buffer 中相同位置的数据，计算后以相加混合方式写入颜色缓冲。光源越多，内存带宽用量越大。</p>
<p>而分块延迟渲染的主要思想则是把屏幕分拆成细小的栅格，例如每 32 × 32 像素作为一个分块（tile），然后计算每个分块会受到哪些光源影响，把那些光源的索引储存在分块的光源列表里。最后，逐个分块进行着色，对每个像素读取 G-buffer 和光源列表及相关的光源信息。因此，G-buffer 的数据只会被读取 1 次且仅 1 次，写入 color buffer 也是 1 次且仅 1 次，大幅降低内存带宽用量。不过，这种方法需要计算光源会影响哪些分块，这个计算又称为光源剔除（light culling），可以在 CPU 或 GPU（通常以 compute shader 实现）中进行。用 GPU 计算的好处是，GPU 计算这类工作比 CPU 更快，也可以减少 CPU 和 GPU 之间的数据传输。此外，还可以计算每个分块的深度范围（depth range），作更有效的剔除。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516164106531.png" alt="image-20220516164106531"></p>
<p>总结来说，分块延迟渲染将屏幕分成一个个小块 tile 并计算每个分块的深度范围。然后根据深度范围和分块大小，可以求得每个 tile 的 bounding volume。对每个 tile 的 bounding volume 和光源进行求交点，这样就得到了对该 tile 有作用的光源的序列。最后根据得到的序列计算所在 tile 的光照效果。整个过程如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/1617944-20190906002505353-1795972401.png" alt="1617944-20190906002505353-1795972401"></p>
<p>对比传统 Deferred Rendering，之前是对每个光源求其作用区域 light volume，然后决定其作用的 pixel，也就是说每个光源要求取一次。而使用 TBDR，只要遍历每个 pixel，让其所属 tile 与光线求交，来计算作用其上的光源，并利用 G-Buffer 进行着色。这样做一方面减少了所需考虑的光源个数，另一方面与传统的 Deferred Rendering 相比减少了存取的带宽。因此分块渲染现在广泛应用于移动设备渲染中。</p>
<h3 id="9-延迟渲染-vs-延迟光照"><a href="#9-延迟渲染-vs-延迟光照" class="headerlink" title="9 延迟渲染 vs 延迟光照"></a>9 延迟渲染 vs 延迟光照</h3><p>关于延迟着色和延迟光照，经常会被弄混，这里简单区分一下。</p>
<ul>
<li>延迟渲染需要更大的 G-Buffer 来完成对 Deferred 阶段的前期准备，而且一般需要硬件有 MRT 的支持，可以说是硬件要求更高。</li>
<li>延迟光照需要两个几何体元的绘制过程来完成整个渲染操作：G-Pass 与 Shading pass。这个既是劣势也是优势：由于延迟渲染中的 Deffered 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作；而延迟光照却可以在 Shading 阶段得到物体的材质信息进而使这一问题的处理变得较简单。</li>
<li>两种方法的上述操作均是只能完成对不透明物体的渲染，而透明或半透明的物体则需额外的传统 Pass 来完成。</li>
</ul>
<p>延迟渲染的流程图如下，根据 G-Buffer 中的信息直接计算光照和着色：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516165141752.png" alt="image-20220516165141752"></p>
<p>延迟光照的流程图如下，提前计算光照并存入纹理，在着色时直接对纹理采样得到光照结果，不再计算光照，只进行其他后处理，从这个流程上来说，Light Pre-Pass 这个名称更为合适：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/16/20220516-RTR-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93/image-20220516165158816.png" alt="image-20220516165158816"></p>
<p><strong>无论是正向渲染，延迟渲染、延迟光照、分块延迟渲染，都属于不同的渲染路径（Rendering Path）。</strong></p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】基于图像的渲染技术总结</title>
    <url>/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中基于图像的渲染技术进行概括总结和扩展。以综述形式为主，许多内容已经实现过或学习过，其他概念只需了解即可，主要内容包括：</p>
<ul>
<li>谱渲染 The Rendering Spectrum</li>
<li>固定视角的渲染 Fixed-View Rendering</li>
<li>天空盒 Skyboxes</li>
<li>光场渲染 Light Field Rendering</li>
<li>精灵与层 Sprites and Layers</li>
<li>公告板 Billboarding</li>
<li>粒子系统 Particle System</li>
<li>颜色校正 Color Correction</li>
<li>色调映射 Tone Mapping</li>
<li>镜头眩光和泛光 Lens Flare and Bloom</li>
<li>景深 Depth of Field</li>
<li>运动模糊 Motion Blur</li>
<li>体渲染 Volume Rendering</li>
</ul>
<p><em><span id="more"></span></em></p>
<h3 id="1-谱渲染"><a href="#1-谱渲染" class="headerlink" title="1 谱渲染"></a>1 谱渲染</h3><p>众所周知，渲染的目的就是在屏幕上渲染出物体，至于如何达到结果，主要依赖于用户的选择，白猫黑猫，抓到老鼠的就是好猫。而用多边形将三维物体显示在屏幕上，并非是进行三维渲染的唯一方法，也并非是最合适的方法。多边形具有从任何视角以合理的方式表示对象的优点，当移动相机的时候，物体的表示可以保持不变。但是，当观察者靠近物体的时候，为了提高显示质量，往往希望用比较高的细节层次来表示模型。与之相反，当物体位于比较远的地方时，就可以用简化形式来表示模型。这就是细节层次技术 (Level Of Detail,LOD)。使用 LOD 技术主要目的是为了加快场景的渲染速度。还有很多技术可以用来表示物体逐渐远离观察者的情形，比如，可以用图像而不是多边形来表示物体，从而减少开销，加快渲染速度。另外，单张图片可以很快地被渲染到屏幕上，用来表示物体往往开销很小。</p>
<p>Lengyel 于 1998 在《The Convergence of Graphics and Vision》一文中提出了一种表示渲染技术连续性的方法，名为 The Rendering Spectrum  渲染谱，如下图所示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135741473.png" alt="image-20220518135741473"></p>
<p>下面是论文中更具体的图示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518135757327.png" alt="image-20220518135757327"></p>
<p>可以将渲染谱理解为渲染的金字塔。从左到右，由简单到复杂，由二维图像到几何模型，从外观特征到物理渲染。</p>
<h3 id="2-固定视角的渲染"><a href="#2-固定视角的渲染" class="headerlink" title="2 固定视角的渲染"></a>2 固定视角的渲染</h3><p>固定视角的渲染（Fixed-View Rendering）技术，通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量渲染时间与性能。<br>对于复杂的几何和着色模型，每帧去重新渲染整个场景很可能是昂贵的。可以通过限制观看者的移动能力来对渲染进行加速。 最严格的情况是相机固定在位置和方位，即根本不移动。而在这种情况下，很多渲染可以只需做一次。<br>例如，想象一个有栅栏的牧场作为静态场景，一匹马穿过它。牧场和栅栏渲染仅一次，存储其颜色和 Z 缓冲区。每帧将这些 buffer 复制到可显示的颜色和 Z 缓冲中。为了获得最终的渲染效果，马本身是需要渲染的。如果马在栅栏后面，存储和复制的 z 深度值将把马遮挡住。请注意，在这种情况下，马不能投下阴影，因为场景无法改变。可以进行进一步的处理，例如，可以确定出马影子的区域，根据需求进行处理。关键是对于要显示的图像的颜色何时或如何设置这点上，是没有限制的。固定视角的特效（Fixed-View Effects）可以通过将复杂几何模型转换为可以在多帧中重复使用的一组简单的 buffer 来节省大量时间。</p>
<h3 id="3-天空盒"><a href="#3-天空盒" class="headerlink" title="3 天空盒"></a>3 天空盒</h3><p>对于一些远离观众的物体，观众移动时几乎没有任何视差效果。换言之，如果你移动一米，甚至一千米，一座遥远的山本身看起来通常不会有明显的不同。当你移动时，它可能被附近的物体挡住视线，但是把那些物体移开，山本身看起来也依旧一样。天空盒就属于这种类型的物体。</p>
<p>环境贴图（environment map）可以代表本地空间入射光亮度。虽然环境贴图通常用于模拟反射，但它们也可以直接用来表示环绕环境的远处物体。任何独立于视图的环境地图表示都可以用于此目的；立方体贴图（cubic maps）是最为常见的一种环境贴图。环境贴图放置在围绕着观察者的网格上，并且足够大以包含场景中所有的对象。且网格的形状并不重要，但通常是立方体贴图。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518140529046.png" alt="image-20220518140529046"></p>
<h3 id="4-光场渲染"><a href="#4-光场渲染" class="headerlink" title="4 光场渲染"></a>4 光场渲染</h3><p>所谓光场（Light Field），可以理解为空间中任意点发出的任意方向的光的集合。而光场渲染（Light Field Rendering），可以理解为在不需要图像的深度信息或相关性的条件下，通过相机阵列或由一个相机按设计的路径移动，把场景拍摄下来作为输出图像集。对于任意给定的新视点，找出该视点邻近的几个采样点进行简单的重新采样和插值，就能得到该视点处的视图。</p>
<h3 id="5-精灵与层"><a href="#5-精灵与层" class="headerlink" title="5 精灵与层"></a>5 精灵与层</h3><p>最基本的基于图像的渲染的图元之一便是精灵（sprite）。精灵（sprite）是在屏幕上移动的图像，例如鼠标光标。精灵不必具有矩形形状，而且一些像素可以以透明形式呈现。对于简单的精灵，屏幕上会显示一个一对一的像素映射。存储在精灵中的每个像素将被放在屏幕上的像素中。可以通过显示一系列不同的精灵来生成动画。</p>
<p>更一般的精灵类型是将其渲染为应用于总是面向观看者的多边形的图像纹理。图像的 Alpha 通道可以为 sprite 的各种像素提供全部或部分透明度。这种类型的精灵可以有一个深度，所以在场景本身，可以顺利地改变大小和形状。一组精灵也可以用来表示来自不同视图的对象。对于大型物体，这种用精灵来替换的表现效果会相当弱，因为从一个精灵切换到另一个时，会很容易穿帮。也就是说，如果对象的方向和视图没有显着变化，则给定视图中的对象的图像表示可以对多个帧有效。而如果对象在屏幕上足够小，存储大量视图，即使是动画对象也是可行的策略。</p>
<p>考虑场景的一种方法是将其看作一系列的层（layers），而这种思想也通常用于二维单元动画。每个精灵层具有与之相关联的深度。通过这种从前到后的渲染顺序，我们可以渲染出整个场景而无需 Z 缓冲区，从而节省时间和资源。</p>
<h3 id="6-公告板"><a href="#6-公告板" class="headerlink" title="6 公告板"></a>6 公告板</h3><p>我们将根据观察方向来确定多边形面朝方向的技术叫做公告板（Billboarding）。而随着观察角度的变化，公告板多边形的方向也会根据需求随之改变。与 alpha 纹理和动画技术相结合，可以用公告板技术表示许多不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，能量盾（Energy Shields），水蒸气痕迹，以及云朵等。比如下图的树：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141422780.png" alt="image-20220518141422780"></p>
<p>给定表面的法线向量 n 和近似向上方向的向量 u，通过创建一组由三个相互垂直的向量，就可以确定公告板的方向。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518141522323.png" alt="image-20220518141522323"></p>
<p>其中，左图是互相垂直的 u 和 n。中图是 r 向量通过 u 和 n 的叉乘得到，因此同时垂直于 u 和 n，而在右图中，对固定向量 n 和 r 进行叉乘就可以得到与他们都垂直的的向上向量  u’。</p>
<p>有三种不同类型的 Billboard，分别是：</p>
<ul>
<li><strong>Screen-Aligned Billboard  对齐于屏幕的公告板</strong>：这里的 n 是镜头视平面法线的逆方向，u 是镜头的 up 方向</li>
<li><strong>World-Oriented Billboard  面向世界的公告板</strong>：不能直接使用镜头的 up 做 up，因为镜头旋转了，并且所画的 billboard 原本是应该相对世界站立的，按 Screen-Aligned 的做法就会随镜头旋转，所以此时应该 r &#x3D; u * n(u 是其在世界上的 up，n 是镜头视线方向的逆方向)，最后再计算一次 u‘ &#x3D; r * n，即 u’ 才是最后的 up，即非物体本身相对世界的 up，亦非镜头的 up。</li>
<li><strong>Axial Billboard  轴向公告板</strong></li>
</ul>
<p>所以公告板技术是一种看似简单其实较为复杂的技术,它的实现变种较多。归其根本在于：</p>
<ul>
<li>View Oriented &#x2F; View plane oriented 的不同</li>
<li>Sphere&#x2F; Axial 的不同</li>
<li>Camera up &#x2F; World up 的不同</li>
</ul>
<p>如 View Oriented 和 View plane oriented 的不同，得到的公告板效果就完全不同：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142041015.png" alt="image-20220518142041015"></p>
<p>下图是使用公告板技术渲染的云层：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142105766.png" alt="image-20220518142105766"></p>
<p>另外还有一种特殊的公告板技术：替代物（Impostors），替代物是通过从当前视点将一个复杂物绘制到一幅图像纹理上来创建的，其中的图像纹理用于映射到公告板上，渲染过程与替代物在屏幕上覆盖的像素点数成正比，而不是与顶点数或者物体的复杂程度成正比。替代物可以用于物体的一些实例上或者渲染过程的多帧上，从而使整体性能获得提升。</p>
<p>使用 Imposters 的一个问题是渲染的图像必须持续地面向观察者。如果远处的物体正在改变方向，则必须重新计算 Imposters 的朝向。而为了模拟更像他们所代表的三角形网格的远处物体，D´ecoret 等人提出了公告板云（Billboard Clouds）的想法，即一个复杂的模型通常可以通过一系列的公告板集合相互交叉重叠进行表示。我们知道，一个真实物体可以用一个纸模型进行模拟，而公告板云可以比纸模型更令人信服，比如公告板云可以添加一些额外的信息，如法线贴图、位移贴图和不同的表面材质。另外，裂纹沿裂纹面上的投影也可以由公告板进行处理。而  D´ecoret 等人也提出了一种在给定误差容限内对给定模型进行自动查找和拟合平面的方法。</p>
<h3 id="7-粒子系统"><a href="#7-粒子系统" class="headerlink" title="7 粒子系统"></a>7 粒子系统</h3><p>粒子系统（Particle System）是一组分散的微小物体集合，其中这些微小物体按照某种算法运动。粒子系统的实际运用包括模拟火焰，烟，爆炸，流水，树木，瀑布，泡沫，旋转星系和其他的一些自然现象。粒子系统并不是一种渲染形式，而是一种动画方法，这种方法的思想是在粒子的生命周期内控制他们的产生，运动，变化和消失。</p>
<p>除了爆炸，瀑布，泡沫以及其他现象以外，还可以使用粒子系统进行渲染。例如，可以使用粒子系统来创建树木模型，也就是表示树木的几何形状，当视点距离模型较近时，就会产生更多的粒子来生成逼真的视觉效果。下图是用粒子系统渲染的树木：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518142415857.png" alt="image-20220518142415857"></p>
<h3 id="8-图像处理"><a href="#8-图像处理" class="headerlink" title="8 图像处理"></a>8 图像处理</h3><p>图像处理的过程，一般在像素着色器中进行，因为在像素着色器中，可以很好地将渲染过程和纹理结合起来，而且在 GPU 上跑像素着色器，速度和性能都可以满足一般所需。<br>一般而言，首先需要将场景渲染成 2D 纹理或者其他图像的形式，再进行图像处理，这里的图像处理，往往指的是后处理（post effects）。而下文将介绍到的颜色校正（Color Correction）、色调映射（Tone Mapping）、镜头眩光和泛光（Lens Flare and Bloom）、景深（Depth of Field）、运动模糊（Motion Blur），一般而言都是后处理效果。</p>
<h3 id="9-颜色校正"><a href="#9-颜色校正" class="headerlink" title="9 颜色校正"></a>9 颜色校正</h3><p>色彩校正(Color correction)是使用一些规则来转化给定的现有图像的每像素颜色到其他颜色的一个过程。颜色校正有很多目的，例如模仿特定类型的电影胶片的色调，在元素之间提供一致的外观，或描绘一种特定的情绪或风格。一般而言，通过颜色校正，游戏画面会获得更好的表现效果。</p>
<p>颜色校正通常包括将单个像素的 RGB 值作为输入，并向其应用算法来生成一个新的 RGB。颜色校正的另一个用途是加速视频解码，如 YUV 色彩空间到 RGB 色彩空间的转换。基于屏幕位置或相邻像素的更复杂的功能也可行，但是大多数操作都是使用每像素的颜色作为唯一的输入。</p>
<p>对于一个计算量很少的简单转换，如亮度的调整，可以直接在像素着色器程序中基于一些公式进行计算，应用于填充屏幕的矩形。而对于复杂的计算函数，一个通常使用的方法是使用查找表（Look-Up Table，LUT）。由于从内存中提取数值经常要比复杂的计算速度快很多，所以使用查找表进行颜色校正操作，速度提升是很显著的。</p>
<h3 id="10-色调映射"><a href="#10-色调映射" class="headerlink" title="10 色调映射"></a>10 色调映射</h3><p>计算机屏幕具有特定的亮度范围，而真实图像具有更巨大的亮度范围。色调映射（Tonemapping），也称为色调复制（tone reproduction），便是将宽范围的照明级别拟合到屏幕有限色域内的过程。色调映射与表示高动态范围的  HDR 和  HDRI 密切相关：</p>
<ul>
<li>HDR，是 High-Dynamic Range（高动态范围）的缩写</li>
<li>HDRI 是 High-Dynamic Range Image 的缩写，即 HDR 图像，高动态范围图像</li>
<li>实际过程中，HDR 和 HDRI 两者经常会被混用，都当做高动态范围成像的概念使用，这也是被大众广泛接受的</li>
</ul>
<p>本质上来讲，色调映射要解决的问题是进行大幅度的对比度衰减以将场景亮度变换到可以显示的范围，同时要保持图像细节与颜色等表现原始场景的重要信息。</p>
<p>根据应用的不同，色调映射的目标可以有不同的表述。在有些场合，生成“好看”的图像是主要目的，而在其它一些场合可能会强调生成尽可能多的细节或者最大的图像对比度。在实际的渲染应用中可能是要在真实场景与显示图像中达到匹配，尽管显示设备可能并不能够显示整个的亮度范围。</p>
<p>简单来说，整个 Tone Mapping 的过程就是首先要根据当前的场景推算出场景的平均亮度，再根据这个平均亮度选取一个合适的亮度域，再将整个场景映射到这个亮度域得到正确的结果。</p>
<p>具体关于色调映射算法可以查看：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_37363005/article/details/103593541">Tone Mapping—色调映射算法</a></li>
<li><a href="https://blog.csdn.net/qq_21842097/article/details/121035017">色调映射（Tone Mapping）</a></li>
</ul>
<h3 id="11-镜头眩光和泛光"><a href="#11-镜头眩光和泛光" class="headerlink" title="11 镜头眩光和泛光"></a>11 镜头眩光和泛光</h3><p>镜头眩光（Lens flare）是由于眼睛的晶状体或者相机的透镜直接面对强光所产生的一种现象，由一圈光晕（halo）和纤毛状的光环（ciliary corona）组成。光晕的出现是因为透镜物质（如三棱镜）对不同波长光线折射数量的不过而造成的，看上去很像是光周围的一个圆环，外圈是红色，内圈是紫红色。纤毛状的光环源于透镜的密度波动，看起来像是从一个点发射出来的光线。Lens flare 是近来较为流行的一种图像效果，自从我们认识到它是一种实现真实感效果的技术后，计算机便开始模拟此效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143849029.png" alt="image-20220518143849029"></p>
<p>泛光（Bloom）效果，是由于眼睛晶状体和其他部分的散光而产生，在光源附近出现的一种辉光。在现实世界中，透镜无法完美聚焦是泛光效果的物理成因；理想透镜也会在成像时由于衍射而产生一种名为艾里斑的光斑。在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/">【Unity Shader】（七）基础屏幕特效</a>中实现过 Bloom 效果。<br>常见的一个误解便是将 HDR 和 Bloom 效果混为一谈。Bloom 可以模拟出 HDR 的效果，但是原理上和 HDR 相差甚远。HDR 实际上是通过映射技术，来达到整体调整全局亮度属性的，这种调整是颜色，强度等都可以进行调整，而 Bloom 仅仅是能够将光照范围调高达到过饱和，也就是让亮的地方更亮。不过 Bloom 效果实现起来简单，性能消耗也小，却也可以达到不错的效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518143939832.png" alt="image-20220518143939832"></p>
<h3 id="12-景深"><a href="#12-景深" class="headerlink" title="12 景深"></a>12 景深</h3><p>在光学领域，特别是摄影摄像领域，景深（Depth of field，DOF），也叫焦点范围（focus range）或有效焦距范围（effective focus），是指场景中最近和最远的物体之间出现的可接受的清晰图像的距离。换言之，景深是指相机对焦点前后相对清晰的成像范围。在相机聚焦完成后，在焦点前后的范围内都能形成清晰的像，这一前一后的距离范围，便叫做景深。</p>
<p>景深通常由物距、镜头焦距，以及镜头的光圈值所决定（相对于焦距的光圈大小）。除了在近距离时，一般来说景深是由物体的放大率以及透镜的光圈值决定。固定光圈值时，增加放大率，不论是更靠近拍摄物或是使用长焦距的镜头，都会减少景深的距离；减少放大率时，则会增加景深。如果固定放大率时，增加光圈值（缩小光圈）则会增加景深；减小光圈值（增大光圈）则会减少景深。</p>
<p>在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/16/20220416-RayTracer-%E6%94%B9%E8%BF%9B%E7%9B%B8%E6%9C%BA/">【RayTracer】（七）景深效果</a>中有代码实现。</p>
<h3 id="13-运动模糊"><a href="#13-运动模糊" class="headerlink" title="13 运动模糊"></a>13 运动模糊</h3><p>实现运动模糊的方法大致分  3 种：</p>
<ul>
<li>直接渲染模糊本身。通过在对象移动之前和之后添加几何体来完成，并通过次序无关的透明，避免 Alpha 混合，在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/17/20220417-RayTracer-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A/">【RayTracer】（九）运动模糊</a>中的实现就是使用的这种方法。</li>
<li>基于累积缓冲区（accumulationbuffer），通过平均一系列图像来创建模糊。</li>
<li>基于速度缓冲器（velocity buffer）。目前这个方法最为主流。创建此缓冲区，需插入模型三角形中每个顶点的屏幕空间速度。通过将两个建模矩阵应用于模型来计算速度，一个用于最后一帧，一个用于当前模型。顶点着色器程序计算位置的差异，并将该向量转换为相对的屏幕空间坐标。</li>
</ul>
<p>运动模糊对于由摄像机运动而变得模糊的静态物体来说比较简单，因为往往这种情况下不需要速度缓冲区。如果需要的是摄像机移动时的运动感，可以使用诸如径向模糊（radial blur）之类的固定效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518144557566.png" alt="image-20220518144557566"></p>
<h3 id="14-体渲染"><a href="#14-体渲染" class="headerlink" title="14 体渲染"></a>14 体渲染</h3><p>体渲染（Volume Rendering），又称立体渲染，体绘制，是一种用于显示离散三维采样数据集的二维投影的技术。体渲染技术中的渲染数据一般用体素（Volumeric Pixel，或  Voxel）来表示，每个体素表示一个规则空间体。例如，要生成人头部的医学诊断图像（如 CT 或 MRI），同时生成 256 x256 个体素的数据集合，每个位置拥有一个或者多个值，则可以将其看做三维图像。因此，体渲染也是基于图像的渲染技术中的一种。</p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Real-Time Rendering】渲染加速技术总结</title>
    <url>/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇对《Real-Time Rendering》一书中的渲染加速技术进行概括总结和扩展。主要内容包括：</p>
<ul>
<li>空间管理（BVH、BSP 树、八叉树、场景图）</li>
<li>裁剪技术（背面裁剪、视锥裁剪、遮挡剔除、层次视锥裁剪、入口裁剪、细节裁剪）</li>
<li>层次细节技术（LOD）</li>
<li>点渲染</li>
</ul>
<p><em><span id="more"></span></em></p>
<h2 id="1-空间管理"><a href="#1-空间管理" class="headerlink" title="1 空间管理"></a>1 空间管理</h2><p>空间数据结构（Spatial Data Structures）是将几何体组织在 N 维空间中的一系列数据结构，而且我们可以很容易地将二维和三维的一些概念扩展到高维之中。这些空间数据结构可以用于很多实时渲染相关操作的加速查询中，如场景管理，裁减算法、相交测试、光线追踪、以及碰撞检测等。</p>
<p>空间数据结构的组织通常是层次结构的。宽泛地说，即最顶层包含它之下的层次，后者又包含更下层的层次，以此类推。因此，这种结构具有嵌套和递归的特点。用层次结构的实现方式对访问速度的提升很有帮助，复杂度可以从 O(n) 提升到 O(log n)。但同时，使用了层次结构的大多数空间数据结构的构造开销都比较大，虽然也可以在实时过程中进行渐进更新，但是通常需要作为一个预处理的过程来完成。</p>
<p>一些常见的空间数据结构包括：</p>
<ul>
<li>层次包围盒（Bounding Volume Hierachy，BVH）</li>
<li>二元空间分割树（Binary Space Partitioning，BSP）</li>
<li>四叉树（QuadTree）</li>
<li>kd 树（k-dimensional tree）</li>
<li>八叉树（Octree）</li>
<li>场景图（Scene Graphs）</li>
</ul>
<p>其中，BSP 树和八叉树都是基于空间细分（Space Subdivision）的数据结构，这说明它们是对整个场景空间进行细分并编码到数据结构中的。例如，所有叶子节点的空间集合等同于整个场景空间，而且叶子节点不相互重叠。</p>
<p>层次包围盒不是空间细分结构，是对物体进行细分的结构，它仅将几何物体周围的空间包围起来，所以包围层次不需要包围所有的空间，但包围盒之间可以重叠。</p>
<p>而场景图是一种比较高层次的，相较渲染性能更关注模型关系的数据结构。</p>
<h3 id="1-1-层次包围盒-BVH"><a href="#1-1-层次包围盒-BVH" class="headerlink" title="1.1 层次包围盒 BVH"></a>1.1 层次包围盒 BVH</h3><p>对于三维场景的实时渲染来说，层次包围体（Bounding Volume Hierarchy，BVH）是最常使用的一种空间数据结构。例如，层次包围体经常用于层次视锥裁减。使用 BVH 的场景以层次树结构进行组织，包含一个根节点（root）、一些中间节点（internal nodes），以及一些叶子节点（leaves）。顶部的节点是根，其无父节点。叶子节点（leaf node）包含需渲染的实际几何体，且其没有子节点。</p>
<p>相比之下，中间节点包含指向它子节点的指针。因此，只要根节点不是这颗树唯一的一个节点，那么它就是一个内部节点。树中的每一个节点，包括叶子节点，都有一个包围体可以将其子树中的所有几何体包围起来，这就是包围体层次的命名来源，同时，也说明了根节点有一个包含整个场景的包围体。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154315059.png" alt="image-20220518154315059"></p>
<p>关于 BVH 的理论详述可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/17/20220317-Whitted%E9%A3%8E%E6%A0%BC%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/">【计算机图形学】（十一）Whitted 风格光线追踪</a>中的“交点计算加速”部分。而 BVH 的代码实现可以在<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/18/20220418-RayTracer-%E5%AE%9E%E7%8E%B0BVH/">【RayTracer】（十）实现 BVH</a>中查看。</p>
<h3 id="1-2-BSP-树"><a href="#1-2-BSP-树" class="headerlink" title="1.2 BSP 树"></a>1.2 BSP 树</h3><p>BSP 树（二叉空间分割树，全称 Binary Space Partitioning Tree）是一种常用于判别对象可见性的空间数据结构。类似于画家算法，BSP 树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。</p>
<p>其中，BSP 是 Binary SpacePartitioning（二叉空间划分法）的缩写。这种方法递归地将空间使用超平面划分为凸面体集合。而这种子划分引出了借助于称之为 BSP 树的树形数据结构的场景表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518154653690.png" alt="image-20220518154653690"></p>
<p>BSP 树是一棵二叉树，每个节点表示一个有向超平面，其将当前空间划分为前向（front）和背向（back）两个子空间，分别对应当前节点的左子树和右子树。BSP 树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。而 BVH 与之不同，因为 BVH 通常不包含任何形式的排序。</p>
<h4 id="1-2-1-BSP-树的构建"><a href="#1-2-1-BSP-树的构建" class="headerlink" title="1.2.1 BSP 树的构建"></a>1.2.1 BSP 树的构建</h4><ul>
<li>从空树开始，每次选择一个面片作为节点插入树中</li>
<li>每次插入一个新节点，从树的根节点开始遍历<ul>
<li>如果新节点面片与当前结点片面相交，将新面片分割成两个面片</li>
<li>新节点在当前节点前向空间，插入左子树</li>
<li>新节点在当前节点背向空间，插入右子树</li>
<li>当前节点为空，直接插入新节点</li>
</ul>
</li>
<li>直到所有面片都被插入树中</li>
</ul>
<p>简单来说，若要创建 BSP 树，需递归将一个平面空间一分为二，并将几何体归类到这两个空间中来完成。</p>
<h4 id="1-2-2-BSP-树的遍历"><a href="#1-2-2-BSP-树的遍历" class="headerlink" title="1.2.2 BSP 树的遍历"></a>1.2.2 BSP 树的遍历</h4><p>从根节点开始，判断输入位置与当前分割平面的“前”、“后”关系，“前”则遍历左子树，“后”则遍历右子树，递归到叶子节点终止。</p>
<p>用平面方程 <code>Ax + By + Cz + D = 0</code> 判断前后位置，可用<code>D(x0, y0, z0) = Ax0 + By0 + Cz0 + D</code>  进行判别，其中：</p>
<ul>
<li>D &gt; 0：在平面前面</li>
<li>D &#x3D; 0：在平面上</li>
<li>D &lt; 0：在平面后面</li>
</ul>
<h4 id="1-2-3-BSP-树的种类"><a href="#1-2-3-BSP-树的种类" class="headerlink" title="1.2.3 BSP 树的种类"></a>1.2.3 BSP 树的种类</h4><p>在计算机图形学中，BSP 树有两大类别，分别是为轴对齐（Axis-Aligned）BSP 树和多边形对齐（Polygon-Aligned）BSP 树。下面分别进行介绍。</p>
<h4 id="1-2-4-轴对齐-BSP-树"><a href="#1-2-4-轴对齐-BSP-树" class="headerlink" title="1.2.4 轴对齐 BSP 树"></a>1.2.4 轴对齐 BSP 树</h4><p>轴对齐 BSP 树可以按如下方式来创建。首先，将整个场景包围在一个 AABB（轴对齐包围盒，Axis-Aligned Bounding Box）中，然后以递归的方式将这个包围盒分为若干个更小的盒子。</p>
<p>现在，考虑一下任何递归层次的盒子。选取盒子的一个轴，生成一个与之垂直的平面，将盒子一分为二。有一些方法可以将这个分割平面固定，从而将这个盒子分为完全相同的两部分，而也有其他的一些方法，允许这个平面在位置上有一些变化。与分割平面相交的物体，要么存储在这个层次上，成为两个子集中的一员，要么被这个平面分割为两个不同的物体。</p>
<p>经过这个过程，每个子集就处于一个比较小的盒子中，重复这个平面分割的过程，就可以对每个 AABB 进行递归细分，直到满足某个标准才终止这个分割过程。而这个标准，通常是用户定义的树最大深度，或者是盒子里面所包含的几何图元数量，需低于用户定义的某个值。</p>
<p>分割平面的轴线和位置对提高效率至关重要。一种分割包围盒的方法就是轴进行循环。即在根节点，沿着 x 轴对盒子进行分割，然后再沿着 y 轴对其子盒子进行分割，最后沿 z 轴对其孙盒子进行分割。这样，就完成了一个循环周期。<strong>使用这种分割策略的 BSP 树常被称为 k-d 树。</strong>而另一种常见策略是找到盒子的最长边，沿着这条边的方向对盒子进行分割。</p>
<p>下图显示了一个 BSP 树的分割过程，可以直观理解上述过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155441829.png" alt="image-20220518155441829"></p>
<p>值得一提的是，从前到后的粗排序（Rough Front-to-Back Sorting）是轴对齐 BSP 树的一种应用示例，这种方法对于遮挡剔除算法非常有用。而在视点的另一侧进行遍历，可以得到从后向前的粗排序（Rough Fack-to-Gront Sorting）,这对于透明排序非常有用。且还可以用来测试射线和场景几何体相交的问题，只需将视点位置换为射线原点即可，另外还可以用于视锥裁剪。</p>
<h4 id="1-2-5-多边形对齐-BSP-树"><a href="#1-2-5-多边形对齐-BSP-树" class="headerlink" title="1.2.5 多边形对齐 BSP 树"></a>1.2.5 多边形对齐 BSP 树</h4><p>多边形对齐 BSP 树（Polygon-aligned BSP tree）是 BSP 树的另一大类型，其中将多边形作为分隔物，对空间进行平分。也就是说，在根节点处，选取一个多边形，用这个多边形所在平面将场景中剩余多边形分为两组。对于与分割平面相交的多边形来说，沿着其中的交线将这个多边形分为两部分。然后，在分割平面的每个半空间中，选取另外一个多边形作为分隔物，只对这个分隔物所在平面的多边形进行继续分割，直到所有的多边形都在 BSP 树中为止。下图是一个多边形对齐 BSP 树的示意图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518155804963.png" alt="image-20220518155804963"></p>
<p>需要注意，多边形对齐 BSP 树的创建是一个非常耗时的过程，这些树通常只需计算一次，可以存储起来进行重用。另外，因为完全不平衡树的效率非常低，所以多边形对齐 BSP 树分割时最好是形成平衡树，即每个叶子节点的深度相同或者相差一个层次的树。</p>
<p>多边形对齐 BSP 树的一个典型性质就是对于一个给定的视点来说，可以对该结构按照从后往前（或者从前往后）的顺序进行严格遍历，而轴对齐的 BSP 通常只能给出粗略的排序顺序。所以，基于多边形对齐 BSP 树的此性质，建立了严格的前后顺序，可以配合画家算法来绘制整个场景，而无需 Z 缓冲。多边形对齐 BSP 树的其他应用也包括相交测试和碰撞检测等。</p>
<h3 id="1-3-八叉树"><a href="#1-3-八叉树" class="headerlink" title="1.3 八叉树"></a>1.3 八叉树</h3><h4 id="1-3-1-普通八叉树"><a href="#1-3-1-普通八叉树" class="headerlink" title="1.3.1 普通八叉树"></a>1.3.1 普通八叉树</h4><p>八叉树（octree），或称八元树，是一种用于描述三维空间的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<p>简单来说，八叉树的空间划分方式很简单，即递归地进行规整地 1 分为 8 的操作。如下图，把一个立方体分割为八个同样大小的小立方体，然后递归地分割出更的小立方体。这个就是八叉树的命名来源。这种分割方式可以得到比较规则的结构，从而使得查询变得高效。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160027641.png" alt="image-20220518160027641"></p>
<p>相似地，四叉树是把一个二维的正方形空间分割成四个小正方形。而八叉树是四叉树的三维空间推广。</p>
<h4 id="1-3-2-松散八叉树"><a href="#1-3-2-松散八叉树" class="headerlink" title="1.3.2 松散八叉树"></a>1.3.2 松散八叉树</h4><p>松散八叉树（Loose Octrees）的基本思想和普通八叉树一样，但是每个长方体的大小选择比较宽松。如果一个普通长方体的边长为 a，那么可以用 ka 来代替，其中 k &gt; 1，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160218107.png" alt="image-20220518160218107"></p>
<p>上图是一个普通八叉树和松散八叉树的比较。图中黑色的原点表示长方形的中心点（第一次细分）。在左图中，星形物体刺穿了一个普通八叉树的一个分割平面。这时，一种选择就是将这个星型物体放在最大的长方形中（根节点的长方体）。而右图所示为一个 k&#x3D;1.5 的松散八叉树，也就是将细分的长方体放大了 50%，如果将这些长方体稍微移动，就可以保证区分出们。这样，这个星形多边形就完全位于左上角的长方形之中。</p>
<h3 id="1-4-场景图"><a href="#1-4-场景图" class="headerlink" title="1.4 场景图"></a>1.4 场景图</h3><p>BVH、BSP 树和八叉树都是使用某种形式的树来作为基本的数据结构，它们的具体区别在于各自是如何进行空间分割和几何体的存储，且他们均是以层次的形式来保存几何物体。然而三维场景的绘制不仅仅是几何体。对动画，可见性，以及其他元素的控制，往往需要通过场景图（Scene Graphs）来完成。</p>
<p>场景图被誉为“当今最优秀且最为可重用的数据结构之一“。Wiki 中对场景图的定义是：</p>
<blockquote>
<p>场景图（Scene Graph）是组织和管理三维虚拟场景的一种数据结构，是一个有向无环图（Directed Acyclic Graph， DAG）。</p>
</blockquote>
<p>场景图是一个面向用户的树结构，可以通过纹理、变换、细节层次、渲染状态（例如材质属性）、光源以及其他任何合适的内容进行扩充。它由一棵以深度优先遍历来渲染整个场景的树来表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518160821493.png" alt="image-20220518160821493"></p>
<p>开源的场景图有 Open Scene Graph 和 OpenSG 等。</p>
<h2 id="2-裁剪技术"><a href="#2-裁剪技术" class="headerlink" title="2 裁剪技术"></a>2 裁剪技术</h2><p>裁剪（Culling）的字面意思是“从大量事物中进行删除”。在计算机图形学中，相对应的就是裁剪技术（Culling Techniques）所要做的工作——“从大量游戏事物中进行删除”。所谓的“大量事物”就是需要绘制的整个场景，删除的是对最终图像没有贡献的场景部分，然后将剩余场景发送到渲染管线。因此，在渲染方面通常使用“可见性裁剪 (Visibility Culling)”这个术语。但其实，裁剪也可以用于程序的其他部分，如碰撞检测（对不可见物体进行不十分精确的计算）、物理学计算，以及人工智能（AI）领域。</p>
<p>与渲染相关的裁剪技术，常见的有：</p>
<ul>
<li><strong>背面裁剪（Backface Culling）</strong>：将背向视点的物体删除，是一种非常简单直观的操作，只能一次对一个单一多边形进行操作。</li>
<li><strong>视锥裁剪（View Frustum Culling）</strong>：将视锥之外的多边形删除，相对而言，这种操作比背面裁剪稍微复杂。</li>
<li><strong>遮挡剔除（Occlusion Culling）</strong>：将被其他物体遮挡的物体进行删除，这种操作在三者中最为复杂，因为其需要聚集一个或者多个物体，同时还需使用其他物体的位置信息。</li>
</ul>
<p>理论上，裁剪操作可以发生在渲染管线的任何一个阶段，而且对于一些遮挡裁剪算法来说，甚至可以预先计算出来。对于在硬件中实现的裁剪算法来说，有时只需启动&#x2F;禁止或者设置一些裁剪函数即可。而为了进行完全控制，我们可以在应用程序阶段在（CPU 上）实现一些裁剪算法。裁剪通常可以使用几何计算来实现，但也不局限于此。</p>
<p>下图展示了三种裁剪技术：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161245851.png" alt="image-20220518161245851"></p>
<h3 id="2-1-背面裁剪"><a href="#2-1-背面裁剪" class="headerlink" title="2.1 背面裁剪"></a>2.1 背面裁剪</h3><p>假设你正在观察一个场景中不透明的球体。大约有一半的球体是不可见的。那么，可以从中这个例子里得到一个众所周知的结论，那就是，对不可见的内容不需要进行渲染，因为它们对最终的渲染图像没有贡献。不需要对球体的背面进行处理，这就是背面裁剪的基本思想。对于一组物体来说，还可以一次性地进行背面裁剪，这也称为聚集背面裁剪（Clustered Backface Culling）。</p>
<p>背面裁剪有屏幕空间和观察空间两种方法，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161502669.png" alt="image-20220518161502669"></p>
<p>左图为屏幕空间背面裁剪，使用叉乘运算。根据右手定则可以判断出三角形和四边形是正面，七边形是背面，背面的多边形无需进行光栅化。</p>
<p>右图为观察空间背面裁剪，使用点乘运算。根据表面法线和视线夹角判断正面还是背面。</p>
<h3 id="2-2-层次视锥裁剪"><a href="#2-2-层次视锥裁剪" class="headerlink" title="2.2 层次视锥裁剪"></a>2.2 层次视锥裁剪</h3><p>众所周知，只需对完全或者部分在视锥中的图元进行渲染。一种加快渲染速度的方法便是将每个物体的包围体与视锥进行比较，如果包围体位于视锥之外，那么便不需要渲染包围体中的几何体。由于这些计算在 CPU 上进行，因此包围体中的几何体不需要通过管线中的几何和光栅阶段。相反，如果包围体在视锥内或者与视锥相交，那么包围体中的内容就是可见的，所以必须发送到渲染管线中去。</p>
<p>利用空间数据结构，可以分层地来应用这种裁剪。例如，对于层次包围盒 BVH 来说，从根节点进行前序遍历（Preorder Transversal），就可以完成这一任务。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518161828374.png" alt="image-20220518161828374"></p>
<p>视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围盒中，而且几乎所有包围盒都是以层次形式聚集在一起。</p>
<p>除了层次包围盒，其他的空间数据结构同样也可以用于视锥裁剪，包括上文提到的八叉树和 BSP 树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围盒。</p>
<h3 id="2-3-入口裁剪"><a href="#2-3-入口裁剪" class="headerlink" title="2.3 入口裁剪"></a>2.3 入口裁剪</h3><p>对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪（Protal Culling）。入口裁剪算法的基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪，只对穿过入口能看到的几体体进行渲染。当遍历入口的时候，就减小视锥，使得与入口尽可能紧密贴合。因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展，且需将位于视锥之外的入口丢弃。</p>
<p>入口裁剪方法以某种方式对场景进行预处理，可以是自动形式，也可以是手动形式，可以将场景分割为一系列单元（Cells），其通常对应于建筑物中的房间或者走廊；房间的门和窗口称为入口（Protals）。单元中的每个物体和单元的墙面可以存储在一个与单元关联的数据结构中，还可以将邻接单元和链接这些单元的入口信息保存在一个临接图中。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162241213.png" alt="image-20220518162241213"></p>
<h3 id="2-4-细节裁剪"><a href="#2-4-细节裁剪" class="headerlink" title="2.4 细节裁剪"></a>2.4 细节裁剪</h3><p>细节裁剪（Detail Culling）是一种通过牺牲质量换取速度的技术。其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。</p>
<p>考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪（Screen-Size Culling）。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。</p>
<p>细节裁剪还可以作为一种简化的 LOD 技术来实现，其中一个 LOD 是整个模型，另外一个 LOD 是空物体。</p>
<h3 id="2-5-遮挡剔除"><a href="#2-5-遮挡剔除" class="headerlink" title="2.5 遮挡剔除"></a>2.5 遮挡剔除</h3><p>可见性问题可以通过 Z 缓冲器的硬件构造来实现，即使可以使用 Z 缓冲器正确解决可见性问题，但其中 Z 缓冲并不是在所有方面都不是一个很“聪明”的机制。例如，假设视点正沿着一条直线观察，其中，在这条直线上有 10 个球体，虽然这 10 个球体进行了扫描转换，同时与 Z 缓冲器进行了比较并写入了颜色缓冲器和 Z 缓冲器，但是这个从这个视点渲染出的图像只会显示一个球体，即使所有 10 个球体都将被光栅化并与 Z 缓冲区进行比较，然后可能写入到颜色缓冲区与 Z 缓冲区。下图中间部分显示了在给定视点处场景的深度复杂度，深度复杂度指的是对每个像素重写的次数。对于有 10 个球体的情形，最中间的位置，深度复杂度为 10，因为在这个地方渲染了 10 个球体（假设背面裁剪是关闭的），而且这意味着其中有 9 次像素写入是完全没有必要的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162730519.png" alt="image-20220518162730519"></p>
<p>像上图这样无聊极端的场景，现实生活中很难找到，但其描述的这种密集性很高的模型的情形，在现实生活中却很常见，如热带雨林，发动机，城市，以及摩天大楼的内部。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162841447.png" alt="image-20220518162841447"></p>
<p>左图和中图为视锥裁剪后的图示，右图所示为遮挡剔除和视锥裁剪后的图示。</p>
<p>有两种主要形式的遮挡裁剪算法，分别是基于点的遮挡裁剪和基于单元的遮挡裁剪。如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518162926792.png" alt="image-20220518162926792"></p>
<p>左图所示为基于点的可见性，右图所示为基于单元的可见性，其中单元是一个长方形，从中可以看出，从视点左边看上去，有些圆被遮挡了，但是从右边看上去，这些圆却是可见的，因为可以从单元的某个位置到这些圆画一些射线，这些射线没有和任何遮挡物相交。</p>
<h4 id="2-5-1-硬件遮挡查询"><a href="#2-5-1-硬件遮挡查询" class="headerlink" title="2.5.1 硬件遮挡查询"></a>2.5.1 硬件遮挡查询</h4><p>现代  GPU 可以以一种特殊的渲染模式来支持遮挡剔除。通过硬件遮挡查询（Hardware Occlusion Queries），我们能够直接获得所提交的物体是否被绘制到场景中。<br>简单来说，硬件遮挡查询的基本思想是，当和 Z 缓冲器中内容进行比较时，用户可以通过查询硬件来找到一组多边形是否可见的，且这些多边形通常是复杂物体的包围体（如长方体）。如果其中没有多边形可见，那么便可将这个物体裁剪掉。硬件实现对查询的多边形进行光栅化，并且将其深度和 Z 缓冲器进行比较。</p>
<h4 id="2-5-2-层次-Z-缓冲"><a href="#2-5-2-层次-Z-缓冲" class="headerlink" title="2.5.2 层次  Z 缓冲"></a>2.5.2 层次  Z 缓冲</h4><p>层次 Z-缓冲算法（Hierarchical Z-Buffering，HZB）对遮挡剔除的研究有着显著的影响。尽管其在 CPU 上很少使用，但该算法是 GPU 上做 Z-Culling（深度裁剪）的基础。</p>
<p>层次  Z-缓冲算法用八叉树来维护场景模型，并将画面的 Z 缓冲器作为图像金字塔（也称为 Z-金字塔，Z-pyramid），该算法因此在图像空间中进行操作。其中，八叉树能够对场景的遮挡区域进行层次剔除，而  Z-金字塔则可以对单个基元和边界体积进行层次 Z 缓冲。因此  Z-金字塔可以作为此算法的遮挡表示。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163313731.png" alt="image-20220518163313731"></p>
<p>使用  HZB 算法的遮挡裁剪示例，显示了一个复杂的场景（右下），相应的  Z-pyramid（左图），以及八叉树细分（右上）。通过从前到后遍历八叉树并裁剪遇到的八叉树节点，此算法可以仅访问可见的八叉树节点及其子节点（右上角的节点），的容器只对可见包围体中的多边形进行渲染。在这个例子中，遮挡八叉树节点的裁剪可以将深度复杂度从 84 降低到了 2.5。</p>
<h2 id="3-层次细节技术"><a href="#3-层次细节技术" class="headerlink" title="3 层次细节技术"></a>3 层次细节技术</h2><p>细节层次（Level of Detail，LOD）的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。这是一个已经在各种游戏中广泛使用的基本优化技术。</p>
<p>例如，一个包含一百万个三角形的汽车，其中所包含的细节信息比较丰富。当视点靠近物体时，可以使用详细的细节表示，而当视点远离物体时，比如仅需覆盖 200 个像素，则完全无需渲染出一百万个三角形，相反，我可以使用诸如只有 1000 个三角形的简化模型。而由于距离的原因，简化后的模型与细节较丰富的模型看上去其实很接近。以这种方式，可以显著地提高渲染的性能开销。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518163650813.png" alt="image-20220518163650813"></p>
<p>通常情况下，雾效会与 LOD 一起使用。这样我们可以完全跳过对一些物体的渲染，直接用不透明的雾来进行遮挡。</p>
<p>一般情况下，完整的 LOD 算法包含 3 个主要部分：</p>
<ul>
<li><strong>生成 Generation</strong>：生成不同细节的模型表示，可以使用算法，也可以手工制作具有不同数量的三角形模型</li>
<li><strong>选择 Selection</strong>：基于某种准则选取一个层次细节模型，比如屏幕上的评估面积</li>
<li><strong>切换 Switching</strong>：从一个细节层次转换到另一个细节层次</li>
</ul>
<h3 id="3-1-LOD-的切换方法"><a href="#3-1-LOD-的切换方法" class="headerlink" title="3.1 LOD 的切换方法"></a>3.1 LOD 的切换方法</h3><p>当从一个 LOD 切换到另一个 LOD 的时候，忽然的模型替换往往会引起观察者的注意。这种现象被称为突越（Poping）。这里有几种不同的 LOD 切换方法，有着不同的特性。</p>
<h4 id="3-1-1-离散几何-LOD"><a href="#3-1-1-离散几何-LOD" class="headerlink" title="3.1.1 离散几何 LOD"></a>3.1.1 离散几何 LOD</h4><p>离散几何 LOD 是最简单的 LOD 算法，不同的表示是不同图元数量的同一模型，但这种方法突越现象严重。</p>
<h4 id="3-1-2-混合-LOD"><a href="#3-1-2-混合-LOD" class="headerlink" title="3.1.2 混合 LOD"></a>3.1.2 混合 LOD</h4><p>在概念上，完全可能存在一种直观的方法，从一个 LOD 切换到另一个 LOD，只需要在较短的时间内在两个 LOD 之间执行一个线性混合，这种方法无疑可以得到一种比较平滑的切换，但是这种混合操作的代价较高。渲染两个 LOD 要比一个 LOD 需要更大开销，因此也就违背了 LOD 的初衷。但 LOD 切换通常发生在较短时间内容，在同一时间也不是对场景中所有物体进行切换，所以依然可以从中获益。</p>
<h4 id="3-1-3-透明-LOD"><a href="#3-1-3-透明-LOD" class="headerlink" title="3.1.3 透明 LOD"></a>3.1.3 透明 LOD</h4><p>完全避免突越现象的一种简单方法便是使用 alpha LOD。其中并没有使用同一物体很多不同细节的实例，而且每个物体只有一个实例。随着 LOD 选取度量值（如与物体之间的距离）的增大，物体整体透明度也随之增大（也就是 alpha 值减小），当完全透明时，物体最终就会消失。这种方法的优点是，比离散几何 LOD 方法上感觉更连续一些，可以避免突跃现象。此外，由于物体最终会完全消失而不需要进行渲染，可以得到很好的加速效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164303220.png" alt="image-20220518164303220"></p>
<p>使用 Alpha LOD 对图中的圆锥体进行渲染，当距离圆锥体较远时，就提高它的透明度，直到最后消失。直线左边的图像是从同一距离处进行的观察，而直线右边的图像是左边图像不同尺寸的情形。</p>
<h4 id="3-1-4-连续-LOD-和几何形变-LOD"><a href="#3-1-4-连续-LOD-和几何形变-LOD" class="headerlink" title="3.1.4  连续 LOD 和几何形变 LOD"></a>3.1.4  连续 LOD 和几何形变 LOD</h4><p>连续细节层次（Continuous Level of Detail , CLOD）的基本思想是基于 LOD 选取值来精确决定可见多边形的数量。在 100m 远处，模型包含 1000 个多边形，当移动的到 101m 的地方时，模型减少到 998 个多边形。</p>
<p>几何形变层次细节（Geomorph LODs）是基于简化生成的一组离散模型，且其中模型顶点之间的链接关系保持不变。关于GLODs 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E5%87%A0%E4%BD%95/">【计算机图形学】（九）几何</a>中的表面简化方法。</p>
<h3 id="3-2-LOD-的选取方法"><a href="#3-2-LOD-的选取方法" class="headerlink" title="3.2 LOD 的选取方法"></a>3.2 LOD 的选取方法</h3><p>给定一个物体不同细节层次，必须做一个选择，决定渲染或者混合其中的哪一个层次，这就是 LOD 选择（LOD selection）的任务。有几种不同的 LOD 选择方案，这些方案也可以用于遮挡剔除算法。</p>
<h4 id="3-2-1-基于距离的-LOD-选取"><a href="#3-2-1-基于距离的-LOD-选取" class="headerlink" title="3.2.1 基于距离的 LOD 选取"></a>3.2.1 基于距离的 LOD 选取</h4><p>原理如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164744364.png" alt="image-20220518164744364"></p>
<h4 id="3-2-2-基于投影面积的-LOD-选取"><a href="#3-2-2-基于投影面积的-LOD-选取" class="headerlink" title="3.2.2 基于投影面积的 LOD 选取"></a>3.2.2 基于投影面积的 LOD 选取</h4><p>基于投影面积的 LOD 选取，顾名思义，即投影面积越大，就选取细节越丰富的 LOD。</p>
<h4 id="3-2-3-基于滞后的-LOD-选取"><a href="#3-2-3-基于滞后的-LOD-选取" class="headerlink" title="3.2.3 基于滞后的 LOD 选取"></a>3.2.3 基于滞后的 LOD 选取</h4><p>若用于确定 LOD 度量标准围绕某个值 ri 在画面之间是变化的，那么就会出现不必要的突跃现象，也就会在不同的 LOD 之间来回快速切换。对此，可以引入一个围绕 ri 值的滞后来解决这个问题。如下图，这是一个基于距离的 LOD，可以应用于任何类型，当 r 增大时，使用上一行的 LOD 距离；当 r 减小时，使用下面一行的 LOD 距离。  </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/18/20220518-RTR-%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9F%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/image-20220518164927013.png" alt="image-20220518164927013"></p>
<h2 id="4-点渲染"><a href="#4-点渲染" class="headerlink" title="4 点渲染"></a>4 点渲染</h2><p>点渲染的基本思想是用一个大的点集来表示物体表面并予以渲染。在随后的通道中，使用高斯滤波来填充渲染点之间的间隙。而高斯滤波器的半径取决于表面上点的密度和屏幕上的投影密度。知道有这种渲染方法即可，不必深究。</p>
]]></content>
      <categories>
        <category>Real-Time Rendering</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（二）框架搭建</title>
    <url>/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>上一节完成了环境配置和测试，这一节开始搭建一个渲染管线的框架，之后就都在此框架上加入各种功能和算法。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-统一管理全局变量"><a href="#1-统一管理全局变量" class="headerlink" title="1 统一管理全局变量"></a>1 统一管理全局变量</h3><p>首先我们使用一个头文件 <code>Global.h</code> 来统一管理我们用到的所有头文件、全局变量和类声明，为了之后使用方便：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GLOBEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image_write.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MVP变换矩阵</span></span><br><span class="line">glm::mat4 ModelMatrix;</span><br><span class="line">glm::mat4 ViewMatrix;</span><br><span class="line">glm::mat4 ProjectMatrix;</span><br><span class="line"><span class="comment">// 视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix;</span><br><span class="line"><span class="comment">// 法线变换矩阵</span></span><br><span class="line">glm::mat3 NormalMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14159265359</span>;</span><br><span class="line"><span class="comment">// 环境光</span></span><br><span class="line"><span class="type">const</span> glm::vec3 Ambient = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span>;</span><br><span class="line"><span class="comment">// 渲染管线类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span>;</span><br><span class="line"><span class="comment">// 材质类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Material</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平行光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionLight</span>;</span><br><span class="line"><span class="comment">// 聚光灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpotLight</span>;</span><br><span class="line"><span class="comment">// 点光源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointLight</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-FrameBuffer-类"><a href="#2-FrameBuffer-类" class="headerlink" title="2 FrameBuffer 类"></a>2 FrameBuffer 类</h3><p>和光线追踪器中一样，我们使用一个 unsigned char 数组来存放像素，但这次我们使用 RGBA 四个通道。为了保证整个代码结构清晰，我们封装一个 <code>FrameBuffer</code> 类来管理颜色缓冲，后续还可以加入深度缓冲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> Width, Height;</span><br><span class="line">	std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">	~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">		Width = w;</span><br><span class="line">		Height = h;</span><br><span class="line">		<span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">		colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重设缓冲区大小</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">		Width = w;</span><br><span class="line">		Height = h;</span><br><span class="line">		colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">			*(p + i) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">			*(p + i + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">			*(p + i + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">			*(p + i + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将颜色写入对应位置</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">		*(p + xy * <span class="number">4</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.r;</span><br><span class="line">		*(p + xy * <span class="number">4</span> + <span class="number">1</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.g;</span><br><span class="line">		*(p + xy * <span class="number">4</span> + <span class="number">2</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.b;</span><br><span class="line">		*(p + xy * <span class="number">4</span> + <span class="number">3</span>) = (<span class="type">unsigned</span> <span class="type">char</span>)color.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-管理顶点数据"><a href="#3-管理顶点数据" class="headerlink" title="3 管理顶点数据"></a>3 管理顶点数据</h3><p>顶点是我们光栅化渲染器的输入数据，所以理所应当用一个类来管理。一个顶点包含的数据有：模型坐标、顶点颜色、顶点法线、纹理坐标。注意位置坐标使用的是四维齐次坐标，在模型空间和世界空间的坐标都是 x, y, z 加上恒为 1 的 w，所以要用四维向量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 顶点Vertex类和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VERTEX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERTEX_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	glm::vec4 position;</span><br><span class="line">	glm::vec4 color;</span><br><span class="line">	glm::vec2 texcoord;</span><br><span class="line">	glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Vertex</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _pos,</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line">		<span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line">		<span class="type">const</span> glm::vec3&amp; _normal</span><br><span class="line">	) :</span><br><span class="line">		<span class="built_in">position</span>(_pos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(</span><br><span class="line">		<span class="type">const</span> glm::vec3&amp; _pos,</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="type">const</span> glm::vec2&amp; _tex = glm::<span class="built_in">vec2</span>(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="type">const</span> glm::vec3&amp; _normal = glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	) :</span><br><span class="line">		<span class="built_in">position</span>(_pos, <span class="number">1.0f</span>), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; v) :<span class="built_in">position</span>(v.position), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-渲染管线思路"><a href="#4-渲染管线思路" class="headerlink" title="4 渲染管线思路"></a>4 渲染管线思路</h3><p>输入输出都定义完了，接下来开始一步一步实现渲染管线。通常的 OpenGL 渲染管线流程如下：</p>
<ol>
<li>输入顶点数据和图元类型（点、直线、三角形等基本图元）</li>
<li>顶点着色器对顶点进行处理，将坐标变换到世界坐标，计算纹理坐标和顶点颜色等，输出到中间结构体（v2f）</li>
<li>对 v2f 进行图元装配过程，也就是为每个三角形指定顶点数据与索引</li>
<li>将顶点变换到摄像机的观察空间</li>
<li>进行投影，将顶点变换到裁剪空间</li>
<li>进行裁剪和面剔除工作，将看不见的图元进行裁剪，剔除背向面，减少后续计算量</li>
<li>执行齐次除法，将顶点变换到 NDC（标准设备坐标）</li>
<li>执行视口变换，最终将顶点转换到屏幕坐标（从三维变成二维）</li>
<li>光栅化，计算图形在屏幕上最终覆盖的像素点</li>
<li>用顶点数据插值，在像素点位置生成新的 v2f</li>
<li>逐像素运行片元着色器，进行纹理采样、光照计算等，输出该点最终颜色值（RGBA）</li>
<li>执行透明度测试-&gt;模板测试-&gt;深度测试，丢弃掉一些片元</li>
<li>执行混合操作</li>
</ol>
<h3 id="5-V2F-类"><a href="#5-V2F-类" class="headerlink" title="5 V2F 类"></a>5 V2F 类</h3><p>上述过程中，一个重要的结构体是 v2f，因此首先我们需要定义一个 v2f 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> V2F_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2F_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V2F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	glm::vec4 worldPos;</span><br><span class="line">	glm::vec4 windowPos;</span><br><span class="line">	glm::vec4 color;</span><br><span class="line">	glm::vec2 texcoord;</span><br><span class="line">	glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">	glm::mat3 TBN;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> Z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">V2F</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">V2F</span>(</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _wPos,</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _pPos,</span><br><span class="line">		<span class="type">const</span> glm::vec4&amp; _color,</span><br><span class="line">		<span class="type">const</span> glm::vec2&amp; _tex,</span><br><span class="line">		<span class="type">const</span> glm::vec3&amp; _normal,</span><br><span class="line">		<span class="type">const</span> glm::mat3&amp; _tbn</span><br><span class="line">	) :</span><br><span class="line">		<span class="built_in">worldPos</span>(_wPos), <span class="built_in">windowPos</span>(_pPos), <span class="built_in">color</span>(_color), <span class="built_in">texcoord</span>(_tex), <span class="built_in">normal</span>(_normal), <span class="built_in">TBN</span>(_tbn) &#123;&#125;</span><br><span class="line">	<span class="built_in">V2F</span>(<span class="type">const</span> V2F&amp; v) :</span><br><span class="line">		<span class="built_in">worldPos</span>(v.worldPos), <span class="built_in">windowPos</span>(v.windowPos), <span class="built_in">color</span>(v.color), <span class="built_in">texcoord</span>(v.texcoord), <span class="built_in">normal</span>(v.normal), <span class="built_in">TBN</span>(v.TBN), <span class="built_in">Z</span>(v.Z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个顶点之间的插值</span></span><br><span class="line">	<span class="function"><span class="type">static</span> V2F <span class="title">lerp</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> <span class="type">float</span>&amp; factor)</span> </span>&#123;</span><br><span class="line">		V2F result;</span><br><span class="line">		result.windowPos = <span class="built_in">Lerp</span>(v1.windowPos, v2.windowPos, factor);</span><br><span class="line">		result.worldPos = <span class="built_in">Lerp</span>(v1.worldPos, v2.worldPos, factor);</span><br><span class="line">		result.color = <span class="built_in">Lerp</span>(v1.color, v2.color, factor);</span><br><span class="line">		result.normal = <span class="built_in">Lerp</span>(v1.normal, v2.normal, factor);</span><br><span class="line">		result.texcoord = <span class="built_in">Lerp</span>(v1.texcoord, v2.texcoord, factor);</span><br><span class="line"></span><br><span class="line">		result.TBN = v1.TBN;</span><br><span class="line"></span><br><span class="line">		result.Z = <span class="built_in">Lerp</span>(v1.Z, v2.Z, factor);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>V2F 中一个重要的操作就是插值，为此我们新建一个 <code>math.h</code> 文件来存放需要用到的数学操作，首先是线性插值函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插值</span></span><br><span class="line"><span class="function">glm::vec4 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v1, <span class="type">const</span> glm::vec3&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">Lerp</span><span class="params">(<span class="type">const</span> glm::vec2&amp; v1, <span class="type">const</span> glm::vec2&amp; v2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * v1 + factor * v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Lerp</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; f1, <span class="type">const</span> <span class="type">float</span>&amp; f2, <span class="type">float</span> factor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1.0f</span> - factor) * f1 + factor * f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-Shader-类"><a href="#6-Shader-类" class="headerlink" title="6 Shader 类"></a>6 Shader 类</h3><p>有了上面这些准备，现在我们可以用顶点着色器来对顶点进行处理了。先从简单的情况开始，我们首先渲染一个二维图形，因为画二维图形不需要三维到二维的变换，所以三个变换矩阵都置为单位矩阵，实际上等于没做变换直接输出。片元着色器也是直接将调用点的颜色进行输出即可。我们同样封装一个 <code>Shader</code> 类来管理顶点和片元着色器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 着色器 Shader 类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Shader</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		ModelMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">		ViewMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">		ProjectMatrix = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	glm::mat4 ModelMatrix;</span><br><span class="line">	glm::mat4 ViewMatrix;</span><br><span class="line">	glm::mat4 ProjectMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 顶点着色器</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> V2F <span class="title">VertexShader</span><span class="params">(<span class="type">const</span> Vertex&amp; a2v)</span> </span>&#123;</span><br><span class="line">		V2F o;</span><br><span class="line">		<span class="comment">// 变换到世界空间</span></span><br><span class="line">		o.worldPos = ModelMatrix * a2v.position;</span><br><span class="line">		<span class="comment">// 变换到裁剪空间</span></span><br><span class="line">		o.windowPos = ProjectMatrix * ViewMatrix * o.worldPos;</span><br><span class="line">		<span class="comment">// 法线变换</span></span><br><span class="line">		o.normal = glm::<span class="built_in">normalize</span>(NormalMatrix * a2v.normal);</span><br><span class="line">		o.texcoord = a2v.texcoord;</span><br><span class="line">		o.color = a2v.color;</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 片元着色器</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> glm::vec4 <span class="title">FragmentShader</span><span class="params">(<span class="type">const</span> V2F&amp; v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v.color;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">		ModelMatrix = model;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">		ViewMatrix = view;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">		ProjectMatrix = project;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7-视口变换"><a href="#7-视口变换" class="headerlink" title="7 视口变换"></a>7 视口变换</h3><p>现在我们可以在主函数中定义是三个顶点，由于 OpenGL 的 NDC 的坐标范围是[-1,1)，而我们目前并没有做任何的坐标变换，因此我们直接定义 NDC 下的顶点坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br></pre></td></tr></table></figure>

<p>现在我们得到了处理后的顶点，但还在 NDC 当中，需要进一步转化为屏幕空间中的坐标，即需要进行视口变换。视口变换做的操作是将 X, Y 坐标从 [-1,1) 映射到屏幕坐标 [0,w) 和 [0,h) 上，同时将原点从屏幕中间移到左下角。注意，在 OpenGL 中，左下角是原点，右上角是 (w,h) ，而 DirectX 中左上角是原点。在我们的 <code>math.h</code> 中定义视口变换矩阵，该矩阵是一个缩放+平移的矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// glm 的矩阵是行矩阵，而我们一般使用的是列矩阵，所以存放的时候要转置</span></span><br><span class="line"><span class="comment">// 行矩阵做变换是右乘 v * M  ，列矩阵是左乘 M * v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视口变换矩阵  ox oy是左下角的坐标  从[-1,1]的 NDC 变换到屏幕坐标 [0,0],[w,h]</span></span><br><span class="line"><span class="comment">// Vp = [  w/2 ,   0  ,  0  , ox+w/2 ,</span></span><br><span class="line"><span class="comment">//			0  ,  h/2 ,  0  , oy+h/2 ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  1  ,   0    ,</span></span><br><span class="line"><span class="comment">//          0  ,   0  ,  0  ,   1   ]</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewPortMatrix</span><span class="params">(<span class="type">int</span> ox, <span class="type">int</span> oy, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">	result[<span class="number">0</span>][<span class="number">0</span>] = width / <span class="number">2.0f</span>;</span><br><span class="line">	result[<span class="number">3</span>][<span class="number">0</span>] = ox + (width / <span class="number">2.0f</span>);</span><br><span class="line">	result[<span class="number">1</span>][<span class="number">1</span>] = height / <span class="number">2.0f</span>;</span><br><span class="line">	result[<span class="number">3</span>][<span class="number">1</span>] = oy + (height / <span class="number">2.0f</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line"><span class="function">FrameBuffer <span class="title">FrontBuffer</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视口变换</span></span><br><span class="line">o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br></pre></td></tr></table></figure>

<h3 id="8-光栅化"><a href="#8-光栅化" class="headerlink" title="8 光栅化"></a>8 光栅化</h3><p>接下来需要计算我们的三角形覆盖了哪些屏幕像素，这里使用经典的扫描线算法。其思想很简单，从三角形最上面的点开始往下逐步画横线，两个交点之间的区域就是覆盖的区域。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162253946.png" alt="image-20220519162253946"></p>
<p>朝向下侧的三角形原理也是一样的，只不过是对称过来了。有了这两种三角形，不难发现任意三角形都能最多分为一个平顶和一个平底三角形，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/image-20220519162338364.png" alt="image-20220519162338364"></p>
<p>于是我们得到一般三角形的光栅化方法：</p>
<ol>
<li>根据三个顶点的 y 坐标判定是否有两个相等，有则判断是平底还是平顶三角形，直接画</li>
<li>找到 y 值在中间的点，划分出上下两个三角形，画两个</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扫描线算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line">	<span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line">	<span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">		V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">		arr[<span class="number">1</span>] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">		V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">		arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">		arr[<span class="number">2</span>] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">		V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">		arr[<span class="number">1</span>] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line">		<span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">	&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line">		<span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">		V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line">		<span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line">		<span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">	V2F left, right, top;</span><br><span class="line">	left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">	right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">	top = v3;</span><br><span class="line">	<span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">	left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line">	<span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line">	<span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line">	<span class="comment">//从上往下插值</span></span><br><span class="line">	<span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">			weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">		&#125;</span><br><span class="line">		V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">		V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">		newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">		newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">		newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line">		<span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">		nowY--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">	V2F left, right, bottom;</span><br><span class="line">	left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">	right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">	bottom = v3;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line">	<span class="comment">//从上往下插值</span></span><br><span class="line">	<span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line">		<span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">			weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">		&#125;</span><br><span class="line">		V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">		V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">		newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">		newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">		newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line">		<span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">		nowY--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">		V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">		v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">		v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">		FrontBuffer.<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader.<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改上一节的主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Shader shader;</span><br><span class="line">FrameBuffer FrontBuffer;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 获取视口变换矩阵</span></span><br><span class="line">	glm::mat4 ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">	FrontBuffer.<span class="built_in">Resize</span>(SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"></span><br><span class="line">	<span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">	<span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">	<span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	V2F o1 = shader.<span class="built_in">VertexShader</span>(V1);</span><br><span class="line">	V2F o2 = shader.<span class="built_in">VertexShader</span>(V2);</span><br><span class="line">	V2F o3 = shader.<span class="built_in">VertexShader</span>(V3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 视口变换</span></span><br><span class="line">	o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">	o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">	o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 渲染并写出图片</span></span><br><span class="line">	FrontBuffer.<span class="built_in">ClearColorBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">	<span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line"></span><br><span class="line">	std::string filepath = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\test.png&quot;</span>;</span><br><span class="line">	<span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), SCR_WIDTH, SCR_HEIGHT, <span class="number">4</span>, FrontBuffer.colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test.png" alt="test"></p>
<h3 id="9-Draw-类"><a href="#9-Draw-类" class="headerlink" title="9 Draw 类"></a>9 Draw 类</h3><p>我们成功渲染出了二维图形，不过目前我们的渲染流程全都写在主函数中，需要一定的封装，于是我们定义一个 <code>Draw</code> 类来封装渲染过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRAW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FrameBuffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;V2F.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> Width;</span><br><span class="line">	<span class="type">int</span> Height;</span><br><span class="line">	FrameBuffer* FrontBuffer;</span><br><span class="line">	Shader* shader;</span><br><span class="line">	glm::mat4 ViewPortMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line">		<span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Draw</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">			<span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">		<span class="keyword">if</span> (shader)</span><br><span class="line">			<span class="keyword">delete</span> shader;</span><br><span class="line">		FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">		shader = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setModelMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; model)</span> </span>&#123;</span><br><span class="line">		shader-&gt;<span class="built_in">setModelMatrix</span>(model);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setViewMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; view)</span> </span>&#123;</span><br><span class="line">		shader-&gt;<span class="built_in">setViewMatrix</span>(view);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setProjectMatrix</span><span class="params">(<span class="type">const</span> glm::mat4&amp; project)</span> </span>&#123;</span><br><span class="line">		shader-&gt;<span class="built_in">setProjectMatrix</span>(project);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化，设定帧缓冲区和 Shder</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">			<span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">		<span class="keyword">if</span> (shader)</span><br><span class="line">			<span class="keyword">delete</span> shader;</span><br><span class="line">		ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, Width, Height);</span><br><span class="line">		FrontBuffer = <span class="keyword">new</span> <span class="built_in">FrameBuffer</span>(Width, Height);</span><br><span class="line">		shader = <span class="keyword">new</span> <span class="built_in">Shader</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">		Width = w;</span><br><span class="line">		Height = h;</span><br><span class="line">		FrontBuffer-&gt;<span class="built_in">Resize</span>(w, h);</span><br><span class="line">		ViewPortMatrix = <span class="built_in">GetViewPortMatrix</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">		FrontBuffer-&gt;<span class="built_in">ClearColorBuffer</span>(color);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(std::string&amp; filepath)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">stbi_write_png</span>(filepath.<span class="built_in">c_str</span>(), Width, Height, <span class="number">4</span>, FrontBuffer-&gt;colorBuffer.<span class="built_in">data</span>(), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">		V2F o1 = shader-&gt;<span class="built_in">VertexShader</span>(v1);</span><br><span class="line">		V2F o2 = shader-&gt;<span class="built_in">VertexShader</span>(v2);</span><br><span class="line">		V2F o3 = shader-&gt;<span class="built_in">VertexShader</span>(v3);</span><br><span class="line">		<span class="comment">// 视口变换</span></span><br><span class="line">		o1.windowPos = ViewPortMatrix * o1.windowPos;</span><br><span class="line">		o2.windowPos = ViewPortMatrix * o2.windowPos;</span><br><span class="line">		o3.windowPos = ViewPortMatrix * o3.windowPos;</span><br><span class="line">		<span class="built_in">ScanLineTriangle</span>(o1, o2, o3);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	****************** 扫描线算法 *******************</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">			V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">			v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">			v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">			FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">UpTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 分为左、右、上三个顶点</span></span><br><span class="line">		V2F left, right, top;</span><br><span class="line">		left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">		right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">		top = v3;</span><br><span class="line">		<span class="comment">// 对左顶点 x 坐标取整</span></span><br><span class="line">		left.windowPos.x = <span class="built_in">int</span>(left.windowPos.x);</span><br><span class="line">		<span class="comment">// y 的垂直跨度，用于插值系数的计算</span></span><br><span class="line">		<span class="type">int</span> dy = top.windowPos.y - left.windowPos.y;</span><br><span class="line">		<span class="comment">//从上往下插值</span></span><br><span class="line">		<span class="type">int</span> nowY = top.windowPos.y;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = dy; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">				weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">			&#125;</span><br><span class="line">			V2F newLeft = V2F::<span class="built_in">lerp</span>(left, top, weight);</span><br><span class="line">			V2F newRight = V2F::<span class="built_in">lerp</span>(right, top, weight);</span><br><span class="line">			newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">			newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">			newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line">			<span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">			nowY--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DownTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">		V2F left, right, bottom;</span><br><span class="line">		left = v1.windowPos.x &gt; v2.windowPos.x ? v2 : v1;</span><br><span class="line">		right = v1.windowPos.x &gt; v2.windowPos.x ? v1 : v2;</span><br><span class="line">		bottom = v3;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> dy = left.windowPos.y - bottom.windowPos.y;</span><br><span class="line">		<span class="comment">//从上往下插值</span></span><br><span class="line">		<span class="type">int</span> nowY = left.windowPos.y;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dy; ++i) &#123;</span><br><span class="line">			<span class="type">float</span> weight = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">				weight = <span class="built_in">float</span>(i) / dy;</span><br><span class="line">			&#125;</span><br><span class="line">			V2F newLeft = V2F::<span class="built_in">lerp</span>(left, bottom, weight);</span><br><span class="line">			V2F newRight = V2F::<span class="built_in">lerp</span>(right, bottom, weight);</span><br><span class="line">			newLeft.windowPos.x = <span class="built_in">int</span>(newLeft.windowPos.x);</span><br><span class="line">			newRight.windowPos.x = <span class="built_in">int</span>(newRight.windowPos.x + <span class="number">0.5</span>);</span><br><span class="line">			newLeft.windowPos.y = newRight.windowPos.y = nowY;</span><br><span class="line">			<span class="built_in">ScanLine</span>(newLeft, newRight);</span><br><span class="line">			nowY--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ScanLineTriangle</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		std::vector&lt;V2F&gt; arr = &#123; v1, v2, v3 &#125;;</span><br><span class="line">		<span class="comment">//对顶点根据 y 坐标排序，arr[0] 在最下面  arr[2]在最上面</span></span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">			V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">			arr[<span class="number">1</span>] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">1</span>].windowPos.y &gt; arr[<span class="number">2</span>].windowPos.y) &#123;</span><br><span class="line">			V2F tmp = arr[<span class="number">1</span>];</span><br><span class="line">			arr[<span class="number">1</span>] = arr[<span class="number">2</span>];</span><br><span class="line">			arr[<span class="number">2</span>] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">0</span>].windowPos.y &gt; arr[<span class="number">1</span>].windowPos.y) &#123;</span><br><span class="line">			V2F tmp = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">			arr[<span class="number">1</span>] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//中间跟上面的 y 相等，是底三角形</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">2</span>].windowPos.y)) &#123;</span><br><span class="line">			<span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">0</span>]);</span><br><span class="line">		&#125;<span class="comment">//否则是顶三角形</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">equal</span>(arr[<span class="number">1</span>].windowPos.y, arr[<span class="number">0</span>].windowPos.y)) &#123;</span><br><span class="line">			<span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], arr[<span class="number">0</span>], arr[<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他情况划分为两个三角形</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">float</span> weight = (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">1</span>].windowPos.y) / (arr[<span class="number">2</span>].windowPos.y - arr[<span class="number">0</span>].windowPos.y);</span><br><span class="line">			V2F newEdge = V2F::<span class="built_in">lerp</span>(arr[<span class="number">2</span>], arr[<span class="number">0</span>], weight);</span><br><span class="line">			<span class="built_in">UpTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">2</span>]);</span><br><span class="line">			<span class="built_in">DownTriangle</span>(arr[<span class="number">1</span>], newEdge, arr[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后主函数就变得非常简单了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;test.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line">	<span class="comment">// 初始化渲染器</span></span><br><span class="line">	dw.<span class="built_in">Init</span>();</span><br><span class="line">	<span class="comment">// 三角形三个顶点</span></span><br><span class="line">	<span class="function">Vertex <span class="title">V1</span><span class="params">(glm::vec3(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line">	<span class="function">Vertex <span class="title">V2</span><span class="params">(glm::vec3(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line">	<span class="function">Vertex <span class="title">V3</span><span class="params">(glm::vec3(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>), glm::vec4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">128</span>))</span></span>;</span><br><span class="line">	<span class="comment">// 设定背景并画三角形，这次有透明效果</span></span><br><span class="line">	dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">	dw.<span class="built_in">DrawTriangle</span>(V1, V2, V3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写出图片</span></span><br><span class="line">	std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">	dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/20/20220520-%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/test-16530173154901.png" alt="test"></p>
<p>到此为止整个渲染器的框架就搭建完成，之后只需要在这个框架上添加算法和各种功能即可。</p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（三）变换与深度测试</title>
    <url>/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>上一节我们搭建了整个渲染器的框架，并实现了最简单的渲染二维图形。这一节我们开始渲染真正的三维物体，实现一个基本的渲染管线。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Mesh-类"><a href="#1-Mesh-类" class="headerlink" title="1 Mesh 类"></a>1 Mesh 类</h3><p>网格（Mesh）是用于保存三维模型的数据结构，通常来说一个网格包含一系列顶点数据和索引，用它们就能绘制出一系列多边形。同时网格还包含该模型所使用的材质信息（贴图、光照等）。上一章中我们是直接用顶点来画图形的，相当于手动创建了一个 Mesh，但是当模型比较复杂的时候，就需要一个类来管理模型的 Mesh，于是我们创建一个 Mesh 类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 网格类，基础单位是三角形</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vertex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Vertex&gt; VBO;        <span class="comment">// 存放顶点数据</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; EBO;    <span class="comment">// 存放顶点索引顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> <span class="type">int</span>&amp; vNum, <span class="type">const</span> <span class="type">int</span>&amp; iNum) &#123;</span><br><span class="line">        VBO.<span class="built_in">resize</span>(vNum);</span><br><span class="line">        EBO.<span class="built_in">resize</span>(iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mesh</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Mesh</span>(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">        :<span class="built_in">VBO</span>(mesh.VBO), <span class="built_in">EBO</span>(mesh.EBO) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mesh == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        VBO = mesh.VBO;</span><br><span class="line">        EBO = mesh.EBO;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mesh&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Mesh&amp; mesh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AddMesh</span>(mesh);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向网格中加入其它网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> offset = VBO.<span class="built_in">size</span>();</span><br><span class="line">        VBO.<span class="built_in">insert</span>(VBO.<span class="built_in">end</span>(), mesh.VBO.<span class="built_in">begin</span>(), mesh.VBO.<span class="built_in">end</span>());</span><br><span class="line">        EBO.<span class="built_in">reserve</span>(EBO.<span class="built_in">size</span>() + mesh.EBO.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            EBO.<span class="built_in">push_back</span>(mesh.EBO[i] + offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向网格中添加一一个三角形片面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTriangle</span><span class="params">(<span class="type">const</span> Vertex&amp; v1, <span class="type">const</span> Vertex&amp; v2, <span class="type">const</span> Vertex&amp; v3)</span> </span>&#123;</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v1);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v2);</span><br><span class="line">        VBO.<span class="built_in">push_back</span>(v3);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        EBO.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以在 Draw 类中将之前画三角形的函数 <code>DrawTriangle</code> 改为更一般的画网格的函数 <code>DrawMesh</code> 了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">// 顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-三维变换"><a href="#2-三维变换" class="headerlink" title="2 三维变换"></a>2 三维变换</h3><p>接下来是重头戏，三维变换。虽然对三维坐标变换已经有过深入的理论学习，但是在实践之前还是有必要再复习一次，把理论和实际结合起来。之前的笔记参考<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/02/20200302-%E5%8F%98%E6%8D%A2/">【计算机图形学】（一）变换</a>。</p>
<p>首先梳理一下整个从三维模型到屏幕上的图像变换过程：</p>
<ul>
<li>模型定点定义在模型空间，需要将所有模型的顶点转换到世界空间</li>
<li>世界空间中有各种模型和观察整个场景的相机，因此要将世界空间变换到相机空间，也称观察空间</li>
<li>观察空间中的顶点位置还是三维坐标，因此要进行投影变换将所有物体顶点变换到裁剪空间，得到二维位置以及深度</li>
<li>裁剪空间经过透视除法变换到标准设备坐标系</li>
<li>标准设备坐标系最后经过视口变换到屏幕空间中</li>
</ul>
<p>于是首先是世界空间到观察空间的变换，也就是将世界空间原点移动到相机位置，然后将世界空间的三个坐标轴和相机的 right、up、front 三个方向对齐。平移矩阵很好写出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165556253.png" alt="image-20220521165556253"></p>
<p>坐标轴对齐也很简单，要将 A 空间的坐标轴和 B 空间的坐标轴对齐，只需要将 A 空间下 B 空间的坐标轴按行排列即可，因此只要将世界坐标系下的相机的三个方向按行排列，就是从世界空间到相机空间的变换矩阵：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165545686.png" alt="image-20220521165545686"></p>
<p>于是整个视角变换矩阵即为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521165714434.png" alt="image-20220521165714434"></p>
<p>我们在 <code>math.h</code> 中加入视角变换矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视角变换矩阵，也称观察矩阵</span></span><br><span class="line"><span class="comment">// V = R*T</span></span><br><span class="line"><span class="comment">// T = [  1 , 0 , 0 , -eyex          R = [  Right , 0 </span></span><br><span class="line"><span class="comment">//        0 , 1 , 0 , -eyey                   UP  , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 1 , -eyez               - Front , 0</span></span><br><span class="line"><span class="comment">//        0 , 0 , 0 ,   1   ]                 0   , 1 ]</span></span><br><span class="line"><span class="comment">//V =  [  Right  ,  - Right·eye</span></span><br><span class="line"><span class="comment">//          UP   ,  - UP·eye</span></span><br><span class="line"><span class="comment">//       -Front  ,   Front·eye</span></span><br><span class="line"><span class="comment">//         0     ,       1        ]</span></span><br><span class="line"><span class="comment">// OpenGL中观察空间是右手系，+z 轴指向屏幕外，为了让朝向保持不变，对Front向量取反</span></span><br><span class="line"></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">(glm::vec3 pos, glm::vec3 front, glm::vec3 right, glm::vec3 up)</span> </span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = right.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">0</span>] = right.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">0</span>] = right.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">0</span>] = -glm::<span class="built_in">dot</span>(right, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">1</span>] = up.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = up.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">1</span>] = up.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">1</span>] = -glm::<span class="built_in">dot</span>(up, pos);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">2</span>] = -front.x;</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">2</span>] = -front.y;</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -front.z;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = glm::<span class="built_in">dot</span>(front, pos);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是透视投影矩阵，之前的笔记有详细推导，这里就不再赘述了，顺便再附上两篇透视投影的详细推导和理解的文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/leixinyue/p/11166135.html">OpenGL投影矩阵(Projection Matrix)构造方法</a></li>
<li><a href="https://www.jianshu.com/p/7e701d7bfd79">写给大家看的“透视除法” —— 齐次坐标和投影</a></li>
</ul>
<p>这里我们使用的透视投影矩阵为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172401734.png" alt="image-20220521172401734"></p>
<p>其中 r &#x3D; -l, t &#x3D; -b，因此投影矩阵最终为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/image-20220521172445502.png" alt="image-20220521172445502"></p>
<p>其中，r 是屏幕半宽，t 是屏幕半高，f 是远平面距离，n 是近平面距离。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透视投影 参数 fov(弧度) aspect near far</span></span><br><span class="line"><span class="comment">//M = [   1/aspect*tan(fov/2),       0      ,         0      ,       0</span></span><br><span class="line"><span class="comment">//               0  ,         1/tan(fov/2)  ,         0      ,       0 </span></span><br><span class="line"><span class="comment">//               0  ,                0      ,  - (f+n)/(f-n) ,  -2fn/(f-n)</span></span><br><span class="line"><span class="comment">//               0  ,                0      ,         -1     ,       0     ]</span></span><br><span class="line"><span class="comment">// 投影之后从右手系变成了左手系，+Z指向屏幕内</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">GetPerspectiveMatrix</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; fovy, <span class="type">const</span> <span class="type">float</span>&amp; aspect, <span class="type">const</span> <span class="type">float</span>&amp; n, <span class="type">const</span> <span class="type">float</span>&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::mat4 result = glm::<span class="built_in">mat4</span>(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> tanHalfFov = <span class="built_in">tan</span>(fovy * <span class="number">0.5f</span>);</span><br><span class="line">    result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0f</span> / (aspect * tanHalfFov);</span><br><span class="line">    result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span> / (tanHalfFov);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">2</span>] = -(f + n) / (f - n);</span><br><span class="line">    result[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-1.0f</span>;</span><br><span class="line">    result[<span class="number">3</span>][<span class="number">2</span>] = (<span class="number">-2.0f</span> * n * f) / (f - n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过透视投影后，所有坐标都在 [-w, w] 之间，还需要经过透视除法将其变换到 NDC：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透视除法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerspectiveDivision</span><span class="params">(V2F&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    v.windowPos /= v.windowPos.w;</span><br><span class="line">    v.windowPos.w = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">// OpenGL 的 NDC 中 Z 的范围是[0,1]</span></span><br><span class="line">    v.windowPos.z = (v.windowPos.z + <span class="number">1.0</span>) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 透视除法在顶点着色器变换到裁剪空间之后，视口变换之前进行，因此修改画网格的函数，加入透视除法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">        <span class="comment">//顶点着色器</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line">        <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">        <span class="comment">// 视口变换</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3 构建模型"></a>3 构建模型</h3><p>到此为止我们已经可以渲染一个三维物体了，我们使用 Mesh 构建一个立方体。一个立方体由 6 个面组成，每个面又可以分为两个三角形，于是我们写出三个函数：分别是构建三角形，构建平面和构建立方体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建一个三角形</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateTriangle</span><span class="params">(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//逆时针的三角形</span></span><br><span class="line">    <span class="comment">//顶点顺序 0 1 2</span></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(p1, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(p2, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(p3, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建一个平面，顶点顺序为左上 左下 右下 右上</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreatePlane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; leftTop, <span class="type">const</span> glm::vec3&amp; leftBottom, <span class="type">const</span> glm::vec3&amp; rightBottom, <span class="type">const</span> glm::vec3&amp; rightTop, <span class="type">const</span> glm::vec3&amp; normal)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mesh <span class="title">result</span><span class="params">(<span class="number">4</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">0</span>].position = glm::<span class="built_in">vec4</span>(leftTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">0</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">0</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">1</span>].position = glm::<span class="built_in">vec4</span>(rightTop, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">1</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>);</span><br><span class="line">    result.VBO[<span class="number">1</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">2</span>].position = glm::<span class="built_in">vec4</span>(rightBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">2</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>);</span><br><span class="line">    result.VBO[<span class="number">2</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    result.VBO[<span class="number">3</span>].position = glm::<span class="built_in">vec4</span>(leftBottom, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].normal = normal;</span><br><span class="line">    result.VBO[<span class="number">3</span>].color = glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0f</span>);</span><br><span class="line">    result.VBO[<span class="number">3</span>].texcoord = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个逆时针三角形</span></span><br><span class="line">    result.EBO[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    result.EBO[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    result.EBO[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    result.EBO[<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">    result.EBO[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建立方体</span></span><br><span class="line"><span class="function">Mesh <span class="title">CreateBox</span><span class="params">(<span class="type">const</span> glm::vec3&amp; center, <span class="type">float</span> radius)</span> </span>&#123;</span><br><span class="line">    Mesh result;</span><br><span class="line"></span><br><span class="line">    Mesh front = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(front);</span><br><span class="line"></span><br><span class="line">    Mesh left = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(left);</span><br><span class="line"></span><br><span class="line">    Mesh right = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(right);</span><br><span class="line"></span><br><span class="line">    Mesh back = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(back);</span><br><span class="line"></span><br><span class="line">    Mesh up = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, radius, -radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(up);</span><br><span class="line"></span><br><span class="line">    Mesh down = <span class="built_in">CreatePlane</span>(</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(-radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, -radius),</span><br><span class="line">        center + glm::<span class="built_in">vec3</span>(radius, -radius, radius),</span><br><span class="line">        glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    result.<span class="built_in">AddMesh</span>(down);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面的颜色更加标准了，所有分量范围都在 [0 ,1]，因此需要修改对应的 <code>FrameBuffer</code> 中的写颜色函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将颜色写入对应位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">    *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">    *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>saturate</code> 函数在 math.h 中定义，作用是将输入值截断在 [0, 1] 范围内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">saturate</span><span class="params">(<span class="type">const</span> <span class="type">float</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改主函数绘制立方体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Draw.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> std::string OUT_PATH = <span class="string">&quot;D:\\TechStack\\ComputerGraphics\\RenderEngine\\Results\\&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string FILE_NAME = <span class="string">&quot;box.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Draw <span class="title">dw</span><span class="params">(SCR_WIDTH, SCR_HEIGHT)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw.<span class="built_in">Init</span>();</span><br><span class="line">    dw.<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置观察矩阵</span></span><br><span class="line">    dw.<span class="built_in">setViewMatrix</span>(</span><br><span class="line">        <span class="built_in">GetViewMatrix</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>), glm::<span class="built_in">vec3</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="comment">// 设置投影矩阵</span></span><br><span class="line">    dw.<span class="built_in">setProjectMatrix</span>(</span><br><span class="line">        <span class="built_in">GetPerspectiveMatrix</span>(glm::<span class="built_in">radians</span>(<span class="number">60.0f</span>), (<span class="type">float</span>)SCR_WIDTH / SCR_HEIGHT, <span class="number">0.3f</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个立方体</span></span><br><span class="line">    Mesh Box = <span class="built_in">CreateBox</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 让模型在原点绕着(1,1,0)旋转angle度</span></span><br><span class="line">    <span class="type">float</span> angle = <span class="number">30.0</span>;</span><br><span class="line">    dw.<span class="built_in">setModelMatrix</span>(glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(angle), glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)));</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    dw.<span class="built_in">DrawMesh</span>(Box);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写出图片</span></span><br><span class="line">    std::string filepath = OUT_PATH + FILE_NAME;</span><br><span class="line">    dw.<span class="built_in">show</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box.png" alt="box"></p>
<p>可以看出透视关系不正确，这是因为没有做深度测试的原因，因此我们需要实现深度测试。</p>
<h3 id="4-深度测试"><a href="#4-深度测试" class="headerlink" title="4 深度测试"></a>4 深度测试</h3><p>我们首先需要在 FrameBuffer 类中加入深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* FrameBuffer 类，管理颜色缓冲和深度缓冲</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrameBuffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> Width, Height;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; colorBuffer;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; depthBuffer;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">FrameBuffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FrameBuffer</span>(<span class="type">const</span> <span class="type">int</span>&amp; w = <span class="number">800</span>, <span class="type">const</span> <span class="type">int</span>&amp; h = <span class="number">600</span>) &#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        <span class="comment">//RGBA四个通道，数组大小为宽*高*4</span></span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重设缓冲区大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Resize</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line">        Width = w;</span><br><span class="line">        Height = h;</span><br><span class="line">        colorBuffer.<span class="built_in">resize</span>(w * h * <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        depthBuffer.<span class="built_in">resize</span>(w * h, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用给定的颜色清空颜色缓冲，不要使用vector下标访问，会很慢，直接使用指针操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearColorBuffer</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Width * Height * <span class="number">4</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">            *(p + i) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">            *(p + i + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时重置深度缓冲</span></span><br><span class="line">        depthBuffer.<span class="built_in">assign</span>(Width * Height, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将颜色写入对应位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WritePoint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> glm::vec4&amp; color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> xy = (y * Width + x);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* p = colorBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + xy * <span class="number">4</span>) = <span class="built_in">saturate</span>(color.r) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">1</span>) = <span class="built_in">saturate</span>(color.g) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">2</span>) = <span class="built_in">saturate</span>(color.b) * <span class="number">255</span>;</span><br><span class="line">        *(p + xy * <span class="number">4</span> + <span class="number">3</span>) = <span class="built_in">saturate</span>(color.a) * <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入深度，Z-Buffer 中深度范围是 [0,1]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y, <span class="type">const</span> <span class="type">float</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">float</span>* p = depthBuffer.<span class="built_in">data</span>();</span><br><span class="line">        *(p + y * Width + x) = depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取深度</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetDepth</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= Width || y &lt; <span class="number">0</span> || y &gt;= Height)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> *(depthBuffer.<span class="built_in">data</span>() + y * Width + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正常深度测试应该在片元着色器之后，但是为了避免不必要的计算，可以在扫描线算法中加入深度测试，也相当于实现了 Early-Z 算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanLine</span><span class="params">(<span class="type">const</span> V2F&amp; left, <span class="type">const</span> V2F&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = right.windowPos.x - left.windowPos.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        V2F v = V2F::<span class="built_in">lerp</span>(left, right, (<span class="type">float</span>)i / length);</span><br><span class="line">        v.windowPos.x = left.windowPos.x + i;</span><br><span class="line">        v.windowPos.y = left.windowPos.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//深度测试</span></span><br><span class="line">        <span class="type">float</span> depth = FrontBuffer-&gt;<span class="built_in">GetDepth</span>(v.windowPos.x, v.windowPos.y);</span><br><span class="line">        <span class="keyword">if</span> (v.windowPos.z &lt;= depth) &#123;</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(v.windowPos.x, v.windowPos.y, shader-&gt;<span class="built_in">FragmentShader</span>(v));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WriteDepth</span>(v.windowPos.x, v.windowPos.y, v.windowPos.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/21/20220521-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%8F%98%E6%8D%A2%E4%B8%8E%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/box-16531280264721.png" alt="box"></p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【光栅化渲染器】（六）剔除与裁剪</title>
    <url>/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/</url>
    <content><![CDATA[<p>目前我们已经基本实现了一个最简单的渲染管线，不过还有很多功能没有加入，这一节开始来完善我们的渲染管线。首先在之前的实现中，正方体大多数情况下都只有 3 个面正对我们，其他三个面是看不见的，也就完全不需要渲染，为了之后应对更复杂的模型和场景，提高渲染效率，我们需要先实现剔除和裁剪算法。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-剔除和裁剪概览"><a href="#1-剔除和裁剪概览" class="headerlink" title="1 剔除和裁剪概览"></a>1 剔除和裁剪概览</h3><p>在整个渲染管线中，需要进行多次剔除与裁剪，分别是：视锥剔除、正面&#x2F;背面剔除、齐次裁剪。</p>
<ul>
<li>视锥剔除一般发生在 CPU 阶段，通过 AABB、OBB 等将物体包围起来，然后与视锥体做碰撞检测，可以直接剔除掉完全不可见的物体，运算量较低但精度也较低。</li>
<li>正面&#x2F;背面剔除在顶点着色器之后，齐次裁剪之前进行，将不需要渲染的图元直接剔除掉；一般来说这一步也可以在齐次裁剪之后进行，因为操作比较简单，所以可以在世界空间运算也可以在 NDC 中运算，取决于管线的设计。</li>
<li>齐次裁剪自然是在裁剪空间中进行，即顶点着色器之后，透视除法之前。在透视除法之前是因为如果有物体在摄像机的位置，会出现 w &#x3D; 0 ，做透视除法的时候会出现除零错误。这一阶段是将在视口外的图元丢弃，一部分在视口内的图元，会进行裁剪，生成新的多边形。当然做裁剪的性能消耗也不小，很多情况下裁剪之后并不比直接把原来的多边形画出来丢弃一部分更快，尤其是 GPU 并不适合做这种判断条件比较多的工作。现代 GPU 通常是用一个比视口大很多（10倍以上？）的虚拟视口来裁剪，那种超出一点点的，就直接画了吧，GPU 性能没那么捉襟见肘。</li>
</ul>
<h3 id="2-视锥剔除"><a href="#2-视锥剔除" class="headerlink" title="2 视锥剔除"></a>2 视锥剔除</h3><p>视锥剔除首先要计算物体的包围盒，一般来说如果场景管理使用 BVH 的话，层次包围盒已经计算好了，直接遍历整个 BVH 树即可。然后获得视锥体的六个面的方程，用包围盒和六个面进行碰撞检测，具体实现可以有很多种方法，这里我们实现世界空间下的视锥剔除，流程如下：</p>
<ul>
<li>计算包围要绘制物体的 AABB（世界空间），实际我们逐图元计算，剔除掉完全在视锥体外的图元，这样一来就和后面的齐次裁剪中的剔除所做的工作几乎一样了，但这里只是为了学习原理，实际的渲染管线中是利用 BVH 等来剔除掉完全不在视锥体内的物体，而图元是在齐次裁剪的时候剔除的</li>
<li>获得视锥体六个面的平面方程（世界空间）</li>
<li>判断 AABB 的顶点在六个面的内侧还是外侧，也可以判断最小点和最大点，实现方法不唯一</li>
<li>剔除掉所有顶点完全在某一面外侧的物体，我们这里是图元</li>
</ul>
<h4 id="2-1-获取视锥平面方程"><a href="#2-1-获取视锥平面方程" class="headerlink" title="2.1 获取视锥平面方程"></a>2.1 获取视锥平面方程</h4><p>那么如何获取视锥体六个平面的方程呢？通过 MVP 变换矩阵就可以直接得出，并且使用 MVP 三个矩阵的不同组合可以得出不同空间下的视锥体平面方程。具体推导的原文可以查看：<a href="http://www8.cs.umu.se/kurser/5DV180/VT18/lab/plane_extraction.pdf">Fast Extraction of Viewing Frustum Planes from the WorldView-Projection Matrix</a></p>
<p>我们首先定义一个顶点 $v &#x3D; (x, y, z, w&#x3D;1)$，以及一个 4 * 4 的矩阵 $$M &#x3D; m_{ij}$$，这个矩阵可以是投影矩阵 P，也可以是 VP，还可以是 MVP，总之经过矩阵 $M$ 后，顶点 $v$ 就被转换到了一个规范立方体中变为 $v’ &#x3D; (x’, y’, z’, w’)$，这个过程可以写为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523110857514.png" alt="image-20220523110857514"></p>
<p>规范立方体的范围是 [-w’, w’]，因此如果这个顶点在立方体内，那么必须满足：</p>
<ul>
<li>-w’ &lt; x’ &lt; w’</li>
<li>-w’ &lt; y’ &lt; w’</li>
<li>-w’ &lt; z’ &lt; w’</li>
</ul>
<p>这实际上描述了顶点和视锥体六个平面的关系，原文中以下表列出：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111017102.png" alt="image-20220523111017102"></p>
<p>现在以顶点和左侧平面的关系为例，只需要判断 -w’ &lt; x’ 就可以了，根据矩阵乘法，可以得出：<br>$$<br>-w’ &lt; x’ \Rightarrow -(row4 · v) &lt; (row1 · v)<br>$$<br>于是可以进一步得到：<br>$$<br>(row1 + row4) · v &gt; 0<br>$$<br>将矩阵元素带入展开可以写成：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44})*w &gt; 0<br>$$<br>由于 $w &#x3D; 1$，因此可以写为：<br>$$<br>(m_{11}+m_{41})*x + (m_{12}+m_{42})*y + (m_{13}+m_{43})*z + (m_{14}+m_{44}) &gt; 0<br>$$<br>这实际上已经得到了视锥体左平面的方程，因为空间中一个平面可以表示为 $$Ax + By + Cz + D &#x3D; 0$$，所以视锥体左平面的方程中：<br>$$<br>A &#x3D; m_{11}+m_{41},\ B &#x3D; m_{12}+m_{42},\ C &#x3D; m_{13}+m_{43},\ D &#x3D; m_{14}+m_{44}<br>$$<br>类似的可以得出其他几个面的方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111837599.png" alt="image-20220523111837599"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523111857255.png" alt="image-20220523111857255"></p>
<p>上面说过， 4 * 4 的矩阵 $$M$$ 可以是投影矩阵 P，也可以是 VP，还可以是 MVP，不同的组合得到的视锥体平面方程是不同空间下的：</p>
<ul>
<li>当矩阵是 P 时，得到的是观察空间下的平面</li>
<li>当矩阵是 VP 时，得到的是世界空间下的平面</li>
<li>当矩阵是 MVP 时，得到的是模型空间下的平面</li>
</ul>
<h4 id="2-2-判断顶点与平面的关系"><a href="#2-2-判断顶点与平面的关系" class="headerlink" title="2.2 判断顶点与平面的关系"></a>2.2 判断顶点与平面的关系</h4><p>顶点与平面的关系判断非常简单，类似于二维中点和直线的关系，将顶点坐标 $(x, y, z)$ 带入平面方程计算得到点到平面的距离 $$d &#x3D; Ax + By + Cz + D$$：</p>
<ul>
<li>d &gt; 0 时，点在平面法向所指的区域</li>
<li>d &lt; 0 时，点在平面法向反方向所指的区域</li>
<li>d &#x3D; 0 时，点在平面上</li>
</ul>
<h4 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h4><p>我们使用世界空间下的视锥体剔除，首先在 <code>math.h</code> 中加入视锥体六个平面的方程以及点和平面的关系判断函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视锥体的六个平面方程（世界空间下，传入的是 VP 矩阵），用于视锥剔除</span></span><br><span class="line"><span class="comment">// 所得的平面法向都是指向视锥体内部的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewingFrustumPlanes</span><span class="params">(std::vector&lt;glm::vec4&gt;&amp; result, <span class="type">const</span> glm::mat4&amp; vp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左侧  </span></span><br><span class="line">    result[<span class="number">0</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">0</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//右侧</span></span><br><span class="line">    result[<span class="number">1</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    result[<span class="number">1</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//上侧</span></span><br><span class="line">    result[<span class="number">2</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">2</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//下侧</span></span><br><span class="line">    result[<span class="number">3</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    result[<span class="number">3</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//Near</span></span><br><span class="line">    result[<span class="number">4</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] + vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] + vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] + vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">4</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] + vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//Far</span></span><br><span class="line">    result[<span class="number">5</span>].x = vp[<span class="number">0</span>][<span class="number">3</span>] - vp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].y = vp[<span class="number">1</span>][<span class="number">3</span>] - vp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].z = vp[<span class="number">2</span>][<span class="number">3</span>] - vp[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    result[<span class="number">5</span>].w = vp[<span class="number">3</span>][<span class="number">3</span>] - vp[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点到平面距离 d =  Ax + By + Cz + D;</span></span><br><span class="line"><span class="comment">// d &lt; 0 点在平面法向反方向所指的区域</span></span><br><span class="line"><span class="comment">// d &gt; 0 点在平面法向所指的区域</span></span><br><span class="line"><span class="comment">// d = 0 在平面上</span></span><br><span class="line"><span class="comment">// d &lt; 0 返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point2Plane</span><span class="params">(<span class="type">const</span> glm::vec3&amp; v, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    <span class="keyword">return</span> sb &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于管理，我们新建一个 <code>Cull.h</code> 来管理各类剔除函数，目前只有视锥体剔除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//世界空间的视锥剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFrustumCull</span><span class="params">(<span class="type">const</span> std::vector&lt;glm::vec4&gt; ViewPlanes, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果三个顶点都在某一个平面外侧，则剔除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">0</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">3</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">3</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">4</span>]) &amp;&amp; !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">4</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 远平面只保留完全在内的图元，部分在内的直接丢掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Point2Plane</span>(v1, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v2, ViewPlanes[<span class="number">5</span>]) || !<span class="built_in">Point2Plane</span>(v3, ViewPlanes[<span class="number">5</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在渲染流程中加入视锥体剔除，一般来说应该在 CPU 阶段进行，但是我们为了方便将视锥体剔除放在顶点着色器之后，因为顶点着色器之后才知道世界空间下的坐标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Width;</span><br><span class="line">    <span class="type">int</span> Height;</span><br><span class="line">    FrameBuffer* FrontBuffer;</span><br><span class="line">    Shader* shader;</span><br><span class="line">    glm::mat4 ViewPortMatrix;</span><br><span class="line">    std::string TexturePath;</span><br><span class="line">    <span class="comment">// 视锥体剔除用到的视锥体平面</span></span><br><span class="line">    std::vector&lt;glm::vec4&gt; ViewPlanes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除开关</span></span><br><span class="line">    <span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Draw</span>(<span class="type">const</span> <span class="type">int</span>&amp; w, <span class="type">const</span> <span class="type">int</span>&amp; h, <span class="type">const</span> std::string tpath) :</span><br><span class="line">        <span class="built_in">Width</span>(w), <span class="built_in">Height</span>(h), <span class="built_in">FrontBuffer</span>(<span class="literal">nullptr</span>), <span class="built_in">shader</span>(<span class="literal">nullptr</span>), <span class="built_in">TexturePath</span>(tpath), <span class="built_in">FrustumCull</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlanes.<span class="built_in">resize</span>(<span class="number">6</span>, glm::<span class="built_in">vec4</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Draw</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (FrontBuffer)</span><br><span class="line">            <span class="keyword">delete</span> FrontBuffer;</span><br><span class="line">        <span class="keyword">if</span> (shader)</span><br><span class="line">            <span class="keyword">delete</span> shader;</span><br><span class="line">        FrontBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        shader = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnableFrustumCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FrustumCull = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取视锥体六个平面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UpdateViewPlanes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ViewingFrustumPlanes</span>(ViewPlanes, ProjectMatrix * ViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画网格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">            Vertex p1, p2, p3;</span><br><span class="line">            p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">            p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">            p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line">            <span class="comment">//顶点着色器变换到裁剪空间</span></span><br><span class="line">            V2F v1, v2, v3;</span><br><span class="line">            v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">            v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">            v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视锥体剔除</span></span><br><span class="line">            <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">            <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//做透视除法，变换到NDC</span></span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">            v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">            v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-正面-x2F-背面剔除"><a href="#3-正面-x2F-背面剔除" class="headerlink" title="3 正面&#x2F;背面剔除"></a>3 正面&#x2F;背面剔除</h3><p>经过视锥体剔除将所有完全不在视锥体内的图元剔除掉之后，剩下的图元要么完全在视锥体内，要么部分在视锥体内，对于部分在视锥体内的图元需要进行裁剪，但因为裁剪是计算量较大的操作，为了进一步减少无用的运算，在此之前还要根据需要将背面（有时也需要将正面的剔除）的图元剔除掉，这一步操作比较简单，我们在世界空间计算。根据观察方向和图元的法线方向的夹角来判断图元是正对我们还是背对我们，原理在之前的 RTR 总结中有介绍，这里不再赘述。</p>
<p>也可以先做齐次裁剪，透视除法之后在 NDC 中进行正面&#x2F;背面剔除，但要注意 NDC 是左手系，观察方向恒定为 (0, 0, 1)。无论在哪里计算，原理都是一样的。</p>
<p>在 <code>Cull.h</code> 中加入正面&#x2F;背面剔除函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正面/背面</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Face</span> &#123;</span><br><span class="line">    Back,</span><br><span class="line">    Front</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界空间的面剔除，剔除正向面或者逆向面</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorldFaceCull</span><span class="params">(Face face, <span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叉乘得到法向量</span></span><br><span class="line">    glm::vec3 tmp1 = glm::<span class="built_in">vec3</span>(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);</span><br><span class="line">    glm::vec3 tmp2 = glm::<span class="built_in">vec3</span>(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);</span><br><span class="line">    glm::vec3 normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(tmp1, tmp2));</span><br><span class="line">    <span class="comment">// 世界空间下的观察方向</span></span><br><span class="line">    glm::vec3 view = camera-&gt;Front;</span><br><span class="line">    <span class="comment">// 也可以在NDC中剔除，这时观察方向恒定为(0, 0, 1)，但上面的叉乘顺序顺序要颠倒一下，因为NDC是左手系</span></span><br><span class="line">    <span class="comment">//glm::vec3 view = glm::vec3(0, 0, 1);</span></span><br><span class="line">    <span class="keyword">if</span> (face == Back)</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, view) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在渲染流程中加入正面&#x2F;背面剔除：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 剔除开关</span></span><br><span class="line"><span class="type">bool</span> FrustumCull;</span><br><span class="line"><span class="type">bool</span> FaceCull;</span><br><span class="line">Face CullMode;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisableFaceCull</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableFaceCull</span><span class="params">(Face f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FaceCull = <span class="literal">true</span>;</span><br><span class="line">    CullMode = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldSpaceCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v1);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v2);</span><br><span class="line">        <span class="built_in">PerspectiveDivision</span>(v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">        v1.windowPos = ViewPortMatrix * v1.windowPos;</span><br><span class="line">        v2.windowPos = ViewPortMatrix * v2.windowPos;</span><br><span class="line">        v3.windowPos = ViewPortMatrix * v3.windowPos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 光栅化</span></span><br><span class="line">        <span class="built_in">ScanLineTriangle</span>(v1, v2, v3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改主函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化渲染器</span></span><br><span class="line">    dw = <span class="keyword">new</span> <span class="built_in">Draw</span>(SCR_WIDTH, SCR_HEIGHT, TEXTURE_PATH);</span><br><span class="line">    dw-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    dw-&gt;<span class="built_in">ClearBuffer</span>(glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 开启视锥体剔除,实际上默认已经开启</span></span><br><span class="line">    dw-&gt;<span class="built_in">EnableFrustumCull</span>();</span><br><span class="line">    <span class="comment">// 开启背面剔除，背面剔除默认关闭，需要手动开启并指定剔除模式</span></span><br><span class="line">    Face CullMode = Back;</span><br><span class="line">    dw-&gt;<span class="built_in">EnableFaceCull</span>(CullMode);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-齐次裁剪"><a href="#4-齐次裁剪" class="headerlink" title="4 齐次裁剪"></a>4 齐次裁剪</h3><p>最后是比较麻烦的齐次裁剪，之前说过，渲染管线中进行齐次裁剪的位置是<strong>投影之后，透视除法之前</strong>，我们知道，在世界空间和观察空间中，一个点的坐标是 (X, Y, Z, 1)，经过透视投影之后变为 (X’, Y’, Z’, -Z)，再除以 W 坐标变化到 NDC 中 (X’&#x2F;-Z, Y’&#x2F;-Z, Z’&#x2F;-Z, 1)。这其中，如果一个点在观察者的身后，其观察坐标 Z 会大于 0（观察空间是右手系），那么透视投影之后 W 会小于 0，进行透视除法会导致顶点的 X, Y 坐标上下左右翻转。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220523175755959.png" alt="image-20220523175755959"></p>
<p>并且如果一个物体在相机平面上，会在透视除法时导致除零错误。</p>
<p>透视投影之后，透视除法之前的坐标空间被称为裁剪空间，也叫齐次（裁剪）空间，它实质上是一个四维空间，变换到齐次空间的顶点之间仍然是线性相关的（可以直接使用线性插值而不是透视插值）。这是因为透视除法将所有坐标除以 w 才会真正破坏顶点之间的线性关系，所以也有这种说法：<strong>真正的投影是通过透视除法完成的</strong>。</p>
<p>这时，在视锥体中的点一定满足如下条件：</p>
<ul>
<li>$-w &lt; x,y,z &lt; w$</li>
<li>$near&lt;w&lt;far$</li>
</ul>
<p>如果不满足这个条件的点，就需要被剔除，因此我们可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 裁剪空间剔除</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClipSpaceCull</span><span class="params">(<span class="type">const</span> glm::vec4&amp; v1, <span class="type">const</span> glm::vec4&amp; v2, <span class="type">const</span> glm::vec4&amp; v3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 三个点的w都在near或far之外则需要剔除</span></span><br><span class="line">    <span class="keyword">if</span> (v1.w &lt;= camera-&gt;Near &amp;&amp; v2.w &lt;= camera-&gt;Near &amp;&amp; v3.w &lt;= camera-&gt;Near)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1.w &gt;= camera-&gt;Far &amp;&amp; v2.w &lt;= camera-&gt;Far &amp;&amp; v3.w &lt;= camera-&gt;Far)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 任意一个点在规范立方体内则不需要剔除，等待进行下一步裁剪</span></span><br><span class="line">    <span class="keyword">if</span> (v1.x &lt;= v1.w || v1.y &lt;= v1.w || v1.z &lt;= v1.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2.x &lt;= v2.w || v2.y &lt;= v2.w || v2.z &lt;= v2.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (v3.x &lt;= v3.w || v3.y &lt;= v3.w || v3.z &lt;= v3.w)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是对没有被剔除的片元进行裁剪，使用 <strong>Sutherland-Hodgeman 裁剪算法</strong>，也叫做逐边裁剪算法，它的原理很简单，在二维中就是每次使用裁剪框的一条边去裁剪多边形的每一条边，生成新的顶点并作为下一条裁剪边的输入，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/image-20220524094004535.png" alt="image-20220524094004535"></p>
<p>这个算法在齐次空间也同样适用（而且可以推广到任意维），与二维的区别是，裁剪平面变为了 6 个，而不是四条线了。</p>
<p>使用点到平面的距离来判断点在平面的内外，和之前的计算方法类似，之前的计算方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Point2Plane(const glm::vec3&amp; v, const glm::vec4&amp; p) &#123;</span><br><span class="line"></span><br><span class="line">    float sb = p.x * v.x + p.y * v.y + p.z * v.z + p.w;</span><br><span class="line">    return sb &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数只适用于世界空间或者观察空间等 w 为 1 的空间中，而我们现在是在裁剪空间，顶点的 w 值不为 1， 因此不能省略顶点的 w，所以需要重新写一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断点是否在裁剪平面法线所指方向，即内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Inside</span><span class="params">(<span class="type">const</span> glm::vec4&amp; line, <span class="type">const</span> glm::vec4&amp; p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line.x * p.x + line.y * p.y + line.z * p.z + line.w * p.w &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们还需要一个函数直接判断三个顶点是否都在视口内，这样就无需裁剪了，也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有顶点都在内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AllVertexsInside</span><span class="params">(<span class="type">const</span> std::vector&lt;V2F&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.x) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.y) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(v[i].windowPos.z) &gt; <span class="built_in">fabs</span>(v[i].windowPos.w))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是计算两个点连线与平面的交点，这可以通过插值实现，分别在一个平面两侧的两个点 A 和 B，它们连线与平面的交点 C 可以通过权重 da &#x2F; (da - db) 从 A 到 B 插值得到。其中 da 和 db 分别是点 A 和 B 到裁剪平面的距离，可以通过上面函数的方法计算得到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交点，通过端点插值得到</span></span><br><span class="line"><span class="function">V2F <span class="title">Intersect</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> glm::vec4&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> da = v1.windowPos.x * line.x + v1.windowPos.y * line.y + v1.windowPos.z * line.z + v1.windowPos.w * line.w;</span><br><span class="line">    <span class="type">float</span> db = v2.windowPos.x * line.x + v2.windowPos.y * line.y + v2.windowPos.z * line.z + v2.windowPos.w * line.w;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> weight = da / (da - db);</span><br><span class="line">    <span class="keyword">return</span> V2F::<span class="built_in">lerp</span>(v1, v2, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 Sutherland-Hodgeman 裁剪算法，代码很好理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SutherlandHodgeman裁剪算法</span></span><br><span class="line"><span class="comment">// 输入三个顶点，输出裁剪后的顶点组</span></span><br><span class="line"><span class="function">std::vector&lt;V2F&gt; <span class="title">SutherlandHodgeman</span><span class="params">(<span class="type">const</span> V2F&amp; v1, <span class="type">const</span> V2F&amp; v2, <span class="type">const</span> V2F&amp; v3)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;V2F&gt; output = &#123; v1,v2,v3 &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AllVertexsInside</span>(output)) &#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ViewLines.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;V2F&gt; <span class="title">input</span><span class="params">(output)</span></span>;</span><br><span class="line">        output.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; input.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            V2F current = input[j];</span><br><span class="line">            V2F last = input[(j + input.<span class="built_in">size</span>() - <span class="number">1</span>) % input.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], current.windowPos)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                    V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                    output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">                &#125;</span><br><span class="line">                output.<span class="built_in">push_back</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Inside</span>(ViewLines[i], last.windowPos)) &#123;</span><br><span class="line">                V2F intersecting = <span class="built_in">Intersect</span>(last, current, ViewLines[i]);</span><br><span class="line">                output.<span class="built_in">push_back</span>(intersecting);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在渲染流程中加入裁剪，因为裁剪后生成了新的顶点，所以要做比较多的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画网格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawMesh</span><span class="params">(<span class="type">const</span> Mesh&amp; mesh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mesh.EBO.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh.EBO.<span class="built_in">size</span>(); i += <span class="number">3</span>) &#123;</span><br><span class="line">        Vertex p1, p2, p3;</span><br><span class="line">        p1 = mesh.VBO[mesh.EBO[i]];</span><br><span class="line">        p2 = mesh.VBO[mesh.EBO[i + <span class="number">1</span>]];</span><br><span class="line">        p3 = mesh.VBO[mesh.EBO[i + <span class="number">2</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点着色器变换到裁剪空间</span></span><br><span class="line">        V2F v1, v2, v3;</span><br><span class="line">        v1 = shader-&gt;<span class="built_in">VertexShader</span>(p1);</span><br><span class="line">        v2 = shader-&gt;<span class="built_in">VertexShader</span>(p2);</span><br><span class="line">        v3 = shader-&gt;<span class="built_in">VertexShader</span>(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视锥体剔除</span></span><br><span class="line">        <span class="built_in">UpdateViewPlanes</span>();</span><br><span class="line">        <span class="keyword">if</span> (FrustumCull &amp;&amp; !<span class="built_in">WorldFrustumCull</span>(ViewPlanes, v1.worldPos / v1.w, v2.worldPos / v2.w, v3.worldPos / v3.w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正面/背面剔除</span></span><br><span class="line">        <span class="keyword">if</span> (FaceCull &amp;&amp; <span class="built_in">WorldFaceCull</span>(CullMode, v1.worldPos, v2.worldPos, v3.worldPos))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 裁剪空间剔除</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ClipSpaceCull</span>(v1.windowPos, v2.windowPos, v3.windowPos)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 裁剪</span></span><br><span class="line">        std::vector&lt;V2F&gt; clipingVertexs = <span class="built_in">SutherlandHodgeman</span>(v1, v2, v3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做透视除法，变换到NDC</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clipingVertexs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="built_in">PerspectiveDivision</span>(clipingVertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染</span></span><br><span class="line">        <span class="type">int</span> n = clipingVertexs.<span class="built_in">size</span>() - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            V2F tempv1 = clipingVertexs[<span class="number">0</span>];</span><br><span class="line">            V2F tempv2 = clipingVertexs[i + <span class="number">1</span>];</span><br><span class="line">            V2F tempv3 = clipingVertexs[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视口变换，变换到屏幕空间</span></span><br><span class="line">            tempv1.windowPos = ViewPortMatrix * tempv1.windowPos;</span><br><span class="line">            tempv2.windowPos = ViewPortMatrix * tempv2.windowPos;</span><br><span class="line">            tempv3.windowPos = ViewPortMatrix * tempv3.windowPos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 画线</span></span><br><span class="line">            <span class="keyword">if</span> (renderMode == Line) &#123;</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv1, tempv2);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv2, tempv3);</span><br><span class="line">                <span class="built_in">DrawLine</span>(tempv3, tempv1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 光栅化</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ScanLineTriangle</span>(tempv1, tempv2, tempv3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为了能更方便看出裁剪效果，我们加入了渲染模式选项：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RenderMode</span> &#123;</span><br><span class="line">    Line,    <span class="comment">// 仅绘制边框</span></span><br><span class="line">    Fill    <span class="comment">// 绘制图形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变渲染模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChangeRenderMode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (renderMode == Fill)</span><br><span class="line">        renderMode = Line;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        renderMode = Fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后新增一个画线算法，使用 BresenhamLine 画线算法，原理比较简单，具体可以查看<a href="https://blog.csdn.net/yzh1994414/article/details/82860187">Bresenham 算法原理</a>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ****************** BresenhamLine画线算法 *******************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawLine</span><span class="params">(<span class="type">const</span> V2F&amp; from, <span class="type">const</span> V2F&amp; to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = to.windowPos.x - from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> dy = to.windowPos.y - from.windowPos.y;</span><br><span class="line">    <span class="type">int</span> Xstep = <span class="number">1</span>, Ystep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dx &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Xstep = <span class="number">-1</span>;</span><br><span class="line">        dx = -dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Ystep = <span class="number">-1</span>;</span><br><span class="line">        dy = -dy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> currentX = from.windowPos.x;</span><br><span class="line">    <span class="type">int</span> currentY = from.windowPos.y;</span><br><span class="line">    V2F tmp;</span><br><span class="line">    <span class="comment">//斜率小于1</span></span><br><span class="line">    <span class="keyword">if</span> (dy &lt;= dx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dy - dx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dx));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentX += Xstep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dy;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentY += Ystep;</span><br><span class="line">                P += <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//斜率大于1，利用对称性画</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">2</span> * dx - dy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dy; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = V2F::<span class="built_in">lerp</span>(from, to, ((<span class="type">float</span>)(i) / dy));</span><br><span class="line">            FrontBuffer-&gt;<span class="built_in">WritePoint</span>(currentX, currentY, glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            currentY += Ystep;</span><br><span class="line">            <span class="keyword">if</span> (P &lt;= <span class="number">0</span>)</span><br><span class="line">                P += <span class="number">2</span> * dx;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                currentX += Xstep;</span><br><span class="line">                P -= <span class="number">2</span> * (dy - dx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h3><p>现在来测试一下上面实现的裁剪吧，因为可以只渲染边框，可以清楚的看到每个面的渲染情况。</p>
<p>我们首先关闭背面剔除，得到的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/NonCull.png" alt="NonCull"></p>
<p>然后开启背面剔除：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/BackCull.png" alt="BackCull"></p>
<p>试试开启正面剔除：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/FrontCull.png" alt="FrontCull"></p>
<p>接下来将正方体移动到屏幕边缘，测试裁剪效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/24/20220524-%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%89%94%E9%99%A4%E4%B8%8E%E8%A3%81%E5%89%AA/Clip.png" alt="Clip"></p>
<p>可以看到裁剪产生的新的图元。</p>
]]></content>
      <categories>
        <category>光栅化渲染器</category>
      </categories>
      <tags>
        <tag>实时渲染</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>【高质量实时渲染】实时阴影</title>
    <url>/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<p>阴影是渲染中极其重要的一部分，好的阴影能够大幅提升画面表现力，离线渲染中的各种阴影生成算法或者光线追踪算法都能够做到非常精细和逼真的阴影，但在游戏等实时渲染中，对帧率要求很高的情况下如何以最低的代价生成高质量的阴影就是一个难题。这一节将对实时渲染中的阴影相关的算法原理进行总结。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-再谈-Shadow-Map"><a href="#1-再谈-Shadow-Map" class="headerlink" title="1 再谈 Shadow Map"></a>1 再谈 Shadow Map</h3><h4 id="1-1-Shadow-Map-背后的数学原理"><a href="#1-1-Shadow-Map-背后的数学原理" class="headerlink" title="1.1 Shadow Map 背后的数学原理"></a>1.1 Shadow Map 背后的数学原理</h4><p>关于 Shadow Map，我们在之前已经了解过，原理非常简单，首先从光源的视角看向整个场景生成一张深度图，然后再从真正的相机视角渲染场景，并对每一个着色点计算其到光源的距离，和深度图中的距离作比较，就可以判断该着色点和光源中间是否有遮挡物，从而产生阴影。整个过程可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/03/13/20220313-%E9%98%B4%E5%BD%B1/">【计算机图形学】（十）阴影</a>。</p>
<p>那么 Shadow Map 为什么可以这么做，可以利用数学知识简单的进行解释，同时了解实时渲染中的优化方向。</p>
<p>首先是在实时渲染领域非常重要的一个思想，那就是只要看起来是对的，那么它就是对的。也就是说我们不需要精确地计算出结果，只要能够得到结果的正确近似，使最终的渲染效果看起来正确就足够了。因此在实时渲染中会用到各种近似的方法，后面就可以看到，这里先熟悉一个实时渲染中经常用到的近似等式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152415189.png" alt="image-20220530152415189"></p>
<p>也就是把两个函数乘积的积分近似转化为两个函数积分的乘积，其中分母是一个缩放因子，为了将积分的乘积缩小到和原积分同样的大小，可以通过一个例子来理解：比如 $f(x)$ 是一个常量函数，函数值恒为 2，积分区间是一个长度为 3 的一维区间，那么原积分相当于两倍的 $g(x)$ 在该区间上的积分，转化后的分子，也就是对 $f(x)$ 的积分结果为 3 * 2 &#x3D;  6，如果不除以缩放因子那么结果就是 6 倍的 $g(x)$ 在该区间上的积分，而除以分母的缩放因子，也就是积分区间长度 3，结果刚好就是 2 倍的 $g(x)$ 在该区间上的积分。</p>
<p>这个式子在实时渲染中非常有用，比如我们的渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530152854014.png" alt="image-20220530152854014"></p>
<p>在实时渲染中经常会改写为下面的形式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153029862.png" alt="image-20220530153029862"></p>
<p>其中 V 代表可见项，表示了该点的可见程度，可以理解为阴影项，于是上面的渲染方程根据之前的近似等式就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530153303843.png" alt="image-20220530153303843"></p>
<p>我们在之前的 Shader 中就是在光照计算结果上乘了一个阴影项，这就是可以这么做的道理所在。当然使用这样的近似结果要想估计的准确需要一定的条件：</p>
<ul>
<li>$g(x)$ 在积分区间上的波动要尽可能小，或者说积分区间要足够小，体现到渲染中就是光源最好是点光源或者平行光</li>
<li>$g(x)$ 要是光滑函数，体现到渲染中就是如果不是点光源那么最好是均匀发光的面光源</li>
</ul>
<h4 id="1-2-Shadow-Map-的问题"><a href="#1-2-Shadow-Map-的问题" class="headerlink" title="1.2 Shadow Map 的问题"></a>1.2 Shadow Map 的问题</h4><p>Shadow Map 是最基础的阴影算法，优点在于它是一个屏幕空间的算法，不需要知道场景的几何信息，只要知道光源位置和每一个片段的位置就可以完成（世界空间或者裁剪空间都可以），但是正因为其简单，所以有不少缺点，这也是后面的阴影算法的改进方向，总的来说 Shadow Map 有三个最大的问题：</p>
<p>首先是<strong>自遮挡问题。</strong> Shadow Map 是一个需要两个 Pass 完成的算法，在第一个 Pass 中先从光源位置渲染一遍场景，并将每个像素的深度信息存下来，第二个 Pass 中利用这些深度信息产生阴影。问题在于 Shadow Map 分辨率有限，Shadow Map 中每个像素对应到场景中的一块区域，当第二次进行深度对比的时候，就可能会产生错误，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145535937.png" alt="image-20220530145535937"></p>
<p>由于 Shadow Map 分辨率有限，因此每个 texel 对应于场景中一个区域，如图中的区域 1。点 p1 和 p2 对应于屏幕上的不同像素点，由于我们判断一个像素是否位于阴影中，是通过比较该点在以光源为视点的空间中的深度和对应 texel 中储存的深度值。在这种情况下 d(p1) &gt; s，而 d(p2) &lt; s，因此 p1 将会被认为是在阴影中，但其实 p1 和 p2 应该都不在阴影中。于是渲染出来的图就会产生下面的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530145805637.png" alt="image-20220530145805637"></p>
<p>存在很多阴影纹路，解决这个问题最简单的方法就是在深度比较的时候加上一个容忍度，也就是当着色点的深度比 Shadow Map 中的深度大且它们的差在一定范围内我们就不认为该点被遮挡了。但是如果我们手动设定一个固定的容忍度，也就相当于为 Shadow Map 中的深度进行了一个统一的偏移，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150153504.png" alt="image-20220530150153504"></p>
<p>这样虽然解决了自遮挡的问题，但会产生新的问题，也就是一部分本该在阴影中的点就不在阴影中了，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150232576.png" alt="image-20220530150232576"></p>
<p>脚的部分阴影就会断掉，原因如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530150705056.png" alt="image-20220530150705056"></p>
<p>当三角形平面相对于光源的斜率比较大的时候，Shadow Map 中的深度偏移了一段距离，原本被遮挡的点就会变成没有被遮挡从而不产生阴影，如果使用相同的偏移量就会在斜率大的地方有更多的点不被遮挡，从而造成阴影断裂，也就是上图中鞋的部分显然相对于光源的斜率更大，因此会产生阴影断裂现象。因此我们希望可以根据三角形相对于光源的斜率来自适应的调整容忍度，现代显卡已经支持了这种操作。</p>
<p>Shadow Map 的第二个问题是会<strong>产生走样</strong>，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530151628306.png" alt="image-20220530151628306"></p>
<p>这同样是由于 Shadow Map 的分辨率有限造成的，可以通过 PCF 来解决，下面会详细介绍。</p>
<p>Shadow Map 的第三个问题是<strong>只能产生硬阴影</strong>。于是产生了各种软阴影算法，同样在之后详细介绍。</p>
<h3 id="2-Percentage-Closer-Filtering（PCF）"><a href="#2-Percentage-Closer-Filtering（PCF）" class="headerlink" title="2 Percentage Closer Filtering（PCF）"></a>2 Percentage Closer Filtering（PCF）</h3><p>PCF 是解决 Shadow Map 的走样问题而被提出的。其思想是获取着色点周围的一系列点的深度值，与 P 点深度比较再对比较结果计算一个平均值，也就是说，在比较着色点和 Shadow Map 中的深度的时候，不仅和一个 texel 作比较，而是和多个 texel 作比较，然后将比较的结果进行一个平均作为该点的最终比较结果，这样就得到了一个平滑的，不是非 0 即 1 的阴影项。下面通过一个例子来说明：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154335327.png" alt="image-20220530154335327"></p>
<p>对于点 P，我们将其周围 3 * 3 的深度值和当前像素作比较，得到一个比较结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530154413210.png" alt="image-20220530154413210"></p>
<p>然后将这些结果（加权）平均起来，作为最终该像素的阴影项，这个例子中阴影项最终结果是 0.667，当然一般来说不会取 3 * 3 这么小的邻域。现在的硬件也支持 PCF，但只会取离纹理坐标最近的四个 texel 做平均，效果有限，因此大多数情况下还是在软件 Shader 中做 PCF。</p>
<p>需要注意的是，PCF 既不是对 Shadow Map 中的深度进行平均，也不是对生成的阴影图像进行滤波，而是对深度比较的结果进行平均。</p>
<p>下图是 PCF 的效果，可以一定程度上改善阴影的走样问题：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155053026.png" alt="image-20220530155053026"></p>
<h3 id="3-Percentage-Closer-Soft-Shadows（PCSS）"><a href="#3-Percentage-Closer-Soft-Shadows（PCSS）" class="headerlink" title="3 Percentage Closer Soft Shadows（PCSS）"></a>3 Percentage Closer Soft Shadows（PCSS）</h3><p>PCSS 是利用 PCF 产生软阴影的算法，为了解决 Shadow Map 无法产生软阴影的问题，实际上所有阴影反走样算法都可以用来产生软阴影。</p>
<p>从 PCF 的原理可以看出，当我们使用的邻域面积越大，也就是卷积核越大，得到的阴影就会越软，因此我们完全可以使用大卷积核的 PCF 来产生软阴影，但是卷积核选择多大合适呢？如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530155441750.png" alt="image-20220530155441750"></p>
<p>笔尖附近的阴影非常锐利，而笔杆部分的阴影就变得比较软，这是因为在笔尖处，阴影投射物（Shadow Caster）和阴影接收物（Shadow Reciever）之间的距离很近，而在笔杆部分 Shadow Caster 和 Shadow Reciever 之间的距离较远。因此我们希望 Shadow Caster 和 Shadow Reciever 之间的距离越远，使用的卷积核越大，也就使得阴影越软。</p>
<p>这可以通过几何关系来描述：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160458278.png" alt="image-20220530160458278"></p>
<p>绿色虚线是遮挡物（Blocker）到光源平面的距离，蓝色虚线是阴影接收平面到光源平面的距离，当 Blocker 离光源平面越远，也就是离阴影接收平面越近，光源平面经过 Blocker 上一点映射到阴影接收平面上的面积就越小，我们根据这个映射后的面积决定使用多大的卷积核，这样一来，Blocker 离阴影接收平面越近，使用的卷积核就越小，当 Blocker 离光源平面越近，也就是离阴影接收平面越远，使用的卷积核就越大，这样就可以产生比较真实的软阴影效果。从图中也很容易根据相似三角形原理得出映射后的光源面积：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530160930593.png" alt="image-20220530160930593"></p>
<p>现在的问题是，Blocker 的深度 $d_{Blocker}$ 如何得到？我们在渲染时只知道阴影接收平面上的一点，并不知道遮挡物距离光源的深度是多少，这时可以再次利用 PCF 的思想，将这一点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 Blocker 的深度。</p>
<p>于是 PCSS 算法的整个流程就是：</p>
<ul>
<li>对于每个像素，首先利用上述方法计算其 $d_{Blocker}$ </li>
<li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li>
<li>使用对应大小的卷积核进行 PCF</li>
</ul>
<p>那么又产生了一个问题，计算 $d_{Blocker}$ 时，又该选用多大的邻域范围呢？当然可以是一个固定的大小，比如 5 * 5，但是更好的方法是根据光源面积大小和着色点到光源的距离远近来选择不同的卷积核大小，一种方法是从着色点到光源平面构建一个锥体，然后看该点在  Shadow Map 上对应了多大的区域，将该区域内的深度和该点的深度进行比较，把所有小于该点深度的值平均起来作为 $d_{Blocker}$，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530162415880.png" alt="image-20220530162415880"></p>
<p>另外需要说明的是对于面光源，生成 Shadow Map 时也要像点光源一样，取光源平面中心一点，作为渲染深度图的视点，从该视点出发构建视锥体进行渲染，而 Shadow Map 也就是视锥体的近平面，所以使用上面的方法就可以从空间中一点覆盖到 Shadow Map 上的一块区域。</p>
<h3 id="4-Variance-Soft-Shadow-Mapping（VSM）"><a href="#4-Variance-Soft-Shadow-Mapping（VSM）" class="headerlink" title="4 Variance Soft Shadow Mapping（VSM）"></a>4 Variance Soft Shadow Mapping（VSM）</h3><h4 id="4-1-PCSS-的问题"><a href="#4-1-PCSS-的问题" class="headerlink" title="4.1 PCSS 的问题"></a>4.1 PCSS 的问题</h4><p>PCSS 利用 PCF 产生软阴影，但是速度并不快，因为 PCSS 在第一步计算 $d_{Blocker}$ 和最后一步进行 PCF 都需要对 Shadow Map 进行采样，而且当卷积核比较大的时候，需要采样很多纹理值，造成性能下降。一种解决方法是不对卷积核内的所有纹理进行采样，而是选取其中一些样本进行计算，但是这样得到的结果中一定存在噪声，不过可以利用后期的去噪方法来优化结果。</p>
<p>进一步思考这个问题，PCF 的精髓在于 “Percentage Closer”，也就是有多少百分比的 texel 是能够遮挡到当前位置的，换一种说法就是在当前点的一定邻域范围内有多少深度是小于当前点深度的。这就将原问题转化为了一个统计问题，因此使用少量样本也一定程度上能够得到近似正确的结果，但有没有更好的方法来得到相对准确的近似呢？</p>
<p>从概率与统计的角度来解决上述问题，我们只要能够知道这个邻域范围内的深度是如何分布的，就可以快速地得到一个近似的百分比。最容易想到的就是将深度的分布近似的看作是正态分布，而得到一个正态分布只需要两个量：均值和方差。</p>
<p><strong>因此 VSM 的核心思想就是</strong>，利用区域查询方法快速地得到 Shadow Map 中一个区域内深度的均值和方差，从而得到深度的近似分布，根据深度分布得到这个区域内有多少深度是小于当前点深度的，然后就可以改进 PCSS 的第一步和第三步中 PCF 的多次纹理采样，从而获得效率提升。</p>
<h4 id="4-2-区域查询方法"><a href="#4-2-区域查询方法" class="headerlink" title="4.2 区域查询方法"></a>4.2 区域查询方法</h4><p>对于一个区域内的均值，可以利用 MipMap 来快速查询，但是 MipMap 得到的均值是近似值，因为需要三线性插值，即在同一层级的不同平均值之间插值，然后还得在不同层级之间再插值一次得到结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530174618341.png" alt="image-20220530174618341"></p>
<p>更准确的查询区域均值的方法是利用 Summed Area Tables (SAT)。SAT 实际上就是二维前缀和，具体细节就不赘述了，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170245397.png" alt="image-20220530170245397"></p>
<p>因此使用 SAT 获取区域均值是绝对准确的，非近似的，而且还支持矩形区域查询，MipMap 只支持正方形区域。</p>
<p>至于 SAT 的构建，需要随着 Shadow Map 的更新而重新计算，而 Shadow Map 也要在场景中的物体运动或者光源运动的情况下不断更新，所以还是存在一定的开销的，但 SAT 一旦构建完成就可以使用 VSM 算法快速得到的 PCF 的结果，而不需要再对 Shadow Map 进行多次采样再平均，所以降低了 PCSS 的开销。</p>
<h4 id="4-3-VSM-的实现"><a href="#4-3-VSM-的实现" class="headerlink" title="4.3 VSM 的实现"></a>4.3 VSM 的实现</h4><p>利用区域查询方法可以快速得到深度的均值，那么如何得到区域内深度的方差呢？利用一个经典概率论公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530170818733.png" alt="image-20220530170818733"></p>
<p>我们只需要在构建 Shadow Map 的时候，将深度的平方也存在一张纹理中，就可以计算出区域内深度的方差了。在实际实现中，深度和深度的平方可以存在一张纹理的两个不同通道，甚至不需要两张纹理，也不需要 MRT 支持，非常方便。</p>
<p>于是根据均值和方差就可以构建出该区域内深度的近似分布了，下一步就是得到有多少深度比当前点深度小，也就是算出 $P(x &lt; x_{cur})$，已知概率密度函数（PDF）求概率就是对 PDF 进行积分，而如果能够提前算出所有的概率，对于给定的 $x_{cur}$，只需要查询就可以了，这正是分段概率函数（CDF），如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171327752.png" alt="image-20220530171327752"></p>
<p>但是对于一个连续的概率分布，求其 CDF 是非常困难的，于是 VSM 又利用了一个巧妙的方法来近似 CDF —— 利用切比雪夫不等式。</p>
<p>切比雪夫不等式（Chebychev’s inequality）在单峰概率分布时如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171632090.png" alt="image-20220530171632090"></p>
<p>这个不等式甚至不需要知道具体的概率分布，只要给定均值和方差，就可以得到上面的关系，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530171726482.png" alt="image-20220530171726482"></p>
<p>切比雪夫不等式描述的是 $x&gt;t$ 的概率不大于右边通过均值和方差计算出来的值。而在图形学中一个常规操作就是把不等式看作约等式，因此可以直接把切比雪夫不等式的右边的值作为 $P(x&gt;t)$ 的估计值，这样自然也就得到了我们需要的 $P(x &lt; t)$ 的估计值。</p>
<p>但是切比雪夫不等式要求 t 必须大于均值才有效，不过对于图形学来说，这样的近似估计已经足够好了，因为它足够简单快速。</p>
<p>现在我们可以总结一下 VSM 算法对 PCF 的改进流程：</p>
<ul>
<li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li>
<li>然后预处理得到 Shadow Map 的 SAT</li>
<li>然后在渲染时，只需要查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，这一系列操作只需要 O(1) 时间，不需要任何循环和多次纹理采样</li>
</ul>
<p>于是就解决了 PCSS 中的第三步 PCF，那么第一步获取 $d_{Blocker}$ 又该如何优化呢？</p>
<p>回顾获取 $d_{Blocker}$ 的方法：将当前点和其周围一定邻域内的 Shadow Map 中的深度进行比较，将所有小于该点深度的值平均起来，也就是将所有该点周围能够遮挡到该点的深度都平均起来，作为 $d_{Blocker}$。</p>
<p>对于一个区域，区域内所有深度可以分为两类：</p>
<ul>
<li>一类是小于当前点深度的，也就是会遮挡到当前点的深度，这些点的深度均值为 $z_{occ}$</li>
<li>另一类是小于当前点深度的，也就是不会遮挡到当前点的深度，这些点的深度均值为 $z_{unocc}$</li>
</ul>
<p>于是区域内所有深度的均值 $z_{avg}$ 可以表示成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530173458126.png" alt="image-20220530173458126"></p>
<p>其中 N 是区域内 texel 总数量， N1 和 N2 分别是不会遮挡和会遮挡当前点的 texel 数量。</p>
<p>我们希望得到的是会遮挡到当前点的深度的均值 $z_{occ}$。而 N1&#x2F;N 就是我们上面切比雪夫不等式计算的 $P(x &gt; x_{cur})$，那么自然 N2&#x2F;N 就是 $1-P(x &gt; x_{cur})$，于是现在我们只要知道 $z_{unocc}$ 就可以得到 $z_{occ}$ 了，VSM 直接假设 $z_{unocc}&#x3D;x_{cur}$ ，也就是假设不会遮挡到当前点的深度的均值就是当前点的深度，根据这些值，就可以得到一个 $z_{occ}$ 的近似值了，这个值就作为 $d_{Blocker}$ 去计算 PCF 卷积核大小。</p>
<p>于是 PCSS 中第一步的多次采样问题也解决了，最后总结一下 VSM 的算法流程：</p>
<ul>
<li>首先正常得到存有深度的 Shadow Map，顺便把深度平方也存在 Shadow Map 的一个通道中</li>
<li>然后预处理得到 Shadow Map 的 SAT</li>
<li>渲染时，对于每个像素，根据之前说的方法得到计算 $d_{Blocker}$ 时的卷积核大小，查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计，利用上述方法计算 $z_{occ}$ 作为 $d_{Blocker}$ </li>
<li>然后根据 $d_{Blocker}$ 计算得到卷积核大小 $w_{Penumbra}$</li>
<li>使用对应大小的卷积核查询 SAT 获得对应区域内的深度均值和深度平方均值，然后计算切比雪夫估计就相当于完成了 PCF，将切比雪夫估计值作为该像素的阴影项</li>
</ul>
<h4 id="4-4-VSM-的优缺点"><a href="#4-4-VSM-的优缺点" class="headerlink" title="4.4 VSM 的优缺点"></a>4.4 VSM 的优缺点</h4><p>VSM 实际上就是 PCSS 的改进方法，加速了 PCF 的计算过程，效率更高，且阴影不会产生噪声，但也存在一些问题。最严重的问题就是会产生漏光（Light Leaking）现象。</p>
<p>所谓漏光是指当两个 shadow caster 的阴影出现重叠时，在阴影的交界处会出现漏光，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175426796.png" alt="image-20220530175426796"></p>
<p>汽车底盘下方有些亮的地方，但是汽车底盘不应该是透光的，这是因为这些地方处于多个 shadow caster 的交界处，车顶有镂空的架子。</p>
<p>漏光的原因在于 VSM 中使用了单峰概率分布的切比雪夫不等式作为 PCF 的估计值，也就是默认当前点周围的深度分布是一个单峰的概率分布。对于一些复杂的情况，比如树枝，确实一个点周围的深度分布很复杂，可以近似为正态分布，所以阴影也不会有问题，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175756313.png" alt="image-20220530175756313"></p>
<p>但是有些情况下，深度分布很简单，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530175829567.png" alt="image-20220530175829567"></p>
<p>这时如果一个着色点刚好在多个镂空区域的下方，那么该点周围的深度分布可能就是多个峰值或者像上图那样的极端情况，只有几个离散的深度，这时还是用单峰切比雪夫不等式就会使得估计出来的 $P(x &gt; x_{cur})$ 偏大或者偏小，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180032457.png" alt="image-20220530180032457"></p>
<p>也就会导致阴影项偏小或者偏大，体现在图像上就是该像素更暗或者更亮，对于阴影来说，更暗我们一般看不出来，但是更亮就会很敏感地被捕捉到，也就是漏光现象。</p>
<h3 id="5-Moment-Shadow-Mapping（MSM）"><a href="#5-Moment-Shadow-Mapping（MSM）" class="headerlink" title="5 Moment Shadow Mapping（MSM）"></a>5 Moment Shadow Mapping（MSM）</h3><p>MSM 就是为了解决 VSM 的漏光现象而提出的。VSM 漏光的本质原因在于对深度分布的估计不准确，因为 VSM 只使用了均值和方差来估计分布，也就是只使用了深度的一阶矩和二阶矩，MEM 使用更高阶的矩来估计深度分布，得到的分布估计自然更加准确，MEM 经过实验指出，一般情况下使用前四阶矩就可以很好的拟合 PCF 的深度分布了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220530180617122.png" alt="image-20220530180617122"></p>
<p>最后值得一提的是，现在更多的实时阴影还是使用在区域内采样深度的 PCSS，得益于时间和空间上的去噪和模糊算法可以在很短时间内达到很好的效果，因此我们可以在很小的开销下得到一张有噪声的结果，然后使用去噪或者模糊算法来优化这个结果得到好的渲染图片。</p>
<h3 id="6-Distance-Field-Soft-Shadows"><a href="#6-Distance-Field-Soft-Shadows" class="headerlink" title="6 Distance Field Soft Shadows"></a>6 Distance Field Soft Shadows</h3><p>基于距离场的软阴影是另一种软阴影的近似算法，与以上基于 Shadow Map 的软阴影算法完全不同。相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，因此目前基于距离场的软阴影算法也逐渐被广泛使用。</p>
<p>首先回顾一下距离场，距离场是由空间中所有点的距离函数组成的场，而距离函数是指一个点到离它最近的物体表面的距离。下图是一个字母 A 的距离场可视化的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142044408.png" alt="image-20220601142044408"></p>
<p>距离场的优势在于可以使用插值得到物体表面的中间状态，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142307684.png" alt="image-20220601142307684"></p>
<p>上面一行是直接对图像进行插值的结果，黑色部分代表物体，从状态 A 到状态 B 表示一个物体从左向右运动，黑白的边界就表示物体的表面。如果直接对两幅图像的每个像素进行插值是无法得到这两个状态的中间状态的，而如果转化为距离场，对距离场插值之后再逆变换回图像，就可以得到两个状态的中间状态。</p>
<h4 id="6-1-距离场的用途"><a href="#6-1-距离场的用途" class="headerlink" title="6.1 距离场的用途"></a>6.1 距离场的用途</h4><p>距离场的一个用途就是用来做 Ray marching，也叫做 sphere tracing，也就是可以通过距离场来求光线和表面的交点，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601142714292.png" alt="image-20220601142714292"></p>
<p>因为距离场表示的是空间中一点到离它最近的物体表面的距离，因此在任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，也就是不会碰到物体的距离，所以在该点处 SDF(p) 范围内，光线不会与任何物体有交点，于是光线就可以前进 SDF(p) 距离到达边界，到达边界后又会得到一点，然后再去查找该点的 SDF(p) 并继续前进，直到光线足够接近物体或者追踪了足够多次，因此这种方法也叫做 sphere tracing。</p>
<h4 id="6-2-基于距离场的软阴影"><a href="#6-2-基于距离场的软阴影" class="headerlink" title="6.2 基于距离场的软阴影"></a>6.2 基于距离场的软阴影</h4><p>在 Ray marching 中就可以顺便完成阴影项的计算，得到一个软阴影，上面说到，任意一点处的距离函数 SDF(p) 表示了这点周围的安全距离，那么也就表示了这一点的安全角度，所谓安全角度是指该点不会被遮挡到的角度，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601143236308.png" alt="image-20220601143236308"></p>
<p>而这个安全角度是很容易算出的，我们知道着色点到该点的距离，也知道该点到离他最近的物体表面的距离，那么安全角度就是：<br>$$<br>arcsin(\frac{SDF(p)}{|p - o|})<br>$$<br>该值就可以直接作为阴影项，安全角度越小，被遮挡的概率就越大，因此该着色点的阴影也就越暗。</p>
<p>但是在着色过程中，反三角函数的计算还是太过复杂，为了简化计算，我们直接使用该点的距离函数值和着色点到该点的距离的比值乘上一个系数来近似 arcsin 值，并且将其限制在 [0, 1] 范围内：<br>$$<br>min(k·\frac{SDF(p)}{|p - o|},1.0)<br>$$<br>这样近似不仅降低了计算开销，还能使软阴影更加灵活，因为 k 值越大，相当于在一个很小的安全角度阴影项就达到了 1.0，因此从0 到 1 的过渡就越陡峭，阴影和非阴影的边界就越明显，阴影也就越硬，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/2022-06-01144018.png" alt="2022-06-01 144018"></p>
<h4 id="6-3-距离场的优缺点"><a href="#6-3-距离场的优缺点" class="headerlink" title="6.3 距离场的优缺点"></a>6.3 距离场的优缺点</h4><p>相比于 Shadow Map，距离场更加快速，效果也不错，同时也不存在走样、自遮挡等问题，但是距离场是定义在三维空间中的，三维空间中的每个点的 SDF 都要存下来，需要非常大的存储开销，虽然有一些距离场的压缩算法，但相比于一张 Shadow Map 二维纹理，依然是极大的开销。</p>
<p>此外，使用距离场自然需要预先对一个场景计算其距离场，对于一些有形变的物体每次还要重新计算，也是一个很大开销，一个场景中有多个物体还要先计算点到不同物体表面的距离，再取所有距离的最小值作为该点的 SDF，当然也可以使用场景管理的 BVH 等数据结构来优化距离场的计算过程，下图是一个复杂场景的距离场可视化结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/05/30/20220530-GAMES202-%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1/image-20220601144718966.png" alt="image-20220601144718966"></p>
<p>除了上面的缺点外，距离场实际上也存在一些 artifact，这里不赘述，有必要可以之后再做深入了解。</p>
<h3 id="7-Cascaded-Shadow-Maps（CSM）"><a href="#7-Cascaded-Shadow-Maps（CSM）" class="headerlink" title="7 Cascaded Shadow Maps（CSM）"></a>7 Cascaded Shadow Maps（CSM）</h3><p>CSM 也称为级联阴影，通常用于大型场景的实时阴影中，当场景很大的时候，在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率，否则就会造成阴影的严重锯齿。CSM 的思想是使用多张不同分辨率的阴影贴图，对于<strong>近处</strong>的场景使用<strong>较高分辨率</strong>的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用。因为远处的对象只占画面的很少一部分像素，而近处的对象占据了画面的很大一部分，进行这样的处理显然非常合理。</p>
<p>CSM 根据场景的远近来划分 camera frustum，靠近 camera 的区域划分的较密，远离 camera 的区域划分的比较稀疏，这就使得靠近 camera 的区域能够使用一个相对较大分辨率的 shandow map，减少失真现象。CSM的具体流程如下：</p>
<ul>
<li>划分 camera frustum 成多个 subfrustum ;</li>
<li>计算每个小的 subfrustum 的包围盒；</li>
<li>对每个 subfrustum 生成投影矩阵；</li>
<li>对每个 subfrustum 生成一张 shadow map；</li>
<li>对每一个像素根据深度选择合适的 shadow map 生成阴影。</li>
</ul>
<p>CSM 几乎是现代游戏引擎中的标配算法，可以配合上面的软阴影生成算法在大型场景中达到很好的效果，并且保证时效性。</p>
]]></content>
      <categories>
        <category>高质量实时渲染</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【高质量实时渲染】实时环境光照</title>
    <url>/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p>环境光照是实时渲染中需要重点解决的问题之一，游戏中的大型场景光照情况非常复杂，如果按照离线渲染中逐光源的去计算环境光照是完全不可能的，因此在实时渲染中基本都是使用环境贴图 + 一些重要光源渲染的方法来渲染整个场景，于是高效的计算环境光照就是一个重要的问题，需要一些比较复杂的算法来实现，这一节对 Split Sum 和 PRT 进行简单的推导，重点是熟悉实时渲染中对环境光照计算的优化思路，同时为下一节的实时全局光照做一个铺垫。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-回顾环境贴图"><a href="#1-回顾环境贴图" class="headerlink" title="1 回顾环境贴图"></a>1 回顾环境贴图</h3><p>环境贴图我们在之前的 Shader 部分中学习过也使用过，就是将整个场景存在一个立方体或者球体贴图中，渲染时根据光线反射方向去采样环境贴图得到环境光照。这样的环境光照渲染被称为基于图像的光照，Image-Based Lighting（IBL）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602111629808-16541623890081.png" alt="image-20220602111629808"></p>
<p>环境光照既然是光照，那自然也是解渲染方程的过程，解渲染方程最简单的方法就是使用数值方法，比如蒙特卡洛方法，但这需要根据光线反射方向采样大量的样本去计算，比如对于漫反射材质，需要在着色点为中心的半球面上均匀采样，而对于金属物体，需要向镜面反射方向一定范围内（Glossy 扰动）随机采样许多光线，这么多采样的计算是非常慢的，因此在实时渲染中需要使用一些方法来代替采样得到正确的环境光照结果。</p>
<h3 id="2-Split-Sum"><a href="#2-Split-Sum" class="headerlink" title="2 Split Sum"></a>2 Split Sum</h3><p>Split Sum 是解决实时环境光照的一个著名算法，也被使用在虚幻引擎中。上面说过，计算环境光照也是解渲染方程的过程，首先再次回顾渲染方程，并且我们现在计算环境光照的时候先不考虑环境光的阴影项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112507731-16541623890092.png" alt="image-20220602112507731"></p>
<p>于是渲方程就只由两项组成，环境光照项 $L_i$ 和 BRDF 项（一般来说实时渲染中把 BRDF 和 cos 项合称为 BRDF 项），而 Split Sum 基于一个重要的观察：</p>
<ul>
<li>如果是 Glossy 的 BRDF，那么我们的积分区间是很小的，如下图：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112750875-16541623890103.png" alt="image-20220602112750875"></p>
<ul>
<li>如果是漫反射的 BRDF，虽然积分区间很大，是整个半球面，但是函数值在整个积分区间上的变化是平滑的：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602112855298-16541623890104.png" alt="image-20220602112855298"></p>
<p>回顾之前我们说到的，实时渲染中非常重要的约等式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602113010978-16541623890105.png" alt="image-20220602113010978"></p>
<p>这个估计要准确，函数 $g(x)$ 必须满足两个条件之一：</p>
<ul>
<li>$g(x)$ 在积分区间上波动尽可能小，也就是积分区间尽可能小</li>
<li>$g(x)$ 在积分区间上平滑</li>
</ul>
<p>渲染方程中的 BRDF 刚好符合这两个条件！于是我们可以把渲染方程写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p>
<p>需要注意，在上一节中我们用同样的方法把阴影项拆分了出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123014213-16541623890107.png" alt="image-20220602123014213"></p>
<p>这是对于正常的光源渲染的，和我们这里讨论的是两个问题，我们这里的渲染方程是计算环境光照的，不过这两个对渲染方程的改写，用到的思路和方法都是一样的，都是基于上面的重要约等式。</p>
<p>渲染方程改写成这个形式意味着我们把环境光照项和 BRDF 项分开了，而光照项是环境光的积分除以积分区间的面积，这不就相当于把积分区间范围内，也就是 Glossy 的扰动范围或者漫反射的半球范围内的所有环境光取了一个平均值吗，那么我们如果能够提前计算好这个平均值，在渲染时就不需要大量采样了，只需要直接取到这个平均值就当作对应的环境光项的积分结果的近似值就可以了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124125503-16541623890108.png" alt="image-20220602124125503"></p>
<p>于是计算环境光照项的时候，我们可以把环境贴图按照一定的滤波核大小平均一下，生成多张平均后的环境贴图，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602123621399-16541623890109.png" alt="image-20220602123621399"></p>
<p>当我们计算环境光的时候，根据 Glossy 的扰动大小，决定到多大滤波核平均后的环境贴图中去获取环境光，也可以在不同 level 之间进行插值，和 Mipmap 非常相似。这一步就是 split sum 的第一阶段，解决了环境光项的计算，接下来该解决后面的 BRDF 的积分了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124242578-165416238901010.png" alt="image-20220602124242578"></p>
<p>BRDF 的积分如何避免采样呢？BRDF 是一个比较复杂的函数，涉及到很多变量，如果我们要避免采样，就只能进行预计算。首先来回顾一下最常用的微表面 BRDF 模型：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124444075-165416238901011.png" alt="image-20220602124444075"></p>
<p>我们来逐个分析一下每项都是关于什么变量的函数。</p>
<p>首先是菲涅尔项，菲涅尔项非常复杂，但是渲染中常用的是 Schlick’s 近似：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602124925813-165416238901113.png" alt="image-20220602124925813"></p>
<p>这个近似只需要一个基础反射率 $R_0$ 和一个角度 $\theta$，这个角度实际上应该是观察方向和法线的夹角，但是也可以是光线和法线的夹角，也可以是观察方向和切线的夹角，还可以是半程向量和法线的夹角，这是无所谓的，因为这些角度可以很方便的进行转换，总之就是一个角度，于是菲涅尔项需要两个参数 $R_0$ 和 $\theta$。</p>
<p>然后是法线分布函数 NDF，NDF 描述了微表面的法线分布，一个常用的 Beckmann 分布的公式如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602125413871-165416238901012.png" alt="image-20220602125413871"></p>
<p>可以看到 NDF 同样是关于两个变量的函数，一个是粗糙程度 $\alpha$，另一个同样是角度 $\theta$。</p>
<p>最后是遮挡项 G，与入射方向和出射方向有关，而我们的观察方向是固定的，于是遮挡项 G 也只与入射角 $\theta$ 有关。</p>
<p>综上， BRDF 与基础反射率 $R_0$ ，表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们如果要预计算，那么至少要计算这三个维度，虽然表面上是三个维度，实际上基础反射率 $R_0$ 还有 RGB 三个通道，如果预先计算出这三个变量所有可能的组合情况的 BRDF 积分结果，这无论是计算量还是存储量都是极大的，因此我们要让预计算的变量尽可能少，每少一个变量，就可以少一个维度的存储和计算，那对于预计算效率来说将会是质的提升。</p>
<p>我们将菲涅尔项的 Schlick’s 近似带入到上面渲染方程中的 BRDF 积分中并做简单的变形可以得到：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p>
<p>这看起来让式子变得更复杂了，但实际上我们把最麻烦的基础反射率 $R_0$ 提取出来了，而剩下的两个积分只与表面粗糙程度 $\alpha$，和入射角 $\theta$ 有关，因此我们只需要预计算表面粗糙程度 $\alpha$，和入射角 $\theta$ 的所有组合情况就可以了，而这两个值 $\alpha$ 和 $cos\theta$ 都是 0 到 1 的标量，因此预计算的结果就可以存在一张二维纹理中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130931415-165416238901115.png" alt="image-20220602130931415"></p>
<p>在渲染时直接查找纹理中的积分结果就可以了。这就是对渲染方程 BRDF 项的计算优化。</p>
<p>至此我们可以总结一下 split sum 算法是如何计算环境光的：</p>
<ul>
<li>首先使用约等式将渲染方程中对光照项和 BRDF 项的乘积的积分转化为了积分的乘积：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602122921399-16541623890106.png" alt="image-20220602122921399"></p>
<ul>
<li>然后对于第一项环境光，使用 pre-filtering 生成不同平均程度的环境贴图，使用类似 Mipmap 的方法直接取环境光的平均值近似作为积分结果</li>
<li>对于第二项 BRDF，预先计算与粗糙程度 $\alpha$ 和入射角 $cos\theta$ 有关的积分的结果，存在一张二维纹理中，计算时只需要查找纹理再乘以基础颜色 $R_0$ 按照以下公式就可以得到 BRDF 积分的近似结果了</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602130652276-165416238901114.png" alt="image-20220602130652276"></p>
<ul>
<li>最后将两个积分结果相乘再除以归一化系数（积分区间的面积）就是最终的渲染方程结果</li>
</ul>
<p>这样一来整个渲染方程的计算过程就避免了采样，虽然使用了各种近似，但最终的效果却非常好：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131814205-165416238901116.png" alt="image-20220602131814205"></p>
<p>在工程中，公式一般不会写成积分形式，而是写成离散的求和形式，但本质是一样的：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602131855491-165416238901117.png" alt="image-20220602131855491"></p>
<p>而 split sum 方法就是将求和拆分开来进行预计算，这也是 split sum 名称的由来。</p>
<h3 id="3-环境光照的阴影"><a href="#3-环境光照的阴影" class="headerlink" title="3 环境光照的阴影"></a>3 环境光照的阴影</h3><p>上面的讨论中，我们完全忽略掉了阴影，也就是 Visibility 项，实际上在实时渲染中做环境光照的阴影是几乎不可能的，因为环境贴图相当于把复杂的环境光照存在了一张贴图上，整个环境中实际上有非常多的光源，如果要做阴影，就要对每个光源生成一张 Shadow Map，这是不可能的，因此现在工业上的解决方案就是只生成最主要光源的阴影，这种方法虽然简单粗暴，但在大多数情况下也就足够了。</p>
<p>当然，有方法能够完全准确的计算出环境光的阴影，比如实时光线追踪，我们将在以后讨论，这里我们将讨论另一种非常强大的方法—— Precomputed radiance transfer（PRT），PRT 不仅可以计算环境光阴影，还可以用于实时全局光照。</p>
<h3 id="4-球面谐波函数"><a href="#4-球面谐波函数" class="headerlink" title="4 球面谐波函数"></a>4 球面谐波函数</h3><h4 id="4-1-球谐函数的定义和性质"><a href="#4-1-球谐函数的定义和性质" class="headerlink" title="4.1 球谐函数的定义和性质"></a>4.1 球谐函数的定义和性质</h4><p>球面谐波函数（Spherical Harmonics，SH）是一组二维基函数，类似于一维中的傅里叶基函数。空间中的任何球面函数（比如我们的环境贴图、BRDF 等都是球面函数）都可以表示为 SH 的线性组合。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135006568-165416238901118.png" alt="image-20220602135006568"></p>
<p>上图表示了前四阶 SH 的可视化结果，不难看出，n 阶 SH 有 2n + 1 个基函数，前 n 阶 SH 有 n * n 个基函数。图中蓝色代表正值，黄色代表负值，颜色深浅代表了值的大小，可以看到同一阶的基函数实际上就是函数值在不同维度的变化，阶数越高函数值变化的频率越高，因此他们的线性组合就可以表示函数中越高频的信息，使用不同阶的球谐函数的组合就可以将一个函数中的不同频率的信息表示出来，再将它们组合在一起就可以基本还原出原本函数的样子，使用的球谐函数越多，自然对原函数的还原也就越好：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602141239497-165416238901119.png" alt="image-20220602141239497"></p>
<p>这和一维中的傅里叶变换是完全一样的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135645988-165416238901120.png" alt="image-20220602135645988"></p>
<p>此外，一个函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分叫做<strong>投影</strong>，投影结果就是这个函数被表示为基函数的线性组合时，对应的基函数的线性组合系数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602135934958-165416238901121.png" alt="image-20220602135934958"></p>
<p>这可以类比于基向量，任意一个向量 $v$ 可以表示为一组基向量的线性组合，而每个基向量的系数就是向量 $v$ 和该基向量的点乘，而我们知道，向量点乘实际上就是投影，所以函数投影的概念和向量投影是完全一样的，上面的函数 $f(w)$ 和一个基函数 $B_i(w)$ 乘积的积分实际上就是对应的函数值相乘再累加起来，这和点乘的计算方式完全一样。</p>
<p>因此基函数自然也有和基向量完全一样的性质：</p>
<ul>
<li>基函数投影到自身结果为 1，相当于基向量是单位向量：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140619749-165416238901122.png" alt="image-20220602140619749"></p>
<ul>
<li>基函数互相正交，即投影结果为 0，相当于基向量互相正交：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602140700382-165416238901123.png" alt="image-20220602140700382"></p>
<h4 id="4-2-用球谐函数表示环境光"><a href="#4-2-用球谐函数表示环境光" class="headerlink" title="4.2 用球谐函数表示环境光"></a>4.2 用球谐函数表示环境光</h4><p>首先我们回顾上面 split sum 中用到的 pre-filtering 方法，也就是对环境贴图提前进行了一个均值滤波，然后在渲染时只进行一次查询得到平均值作为多次采样的积分近似值，因此可以说：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602142643059-165416238901124.png" alt="image-20220602142643059"></p>
<p>而我们知道均值滤波是低通滤波，只保留了低频信号，如上图，虽然滤波后不能完全还原出原本的环境光照，但是光源之间的明暗关系是完全保留了下来的，对于漫反射或者 Glossy 来说，这是完全够用的，这也是 split sum 可以 work 的原因。</p>
<p>在这个理解的基础上，又可以得出一个新的理解，那就是<strong>漫反射的 BRDF 对光照的作用，其实就相当于一个低通滤波器的作用</strong>。这其实很好理解，不管环境光照如何复杂，变化如何剧烈，漫反射物体显示出来的都是模糊的变化，不会显示出原本的环境光照那样高频的变化。而这样的特性是由 BRDF 决定的，因此漫反射的 BRDF 相当于对光照做了一个低通滤波。</p>
<p>于是有人就把 BRDF 投影到了球谐基函数上，并且发现投影只在前三阶有值，之后的投影结果几乎都为 0，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143333455-165416238901125.png" alt="image-20220602143333455"></p>
<p>这说明漫反射的 BRDF 中就只包含前三阶 SH 对应的频率的信息，根本就不包含更高频的信息。于是我们也完全可以把环境光照表示为球谐函数，而且只用前三阶就可以近似得到漫反射物体的环境光照结果，事实也确实如此：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143819188-165416238901126.png" alt="image-20220602143819188"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143830579-165416238901227.png" alt="image-20220602143830579"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602143841772-165416238901228.png" alt="image-20220602143841772"></p>
<h3 id="5-Precomputed-radiance-transfer（PRT）"><a href="#5-Precomputed-radiance-transfer（PRT）" class="headerlink" title="5 Precomputed radiance transfer（PRT）"></a>5 Precomputed radiance transfer（PRT）</h3><h4 id="5-1-PRT-原理"><a href="#5-1-PRT-原理" class="headerlink" title="5.1 PRT 原理"></a>5.1 PRT 原理</h4><p>对于一个场景中的一个着色点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144122954-165416238901229.png" alt="image-20220602144122954"></p>
<p>它的渲染方程可以表示为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602144003377-165416238901230.png" alt="image-20220602144003377"></p>
<p>环境贴图自然表示整个空间的环境光，visibility 是从这一点看向整个场景得到的遮挡关系，下半部分全黑是因为只在着色点上半球有值，最后是 BRDF 可视化，同样只在上半球有值。渲染方程相当于这些值的乘积的和，如果环境贴图每一面分辨率是 64 * 64，那么计算这一个着色点就要进行 6 * 64 * 64 次三个数的乘法运算再求和，当分辨率变大的时候这个数字是指数增长的，因此 PRT 将渲染方程分为两部分处理：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602145517079-165416238901231.png" alt="image-20220602145517079"></p>
<p>一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150253420-165416238901232.png" alt="image-20220602150253420"></p>
<h4 id="5-2-漫反射情况"><a href="#5-2-漫反射情况" class="headerlink" title="5.2 漫反射情况"></a>5.2 漫反射情况</h4><p>我们接下来先从简单的漫反射情况来详细理解上述过程。对于漫反射， BRDF 是一个常数，我们之前推导过，这里不再赘述，于是渲染方程可以写为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150537-165416238901233.png" alt="2022-06-02 150537"></p>
<p>其中光照项表示为球谐函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602150658443-165416238901234.png" alt="image-20220602150658443"></p>
<p>这样一来对于一个环境光（二维函数），我们只需要记录一个 SH 系数的向量（一维向量）就可以表示了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152232311.png" alt="image-20220602152232311"></p>
<p>将 SH 表示的环境光带入渲染方程中可以得到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/img2022-06-02150745-165416238901235.png" alt="2022-06-02 150745"></p>
<p>其中的积分相当于把 light transport 项投影到基函数上，实际上这个投影方程也可以看作是一个渲染方程，因此投影结果可以认为是在某一个基函数的光照条件下的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602151932922-165416238901236.png" alt="image-20220602151932922"></p>
<p>这也是为什么 PRT 能够得到环境光阴影，因为在计算投影结果的时候，计算的是 light transport 的投影结果，而 light transport 就包含了 visibility 项，因此 PRT 能够得到准确的环境光阴影。这个投影结果是可以通过预计算得到的，因此渲染方程最终就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p>
<p>这样在渲染时只需要计算一次点乘就可以得到环境光照了，为什么是点乘呢？我们接下来从另一个角度来理解上面的过程。</p>
<p>上面的推导中我们只把光照项表示为了 SH，然后将光照传播项投影到了这些 SH 上去预计算投影结果。我们当然也可以把光照项和光照传播项完全分开计算，分别把他们表示成 SH：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162810390.png" alt="image-20220602162810390"></p>
<p>于是渲染方程就变成了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602162847615.png" alt="image-20220602162847615"></p>
<p>渲染方程变成了一个二次的求和公式，这看起来和之前推导的结果不一样，因为这里二次求和显然是一个 $O(n^2)$ 的复杂度，要遍历 p 和 q 的结果全部累加起来，但是我们知道 SH 是基函数，基函数有正交性，也就是说只有两个基函数相同的时候，上面的积分值才为 1，其他情况下都是 0，因此上面的求和式实际上只是把光照项和光照传播项表示为 SH 后，相同的基函数对应的系数乘积累加了起来，之前说过，用 SH 表示一个二维函数相当于把二维函数压缩成了一个一维的系数向量，所以上面的求和式表示的就是光照项和光照传播项的系数向量的点乘。这和之前推导的公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-02151611-165416238901837.png" alt="2022-06-02151611"></p>
<p>表示的意义是完全一样的，这里面 $l_i$ 是光照项的每一个 SH 基函数的系数，$T_i$ 是光照传播项投影到每一个基函数的结果，也就是光照传播项的 SH 系数，二者相乘再求和不正是向量点乘吗。 </p>
<h4 id="5-3-Glossy-情况"><a href="#5-3-Glossy-情况" class="headerlink" title="5.3 Glossy 情况"></a>5.3 Glossy 情况</h4><p>在此基础上，我们就可以理解 Glossy 情况下 PRT 的计算了。漫反射时， BRDF 是一个常数，无论观察方向如何变化，观察到的光照结果都是一样的，因此光照传播项就是一个二维函数（因为 visibility 是二维的，只与 $w_i$ 有关），表示为 SH 可以得到一个系数向量，再点乘光照项的系数向量就得到了渲染方程的结果。</p>
<p>但是 Glossy 的 BRDF 不再是一个常数了，而是一个真正的四维函数，当我们在任意一个观察方向 $w_o$ 的时候，BRDF 都是一个与 $w_i$ 有关的二维函数，可以表示为 SH 得到一个系数向量，对于不同的观察方向 $w_o$，自然会得到不同的 SH 表示，也就会得到不同的系数向量。也就是说将 Glossy 的 BRDF 投影到 SH 之后，我们得到的不再是一个系数向量了，而是一个系数矩阵，每一行是一个观察方向 $w_o$ 对应的系数向量，每一列是每一个入射方向 $w_i$ 对应的系数向量，因此上面的公式就变成了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/2022-06-0265720.png" alt="2022-06-0265720"></p>
<p>于是我们在计算时就不再是向量点乘了，而是向量和矩阵相乘了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602165910171.png" alt="image-20220602165910171"></p>
<p>也就是用光照项的系数向量乘以光照传播项的系数矩阵，最终得到的还是一个系数向量，表示的是不同观察方向所看到的光照结果，是一个关于观察方向 $w_o$ 的二维函数，因为对于 Glossy 材质，不同观察方向看到的光照结果是不同的，而漫反射与观察方向无关，所以向量点乘得到的是一个值。</p>
<h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>总结一下，PRT 将渲染方程分为两部分，一部分是光照项，另一部分是 visibility 和 BRDF 结合起来称为光照传播（light transport）项，对于光照项，用球谐函数近似表示，然后将光照传播项投影到球谐基函数空间进行预计算，漫反射需要预计算一个向量，Glossy 反射需要预计算一个矩阵，这样在渲染时对于漫反射只需要一个点乘，对于 Glossy 只需要一个矩阵向量乘法即可完成渲染方程的计算。</p>
<p>PRT 效果好速度快，而且可以准确计算环境光阴影，并且如果预计算的时候考虑了光线的多次弹射还可以实现全局光照，而且得益于 SH 的快速旋转性质，PRT 可以在环境光旋转的时候迅速得到渲染结果，无需重新计算，因为当环境光旋转的时候相当于表示它的所有基函数进行了旋转，而旋转后的基函数可以表示为其他同阶基函数的线性组合，因此可以快速得到旋转后的环境光的 SH 表示。</p>
<p>但 PRT 也存在很多问题，比如只适用于静态场景，因为预计算了光照传播项，而光照传播项又包含了 visibility 和 BRDF，因此预计算完成后，场景的遮挡关系和物体的材质就不能改变了，否则就要重新计算；并且使用 SH 作为基函数只适用于低频环境光照，因为 SH 在表示高频信号的时候会非常吃力，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602152155042-165416238901838.png" alt="image-20220602152155042"></p>
<p>这是因为 SH 是从低到高的频段表示，我们使用前 n 阶的 SH，就只能表示信号中对应的这么多频段的信息，更高频的信息就会丢失掉，对于一些高频环境光照的场景，可以使用其他基函数，比如二维小波函数（Wavelet），任意一个二维函数都可以表示为所有小波基函数的线性组合，而我们可以只保留线性组合系数最高的那些项来表示原函数，因此小波表示是全频率的，比 SH 更适合表示高频环境光，但小波函数不具有快速旋转性质，当环境光变化时处理非常不灵活，下图是 SH 和 小波函数的渲染结果对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/02/20220602-GAMES202-%E5%AE%9E%E6%97%B6%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7/image-20220602172803653.png" alt="image-20220602172803653"></p>
<p>显然小波保留了更多的高频信息，得到了更好的阴影和反射效果。</p>
]]></content>
      <categories>
        <category>高质量实时渲染</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【高质量实时渲染】实时全局光照</title>
    <url>/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<p>全局光照是实时渲染中非常重要的部分，一般来说最简单的评价一个游戏画面好坏的方法就是看画面有多亮，而这就是完全由全局光照质量所决定的。所谓全局光照，指的是光线经过多次弹射后照亮其他物体，在实时渲染中为了减少运算降低开销，一般只考虑光线的一次额外弹射。这一节我们分别讨论一些三维空间和屏幕空间的实时全局光照算法，主要了解大致的思路。</p>
<p><em><span id="more"></span></em></p>
<h2 id="1-三维空间全局光照"><a href="#1-三维空间全局光照" class="headerlink" title="1 三维空间全局光照"></a>1 三维空间全局光照</h2><h3 id="1-1-Reﬂective-Shadow-Maps（RSM）"><a href="#1-1-Reﬂective-Shadow-Maps（RSM）" class="headerlink" title="1.1 Reﬂective Shadow Maps（RSM）"></a>1.1 Reﬂective Shadow Maps（RSM）</h3><p>RSM 算法基于一个很简单的但却是实时全局光照中的核心观察：<strong>所有被光源直接照亮的物体表面都可以作为次级光源照亮其他物体。</strong>于是当我们在渲染时得到这个想法的时候，就可以用各种方法实现全局光照了，问题只是在于如何处理这些次级光源。</p>
<p>那么怎么得到场景中被光源直接照亮的表面信息呢？Shadow Map 所做的正是这个工作，Shadow Map 的每一个 texel 都可以代表场景中的一块区域，这一块区域就一定是被光源直接照亮的区域，就可以作为次级光源照亮其他物体，因此 Shadow Map 实际上可以看作存储了场景中所有的次级光源，因此我们在渲染每个着色点的时候，考虑这些次级光源的贡献即可。</p>
<p>现在的问题是，每一个次级光源对着色点的贡献相当于从着色点 p 看向这个光源表面所得到的光照结果（其实和光线追踪原理一样），那么如果这个表面是 Glossy 的，情况会非常复杂，因此 RSM 假设所有次级光源表面都是 diffuse 的，这样次级光源对着色点 p 的光照就与他们的相对方向无关了，这样一来次级光源就被抽象为一个向各个方向均匀发光的面光源了。</p>
<p>那么对于面光源，我们在路径追踪中有推导过如何将渲染方程中对方向立体角的积分转化为对面光源的积分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103514616.png" alt="image-20220603103514616"></p>
<p>于是渲染方程可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p>
<p>其中 $patch$ 就是代表每一个小的次级光源。现在来看渲染方程中的每一项：</p>
<p>首先是 BRDF 项，没有什么问题。</p>
<p>然后是 visibility 项，visibility 要考虑次级光源和着色点的遮挡关系，这是很难得到的，想要得到就要对每一个次级光源生成一个 Shadow Map，而假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，每个次级光源都生成一次 Shadow Map，这是不可能的，因此 RSM 选择不计算 visibility 项，毕竟间接光照是低频的，而且这么多次级光源分别的贡献实际上都很小，所以不计算 visibility 影响也不大。</p>
<p>最麻烦的是次级光源到着色点的光照 $L_i(q\rightarrow p)$，这要根据该表面的直接光照得到，因为假设了表面是 diffuse 的，所以 BRDF 是一个常数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104607816.png" alt="image-20220603104607816"></p>
<p>需要注意这里的 BRDF 是指计算次级光源表面被实际光源直接照射时的渲染方程中的 BRDF，而上面的渲染方程是计算着色点被次级光源照射时的方程。于是 $L_i(q\rightarrow p)$ 就可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603104650506.png" alt="image-20220603104650506"></p>
<p>因为 BRDF 是出射的 Radiance 和入射的 Irradiance 的比值，因此乘上该表面入射的 Irradiance，得到的就是出射的 Radiance，也就是我们想要的次级光源发出的光线。而该表面入射的 Irradiance 可以根据定义表示为直接光源的光通量，也就是功率除以单位面积（因为 Irradiance 表示单位面积上的光的能量），所以就有上面的公式了。上面公式的好处在于带入渲染方程中，我们会发现单位面积 dA 被约掉了，说明之后的计算与次级光源的面积无关。</p>
<p>接下来考虑的问题是，假设我们的直接光照的 Shadow Map 分辨率是 512 * 512，那就代表我们有 512 * 512 个次级光源，如果每个次级光源都进行上面的计算，开销也是很大的，而实际上很多次级光源可能对着色点是没有贡献的，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105635240.png" alt="image-20220603105635240"></p>
<p>着色点为 x，而 Shadow Map 中存储的桌子上的点就显然是对 x 没有贡献的，不需要进行计算，因此我们可以根据法线方向去掉一些不需要计算的次级光源；此外，距离着色点太远的次级光源也不需要计算，因此我们只需要计算着色点一定距离范围内的有贡献的次级光源就可以了，经过这些筛选最后剩下的次级光源数量是可以接受的，也是完全可以做到实时计算的。</p>
<p>综上，要计算渲染方程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603103524667.png" alt="image-20220603103524667"></p>
<p>我们需要知道的信息有：次级光源到着色点的距离，直接光源对次级光源的光通量以及次级光源表面的法线，因此 Reﬂective Shadow Maps 中存储的就是这些信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603105452496.png" alt="image-20220603105452496"></p>
<p>RSM 只需要在 SM 的基础上额外存储一些信息就可以实现全局光照，是很容易实现的。但也存在很多缺点，比如因为是基于 Shadow Map，那么对于场景中的所有直接光源都要生成一张 RSM，复杂度会随着光源数量增加；而且整个算法做了很多舍弃和假设，比如舍弃了 visibility 项的计算，假设所有次级光源都是 diffuse 的，这会对最终效果产生一定影响。</p>
<h3 id="1-2-Light-Propagation-Volumes（LPV）"><a href="#1-2-Light-Propagation-Volumes（LPV）" class="headerlink" title="1.2 Light Propagation Volumes（LPV）"></a>1.2 Light Propagation Volumes（LPV）</h3><p>LPV 的核心思想是，我们要计算着色点的间接光照就需要知道着色点上从各个方向来的 Radiance 是多少，也就是 RSM 中计算的所有次级光源的 Radiance，那如果我们在渲染着色点的时候能直接查询到各个方向来的 Radiance，就不需要额外的计算了。</p>
<p>于是 LPV 将空间分为一个个网格，然后将所有次级光源表面发出的 Radiance 注入到表面所在的网格中，然后这些 Radiance 根据各自的方向向周围的网格传播，这样一来在渲染的时候只需要查询着色点所在的网格中的 Radiance 就可以快速计算渲染方程了。具体步骤如下：</p>
<ul>
<li>第一步：找到能被光源直接照亮的表面，这直接使用 RSM 即可</li>
<li>第二步：计算这些表面的 Radiance，并注入到所在的网格中，网格中将这些 Radiance 加起来，会得到一个二维函数，表示不同方向上的 Radiance，因为是只与方向有关的二维函数，那么自然可以近似表示为 SH，一般只需要使用前两阶 SH 表示即可，因为 LPV 同样假设次级光源是 diffuse 的，那么次级光源的光照就是低频的，所以不需要太高阶的 SH：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111036435.png" alt="image-20220603111036435"></p>
<ul>
<li>第三步：每个格子中的 Radiance 沿着格子进行传传播，每个格子的 Radiance 会传播到它相邻的六个格子中，传播过去的 Radiance 被加入到那个格子的 Radiance 中，如此迭代，一般 4 到 5 次迭代就可以让整个网格基本达到稳定，这时所有格子里的 Radiance 就可以代表这里的各个方向传播来的 Radiance 了，渲染时可以直接使用：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111410505.png" alt="image-20220603111410505"></p>
<ul>
<li>第四步：渲染时直接将着色点所在的网格中的 Radiance 作为着色点的 Radiance 进行渲染即可。</li>
</ul>
<p>通过上面的步骤可以看出 LPV 有一个很严重的问题，就是如下图中的情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111539524.png" alt="image-20220603111539524"></p>
<p>点 p 是一个次级光源，正常来说它发出的 Radiance 不应该照亮墙的背面，但是由于它发出的 Radiance 会被认为是整个网格的 Radiance  ，于是这些 Radiance 就可以照亮墙的背面，也就会发生漏光现象：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111714792.png" alt="image-20220603111714792"></p>
<p>不过这不影响 LPV 是一个优秀的实时全局光照解决方案。</p>
<h3 id="1-3-Voxel-Global-Illumination（VXGI）"><a href="#1-3-Voxel-Global-Illumination（VXGI）" class="headerlink" title="1.3 Voxel Global Illumination（VXGI）"></a>1.3 Voxel Global Illumination（VXGI）</h3><p>VXGI 同样是基于体素（Voxel）的，不同于 LPV，VXGI 将场景体素化，并创建层次结构（LPV 没有层次结构）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220603111846023.png" alt="image-20220603111846023"></p>
<p>这样一来 RSM 中每个 texel 对应的一片区域就变成对应一些体素，这样就可以计算体素中物体表面的光照作为间接光照，因此 VXGI 可以计算次级光源的 Glossy 光照，不需要假设所有次级光源都是 Glossy 的，所以效果更好，但效率自然更低。VXGI 的实现非常复杂，这里不再赘述。</p>
<h2 id="2-屏幕空间全局光照"><a href="#2-屏幕空间全局光照" class="headerlink" title="2 屏幕空间全局光照"></a>2 屏幕空间全局光照</h2><h3 id="2-1-Screen-Space-Ambient-Occlusion（SSAO）"><a href="#2-1-Screen-Space-Ambient-Occlusion（SSAO）" class="headerlink" title="2.1 Screen Space Ambient Occlusion（SSAO）"></a>2.1 Screen Space Ambient Occlusion（SSAO）</h3><p>我们之前学习过，环境光遮蔽（AO）是一种对全局光照的近似方法，实现简单，但是可以大幅增强画面的层次感，所以被广泛使用。环境光遮蔽的想法非常简单，Blinn Phong 模型把所有间接光照抽象成了一个常数，叠加到所有着色点上进行一个统一的亮度增强来模拟全局光照，这样的问题在于所有着色点的亮度增强程度是一样的，所以无法增强明暗遮蔽关系，如果我们能对每一个着色点，根据它所处位置的遮蔽关系给这个统一的环境光常数乘上一个系数再累加到着色结果上，就可以体现出物体之间的遮蔽关系了。而这个系数正是渲染方程中的 visibility 项。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105404933.png" alt="image-20220605105404933"></p>
<p>上面的过程可以通过渲染方程来更深入的理解。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105617924.png" alt="image-20220605105617924"></p>
<p>我们使用之前常用的近似积分拆解公式：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105818137.png" alt="image-20220605105818137"></p>
<p>把 visibility 项拿出来：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p>
<p>这里我们把 $cos\theta_idw_i$ 看成了一个整体，当作公式中的 $dx$，这实际上是有意义的，我们知道 $dw_i$ 是微分立体角，是单位球面上的一小块面积，乘上了一个和法线的夹角余弦相当于把这一小块面积投影到了单位圆上，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110006953.png" alt="image-20220605110006953"></p>
<p>所以 $cos\theta_idw_i$ 这个整体也叫做微分投影立体角，是单位圆中的一小块面积，因此对 $cos\theta_idw_i$ 的积分实际上就是单位圆的面积 $\pi$，这也从另一个角度解释了半球面上对 $cos\theta$ 的积分为什么是  $\pi$。</p>
<p>现在回到渲染方程，把 visibility 项拿出来之后，渲染方程分为了两部分：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605105715490.png" alt="image-20220605105715490"></p>
<p>其中，蓝色框中实际上就是对着色点 p 周围<strong>遮挡关系结果的加权平均</strong>（加权和除以权值和就是加权平均），权值是 $cos\theta$，即离法线近的权值大，离法线远的权值小。而分母就是对投影立体角的积分，结果是 $\pi$，于是蓝框中的部分就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110447249.png" alt="image-20220605110447249"></p>
<p>一般就写成一个系数 $k_A$  来表示环境光遮蔽系数。</p>
<p>而黄色框中的部分是一个渲染方程，通过之前的算法我们知道，实时渲染中一般在计算全局光照的时候都会假设所有物体表面都是 diffuse 的，这样每一个次级光源就被抽象成了一个均匀发光的面光源，而在这里， SSAO 还假设所有物体的间接光照都一样，这和 Blinn Phong 模型的假设一致，于是间接光照 $L_i^{indir}$ 就是一个常数，diffuse 的 BRDF 也是常数，因此黄色框部分可以写成：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605110615757.png" alt="image-20220605110615757"></p>
<p>自然就是一个常数，这就相当于 Blinn Phong 中的环境光常数，我们可以直接给定。于是整个渲染方程就是环境光常数乘上了每个片段的遮蔽系数，也就是我们一开始说的那个过程。因为上面的推导中使用了积分拆解近似式，而该公式近似的准确的条件是 $g(x)$ 要么连续，要么在积分区间上波动很小，而在这里 $g(x)$ 就是一个常数，自然满足这两个条件，因此使用这样的方法来近似是完全准确的。</p>
<p>屏幕空间环境光遮蔽自然是在屏幕空间完成上述过程，那么关键就在于如何只通过屏幕上的信息得到每一个像素对应的场景中的位置的遮蔽关系，从而得到 visibility 系数。</p>
<p>SSAO 的做法是在屏幕上每一个像素对应的场景中的点周围一个球体范围内随机采样一些点，根据这些点到相机的深度来判断这些点是不是能被看到，用这些结果来近似点 p 会被周围多少物体遮挡，从而得到一个 visibility 系数，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111352019.png" alt="image-20220605111352019"></p>
<p>这样做的问题在于我们实际去判断一个点的遮挡关系的时候只应该考虑该点法线方向半球上的遮挡关系，而这里用了整个球体内采样，是不准确的，于是一种解决方法是当采样点中被遮挡的点的数量大于一半时才开始考虑这一点的 AO，这样相当于粗略的截取了一个半球：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111534174.png" alt="image-20220605111534174"></p>
<p>当然现代渲染中，我们在屏幕空间也可以得到每一个像素对应的法线，因此可以直接准确的在法线方向半球内采样，并且知道了法线还可以考虑上面公式中的 $cos\theta$ 的加权平均，结果会更加准确：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605111716185.png" alt="image-20220605111716185"></p>
<p>这种方法叫做 HBAO，得到的结果也会比 SSAO 更加真实。</p>
<h3 id="2-2-Screen-Space-Directional-Occlusion（SSDO）"><a href="#2-2-Screen-Space-Directional-Occlusion（SSDO）" class="headerlink" title="2.2 Screen Space Directional Occlusion（SSDO）"></a>2.2 Screen Space Directional Occlusion（SSDO）</h3><p>SSDO 是 SSAO 的改进，SSAO 中假设一个点接收到的所有来自于其他物体反射光源的间接光照都是一样的（常数），但实际上我们利用 RSM 的思想，我们是知道哪些物体表面是被直接照亮的，因此我们不需要这样简单粗暴的假设，我们可以去准确的计算这些次级光源发出的间接光照是什么。</p>
<p>SSDO 像是在屏幕空间进行光线追踪一样，在每一个着色点向四面八方打出光光线，如果没有碰到周围的表面说明是直接光照，如果碰到了其他表面就计算该表面的间接光照作为该着色点间接光照的一部分贡献，这里计算其他表面的间接光照还是假设该表面是 diffuse 的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112300423.png" alt="image-20220605112300423"></p>
<p>于是就只有两种情况，可以表示为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112324715.png" alt="image-20220605112324715"></p>
<p>当然，SSDO 既然是屏幕空间的算法，自然不是从 RSM 中获哪那些表面是被直接照亮的，只需要通过深度图就可以近似得到，更准确地说我们认为相机看到的就是被直接照亮的，相机看到的每个点的直接光照结果就作为该点的间接光照去照亮其他点，在实际实现中也不是真的从着色点向周围发出许多光线，而是类似于 HBAO，在着色点法线所在半球随机取点，然后判断这些点的深度是否被遮挡，如果深度大于深度缓冲中的深度，就认为被遮挡，进而认为点 p 到这一点的光线打到了遮挡该点的那个表面，就将那个表面的间接光照作为点 p 的间接光照的贡献之一，整个过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605112905103.png" alt="image-20220605112905103"></p>
<p>当然这样的做法毕竟不是真正的追踪光线，因此必然会出现一些问题，比如上图中最右边的情况，当点 A 和相机之间有一个遮挡物，点 A 会认为被遮挡，进而认为光线 PA 会打到 z1 所对应的那个点，这显然是不对的，同理点 B 被认为没有被遮挡，但实际上光线 PB 被旁边的表面遮挡到了，不过这些瑕疵在实时渲染中不会对结果有太大影响，因此可以忽略，只要整体结果是好的，那么这个是算法就是好的。</p>
<p>SSDO 存在的问题不止上面说到的，由于是屏幕空间的算法，所以我们所拥有的全部信息就是屏幕中的信息，相当于是整个场景能被看到的一层外壳，看不到的部分对我们来说是完全不知道的，因此就会丢失掉一些遮蔽信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113407580.png" alt="image-20220605113407580"></p>
<p>此外，由于是在法线所在半球内随机取点，这个半球一定对应一个范围，这个范围不能太大，如果无限大那就是光线追踪了，因此对于比较远的间接反射 SSDO 是做不出来的，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113455806.png" alt="image-20220605113455806"></p>
<p>上图中立方体反射出了右边的绿色墙面，这是光线追踪的结果，SSDO 是不能做到的，因为它追踪不了那么远，但是近处的颜色是可以得到的，比如左边的红色墙面，这也是 SSDO 最大的优势，就是可以实现 color blending 的效果，能够将物体之间的反射颜色融合起来，这也是因为它把我们看到的颜色作为次级光源来计算着色点的间接光照，而不是像 SSAO 一样全局的设定一个间接光照，下图中最右边可以看出蓝色物体表面映射出了一点黄色：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605113729167.png" alt="image-20220605113729167"></p>
<h3 id="2-3-Screen-Space-Reﬂection（SSR）"><a href="#2-3-Screen-Space-Reﬂection（SSR）" class="headerlink" title="2.3 Screen Space Reﬂection（SSR）"></a>2.3 Screen Space Reﬂection（SSR）</h3><p>屏幕空间反射 SSR 真正做到了屏幕空间的光线追踪，所以 SSR 更准确地应该被叫做屏幕空间光线追踪（Screen Space Ray-tracing），因此效果很好，也是目前在实时渲染中最广泛使用的方法。</p>
<p>既然是光线追踪，那么一定分为两步，一是光线和场景求交点，在屏幕空间没有三维场景的信息，实际上计算的是光线和我们看到的场景的一个外壳求交点；二是计算着色，根据采样光线求解渲染方程，这一步和正常的光线追踪完全一样。</p>
<p>SSR 有效的一个重要原因在于，屏幕中我们能看到的场景中的反射的部分，一定有绝大部分是已经存在于当前的屏幕中的，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605114441736.png" alt="image-20220605114441736"></p>
<p>街道上反射的就是屏幕的上半部分，因此屏幕空间光线追踪是完全可行的，仅利用屏幕中的信息是足够的。</p>
<p>对于每一个像素，如果只考虑最简单的镜面反射情况，那么我们直接从该点追踪镜面反射方向，就可以找到镜面反射光线和场景外壳上的一个交点，这个交点的颜色我们是直接可以知道的，就把这个颜色作为间接光照颜色（间接光照渲染方程的结果）加到该像素上就可以了，对于更复杂的 Glossy 和漫反射就像光线追踪一样采样更多光线即可，但是也不需要像光线追踪那样采样那么多，因为间接光照最后是要叠加到直接光照结果上的，所以我们只要采样少一些光线，得到一个有噪声的间接光照结果，简单去一下噪（加个模糊之类的）再叠加到直接光照上就能得到不错的结果了。</p>
<p>下图是镜面反射的结果：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115220889.png" alt="image-20220605115220889"></p>
<p>以及 Glossy 的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115237982.png" alt="image-20220605115237982"></p>
<p>SSR 还可以实现表面不平整的反射，无非就是不平整的表面法线影响了光线的反射方向而已：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605115334563.png" alt="image-20220605115334563"></p>
<p>于是现在最主要的问题就是如何在屏幕空间追踪光线，也就是如何求得光线和我们看到的这一层外壳的交点。</p>
<p>最原始的做法是从着色点出发，沿着要追踪的光线方向，一次移动一定的距离，每次移动后判断对应的深度，如果深度小于深度缓冲中的深度则继续移动，直到深度大于深度缓冲中的深度，则认为找到了交点：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605125808577.png" alt="image-20220605125808577"></p>
<p>这种方法找到的交点是不准确的，交点的精度取决于每次移动的步长，步长过大会找到不准确的交点，步长过小又会影响速度，因此要进行加速优化，这里又要用到图形学中常用的加速手段，类似于三维空间中的 BVH，我们为深度图生成 Mipmap，但这里的 Mipmap 不能取多个深度的均值，要取多个深度的最小值，也就是离我们最近的深度作为下一 level 的深度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130111638.png" alt="image-20220605130111638"></p>
<p>这样一来，我们就构建了层次深度结构，每次沿着光线移动时可以试探性地增大步长，也就是在更高一层移动，如果找到交点就降低 level 去找具体和哪个像素相交了，举例来说：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130239538.png" alt="image-20220605130239538"></p>
<p>对于上图的情况，我们第一次从着色点出发，先在 level 0 移动，这时每一步会移动一个像素：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130325578.png" alt="image-20220605130325578"></p>
<p>此时深度小于深度缓冲中的深度，说明没有遮挡，继续移动，这次我们增加一个 level，在 level 1上移动，level 1 中每一个像素代表了 level 0 中的 4 个（我们这里是二维，所以是 2 个）像素深度的最小值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130448099.png" alt="image-20220605130448099"></p>
<p>移动之后还是没有交点，于是再增加一个 level，在 level 2上移动，level 2 中每一个像素代表了 level 0 中的 16 个（我们这里是二维，所以是 4 个）像素深度的最小值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130610015.png" alt="image-20220605130610015"></p>
<p>这时发现有交点了，于是减小一个 level，继续判断：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130649452.png" alt="image-20220605130649452"></p>
<p>继续减小 level 到 level 0：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130728981.png" alt="image-20220605130728981"></p>
<p>这时发现在 level 1有交点的像素细化到 level 0 之后没有交点，于是继续传播，因为没有交点，所以 level 加一，在 level 1 上移动：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130912940.png" alt="image-20220605130912940"></p>
<p>找到了交点，再次减小一个 level：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605130937759.png" alt="image-20220605130937759"></p>
<p>最终找到了交点所在的像素，将这个像素对应的颜色作为间接光照累加到当前着色点上即可。上述过程的伪代码如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131027338.png" alt="image-20220605131027338"></p>
<p>屏幕空间光线追踪可以很好的实现全局光照，但也一定存在问题，因为我们只有屏幕中的场景信息，这些信息只是整个场景的一个外壳，内部的信息我们是完全不知道的，因此也就会导致我们看不到的部分就不会产生反射，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131201515.png" alt="image-20220605131201515"></p>
<p>此外，SSR 也只能反射屏幕中存在的物体，因此一部分在屏幕外的物体的反射就会被“切断”，如下图：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131343414.png" alt="image-20220605131343414"></p>
<p>不过这可以通过增加一个随距离增大的模糊衰减来解决，使结果看起来更真实：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/05/20220605-GAMES202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/image-20220605131427066.png" alt="image-20220605131427066"></p>
<p>当然这只是 SSR 最基本的思想，实际实现中有非常多的细节和优化问题，比如重要性采样、样本在时间和空间上的复用等等，这里就不再展开了。</p>
]]></content>
      <categories>
        <category>高质量实时渲染</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【高质量实时渲染】实时PBR材质</title>
    <url>/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/</url>
    <content><![CDATA[<p>在离线渲染中，基于物理的渲染可以带来非常真实效果，基于物理的渲染方法的核心就是各种基于物理的材质，这些材质的 BRDF 相对于Blinn Phong 等基于经验的材质模型会比较复杂，因此处理起来也比较费时，不适用于实时渲染，这一节主要学习实时渲染中如何处理基于物理的材质。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-再谈微表面"><a href="#1-再谈微表面" class="headerlink" title="1 再谈微表面"></a>1 再谈微表面</h3><p>通过之前的学习可以发现，实时渲染的各种方法实际上都是在离线渲染的基础上，做各种假设和近似来快速得到一个近似地效果，材质也不例外，基于物理的材质最常用的就是微表面模型，实时渲染中同样使用微表面模型，因此我们首先来回顾微表面模型的内容。</p>
<p>微表面 BRDF 由菲涅尔项 F，几何项 G 和法线分布函数 D 组成，描述了从某个入射方向来的光会向某个出射方向反射出多少能量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160027871.png" alt="image-20220608160027871"></p>
<h4 id="1-1-菲涅尔项"><a href="#1-1-菲涅尔项" class="headerlink" title="1.1 菲涅尔项"></a>1.1 菲涅尔项</h4><p>菲涅尔项描述了随着入射方向和法线夹角增大，反射会变得越来越强的现象：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160157916.png" alt="image-20220608160157916"></p>
<p>对于非导体，入射方向与法线夹角和反射率的关系为：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160244963.png" alt="image-20220608160244963"></p>
<p>即当我们沿着法线方向观察的时候几乎不会看到反射，而当我们垂直于法线方向观察的时候会看到物体几乎全部被反射。</p>
<p>对于导体（金属），菲涅尔曲线为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160343753.png" alt="image-20220608160343753"></p>
<p>即导体本身就会发生强烈的反射，随着视角变化，观察到的反射不会有太大的变化，因此可以说金属本身就会有比较固定的颜色（反射率），比如金、银、铜都有自己的颜色。</p>
<p>菲涅尔项表达式非常复杂，与介质和材质的折射率有关，一般在渲染中使用 Schlick’s 近似：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608160608070.png" alt="image-20220608160608070"></p>
<p>总的来说，菲涅尔项描述了对于给定的入射方向和出射方向（半程向量），会有多少光从入射方向反射到出射方向上，一般来说渲染的时候出射方向固定，就是观察方向，那么不同入射方向的光反射到观察方向上的比例就不同，这是菲涅尔项的意义。</p>
<h4 id="1-2-法线分布函数"><a href="#1-2-法线分布函数" class="headerlink" title="1.2 法线分布函数"></a>1.2 法线分布函数</h4><p>法线分布函数描述了物体表面有多少微表面的法线和给定的半程向量方向一致，那么这些微表面才会被看到（只考虑镜面反射）。这是一个宏观的理解，实际上 NDF 描述的就是微表面的法线的概率分布：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161221287.png" alt="image-20220608161221287"></p>
<p>有不同的模型来描述法线分布，比如之前提到过的 Beckmann 法线分布函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161340128.png" alt="image-20220608161340128"></p>
<p>该函数由表面粗糙程度 $\alpha$ 和微表面法线与宏观法线（一般是 [0, 0, 1]）的夹角 $\theta_h$ 来定义，从公式可以看出，Beckmann 法线分布实际上和高斯分布非常像，其中表面粗糙程度 $\alpha$ 就类似于正态分布的标准差，粗糙程度越大，法线分布就越分散，而这个正态分布是对于 $tan\theta_h$ 的正态分布， $tan\theta_h$ 的几何意义如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608161702625.png" alt="image-20220608161702625"></p>
<p>如果直接定义为夹角 $\theta_h$ 的正态分布，那么法线可能取到下半球，夹角就大于 90 度，而对于法线来说只有上半球有意义，因此定义为 $tan\theta_h$ 的正态分布的好处在于可以把上半球的所有法线方向对应到一个平面上的区间，这个区间是无穷大的，刚好是正态分布的积分区间，这样定义自然当法线在下半球的时候没有意义，是一个很巧妙的处理。</p>
<p>另一个更好的法线分布函数是 GGX 模型，也叫做 Trowbridge-Reitz（TR）模型，相较于 Beckmann 模型，GGX 是长尾（long tail）分布的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162529565.png" alt="image-20220608162529565"></p>
<p>也就是过度更加平滑，在值较小的部分衰减速度也更小，这样的好处是高光区域和非高光区域的过渡会更加平滑，呈现出一种 Glossy 的效果，更加真实：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162719493.png" alt="image-20220608162719493"></p>
<p>在 TR 模型的基础上还有一个更加通用的 GTR 法线分布，引入了一个可调的参数来控制长尾分布的程度：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608162902522.png" alt="image-20220608162902522"></p>
<p>总之，法线分布函数描述的是微表面的法线方向分布，对于给定的入射和出射方向，可以得到半程向量，法线分布函数可以给出这个材质的表面上有多少微表面的法线是在这个半程向量方向上的，那么这些微表面才可以被看到。更准确的说，NDF 描述的是法线方向的概率分布，渲染时，对于每一个着色点都有不同的半程向量，这个半程向量对应的可以被看到的概率可以通过 NDF 得出，可以被看到也就是表面法线和半程向量方向一致，因此 NDF 给出的概率实际上是当前着色点的法线刚好和当前半程向量重合的概率，而一个点的着色结果是许多不同的半程向量的结果的加权平均，权值就是这个概率，这样就能得到这个着色点正确期望的着色结果。</p>
<h4 id="1-3-几何项"><a href="#1-3-几何项" class="headerlink" title="1.3 几何项"></a>1.3 几何项</h4><p>几何项描述的是微表面之间的自遮挡现象，自遮挡现象有两种情况：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163456607.png" alt="image-20220608163456607"></p>
<p>一种是入射光被其他微表面遮挡入射不进来，一种是反射光被其他微表面遮挡反射不出去，前者称为 shadowing，后者称为 masking，因此几何项也被称为 Shadowing-Masking Term。</p>
<p>从上面的定义可以看出，当我们垂直于表面观察时，几乎不会发生自遮挡，当我们观察方向越接近法线的垂直方向，自遮挡就会越严重，因此对应于上面的法线分布得出的几何项分布大概长这样：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163757728.png" alt="image-20220608163757728"></p>
<p>几何项的意义在于，当我们垂直于表面观察的时候，几何项就是 1，对最终结果不会有任何影响，但是当我们接近垂直于法线的方向观察时，比如一个球体的边缘：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163914474.png" alt="image-20220608163914474"></p>
<p>如果不考虑几何项，那么按照微表面 BRDF 的定义：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608163942337.png" alt="image-20220608163942337"></p>
<p>其他两项可以计算出正常结果，但是分母中有观察方向和法线的点乘，由于我们是接近垂直于法线的方向观察的，那么这个点乘结果就会接近于 0，于是整个BRDF 结果就会非常大，如果没有几何项来修正这个结果，那么最终的渲染图像上球体边缘就会是一圈白色。根据上面的几何项曲线可以看出，几何项在夹角接近 90 度的时候迅速变为 0，从而修正了这个非常大的结果。</p>
<h3 id="2-Kulla-Conty-Approximation"><a href="#2-Kulla-Conty-Approximation" class="headerlink" title="2 Kulla-Conty Approximation"></a>2 Kulla-Conty Approximation</h3><p>上面回顾了微表面模型，并进一步深入理解了各个项的作用，通过上面的分析我们可以很容易得出一个结论：微表面模型只考虑了光线在微表面之间的一次反射。被挡住的光线就认为看不到，这样做的结果就是微表面模型是能量不守恒的，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608164659865.png" alt="image-20220608164659865"></p>
<p>随着粗糙程度增大，最终的渲染结果会越来越暗，因为粗糙程度越大意味着法线分布越分散，从而微表面之间的遮挡也会越严重，在微表面模型中被遮挡掉的能量就被丢掉不考虑了，所以自然会越来越暗。</p>
<p>实际上被遮挡的光线还会在微表面之间弹射从而被看到，因此为了解决这个问题，提出了 Kulla-Conty 估计，用来近似估计光线在微表面之间的多次弹射。</p>
<p>Kulla-Conty 估计基于一个关键思想：微表面 BRDF 只考虑了没有被遮挡的能量，那么如果能再设计一个 BRDF 来专门描述被遮挡的能量就可以修正微表面的结果了。</p>
<p>于是首先要知道没有被遮挡的能量是多少，我们假设入射光强度恒为 1，然后对微表面 BRDF 的渲染方程在整个半球面上积分：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165256048.png" alt="image-20220608165256048"></p>
<p>注意上面的式子中用了一个简单的积分换元，把 $d\theta$ 换成了 $dsin\theta$，这样一来原本渲染方程中的 cos 项也就没有了，光照项为常数 1，因此上面的积分结果就代表了微表面模型中在出射方向 $\mu_o$ 上全部被看到的能量总和，因为光照项为 1，所以该结果是一个系数，表示出射方向 $\mu_o$ 上被看到的能量占全部能量的比例。</p>
<p>于是因为遮挡而没被看到的能量总和自然就是 $1-E(\mu_o)$，因此，我们要设计一个 BRDF 来专门描述被遮挡的能量，那么这个 BRDF 在半球面上的积分结果就必须是 $1-E(\mu_o)$。</p>
<p>考虑到 BRDF 具有双向可逆性，因此 Kulla-Conty 估计设计了这样一个 BRDF：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608165644101.png" alt="image-20220608165644101"></p>
<p>这个 BRDF 的形式并不是唯一的，只要能保证函数在半球的积分结果是 $1-E(\mu_o)$ 就可以，只是 Kulla-Conty 这样设计既把积分结果本身放到了函数中，还考虑了双向可逆的性质，非常巧妙。</p>
<p>于是通过积分结果为 $1-E(\mu_o)$ 可以求出常数 c：<br>$$<br>c &#x3D; \frac{1}{\pi(1-E_{avg})}<br>$$<br>其中：<br>$$<br>E_{avg} &#x3D; \frac{\int_0^1E(\mu)\mu d\mu}{\int_0^1\mu d\mu} &#x3D; 2\int_0^1E(\mu)\mu d\mu<br>$$<br>相当于对上面的 $E(\mu_o)$ 做了一个加权平均，权值就是各个方向的夹角正弦 $\mu$，于是整个 Kulla-Conty 估计就是：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170245422.png" alt="image-20220608170245422"></p>
<p>容易验证该函数在半球面上积分结果为 $1-E(\mu_o)$：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608170313862.png" alt="image-20220608170313862"></p>
<p>因此这个函数可以作为描述被遮挡的能量的 BRDF，现在的问题是 $E_{avg}$ 是对一个积分 $E(\mu)$ 再进行积分，实时计算起来比较复杂，所以需要进行预计算。</p>
<p>对于 $E(\mu)$ 这个积分，是对全部入射方向 $\mu_i$ 的积分，因此积分结果只与观察方向和法线的夹角正弦 $\mu_o$ 和粗糙程度 $\alpha$ 有关，于是预计算的积分结果可以用一张二维纹理来存储：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608171651408.png" alt="image-20220608171651408"></p>
<p>而对于 $E_{avg}$ 这个积分，是对 $\mu_o$ 的积分，所以积分结果只与粗糙程度 $\alpha$ 有关，只需要一个一维纹理就可以存储。</p>
<p>将 Kulla-Conty 的结果加到微表面 BRDF 的结果上就可以近似模拟光线在微表面之间多次弹射的结果，达到能量守恒：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172124188.png" alt="image-20220608172124188"></p>
<p>接下来还有最后一个问题，上面的所有推导都是假设物体表面没有颜色，也就是反射率恒为 1，如果物体表面有颜色，那么能量在每次弹射后都会损失，如何计算这种损失来得到正确的结果呢？</p>
<p>Kulla-Conty 又计算了菲涅尔项的加权平均：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608172427624.png" alt="image-20220608172427624"></p>
<p>这表示每次弹射，表面上有多少能量被反射。这类似于上面的 $E_{avg}$， $E_{avg}$ 表示表面上有多少能量没被遮挡能够被看到，于是我们可以直接看到的能量就可以表示为：<br>$$<br>F_{avg}E_{avg}<br>$$<br>没被看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})<br>$$<br>这部分能量会在微表面之间继续弹射，于是经过一次弹射后被我们看到的能量就是：<br>$$<br>F_{avg}(1-E_{avg})·F_{avg}E_{avg}<br>$$<br>以此类推，可以写出经过无数次弹射后的能量，将这些能量加起来，就可以得到当物体有颜色的时候，光线在微表面之间多次弹射后反射出的能量，这是一个级数求和问题，最终的结果是：<br>$$<br>\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}<br>$$<br>将这个系数乘到 Kulla-Conty 的 BRDF 上就可以得到有颜色的情况下被遮挡的能量的 BRDF 了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173223545.png" alt="image-20220608173223545"></p>
<h3 id="3-Linearly-Transformed-Cosines（LTC）"><a href="#3-Linearly-Transformed-Cosines（LTC）" class="headerlink" title="3 Linearly Transformed Cosines（LTC）"></a>3 Linearly Transformed Cosines（LTC）</h3><p>有了微表面 BRDF，另一个需要解决的问题是如何使用微表面模型进行渲染。线性变换余弦（LTC）方法是用来解决多边形面光源下，使用微表面 BRDF，主要是 GGX 法线模型的渲染而提出的方法（不考虑阴影）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608173712743.png" alt="image-20220608173712743"></p>
<p>当然 LTC 不仅适用于上述情况，对于类似 GGX 法线分布的其他微表面模型也都有很好的效果。</p>
<p>在离线渲染中处理这样的渲染自然是对面光源进行采样计算，但实时渲染需要快速得到渲染结果，而不同的 BRDF 我们不知道它的分布是什么样的，所以也不容易快速求出这个 BRDF 积分的渲染方程的解析解，因此 LTC 将 BRDF 变换成一个 cos 函数，然后对所有的方向、以及面光源（积分区域）都做同样的变换：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174038845.png" alt="image-20220608174038845"></p>
<p>这样就将原积分转化为了一个对余弦函数的积分，保证可以快速求出解析解。具体来说，就是将原本的函数 $F(w_i)$ 变换为 $cos(w_i)$，为了便于理解，我们假设 BRDF 是各向同性的，于是 $F(w_i)$ 实际上和方位角无关，在出射方向固定的情况下就是一个只与俯仰角有关的一维函数，所以可以变换到一维的 cos 函数上，事实上 LTC 也可以处理各向异性的情况，这里就不展开讨论了。</p>
<p>然后将积分变量 $dw_i$ 同样变换为 $dw’_{i}$，实际上就是对原积分进行了换元：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174727016.png" alt="image-20220608174727016"></p>
<p>这样就可以快速求出解析解了。LTC 方法虽然思路很简单，但是效果却非常优秀，因此目前被广泛使用：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608174837806.png" alt="image-20220608174837806"></p>
<h3 id="4-Disney’s-Principled-BRDF"><a href="#4-Disney’s-Principled-BRDF" class="headerlink" title="4 Disney’s Principled BRDF"></a>4 Disney’s Principled BRDF</h3><p>Disney’s Principled BRDF 是目前工业界非常知名的，非常强大的开源 BRDF。微表面 BRDF 的问题之一在于不能够表达复合材质，现实世界中许多材质不是单一的，是多种材质的组合，比如蒙上一层塑料布的木头桌子，那么它的表面就有多层材质，光照表现自然和普通桌子不同，而 Disney’s Principled BRDF 具有强大的表达能力，可以表达各种复合材质。</p>
<p>并且 Disney’s Principled BRDF 摒弃了传统基于物理的材质的各种物理参数，只使用一些非常符合人直觉的参数就可以进行调节，对于艺术家非常友好，这也是迪士尼设计这个 BRDF 的原则之一，这些原则有：</p>
<ul>
<li>使用符合人直觉的参数而不是各种难懂的物理量</li>
<li>越少的参数越好</li>
<li>所有参数都是从 0 到 1 调节的</li>
<li>在一些合理的情况下允许参数不在 0 到 1 范围内</li>
<li>所有参数的任意组合都必须得出合理的结果，而不是某些非常奇怪的结果</li>
</ul>
<p>能够满足上述原则的 BRDF 可以说是完美的，虽然严格来说迪士尼的 BRDF 不是基于物理的，而是进行了各种非常复杂的拟合，但是也常被归为基于物理的 BRDF。</p>
<p>下图是一些可以调节的参数和得出的材质效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220608175902209.png" alt="image-20220608175902209"></p>
<p>从上到下依次是：</p>
<ul>
<li>次表面散射 subsurface：值越大次表面散射越严重，物体看起来更像一个平面</li>
<li>金属度 metallic：值越大物体越像金属</li>
<li>高光度 specular：值越大物体高光反射越强</li>
<li>高光颜色 specularTint：可以调节高光反射的颜色</li>
<li>粗糙程度 roughness：值越大物体表面越粗糙</li>
<li>各向异性程度 anisotropic：值越大物体表面越呈现各向异性</li>
<li>绒毛 sheen：绒毛相当于物体表面每个点都有一根朝向法线方向的绒毛，表现出来就是物体边缘会有模糊感，值越大绒毛越明显</li>
<li>绒毛颜色 sheenTint：控制绒毛颜色</li>
<li>表面通透 clearcoat：类似于给物体表面蒙上一层透明的漆，值越大这个效果越明显</li>
<li>表面通透颜色 clearcoatGloss：表面通透高光的锐利度，值越大高光越锐利</li>
</ul>
<p>上面的所有参数可以随意组合，表达各种复合材质，所以迪士尼 BRDF 的表达能力非常强。</p>
<h3 id="5-Specular-Glossiness-模型"><a href="#5-Specular-Glossiness-模型" class="headerlink" title="5 Specular Glossiness 模型"></a>5 Specular Glossiness 模型</h3><p>Specular Glossiness（SG）模型是在 Disney’s Principled BRDF 的启发下提出的便于实时渲染的 PBR 材质模型，SG 将所有描述材质需要用到的值都存在各种纹理中，渲染时只需要通过简单的纹理采样就可以计算出基于物理的光照结果，不需要调整任何参数，非常方便。</p>
<p>SG 模型使用三张纹理来存储信息，分别是：Diffuse、Specular 和 Glossiness。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613104930087.png" alt="image-20220613104930087"></p>
<p>Diffuse 存储物体的基础颜色，使用 RGB 三个通道；Specular 存储菲涅尔项的基础反射率，也就是菲涅尔近似公式中的 F0，同样对应 RGB 三个通道；Glossiness 是一个标量，用于控制表面光滑程度。</p>
<p>通过这三张纹理，就可以得到物体表面任何一个点对应的 F、D 和 G 项，从而根据微表面模型计算光照结果，下面是使用 SG 模型计算着色的代码，可以非常直观的感受到 SG 模型有多方便：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613105637113.png" alt="image-20220613105637113"></p>
<p>首先根据漫反射颜色计算出了漫反射项，然后根据微表面模型计算高光反射项，其中粗糙程度根据 Glossiness 采样结果得到，基础反射率 F0 根据 Specular 采样结果得到，再结合各种简单的点乘就可以得到 D、F 和 G 项，最后根据公式计算微表面 specular 结果，加上漫反射结果就是整个 BRDF 结果。有了 BRDF 就可以根据渲染方程得到着色结果了。</p>
<h3 id="6-Metallic-Roughness-模型"><a href="#6-Metallic-Roughness-模型" class="headerlink" title="6 Metallic Roughness 模型"></a>6 Metallic Roughness 模型</h3><p>Metallic Roughness（MR）是对 SG 模型的又一层封装，SG 模型可以自由地调节漫反射颜色和基础反射率，但有时这对于艺术家来说还是不够直观，因此 MR 使用了另外三个贴图来描述材质：Base Color、Roughness 和 Metallic。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110249250.png" alt="image-20220613110249250"></p>
<p>其中 Base Color 是物体的基础颜色，RGB 三通道；Roughness 和 Metallic 都是标量，分别代表表面粗糙程度和金属度。使用的时候游戏引擎内部会将这些值转化为 SG 模型中的值，下面是转化代码：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/08/20220608-GAMES202-%E5%AE%9E%E6%97%B6PBR%E6%9D%90%E8%B4%A8/image-20220613110606512.png" alt="image-20220613110606512"></p>
<p>可以看到金属度 Metallic 是一个插值系数，用来从 base color 中取出一定的颜色到介质基本的颜色上，从而构成 SG 模型中的 F0，回顾前文中菲涅尔项的曲线图，金属的基础反射率是非常高的，所以金属度高的时候 base color 中很大一部分颜色就被取出到 F0 中，使得基础反射率变高，而 base color  剩下的颜色就作为 SG 中的 diffuse，于是金属度高就会使 diffuse 很小，也就是金属几乎不会发生漫反射，这和菲涅尔项描述的是完全一致的，所以 MR 模型中的基础颜色就是 diffuse 和 specular 的结合，金属度 Metallic 可以将他们拆分开来，但 base color 的概念对于艺术家来说要比 diffuse 和 specular 更好理解。粗糙程度 Roughness 和 SG 中的光滑程度 Glossiness 相反，二者之间可以互相转化，本质上是一样的。</p>
<p>MR 和 SG 相比，更便于人们理解，但没有 SG 灵活，因为 MR 不能够自己调节 F0，而是全部包含在了 base color 中，但也因此避免了艺术家如果使用 SG，但给出了错误的 F0 而导致的菲涅尔项错误的情况，各有利弊。</p>
]]></content>
      <categories>
        <category>高质量实时渲染</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
        <tag>实时渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【Piccolo代码解读】整体框架与反射机制</title>
    <url>/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>本节主要了解 Piccolo 游戏引擎的代码框架、对象序列化的实现以及反射机制的实现。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-引擎运行结果"><a href="#1-引擎运行结果" class="headerlink" title="1 引擎运行结果"></a>1 引擎运行结果</h3><p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220619142030660.png" alt="image-20220619142030660"></p>
<h3 id="2-代码整体框架"><a href="#2-代码整体框架" class="headerlink" title="2 代码整体框架"></a>2 代码整体框架</h3><p>Pilot 引擎除了第三方库之外，主要包含四部分，分别是编辑器、预编译、引擎运行时核心和 Shader 编译，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220617091342823.png" alt="image-20220617091342823"></p>
<p>其中预编译部分负责预先生成一些文件，比如用来实现反射的文件，会在后文中提到，Shader 编译部分在之后的渲染系统代码中也会说到。编辑器负责整个引擎的界面、工具等的实现，需要引擎核心部分作为成员，是引擎核心功能对使用者的接口；引擎核心部分按照<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/28/20220428-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/">【游戏引擎】（一）游戏引擎架构</a>中的分层结构实现，分别是核心层、功能层、平台层、资源层：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/17/20220617-Pilot-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%B0%84/image-20220617092113728.png" alt="image-20220617092113728"></p>
<p>而 engine.cpp 负责将这些系统整合起来构成完整的运行时引擎。</p>
<p>整个引擎的主函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;runtime/engine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;editor/include/editor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://gcc.gnu.org/onlinedocs/cpp/Stringizing.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_XSTR(s) PILOT_STR(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PILOT_STR(s) #s</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::filesystem::path pilot_root_folder = std::filesystem::<span class="built_in">path</span>(<span class="built_in">PILOT_XSTR</span>(PILOT_ROOT_DIR));</span><br><span class="line"></span><br><span class="line">    Pilot::EngineInitParams params;</span><br><span class="line">    params.m_root_folder      = pilot_root_folder;</span><br><span class="line">    params.m_config_file_path = pilot_root_folder / <span class="string">&quot;PilotEditor.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEngine* engine = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEngine</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">startEngine</span>(params);</span><br><span class="line">    engine-&gt;<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">    Pilot::PilotEditor* editor = <span class="keyword">new</span> Pilot::<span class="built_in">PilotEditor</span>();</span><br><span class="line">    editor-&gt;<span class="built_in">initialize</span>(engine);</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    editor-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    engine-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    engine-&gt;<span class="built_in">shutdownEngine</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从主函数出发可以大概了解引擎运行时的整体架构。主函数中首先初始化了运行时引擎，然后启动和初始化引擎，之后用运行时引擎初始化编辑器，再让编辑器运行，编辑器运行结束后先清理编辑器内容再清理引擎内容。</p>
<p>其中关键的函数就是 <code>editor-&gt;run()</code> 了，函数内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEditor::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m_engine_runtime);</span><br><span class="line">    <span class="built_in">assert</span>(m_editor_ui);</span><br><span class="line">    <span class="type">float</span> delta_time;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delta_time = m_engine_runtime-&gt;<span class="built_in">calculateDeltaTime</span>();</span><br><span class="line">        g_editor_global_context.m_scene_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        g_editor_global_context.m_input_manager-&gt;<span class="built_in">tick</span>(delta_time);</span><br><span class="line">        <span class="keyword">if</span> (!m_engine_runtime-&gt;<span class="built_in">tickOneFrame</span>(delta_time))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断了运行时引擎和引擎 UI 是否初始化成功，然后就是运行时主循环了，循环内就是各种 <code>tick()</code> 函数，其中最重要的是运行时引擎的 <code>tickOneFrame</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PilotEngine::tickOneFrame</span><span class="params">(<span class="type">float</span> delta_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">logicalTick</span>(delta_time);</span><br><span class="line">    <span class="built_in">calculateFPS</span>(delta_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single thread</span></span><br><span class="line">    <span class="comment">// exchange data between logic and render contexts</span></span><br><span class="line">    g_runtime_global_context.m_render_system-&gt;<span class="built_in">swapLogicRenderData</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rendererTick</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">pollEvents</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.m_window_system-&gt;<span class="built_in">setTile</span>(</span><br><span class="line">        std::<span class="built_in">string</span>(<span class="string">&quot;Pilot - &quot;</span> + std::<span class="built_in">to_string</span>(<span class="built_in">getFPS</span>()) + <span class="string">&quot; FPS&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> should_window_close = g_runtime_global_context.m_window_system-&gt;<span class="built_in">shouldClose</span>();</span><br><span class="line">    <span class="keyword">return</span> !should_window_close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其中包含 <code>logicalTick()</code> 和 <code>rendererTick()</code> 两部分，和我们之前笔记中描述的流程完全一致，当窗口关闭时函数返回 false，于是引擎主循环就会退出。</p>
<h3 id="3-代码反射"><a href="#3-代码反射" class="headerlink" title="3 代码反射"></a>3 代码反射</h3><p>代码反射是指允许在运行时检查已知数据类型。 反射允许枚举给定程序集中的数据类型，并且可以发现给定类或值类型的成员。 无论类型在编译时是已知的还是引用的，都是如此。 这使得反射成为开发和代码管理工具的有用功能。</p>
<p>定义很抽象，通过一个实际场景来理解，比如引擎中对于不同对象要显示出它的组件，但是不同对象的属性不同，我们不可能为每个类都编写一个组件面板，这时通过反射，就可以快速方便的知道一个类中有哪些成员变量，他们都是什么类型。</p>
<p>反射的另一个作用是在对象序列化时使用，所谓序列化就是存储到磁盘上，将对象变成一定格式的二进制文件或者自定义格式的文件（如json），然后要用的时候再将保存在磁盘上的文件转化成一个内存中的对象，这个过程中总是需要有一个指示来告诉编译器要生成什么样的对象，最简单的方式当然就是类名了，例如：将一个 ClassXXX 对象存储到磁盘上，再从磁盘读取的时候让编译器根据 “ClassXXX” 名称来 new 一个对象。但问题是，C++ 语言本身不支持反射，也就是说不能通过类的名称字符串来生成一个对象，像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassXXX object = <span class="keyword">new</span> “ClassXXX”;</span><br></pre></td></tr></table></figure>

<p>于是就需要反射机制来实现这个功能。</p>
<p>反射的实现方法是，提前处理需要反射的类型，生成一个类似配置文件的东西，在 Pilot 引擎中也是一个 C++ 文件，在预编译阶段生成，文件中包含一个类有哪些属性变量、父类。这些属性变量的 get 、set、getFieldName 获取变量的名字、getFieldTypeName 获取变量的类型、isArray_id 是不是数组等方法，都被封装成一个结构体，与类型的名字（字符串类型）做一个映射（map）。<br>在运行的时候加载这些配置表，这样我们其实通过一个类型的名字就可以知道他有什么变量，以及这些变量的具体属性和方法，然后就可以把这个类型当做一个方法集，与类型的实例挂钩就可以方便的处理这个实例的各个属性。</p>
<p>接下来我们以常用的 Vector3 类为例，来看看 Pilot 中的反射实现。首先是类的声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">REFLECTION_TYPE</span>(Vector3)</span><br><span class="line"><span class="built_in">CLASS</span>(Vector3, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(Vector3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> y &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> z &#123;<span class="number">0.f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了三个宏定义，他们都在 <code>reflection.h</code> 中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS(class_name, ...) class class_name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_BODY(class_name) \</span></span><br><span class="line"><span class="meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">    friend class PSerializer;</span></span><br><span class="line">    <span class="comment">// public: virtual std::string getTypeName() override &#123;return #class_name;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_TYPE(class_name) \</span></span><br><span class="line"><span class="meta">    namespace Reflection \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        namespace TypeFieldReflectionOparator \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            class Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br></pre></td></tr></table></figure>

<p>可以看到首先声明了与类名称有关的 <code>Type##class_name##Operator</code> 类，<code>##</code> 是连接符，将两个字符串连接起来，这里生成的类则Iran就是 <code>TypeVector3Operator</code>，然后将该类和序列化类 <code>PSerializer</code> 作为了 Vector3 类的友元。</p>
<p><code>TypeVector3Operator</code> 类在 <code>vector3.reflection.gen.h</code> 文件中定义，这个文件是预编译阶段生成的，其中定义的就是对该类的各种回调函数，包括返回类名称，序列化类对象，通过序列化的 json 文件构建该类的对象，获取该类的基类，以及上面说到的对成员变量的各种方法，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;D:/TechStack/GamesEngine/PilotEngine/Pilot-main/engine/source/runtime/core/math/vector3.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Pilot&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector3</span>;</span><br><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line"><span class="keyword">namespace</span> TypeFieldReflectionOparator&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">TypeVector3Operator</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getClassName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Vector3&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">constructorWithJson</span><span class="params">(<span class="type">const</span> PJson&amp; json_context)</span></span>&#123;</span><br><span class="line">          Vector3* ret_instance= <span class="keyword">new</span> Vector3;</span><br><span class="line">          PSerializer::<span class="built_in">read</span>(json_context, *ret_instance);</span><br><span class="line">          <span class="keyword">return</span> ret_instance;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> PJson <span class="title">writeByName</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> PSerializer::<span class="built_in">write</span>(*(Vector3*)instance);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// base class</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getVector3BaseClassReflectionInstanceList</span><span class="params">(ReflectionInstance* &amp;out_list, <span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// fields</span></span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;x));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;y&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_y</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_y</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;y));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;z&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_z</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_z</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector3*&gt;(instance)-&gt;z));&#125;</span><br><span class="line">       <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_z</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="comment">//namespace TypeFieldReflectionOparator</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">TypeWrapperRegister_Vector3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_x=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_x,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_x);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_x);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_y=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_y,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_y);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_y);</span><br><span class="line">       FieldFunctionTuple* f_field_function_tuple_z=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::set_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::get_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getClassName,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getFieldTypeName_z,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::isArray_z);</span><br><span class="line">       <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_field_function_tuple_z);</span><br><span class="line">       ClassFunctionTuple* f_class_function_tuple_Vector3=<span class="keyword">new</span> <span class="built_in">ClassFunctionTuple</span>(</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::getVector3BaseClassReflectionInstanceList,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::constructorWithJson,</span><br><span class="line">           &amp;TypeFieldReflectionOparator::TypeVector3Operator::writeByName);</span><br><span class="line">       <span class="built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="string">&quot;Vector3&quot;</span>, f_class_function_tuple_Vector3);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">namespace</span> TypeWrappersRegister&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Vector3</span><span class="params">()</span></span>&#123; <span class="built_in">TypeWrapperRegister_Vector3</span>();&#125;</span><br><span class="line">&#125;<span class="comment">//namespace TypeWrappersRegister</span></span><br><span class="line">&#125;<span class="comment">//namespace Reflection</span></span><br><span class="line">&#125;<span class="comment">//namespace Pilot</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中还有注册这些回调函数的函数 <code>TypeWrapperRegister_Vector3</code>，函数中就是对所有成员的方法进行了注册，所谓注册就是将这些函数和类型名称对应起来，放到哈希表中，实现方法是用变量的各种方法初始化一个 <code>FieldFunctionTuple</code> 元组，这个元组的声明同样在 <code>reflection.h</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*, <span class="type">void</span>*)&gt;      SetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">void</span>*)&gt;            GetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">const</span> <span class="type">char</span>*()&gt;           GetNameFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span>*)&gt; SetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">int</span>, <span class="type">void</span>*)&gt;       GetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">void</span>*)&gt;              GetSizeFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">bool</span>()&gt;                  GetBoolFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">const</span> PJson&amp;)&gt;                          ConstructorWithPJson;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;PJson(<span class="type">void</span>*)&gt;                                 WritePJsonByName;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt;</span><br><span class="line">    FieldFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetBaseClassReflectionInstanceListFunc, ConstructorWithPJson, WritePJsonByName&gt;</span><br><span class="line">    ClassFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetArrayFunc, GetArrayFunc, GetSizeFunc, GetNameFuncion, GetNameFuncion&gt; ArrayFunctionTuple;</span><br></pre></td></tr></table></figure>

<p>元组中存放的就是各类函数的指针，然后通过一个宏定义 <code>REGISTER_FIELD_TO_MAP</code> 注册这些函数，该宏定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_FIELD_TO_MAP(name, value) TypeMetaRegisterinterface::registerToFieldMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_BASE_CLASS_TO_MAP(name, value) TypeMetaRegisterinterface::registerToClassMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_ARRAY_TO_MAP(name, value) TypeMetaRegisterinterface::registerToArrayMap(name, value);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNREGISTER_ALL TypeMetaRegisterinterface::unregisterAll();</span></span><br></pre></td></tr></table></figure>

<p>实际上宏定义就是调用了 <code>TypeMetaRegisterinterface</code> 类中的方法，该类是用来注册各种回调函数的接口，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeMetaRegisterinterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">unregisterAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类中的各种方法就是用来将给定的函数指针元组和类名称关联起来，存放到全局定义的哈希表中，以类名为键，这样之后使用时通过类名就可以找到类中各种成员变量的名称、类型、方法了，这部分在 <code>reflection.cpp</code> 中实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown_type = <span class="string">&quot;UnknownType&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* k_unknown      = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;      m_class_map;</span><br><span class="line">    <span class="type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt; m_field_map;</span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;      m_array_map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToFieldMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, FieldFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_field_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToArrayMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ArrayFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_array_map.<span class="built_in">find</span>(name) == m_array_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_array_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::registerToClassMap</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, ClassFunctionTuple* value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_class_map.<span class="built_in">find</span>(name) == m_class_map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_class_map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(name, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegisterinterface::unregisterAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_field_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_field_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_class_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_class_map.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; itr : m_array_map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> itr.second;</span><br><span class="line">        &#125;</span><br><span class="line">        m_array_map.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有需要反射的类都会在运行时引擎启动时进行注册，也就是之前主函数中的 <code>engine-&gt;startEngine()</code> 函数，该函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PilotEngine::startEngine</span><span class="params">(<span class="type">const</span> EngineInitParams&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_init_params = param;</span><br><span class="line"></span><br><span class="line">    Reflection::TypeMetaRegister::<span class="built_in">Register</span>();</span><br><span class="line"></span><br><span class="line">    g_runtime_global_context.<span class="built_in">startSystems</span>(param);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;engine start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>TypeMetaRegister</code> 类就是用来注册函数的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> Pilot</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> Reflection</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TypeMetaRegister</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Register</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Unregister</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="comment">// namespace Reflection</span></span><br><span class="line">&#125; <span class="comment">// namespace Pilot</span></span><br></pre></td></tr></table></figure>

<p><code>Register()</code> 函数就是调用了各个类的注册函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TypeMetaRegister::Register</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Transform</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Quaternion</span>();</span><br><span class="line">    TypeWrappersRegister::<span class="built_in">Vector3</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对象序列化和反射的使用示例，Pilot 也提供了一个样例代码，在 <code>meta/meta_example.cpp</code> 中。</p>
]]></content>
      <categories>
        <category>Piccolo引擎代码解读</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU架构深度解析</title>
    <url>/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>本篇以 NVIDIA 为代表详细解析现代 GPU 架构，深入理解 GPU 运行机制，有助于理解大型引擎的渲染系统构建和渲染优化思路。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-GPU-架构发展"><a href="#1-GPU-架构发展" class="headerlink" title="1 GPU 架构发展"></a>1 GPU 架构发展</h3><p>NVIDIA GPU 架构历经多次变革，从起初的 Tesla 发展到最新的 Turing 架构，发展史可分为以下时间节点：</p>
<ul>
<li><p><strong>2008 - Tesla</strong></p>
<p>Tesla最初是给计算处理单元使用的，应用于早期的CUDA系列显卡芯片中，并不是真正意义上的普通图形处理芯片。</p>
</li>
<li><p><strong>2010 - Fermi</strong></p>
<p>Fermi是第一个完整的GPU计算架构。首款可支持与共享存储结合纯cache层次的GPU架构，支持ECC的GPU架构。</p>
</li>
<li><p><strong>2012 - Kepler</strong></p>
<p>Kepler相较于Fermi更快，效率更高，性能更好。</p>
</li>
<li><p><strong>2014 - Maxwell</strong></p>
<p>其全新的立体像素全局光照 (VXGI) 技术首次让游戏 GPU 能够提供实时的动态全局光照效果。基于 Maxwell 架构的 GTX 980 和 970 GPU 采用了包括多帧采样抗锯齿 (MFAA)、动态超级分辨率 (DSR)、VR Direct 以及超节能设计在内的一系列新技术。</p>
</li>
<li><p><strong>2016 - Pascal</strong></p>
<p>Pascal 架构将处理器和数据集成在同一个程序包内，以实现更高的计算效率。1080系列、1060系列基于Pascal架构</p>
</li>
<li><p><strong>2017 - Volta</strong></p>
<p>Volta 配备640 个Tensor 核心，每秒可提供超过100 兆次浮点运算(TFLOPS) 的深度学习效能，比前一代的Pascal 架构快5 倍以上。</p>
</li>
<li><p><strong>2018 - Turing</strong></p>
<p>Turing 架构配备了名为 RT Core 的专用光线追踪处理器，能够以高达每秒 10 Giga Rays 的速度对光线和声音在 3D 环境中的传播进行加速计算。Turing 架构将实时光线追踪运算加速至上一代 NVIDIA Pascal™ 架构的 25 倍，并能以高出 CPU 30 多倍的速度进行电影效果的最终帧渲染。2060系列、2080系列显卡也是跳过了Volta直接选择了Turing架构。</p>
</li>
</ul>
<p>各架构的微观物理结构可以查看<a href="https://www.cnblogs.com/timlly/p/11471507.html#32-gpu%E5%BE%AE%E8%A7%82%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84">深入GPU硬件架构及运行机制-gpu微观物理结构</a>。</p>
<h3 id="2-GPU-的功能"><a href="#2-GPU-的功能" class="headerlink" title="2 GPU 的功能"></a>2 GPU 的功能</h3><p>现代GPU除了绘制图形外，还担当了很多额外的功能，综合起来如下几方面：</p>
<ul>
<li><p><strong>图形绘制。</strong></p>
<p>这是GPU最传统的拿手好戏，也是最基础、最核心的功能。为大多数PC桌面、移动设备、图形工作站提供图形处理和绘制功能。</p>
</li>
<li><p><strong>物理模拟。</strong></p>
<p>GPU硬件集成的物理引擎（PhysX、Havok），为游戏、电影、教育、科学模拟等领域提供了成百上千倍性能的物理模拟，使得以前需要长时间计算的物理模拟得以实时呈现。</p>
</li>
<li><p><strong>海量计算。</strong></p>
<p>计算着色器及流输出的出现，为各种可以并行计算的海量需求得以实现，CUDA就是最好的例证。</p>
</li>
<li><p><strong>AI运算。</strong></p>
<p>近年来，人工智能的崛起推动了GPU集成了AI Core运算单元，反哺AI运算能力的提升，给各行各业带来了计算能力的提升。</p>
</li>
<li><p><strong>其它计算。</strong></p>
<p>音视频编解码、加解密、科学计算、离线渲染等等都离不开现代GPU的并行计算能力和海量吞吐能力。</p>
</li>
</ul>
<h3 id="3-GPU-逻辑架构"><a href="#3-GPU-逻辑架构" class="headerlink" title="3 GPU 逻辑架构"></a>3 GPU 逻辑架构</h3><p>下图是图形架构的微观结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001056361-789565826.png" alt="1617944-20190906001056361-789565826"></p>
<p>从 Fermi 开始 NVIDIA 都使用类似的原理架构，使用一个 Giga Thread Engine 来管理所有正在进行的工作，GPU 被划分成多个 GPCs(Graphics Processing Cluster)，每个 GPC 拥有多个 SM（或者SMX、SMM）和一个光栅化引擎（Raster Engine）。</p>
<p>程序员编写的 shader 是在 SM 上完成的。每个 SM 包含许多为线程执行数学运算的 Core，一个线程可以是顶点或像素着色器调用。这些 Core 包括整数运算的 ALU，浮点运算的 FPU，特殊函数运算的 SFU，用于深度学习的 Tensor Core 和用于光线追踪的 RT Core 等等。这些 Core 和其它单元由 Warp Scheduler  驱动，Warp Scheduler 管理一组 32 个线程作为 Warp（线程束）并将要执行的指令移交给 Dispatch Units。</p>
<p>例如下图是图灵架构单个 SM 的结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001113377-1820574161.png" alt="1617944-20190906001113377-1820574161"></p>
<p>其中包含：</p>
<ul>
<li>4 个 Warp Schedulers：这个模块负责 warp 调度，一个 warp 由 32 个线程组成，warp 调度器的指令通过 Dispatch Units 送到 Core 执行</li>
<li>64 CUDA 核，每个 CUDA 核包含一个整数运算单元（上图中 INT32）和一个浮点数运算单元（上图中 FP32）</li>
<li>16 个 LD&#x2F;ST（load&#x2F;store）模块来加载和存储数据</li>
<li>4 个 SFU（Special function units）执行特殊数学运算（sin、cos、log 等）</li>
<li>256KB 寄存器（4 个 16384 * 32 bit 的 Register File）</li>
<li>96KB L1缓存（共享内存）</li>
<li>4 个纹理读取单元及纹理缓存（上图中 TEX）</li>
<li>若干光线追踪核心（RT Core）</li>
</ul>
<p>其他上图中没有标出的还包括：</p>
<ul>
<li>PolyMorph Engine：多边形引擎负责属性装配（attribute Setup）、顶点拉取(VertexFetch)、曲面细分、栅格化（这个模块可以理解专门处理顶点相关的东西）</li>
<li>指令缓存（Instruction Cache）</li>
<li>内部链接网络（Interconnect Network）</li>
</ul>
<p>Fermi 架构的单个 SM 更清晰的包含了上述的大部分结构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001212393-1848942244.png" alt="1617944-20190906001212393-1848942244"></p>
<h3 id="4-GPU-逻辑管线"><a href="#4-GPU-逻辑管线" class="headerlink" title="4 GPU 逻辑管线"></a>4 GPU 逻辑管线</h3><p>接下来以 Fermi 架构的 SM 为例，进行逻辑管线的详细说明。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001228274-379363267.png" alt="1617944-20190906001228274-379363267"></p>
<p>1、首先程序通过图形 API（DX、GL等）发出 Drawcall 指令，指令会被推送到驱动程序，驱动会检查指令的合法性，然后会把指令放到 GPU 可以读取的 Pushbuffer 中。</p>
<p>2、经过一段时间或者显式调用 flush 指令后，驱动程序把 Pushbuffer 的内容发送给 GPU，GPU 通过主机接口（Host Interface）接受这些命令，并通过前端（Front End）处理这些命令。</p>
<p>3、在图元分配器（Primitive Distributor）中开始工作分配，处理 indexbuffer 中的顶点产生三角形分成批次（batches），然后发送给多个 GPCs。这一步的理解就是提交上来 n 个三角形，分配给这几个 GPC 同时处理。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906000842367-1857714844.png" alt="1617944-20190906000842367-1857714844"></p>
<p>4、在 GPC 中，每个 SM 中的 Poly Morph Engine 负责通过三角形索引(triangle indices)取出三角形的数据(vertex data)，即上图中的Vertex Fetch模块。</p>
<p>5、在获取数据之后，在 SM 中以 32 个线程为一组的线程束(Warp)来调度，来开始处理顶点数据。Warp 是典型的单指令多线程（SIMT，SIMD单指令多数据的升级）的实现，也就是 32 个线程同时执行的指令是一模一样的，只是线程数据不一样，这样的好处就是一个 warp 只需要一个套逻辑对指令进行解码和执行就可以了，芯片可以做的更小更快，之所以可以这么做是由于 GPU 需要处理的任务是天然并行的。</p>
<p>6、SM 的 warp 调度器会按照顺序分发指令给整个 warp，单个 warp 中的线程会锁步(lock-step)执行各自的指令，如果线程碰到不激活执行的情况也会被遮掩(be masked out)。被遮掩的原因有很多，例如当前的指令是if(true)的分支，但是当前线程的数据的条件是false，或者循环的次数不一样（比如for循环次数n不是常量，或被break提前终止了但是别的还在走），<strong>因此在shader中的分支会显著增加时间消耗</strong>，在一个 warp 中的分支除非 32 个线程都走到同一个分支里面，否则相当于所有的分支都走了一遍，任何一个线程都不能独立执行指令，而是以 warp 为单位，这些 warp 之间才是独立的。</p>
<p>7、warp 中的指令可以被一次完成，也可能经过多次调度，例如通常 SM 中的 LD&#x2F;ST(加载存取) 单元数量明显少于基础数学操作单元。</p>
<p>8、由于某些指令比其他指令需要更长的时间才能完成，特别是内存加载，warp 调度器可能会简单地切换到另一个没有内存等待的 warp，这是 GPU 如何克服内存读取延迟的关键，只是简单地切换活动线程组。为了使这种切换非常快，调度器管理的所有 warp 在寄存器文件中都有自己的寄存器。这里就会有个矛盾产生，shader 需要越多的寄存器，就会给 warp 留下越少的空间，就会产生越少的 warp，这时候在碰到内存延迟的时候就会只是等待，而没有可以运行的 warp 可以切换。    </p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001241355-608845528.png" alt="1617944-20190906001241355-608845528"></p>
<p>9、一旦 warp 完成了 vertex-shader 的所有指令，运算结果就会被 Viewport Transform 模块处理，三角形会被裁剪然后准备光栅化，GPU 会使用 L1 和 L2 缓存来进行 vertex-shader 和 pixel-shader 的数据通信。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001250059-1971914812.png" alt="1617944-20190906001250059-1971914812"></p>
<p>10、接下来这些三角形将被分割，再分配给多个 GPC，三角形的范围决定着它将被分配到哪个光栅引擎(raster engines)，每个 raster engines 覆盖了多个屏幕上的 tile，这等于把三角形的渲染分配到多个 tile 上面。也就是一个三角形并不是完全由一个 GPC 处理，而是根据覆盖的屏幕区域会被分配给不同的 GPC 计算。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001300961-1313843419.png" alt="1617944-20190906001300961-1313843419"></p>
<p>11、然后 SM 中的 Attribute Setup 对从 vertex-shader 来的数据进行插值并保证插值后对 pixel-shader 是可读的。</p>
<p>12、GPC 上的光栅引擎(raster engines)在它接收到的三角形上工作，来负责这些三角形的片元信息的生成，同时还会处理裁剪Clipping、背面剔除和 Early-Z 等。</p>
<p>13、接下来 32 个像素线程将被分成一组，或者说 8 个 2x2 的像素块，这是在像素着色器上面的最小工作单元，在这个像素线程内，如果没有被三角形覆盖就会被遮掩，SM 中的 warp 调度器会管理像素着色器的任务。</p>
<p>14、接下来的阶段就和vertex-shader中的逻辑步骤完全一样，但是变成了在像素着色器线程中执行。 由于不耗费任何性能可以获取一个像素内的值，导致锁步执行非常便利，所有的线程可以保证所有的指令可以在同一点。</p>
<p>15、最后一步，现在像素着色器已经完成了颜色的计算还有深度值的计算，在这个点上，我们必须考虑三角形的原始 api 顺序，然后才将数据移交给 ROP(render output unit，渲染输出单元)，一个 ROP 内部有很多 ROP 单元，在 ROP 单元中处理深度测试，和 framebuffer 的混合，深度和颜色的设置必须是原子操作，否则两个不同的三角形在同一个像素点就会有冲突和错误。</p>
<h3 id="5-技术要点"><a href="#5-技术要点" class="headerlink" title="5 技术要点"></a>5 技术要点</h3><p>上面的流程中有很多细节没有展开阐述，这里分别补充。</p>
<h4 id="5-1-SIMD和SIMT"><a href="#5-1-SIMD和SIMT" class="headerlink" title="5.1 SIMD和SIMT"></a>5.1 SIMD和SIMT</h4><p><strong>SIMD</strong>（Single Instruction Multiple Data）是单指令多数据，在GPU的ALU单元内，一条指令可以处理多维向量（一般是4D）的数据。比如，有以下shader指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 c = a + b; // a, b都是float4类型</span><br></pre></td></tr></table></figure>

<p>对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD c.x, a.x, b.x</span><br><span class="line">ADD c.y, a.y, b.y</span><br><span class="line">ADD c.z, a.z, b.z</span><br><span class="line">ADD c.w, a.w, b.w</span><br></pre></td></tr></table></figure>

<p>但有了 SIMD 技术，只需一条指令即可处理完：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIMD_ADD c, a, b</span><br></pre></td></tr></table></figure>

<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001330348-1982690439.png" alt="1617944-20190906001330348-1982690439"></p>
<p><strong>SIMT</strong>（Single Instruction Multiple Threads，单指令多线程）是SIMD的升级版，可对 GPU 中单个 SM 中的多个 Core 同时处理同一指令，并且每个 Core 存取的数据可以是不同的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001403077-1969715914.png" alt="1617944-20190906001403077-1969715914"></p>
<h4 id="5-2-co-issue"><a href="#5-2-co-issue" class="headerlink" title="5.2 co-issue"></a>5.2 co-issue</h4><p><strong>co-issue</strong>是为了解决SIMD运算单元无法充分利用的问题。例如下图，由于float数量的不同，ALU利用率从100%依次下降为75%、50%、25%。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001418746-831705203.png" alt="1617944-20190906001418746-831705203"></p>
<p>为了解决着色器在低维向量的利用率低的问题，可以通过合并 1D 与 3D 或 2D 与 2D 的指令。例如下图，<code>DP3</code>指令用了 3D 数据，<code>ADD</code>指令只有 1D 数据，co-issue会自动将它们合并，在同一个 ALU 只需一个指令周期即可执行完。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001427705-915501113.png" alt="1617944-20190906001427705-915501113"></p>
<h4 id="5-3-if-else-语句"><a href="#5-3-if-else-语句" class="headerlink" title="5.3 if-else 语句"></a>5.3 if-else 语句</h4><p>如下图，SM中有 8 个ALU（Core），由于 SIMD 的特性，每个 ALU 的数据不一样，导致<code>if-else</code>语句在某些ALU中执行的是<code>true</code>分支（黄色），有些ALU执行的是<code>false</code>分支（灰蓝色），这样导致很多 ALU 的执行周期被浪费掉了（即masked out），拉长了整个执行周期。最坏的情况，同一个SM中只有1&#x2F;8（8 是同一个 SM 的线程数，不同架构的 GPU 有所不同）的利用率。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001457351-743980317.png" alt="1617944-20190906001457351-743980317"></p>
<p>同样，<code>for</code>循环也会导致类似的情形，例如以下shader代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func(int count, int breakNum)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0; i&lt;count; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if (i == breakNum)</span><br><span class="line">			break;</span><br><span class="line">		else</span><br><span class="line">			// do something</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每个ALU的<code>count</code>不一样，加上有<code>break</code>分支，导致最快执行完shader的ALU可能是最慢的N分之一的时间，但由于SIMD的特性，最快的那个ALU依然要等待最慢的ALU执行完毕，才能接下一组指令的活！也就白白浪费了很多时间周期。<strong>因此在shader中的分支会显著增加时间消耗</strong></p>
<h4 id="5-4-Early-Z"><a href="#5-4-Early-Z" class="headerlink" title="5.4 Early-Z"></a>5.4 Early-Z</h4><p>关于 Early-Z 可以查看之前的笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/14/20220514-RTR-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95/">【Real-Time Rendering】模板测试和深度测试</a>，这里要强调的是 Early-Z 剔除的最小单位不是 1 像素，而是像素块（pixel quad，2x2个像素）。</p>
<p>此外，从硬件角度讲 Early-Z 还存在<strong>深度数据冲突</strong>（depth data hazard）问题，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001537033-642734220.png" alt="1617944-20190906001537033-642734220"></p>
<p>假设数值深度值 5 已经经过 Early-Z 即将写入 Frame Buffer，而深度值 10 刚好处于 Early-Z 阶段，读取并对比当前缓存的深度值 15，结果就是 10 通过了 Early-Z 测试，会覆盖掉比自己小的深度值 5，最终 frame buffer 的深度值是错误的结果。</p>
<p>避免深度数据冲突的方法之一是在写入深度值之前，再次与frame buffer的值进行对比：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001545523-562795391.png" alt="1617944-20190906001545523-562795391"></p>
<h4 id="5-5-统一着色器架构（Unified-shader-Architecture）"><a href="#5-5-统一着色器架构（Unified-shader-Architecture）" class="headerlink" title="5.5 统一着色器架构（Unified shader Architecture）"></a>5.5 统一着色器架构（Unified shader Architecture）</h4><p>在早期的 GPU，顶点着色器和像素着色器的硬件结构是独立的，它们各有各的寄存器、运算单元等部件。这样很多时候，会造成顶点着色器与像素着色器之间任务的不平衡。对于顶点数量多的任务，像素着色器空闲状态多；对于像素多的任务，顶点着色器的空闲状态多。</p>
<p>于是，为了解决 VS 和 PS 之间的不平衡，引入了统一着色器架构（Unified shader Architecture）。用了此架构的 GPU，VS 和 PS 用的都是相同的 Core。也就是，同一个 Core 既可以是 VS 又可以是 PS。这样就解决了不同类型着色器之间的不平衡问题，还可以减少 GPU 的硬件单元，压缩物理尺寸和耗电量。此外，VS、PS 可还可以和其它着色器（几何、曲面、计算）统一为一体。</p>
<h4 id="5-6-像素块（Pixel-Quad）"><a href="#5-6-像素块（Pixel-Quad）" class="headerlink" title="5.6 像素块（Pixel Quad）"></a>5.6 像素块（Pixel Quad）</h4><p>前文说到，在像素着色器中，会将相邻的四个像素作为不可分割的一组，送入同一个 SM 内 4 个不同的 Core 中。为什么这样做呢？可能有以下几点原因：</p>
<p>1、简化和加速像素分派的工作。</p>
<p>2、精简 SM 的架构，减少硬件单元数量和尺寸。</p>
<p>3、降低功耗，提高效能比。</p>
<p>4、无效像素虽然不会被存储结果，但可辅助有效像素求导函数。</p>
<p>这种设计虽然有其优势，但同时，也会激化过绘制（Over Draw）的情况，损耗额外的性能。比如下图中，白色的三角形只占用了 3 个像素（绿色），按我们普通的思维，只需要 3 个 Core 绘制 3 次就可以了。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001651573-804337756.png" alt="1617944-20190906001651573-804337756"></p>
<p>但是，由于上面的 3 个像素分别占据了不同的像素块（橙色分隔），实际上需要占用 12 个 Core 绘制 12 次（下图）。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001659282-1154417522.png" alt="1617944-20190906001659282-1154417522"></p>
<p>这就会额外消耗 300% 的硬件性能，导致了更加严重的过绘制情况。</p>
<h3 id="6-GPU-资源管理"><a href="#6-GPU-资源管理" class="headerlink" title="6 GPU 资源管理"></a>6 GPU 资源管理</h3><h4 id="6-1-GPU-内存架构"><a href="#6-1-GPU-内存架构" class="headerlink" title="6.1 GPU 内存架构"></a>6.1 GPU 内存架构</h4><p>有些 GPU 的内存架构和 CPU 类似，分为寄存器，L1 缓存，L2 缓存，GPU 显存和系统显存：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001709237-945454718.png" alt="1617944-20190906001709237-945454718"></p>
<p>它们的存取速度从寄存器到系统内存依次变慢：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20220703174542534.png" alt="image-20220703174542534"></p>
<p>由此可见，shader直接访问寄存器、L1、L2缓存还是比较快的，但访问纹理、常量缓存和全局内存非常慢，会造成很高的延迟。</p>
<p>由于 SIMT 技术的引入，导致很多同一个 SM 内的很多 Core 并不是独立的，当它们当中有部分 Core 需要访问到纹理、常量缓存和全局内存时，就会导致非常大的卡顿（Stall）。</p>
<p>如下图，有 4 组上下文（Context），它们共用同一组运算单元ALU：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001735780-1606282901.png" alt="1617944-20190906001735780-1606282901"></p>
<p>假设第一组 Context 需要访问缓存或内存，会导致 2~3 个周期的延迟，此时调度器会激活第二组 Context 以利用ALU：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001744570-1497753939.png" alt="1617944-20190906001744570-1497753939"></p>
<p>当第二组Context访问缓存或内存又卡住，会依次激活第三、第四组Context，直到第一组Context恢复运行或所有都被激活：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001752475-1100477295.png" alt="1617944-20190906001752475-1100477295"></p>
<p>延迟的后果是每组Context的总体执行时间被拉长了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001800006-1870518462.png" alt="1617944-20190906001800006-1870518462"></p>
<p>但是，越多Context可用就越可以提升运算单元的吞吐量。</p>
<h4 id="6-2-CPU-GPU-异构系统"><a href="#6-2-CPU-GPU-异构系统" class="headerlink" title="6.2 CPU-GPU 异构系统"></a>6.2 CPU-GPU 异构系统</h4><p>根据CPU和GPU是否共享内存，可分为两种类型的CPU-GPU架构：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001850363-356121869.png" alt="1617944-20190906001850363-356121869"></p>
<p>上图左是<strong>分离式架构</strong>，CPU和GPU各自有独立的缓存和内存，它们通过PCI-e等总线通讯。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p>
<p>上图右是<strong>耦合式架构</strong>，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p>
<p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 CPU 共享系统内存，由 MMU 进行存储管理。</p>
<h4 id="6-3-GPU-资源管理模型"><a href="#6-3-GPU-资源管理模型" class="headerlink" title="6.3 GPU 资源管理模型"></a>6.3 GPU 资源管理模型</h4><p>下图是分离式架构的资源管理模型：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001903861-1080252910.png" alt="1617944-20190906001903861-1080252910"></p>
<ul>
<li><strong>MMIO（Memory Mapped IO）</strong><ul>
<li>CPU与GPU的交流就是通过MMIO进行的。CPU 通过 MMIO 访问 GPU 的寄存器状态。</li>
<li>DMA传输大量的数据就是通过MMIO进行命令控制的。</li>
<li>I&#x2F;O端口可用于间接访问MMIO区域，像Nouveau等开源软件从来不访问它。</li>
</ul>
</li>
<li><strong>GPU Context</strong><ul>
<li>GPU Context代表了GPU计算的状态。</li>
<li>在GPU中拥有自己的虚拟地址。</li>
<li>GPU 中可以并存多个活跃态下的Context。</li>
</ul>
</li>
<li><strong>GPU Channel</strong><ul>
<li>任何命令都是由CPU发出。</li>
<li>命令流（command stream）被提交到硬件单元，也就是GPU Channel。</li>
<li>每个GPU Channel关联一个context，而一个GPU Context可以有多个GPU channel。</li>
<li>每个GPU Context 包含相关channel的 GPU Channel Descriptors ， 每个 Descriptor 都是 GPU 内存中的一个对象。</li>
<li>每个 GPU Channel Descriptor 存储了 Channel 的设置，其中就包括 Page Table 。</li>
<li>每个 GPU Channel 在GPU内存中分配了唯一的命令缓存，这通过MMIO对CPU可见。</li>
<li>GPU Context Switching 和命令执行都在GPU硬件内部调度。</li>
</ul>
</li>
<li><strong>GPU Page Table</strong><ul>
<li>GPU Context在虚拟基地空间由Page Table隔离其它的Context 。</li>
<li>GPU Page Table隔离CPU Page Table，位于GPU内存中。</li>
<li>GPU Page Table的物理地址位于 GPU Channel Descriptor中。</li>
<li>GPU Page Table不仅仅将 GPU虚拟地址转换成GPU内存的物理地址，也可以转换成CPU的物理地址。因此，GPU Page Table可以将GPU虚拟地址和CPU内存地址统一到GPU统一虚拟地址空间来。</li>
</ul>
</li>
<li><strong>PCI-e BAR</strong><ul>
<li>GPU 设备通过PCI-e总线接入到主机上。 Base Address Registers(BARs) 是 MMIO的窗口，在GPU启动时候配置。</li>
<li>GPU的控制寄存器和内存都映射到了BARs中。</li>
<li>GPU设备内存通过映射的MMIO窗口去配置GPU和访问GPU内存。</li>
</ul>
</li>
<li><strong>PFIFO Engine</strong><ul>
<li>PFIFO是GPU命令提交通过的一个特殊的部件。</li>
<li>PFIFO维护了一些独立命令队列，也就是Channel。</li>
<li>此命令队列是Ring Buffer，有PUT和GET的指针。</li>
<li>所有访问Channel控制区域的执行指令都被PFIFO 拦截下来。</li>
<li>GPU驱动使用Channel Descriptor来存储相关的Channel设定。</li>
<li>PFIFO将读取的命令转交给PGRAPH Engine。</li>
</ul>
</li>
<li><strong>BO</strong><ul>
<li>Buffer Object (BO)，内存的一块(Block)，能够用于存储纹理（Texture）、渲染目标（Render Target）、着色代码（shader code）等等。</li>
</ul>
</li>
</ul>
<h4 id="6-4-CPU-GPU-数据流"><a href="#6-4-CPU-GPU-数据流" class="headerlink" title="6.4 CPU-GPU 数据流"></a>6.4 CPU-GPU 数据流</h4><p>下图是分离式架构的 CPU-GPU 的数据流程图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001916357-1658595620.webp" alt="1617944-20190906001916357-1658595620"></p>
<p>1、将主存的处理数据复制到显存中。</p>
<p>2、CPU指令驱动GPU。</p>
<p>3、GPU中的每个运算单元并行处理。此步会从显存存取数据。</p>
<p>4、GPU将显存结果传回主存。</p>
<p>更加详细的 GPU 数据流程可以查看最后的参考文章。</p>
<h4 id="6-5-显像机制"><a href="#6-5-显像机制" class="headerlink" title="6.5 显像机制"></a>6.5 显像机制</h4><p>计算机显示图像的过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001947961-1190125231.png" alt="1617944-20190906001947961-1190125231"></p>
<p>显示器通常以固定频率进行刷新，CPU 将计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照屏幕刷新信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p>
<h4 id="6-6-双重缓冲"><a href="#6-6-双重缓冲" class="headerlink" title="6.6 双重缓冲"></a>6.6 双重缓冲</h4><p>在单缓冲下，帧缓冲区的读取和刷新都都会有比较大的效率问题，经常会出现相互等待的情况，导致帧率下降。</p>
<p>为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会交换缓冲区内容。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906001957832-296063271.png" alt="1617944-20190906001957832-296063271"></p>
<h4 id="6-7-垂直同步"><a href="#6-7-垂直同步" class="headerlink" title="6.7 垂直同步"></a>6.7 垂直同步</h4><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当 GPU 渲染速度大于屏幕刷新速度时，视频控制器还未读取完成，即屏幕内容刚显示一半时，GPU 就将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换，此时视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906002006570-2008054292.jpg" alt="1617944-20190906002006570-2008054292"></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做<strong>垂直同步</strong>（V-Sync），当开启垂直同步后，GPU 会等待显示器的刷新信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<h3 id="7-Shader-运行机制"><a href="#7-Shader-运行机制" class="headerlink" title="7 Shader 运行机制"></a>7 Shader 运行机制</h3><p>Shader 代码也跟传统的 C++ 等语言类似，需要将面向人类的高级语言（GLSL、HLSL、CGSL）通过编译器转成面向机器的二进制指令，二进制指令可转译成汇编代码，以便技术人员查阅和调试。</p>
<p>由高级语言编译成汇编指令的过程通常是在离线阶段执行，以减轻运行时的消耗。</p>
<p>在执行阶段，CPU端将shader二进制指令经由PCI-e推送到GPU端，GPU在执行代码时，会用Context将指令分成若干Channel推送到各个Core的存储空间。</p>
<p>对现代GPU而言，可编程的阶段越来越多，包含但不限于：顶点着色器（Vertex Shader）、曲面细分控制着色器（Tessellation Control Shader）、几何着色器（Geometry Shader）、像素&#x2F;片元着色器（Fragment Shader）、计算着色器（Compute Shader）等等。总体流程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GPU%E6%9E%B6%E6%9E%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1617944-20190906002027360-504150984.png" alt="1617944-20190906002027360-504150984"></p>
<h3 id="8-渲染优化建议"><a href="#8-渲染优化建议" class="headerlink" title="8 渲染优化建议"></a>8 渲染优化建议</h3><p>由以上分析，可以得出以下渲染优化建议：</p>
<ul>
<li><strong>减少CPU和GPU的数据交换：</strong><ul>
<li>批处理（Batch）</li>
<li>减少顶点数、三角形数</li>
<li>视锥裁剪<ul>
<li>BVH</li>
<li>Portal</li>
<li>BSP</li>
<li>OSP</li>
</ul>
</li>
<li>避免每帧提交Buffer数据<ul>
<li>CPU版的粒子、动画会每帧修改、提交数据，可移至GPU端。</li>
</ul>
</li>
<li>减少渲染状态设置和查询<ul>
<li>例如：<code>glGetUniformLocation</code>会从GPU内存查询状态，耗费很多时间周期。</li>
<li>避免每帧设置、查询渲染状态，可在初始化时缓存状态。</li>
</ul>
</li>
<li>启用GPU Instance</li>
<li>开启LOD</li>
<li>避免从显存读数据</li>
</ul>
</li>
<li><strong>减少过绘制：</strong><ul>
<li>避免Tex Kill操作</li>
<li>避免Alpha Test</li>
<li>避免Alpha Blend</li>
<li>开启深度测试<ul>
<li>Early-Z</li>
<li>层次Z缓冲（Hierarchical Z-Buffering，HZB）</li>
</ul>
</li>
<li>开启裁剪：<ul>
<li>背面裁剪</li>
<li>遮挡裁剪</li>
<li>视口裁剪</li>
<li>剪切矩形（scissor rectangle）</li>
</ul>
</li>
<li>控制物体数量<ul>
<li>粒子数量多且面积小，由于像素块机制，会加剧过绘制情况</li>
<li>植物、沙石、毛发等也如此</li>
</ul>
</li>
</ul>
</li>
<li><strong>Shader优化：</strong><ul>
<li>避免if、switch分支语句</li>
<li>避免<code>for</code>循环语句，特别是循环次数可变的</li>
<li>减少纹理采样次数</li>
<li>禁用<code>clip</code>或<code>discard</code>操作</li>
<li>减少复杂数学函数调用</li>
</ul>
</li>
</ul>
<h3 id="9-参考"><a href="#9-参考" class="headerlink" title="9 参考"></a>9 参考</h3><ul>
<li><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制 - 0向往0 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/61358167">GPU并行架构及渲染优化 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>知识汇总</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【游戏引擎】（三）游戏引擎中的动画系统</title>
    <url>/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>游戏引擎中的动画系统是最重要的系统之一，直接决定了角色动作是否自然，酷炫的动画也是一个游戏最能吸引人的地方，这一节来简单了解游戏引擎中的动画系统，蒙皮动画的数学原理以及动画压缩技术。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-游戏引擎中的动画系统"><a href="#1-游戏引擎中的动画系统" class="headerlink" title="1 游戏引擎中的动画系统"></a>1 游戏引擎中的动画系统</h3><p>引擎中的动画技术来自于动画电影，但相比于动画电影，游戏中的动画还要和玩家进行交互，根据玩家的输入来执行不同的动作，并且游戏需要实时运行，动画的计算也要在极短的时间内完成，大量的游戏对象也会有大量的动画数据，动画数据的存储和使用也是一个极大的挑战。</p>
<p>最早的动画利用人的视觉残留，通过快速播放关键帧来实现，这种方式也叫做精灵动画（Sprite Animation），现在的许多简单 2D 动画，比如 2D 角色的动作和一些特效等，也可以使用这种方式来实现：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703104804654.png" alt="image-20220703104804654"></p>
<p>此外还有比较热门的 Live2D 动画，将 2D 人物的各个部分分别作为不同的组件，通过调整各组件的顶点或者利用动作捕捉生成关键帧，然后在这些帧之间插值来形成流畅的动画，因为 2D 动作捕捉控制点较少，可以快速实时计算，因此 Live2D 广泛用于现在的虚拟直播中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703105116202.png" alt="image-20220703105116202"></p>
<p>当然现在游戏引擎中使用最多的还是 3D 动画，3D 动画依赖于对模型添加骨骼，然后利用骨骼的运动（旋转、平移、缩放）来控制模型表面顶点的运动，从而使模型动起来，对于一些比较复杂的布料、流体运动，不方便添加骨骼来控制，于是会使用顶点动画，将物体表面顶点在每一帧的运动存入一张纹理中，渲染时直接通过纹理就可以改变顶点的位置从而形成动画：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703105453426.png" alt="image-20220703105453426"></p>
<h3 id="2-蒙皮动画"><a href="#2-蒙皮动画" class="headerlink" title="2 蒙皮动画"></a>2 蒙皮动画</h3><p>蒙皮动画是目前最常用的动画技术，蒙皮动画的流程非常简单，大概分为以下几步：</p>
<ul>
<li>首先是创建一个模型的 binding pose 的 Mesh 网格，所谓 binding pose 就是指用于后续绑定骨骼的姿势，一般分为 T Pose 和 A Pose，由于 T Pose 在肩部会有一些顶点的重合，可能导致之后的动画表现不完整，因此目前大多使用 A Pose：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703105729235.png" alt="image-20220703105729235"></p>
<ul>
<li>第二步是为 Mesh 创建绑定的骨骼，更精确地说是关节，所有的动画都是关节在动，骨骼是两个关节之间的部分：</li>
</ul>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703110627378.png" alt="image-20220703110627378"></p>
<p>每个顶点会和多个关节绑定，关节动的时候，顶点就随之移动，同一个顶点受到不同关节的影响自然也不同。此外，除了模型本身的关节，还会为角色的衣服、武器等 Game Play 的部分生成关节：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703110821902.png" alt="image-20220703110821902"></p>
<ul>
<li>第三步就是蒙皮，所谓蒙皮就是为每个顶点生成受到不同关节影响的权重</li>
<li>第四步就是对关节进行动画设计生成动画矩阵</li>
<li>第五步对每个顶点，根据不同权重应用相应的关节动画来计算得到顶点的位置</li>
</ul>
<p>整个蒙皮动画流程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703110247889.png" alt="image-20220703110247889"></p>
<h4 id="2-1-骨骼层次结构"><a href="#2-1-骨骼层次结构" class="headerlink" title="2.1 骨骼层次结构"></a>2.1 骨骼层次结构</h4><p>一般来说会为骨骼生成层次结构以便于关节间动画的传递，对于人类（双足）模型来说，一般用尾椎骨的关节作为中心关节（Pelvis Joint），因为尾椎骨关节向下就是腿部关节，向上就是上身和胳膊关节，对于动物（四足）模型，也是类似的：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703110553383.png" alt="image-20220703110553383"></p>
<p>一般的层次结构中，在尾椎骨关节点之上还会有一个 root 节点，root 节点一般取人的两腿之间或者动物的四肢之间的中心和地地面接触的地方：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111025886.png" alt="image-20220703111025886"></p>
<p>因为这样的 root 节点在模型运动的时候高度不会发生改变，有了层次结构我们就可以知道每个关节的父关节和子关节，从而将运动传递下去。</p>
<p>对于绑定的模型，比如人和载具，还会将他们的 Pelvis Joint 对接到一起，从而使他们的动画能够进行传递，对接不仅是指关节的位置重合，他们的局部坐标系也要变换到完全一致：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111310429.png" alt="image-20220703111310429"></p>
<h4 id="2-2-蒙皮动画矩阵"><a href="#2-2-蒙皮动画矩阵" class="headerlink" title="2.2 蒙皮动画矩阵"></a>2.2 蒙皮动画矩阵</h4><p>接下来推导动画矩阵，首先明确三个坐标系：局部空间、模型空间和世界空间。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111423781.png" alt="image-20220703111423781"></p>
<p>局部空间是指以关节为中心的空间，每个关节的局部空间自然是不同的，模型空间和世界空间不必多说，在渲染中已经非常熟悉了。</p>
<p>对于关节的运动，只有三种：旋转、平移和缩放。旋转改变关节的朝向（Orientation）：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111819051.png" alt="image-20220703111819051"></p>
<p>平移改变关节的位置：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111835096.png" alt="image-20220703111835096"></p>
<p>缩放改变关节的尺寸：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111900765.png" alt="image-20220703111900765"></p>
<p>于是对于关节的变换通常就是三个矩阵的结合：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703111927064.png" alt="image-20220703111927064"></p>
<p>于是一个关节当前的 pose 就可以表示为从根节点开始到该节点的所有运动的作用的叠加，也就是矩阵相乘：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703112129521.png" alt="image-20220703112129521"></p>
<p>这里需要注意的是对于关节的两个 pose 中间状态的插值要在局部空间进行，而不能在模型空间将进行，因为对于关节来说模型空间是一个全局坐标系，直接对关节的位置插值会是不平滑的，而局部空间是相对坐标系，插值会是均匀的，下图左是在局部空间插值的效果，下图右是在模型空间插值的结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703112421587.png" alt="image-20220703112421587"></p>
<p>有了关节的运动，接下来就是如何利用关节运动计算顶点运动，我们先假设每个顶点只和一个关节绑定。</p>
<p>计算顶点运动的关键就在于顶点相对于关节的位置是永远不可能发生变化的，也就是说顶点在绑定的关节的局部空间的坐标是永远不变得，这样才能保证模型动画的正确：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703112652270.png" alt="image-20220703112652270"></p>
<p>于是我们可以得出以下关系：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703112723067.png" alt="image-20220703112723067"></p>
<p>也就是顶点在 Bind Pose 时相对于绑定的关节 J 的局部空间的坐标 $V_b^l$ 和顶点在任何时间 t 时相对于绑定的关节 J 的局部空间的坐标 $V^l(t)$ 恒相等。</p>
<p>如果把顶点在 Bind Pose 时模型空间的坐标表示为 $V_b^m$，关节从局部空间到模型空间的变换矩阵（也就是关节在 Bind Pose 时模型空间下的 pose）表示为 $M^m_{b(j)}$，因为顶点和关节的相对位置不变，利用关节的变换矩阵的逆矩阵和顶点在关节局部空间下的坐标也可以将顶点变换到模型空间，于是顶点在任何时间 t 时相对于绑定的关节 J 的局部空间的坐标就等于 $V_b^m$ 乘上 $M^m_{b(j)}$ 的逆矩阵，即为上式所表示的含义。</p>
<p>上面说过，任何一个关节在模型空间的 pose 可以表示为从根节点到当前关节的 pose 的叠加：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703113522897.png" alt="image-20220703113522897"></p>
<p>而关节和顶点的相对位置不变，于是对顶点施加和关节相同的运动就可以完成顶点的运动：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703113632960.png" alt="image-20220703113632960"></p>
<p>蒙皮动画矩阵就是关节在 t 时刻的 pose 矩阵和关节在 Bind Pose 时的 pose 矩阵的逆矩阵的乘积。有了这个矩阵，我们只要知道任何一个顶点在 Bind Pose 时的模型空间位置，就可以得到该顶点在任何时刻 t 的模型空间坐标，从而实现动画效果。</p>
<p>对于关节在 Bind Pose 时的模型空间的 pose 矩阵，也就是关节在 Bind Pose 时从关节的局部空间到模型空间的变换矩阵，是很容易得到的，但因为我们要用的是该矩阵的逆矩阵，求逆操作代价较大，所以一般提前算好存在每个关节的结构体中：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703114728451.png" alt="image-20220703114728451"></p>
<p>最后对于渲染，我们要知道的是顶点的世界空间坐标，还要在上面的矩阵上乘上一个物体从模型空间到世界空间的变换矩阵，这个矩阵自然还包含了模型在世界空间中的运动，这样一来就可以实现模型在世界空间的运动和模型本身的运动的动画了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703114951451.png" alt="image-20220703114951451"></p>
<p>上面的推导是对于一个顶点只绑定一个关节的情况，实际为了动画更加自然，一个顶点会绑定多个关节，然后将通过不同关节运动计算出的顶点模型空间坐标进行加权平均得到最终的顶点坐标：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703124251350.png" alt="image-20220703124251350"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703124316201.png" alt="image-20220703124316201"></p>
<h4 id="2-3-pose-插值"><a href="#2-3-pose-插值" class="headerlink" title="2.3 pose 插值"></a>2.3 pose 插值</h4><p>通过上面的方法可以生成一个动作的多个关键帧 pose，这些关键帧 pose 组成序列叫做 Clip，对 Clip 中的 pose 进行插值就可以得到连续的动画。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703124737356.png" alt="image-20220703124737356"></p>
<p>插值实际上是对不同 pose 的运动之间的插值，最难处理的就是旋转的插值。</p>
<p>之前学习过四元数的球面线性插值，球面线性插值通过旋转角度的正弦进行插值，当角度很小的时候正弦值也很小，可能造成插值不稳定，因此游戏引擎一般使用球面线性插值对较大的旋转角度进行插值：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703125107407.png" alt="image-20220703125107407"></p>
<p>而对于较小的角度，使用 NLERP 进行插值，也就是先进行线性插值，对插值结果再做归一化：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703125034152.png" alt="image-20220703125034152"></p>
<p>NLERP 插值速度变换不均匀，但插值结果比较稳定，所以非常适合和 SLERP 搭配使用。</p>
<p>无论使用哪种插值方法，都需要使用两个四元数的点乘来判断插值方向，以此保证每次都是向最近的方向插值，因为角度是以 $2\pi$ 为周期的，所以存在插值方向的问题，如果不进行方向判断，就可能出现某个骨骼角度突变的情况。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703124922689.png" alt="image-20220703124922689"></p>
<h3 id="3-动画管线"><a href="#3-动画管线" class="headerlink" title="3 动画管线"></a>3 动画管线</h3><p>最后总结一下最简单的动画管线，如下图所示：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703125320376.png" alt="image-20220703125320376"></p>
<p>首先就是生成模型、骨骼和蒙皮，然后设计动作的 Clip，然后对 Clip 中的 Key Pose 之间进行插值得到每一帧的 pose，然后利用 pose 的动画矩阵计算顶点在世界空间的位置，之后就可以进行渲染，从而使模型动起来了。</p>
<p>上图中大部分计算都是在 CPU 中进行的，但实际上在现代引擎中这些计算几乎都由 GPU 完成。</p>
<p>对于美术人员或者动画设计师来说，建模工具已经提供了模型网格、骨骼结构和蒙皮生成工具，只要在自动生成的蒙皮上稍微修改一些权重就可以得到想要的动画效果，然后再设计骨骼动画生成 Clip，之后将这些数据导出为我们的引擎能够处理的文件，再进行上面的动画管线流程即可。</p>
<h3 id="4-动画压缩"><a href="#4-动画压缩" class="headerlink" title="4 动画压缩"></a>4 动画压缩</h3><p>动画压缩是为了减少 Clip 的数据存储，我们知道 Clip 包含一个动画的关键 pose 的所有 joint 的运动数据，这些运动数据又包含旋转、缩放、平移，对于一个模型来说，正常情况下有几十个到几百个 joint，而一个动画的 Clip 通常又包含几十帧关键 pose，整个游戏资源中的游戏对象又有成百上千个，于是光是动画数据可能就要达到数十 G，如果不进行压缩，存储空间的问题先不说，光是不停的读取这些资源就要消耗大量带宽从而影响游戏性能。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703125937121.png" alt="image-20220703125937121"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703130039721.png" alt="image-20220703130039721"></p>
<p>但是通过观察，人们发现，实际上大量的动画 pose 中，许多数据是几乎不变的，比如人走路的动画，所有关节的位置和尺寸完全不会发生改变，只有关节的朝向在变，也就是人走路的过程中，所有关节只进行了旋转变换：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703130212666.png" alt="image-20220703130212666"></p>
<p>如果还把每个关键 pose 的所有数据存下来，那很多数据都是重复的，于是对于大多数动画，可以舍弃位移和缩放的数据，除非有面部的骨骼变化，然后对于旋转可以对关键 pose 进行压缩，也就是合并一些可以通过插值得到的关键 pose，只要插值结果和关键 pose 结果的误差在一定范围内，我们就不需要这个关键 pose 了，这样一来可以减少很多数据的存储。</p>
<p>此外，对于旋转的角度随时间的变化曲线，还可以通过 Catmull-Rom 样条等曲线进行拟合，这样只需要通过极少的控制点，就可以得到误差在可接受范围内的旋转角度曲线：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703130759588.png" alt="image-20220703130759588"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703130812422.png" alt="image-20220703130812422"></p>
<p>对于四元数的存储，通常是四个浮点数，四个浮点数就需要 4 * 32 个 bit 来存储，但通过观察，人们发现如果不考虑四元数最大的一个分量，其他三个分量的范围都在 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703131014403.png" alt="image-20220703131014403"></p>
<p>并且因为表示旋转的都是单位四元数，因此当我们知道三个分量的时候就可以利用模为 1 来求得第四个分量。</p>
<p>这样一来我们可以用 2 bit 来表示最大的维度是哪个，然后只存储其他三个维度，并且因为其他三个维度的范围我们是知道的，我们可以利用定点数的方式存储他们，将 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内的小数均匀的分成若干个，映射到整数范围内，比如用 15 位来存储 $[-\frac{1}{\sqrt 2},\frac{1}{\sqrt 2}]$ 范围内的小数，那么 0 就对应 $-\frac{1}{\sqrt 2}$，32767 就对应 $\frac{1}{\sqrt 2}$，数据精度就是 $\sqrt2 &#x2F; 32767 &#x3D; 0.000043$。</p>
<p>于是需要用 128 bit 来存储的四元数，经过压缩就只需要 2 + 3 * 15 &#x3D; 47 bit，为了内存对齐，最终使用 48 bit 存储：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703131709781.png" alt="image-20220703131709781"></p>
<p>当然这样存储会产生一定误差，在运动不断传递的过程中就会产生越来越大的累计误差：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703131842087.png" alt="image-20220703131842087"></p>
<p>因此还需要进行误差的修正，这就相对来说比较的复杂了，这里不再讨论，不过一般矫正误差不会从运动参数方面进行矫正，而是从视觉误差方面校正，只要视觉上看起来动画是合理的，即便运动参数有误差，也不需要做额外的矫正操作。</p>
<h3 id="5-动画融合"><a href="#5-动画融合" class="headerlink" title="5 动画融合"></a>5 动画融合</h3><p>动画融合是指在不同动画的 Clip 之间进行插值融合，而之前我们讨论的都是在 Clip 内部的关键 pose 之间的插值。不同动画之间的融合就涉及到更多复杂的问题，比如两个动画需要在时间和骨骼位置上有对应关系，这样融合起来的过渡动画才更加自然，而且对于角色在三维空间的运动，通常会有前后左右各个方向的运动，需要融合的动画可能不是两个动画，而是更多的动画，这时就需要构造融合空间，当角色在空间中移动的时候，选用离的最近的三个动画进行插值融合：<br><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151402089.png" alt="image-20220703151402089"></p>
<p>除了全身动画融合之外，有时还需要将动画只应用到上半身或者下半身，比如：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151517898.png" alt="image-20220703151517898"></p>
<p>这时可以对骨骼动画进行一个 Mask 操作：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151503298.png" alt="image-20220703151503298"></p>
<p>还有的情况需要让同一个动画在不同的朝向执行，比如朝不同方向点头：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151624831.png" alt="image-20220703151624831"></p>
<p>这时可以只存储骨骼的相对运动，再进行融合。</p>
<h3 id="6-动画状态机和动画树"><a href="#6-动画状态机和动画树" class="headerlink" title="6 动画状态机和动画树"></a>6 动画状态机和动画树</h3><p>在游戏过程中设计许多动画的切换，即便是一个动画，也需要分为很多部分进行循环切换，比如一个跳跃的动作，分为起跳，空中循环和落地三个动作，这三个动作需要在不同的时间进行切换，这样的切换可以用状态机来描述：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151854905.png" alt="image-20220703151854905"></p>
<p>而目前游戏引擎中使用最多的动画切换和融合模型是动画树，动画树类似于运算树：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703151951269.png" alt="image-20220703151951269"></p>
<p>动画树将各个动画 pose 视为节点，在融合节点进行融合，融合的条件和权重可以依据游戏进行的过程进行调节，比如角色当前的状态，游戏中发生的事件等等：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703152052410.png" alt="image-20220703152052410"></p>
<p>动画状态机和动画树还可以结合起来表达更加复杂的动画切换。</p>
<h3 id="7-反向动力学"><a href="#7-反向动力学" class="headerlink" title="7 反向动力学"></a>7 反向动力学</h3><p>反向动力学（Inverse Kinematics, IK）是指，有时候角色动画还依赖于和场景的互动，比如攀岩的时候我们的某只手或者脚要固定在山体上，走路的时候一只脚要固定在地面上，这时我们就要求解在某个 joint 固定的情况下，要达到某个目标点，其他 joint 要如何变化，这就是反向动力学。</p>
<p>IK 是动画中比较难的部分，首先要判断能否到达目标点，一般可以用骨骼拉直判断到目标点的距离或者将其他骨骼折叠起来和最长的骨骼对比长度等方法：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703152516324.png" alt="image-20220703152516324"></p>
<p>当能够到达目标点的时候，就需要求解各个 joint 的变化，比较常用的算法有 CCD (Cyclic Coordinate Decent)、FABRIK (Forward And Backward Reaching Inverse Kinematics) 和雅可比矩阵（Jacobian Matrix）等，基本都是靠多次迭代不断逼近目标点，同时调整路径上的各个 joint，具体的算法比较复杂，这里不再展开了。</p>
<p>此外计算 IK 的时候还得考虑整个身体的平衡，要符合物理事实，因此 IK 是一个非常困难的领域。也因为有动画融合和 IK 的存在，整个动画管线就变得更加复杂：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703152759121.png" alt="image-20220703152759121"></p>
<p>还需要考虑不同动画的融合以及动画和世界场景的交互。</p>
<h3 id="8-动画重定向"><a href="#8-动画重定向" class="headerlink" title="8 动画重定向"></a>8 动画重定向</h3><p>动画重定向是为了将一个模型的骨骼动画应用到另一个模型上：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703152943879.png" alt="image-20220703152943879"></p>
<p>这只中还要考虑模型骨骼关系、骨骼数量的差异甚至模型骨骼结构的差异：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703153118965.png" alt="image-20220703153118965"></p>
<p>因为体型不同，还要考虑身体自身的碰撞，比如通过样的走路动画，一个较小的角色动画应用到体型比较大的角色身上就会穿模，鼓掌的时候可能原本首长可以碰到，但换到另一个模型上就碰不到了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/07/03/20220703-GameEngine-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/image-20220703153301117.png" alt="image-20220703153301117"></p>
<p>所以如何能够将一个动画应用到体型不同的其他角色上还不出现错误也是一个比较复杂的工作。</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（五）前缀和</title>
    <url>/LycTechStack.github.io/2022/03/19/20220319-%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>在之前的很多题目中其实已经用到了前缀和，前缀和是一种查询数组中任意区间的元素的和的数据结构，这里数组给定之后就不变了。针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的和。<br>前缀和的推导和计算隐含着动态规划的基本思想，同时它的状态设计是线性动态规划中比较简单的那一类。与线性动态规划一样，前缀和也有一维和二维两种场景。<br>虽然前缀和本身很简单，但需要用到它解决的问题非常多，与其它数据结构配合的变化也很多，因此需要从线性动态规划中剥离出来单独学习。</p>
<p><em><span id="more"></span></em></p>
<p>前缀和最简单的应用就是求区间和，我们之前在动态规划问题中也遇到不少，比如求数组分组的最大分数，就要预先计算前缀和以方便快速求出任意区间的平均值。<br>前缀和除了求区间和之外，还有一些其它的应用：</p>
<ul>
<li>在用动态规划的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，例如哈希表等等，在求每个位置的前缀和的过程中，查询数据结构并更新答案，这是前缀和的一大类问题，变化比较多，力扣上这类题也有很多</li>
<li>前缀和的逆运算是差分，对原序列求出其差分序列，然后再对得到的差分序列求其前缀和序列，可以得到原序列，这在处理一些区间修改的问题时很有用</li>
<li>前缀和还可以推广到二维上，并用于快速求矩形和，二维前缀和的计算过程是最经典的矩阵上的线性动态规划</li>
</ul>
<p>接下来我们对这几类题目分别进行总结梳理。</p>
<h3 id="1-实现前缀和"><a href="#1-实现前缀和" class="headerlink" title="1 实现前缀和"></a>1 实现前缀和</h3><p>为了加深对前缀和的理解，还是先从最基础的前缀和用于求区间和开始，虽然题目很简单，但这两道题的思想就是后面的各种变体题目中会反复用到的，因此一定要熟练掌握。</p>
<p>实现一维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable/submissions/">区域和检索</a></p>
<p>实现二维前缀和：<a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索</a></p>
<blockquote>
<p>二维前缀和需要注意：不要使用一维前缀和先计算每一行前缀和再把每一行结果加起来，这样就违背了前缀和可以在 O(1) 时间内找到区间和的性质，要用二维整体思想维护前缀和。</p>
</blockquote>
<h3 id="2-数据结构维护前缀和"><a href="#2-数据结构维护前缀和" class="headerlink" title="2 数据结构维护前缀和"></a>2 数据结构维护前缀和</h3><p>前缀和最常见的一大类问题是：在用动态规划的方式计算前缀和 sums[i] 的时候，求完 sums[i] 需要查询以前算过的结果来计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。</p>
<p>提到高效查询自然最常用的就是哈希表，这类题目非常多，变化纷繁复杂，这里我们按几大类进行梳理。</p>
<h4 id="2-1-哈希表维护前缀和第一类"><a href="#2-1-哈希表维护前缀和第一类" class="headerlink" title="2.1 哈希表维护前缀和第一类"></a>2.1 哈希表维护前缀和第一类</h4><p>最简单的一类哈希表维护前缀和问题，这类问题中，key为前缀和的值，value为前缀和第一次出现时的下标。</p>
<h5 id="和等于-k-的最长子数组长度"><a href="#和等于-k-的最长子数组长度" class="headerlink" title="和等于 k 的最长子数组长度"></a><a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/">和等于 k 的最长子数组长度</a></h5><blockquote>
<p>给定一个数组 <code>nums</code> 和一个目标值 <code>k</code>，找到和等于 <code>k</code> 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 <code>0</code>。</p>
</blockquote>
<p>需要注意几个细节，哈希表要记录前缀和第一次出现的下标，因为这样才能保证长度更长；初始化前缀和 0 的下标设为 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h5><blockquote>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
</blockquote>
<p>题目本身看起来不难，但按正常思路就是很难做。难点在于问题转换，如果把 0 看成 -1，那么问题就转化成了上一题，求和等于 k 的最长子数组长度，这里 k &#x3D; 0，这就变得无比简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - map[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="每个元音包含偶数次的最长子字符串"><a href="#每个元音包含偶数次的最长子字符串" class="headerlink" title="每个元音包含偶数次的最长子字符串"></a><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">每个元音包含偶数次的最长子字符串</a></h5><blockquote>
<p>给你一个字符串 <code>s</code> ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。</p>
</blockquote>
<p>这道题考查的内容非常丰富，而且非常巧妙，能想到用前缀和解决已经不容易，但是用前缀和如何解决更是一个问题。</p>
<p>我们当然可以为每一个元音字母维护一个前缀和，然后对于每个区间判断五个前缀和都满足条件就更新最长长度，但这样也要遍历全部子区间，时间复杂度太高，因为题目没有给出字母出现多少次这样的限制，只说了出现偶数次，越多越好，这导致我们没有一个恒定的关系式去进行查找（像前两道题中，告诉了我们和为 k，我们就有一个关系式去哈希表中查找了）。</p>
<p>这道题巧妙的地方就在于此，我们还有一个很简单但不容易想到的性质没有充分利用：我们需要找的子串中，每个元音字母都恰好出现了偶数次，而奇数减奇数等于偶数，偶数减偶数等于偶数。也就是说只要每个元音字母的前缀和中两个位置的奇偶性相同，那么这个字母在这两个前缀和区间内就一定出现了偶数次，因此我们只要找到前缀和中和当前奇偶性相同的最小的下标就行了，<strong>因此每个元音字母的前缀和中我们只要记录它最早出现奇数次的下标和最早出现偶数次的下标就行了</strong>，然后向后扫描，出现奇数次就减去奇数次下标，偶数次就减去偶数次下标，这样就能保证是一个元音字母出现了偶数次的最长的子序列。但我们要同时考虑五个元音字母，如果用五个前缀和来维护再去判断依然很麻烦，因此还需要进一步优化。</p>
<p>我们可以把五个字母一起考虑，同时记录五个字母出现次数的奇偶性，扫描字符串的过程中每一个位置都可以记录以当前位置结尾的子字符串中五个元音字母出现次数的奇偶性，当五个元音字母出现次数的奇偶性和之前某一位置完全一致的时候，这两个位置之间的子字符串中，五个元音字母就都出现了偶数次。因为每个元音字母只有出现奇数次和出现偶数次两种状态，因此可以用 0 表示出现偶数次，用 1 表示出现奇数次，那么五个字母每一个都有 0 和 1 两种状态，组合起来就一共有 $2^5&#x3D;32$ 种状态，我们可以用一个二进制数的每一位表示一个元音字母的奇偶性，那么我们只要 00000 到 11111 之间的32个数就可以描述所有的状态，因此哈希表也不需要了，只要用一个长度为 32 的数组 states 来记录就可以，数组中每一个位置对应一种状态，存储的内容就是这个状态第一次出现时的下标。</p>
<p>初始时所有字母都出现零次，因此 00000 状态对应的最早出现的下标就是 0，所以数组 states[0] &#x3D; 0。这样一来我们只需要遍历一次字符串，并且只需要使用常数空间就可以解决问题。</p>
<p>这道题目非常巧妙，值得反复推敲，并且编码的时候注意灵活运用常见的位运算，比如每次出现一个相同的元音字母，它出现次数的奇偶性就会反转，奇数变偶数，偶数变奇数，这里用异或操作很容易实现，可以用当前状态和这个元音字母对应位置为 1 的状态异或就可以达到指定位置翻转的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, status = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                status ^= <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~pos[status]) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i + <span class="number">1</span> - pos[status]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[status] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-哈希表维护前缀和第二类"><a href="#2-2-哈希表维护前缀和第二类" class="headerlink" title="2.2 哈希表维护前缀和第二类"></a>2.2 哈希表维护前缀和第二类</h4><p>这类问题中，key是前缀和（前缀状态）的值，value为前缀和或状态出现的次数。</p>
<h5 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p>
</blockquote>
<p>与“和为 k 的最长子数组长度”完全一样的思路，只是这次维护的哈希表中要记录当前的前缀和出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="统计「优美子数组」"><a href="#统计「优美子数组」" class="headerlink" title="统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">统计「优美子数组」</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k。如果某个连续子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。</p>
<p>请返回这个数组中 「优美子数组」 的数目。</p>
</blockquote>
<p>同样进行问题转化，如果把奇数看作1，偶数看作0，那么这道题就是和上一题一样的找到和为 k 的最大连续子数组的个数。直接把代码复制下来改个条件即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum-k))</span><br><span class="line">            &#123;</span><br><span class="line">                ans += map[sum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题还有优化的空间，完全可以用一个数组 cnt 代替哈希表记录前缀和出现的次数，数组每一项都初始化为 0，哈希表的 <code>map.count(sum-k)</code> 就等价于 <code>cnt[sum-k] &gt; 0</code>，当然要注意数组下标越界问题，要使<code>map[sum-k] &gt; 0</code>首先得有 <code>sum &gt;= k</code>，因为sum 比 k 小的时候说明数组还不够 k 个奇数，此时 map[sum-k] 表示出现了负数个奇数的下标数量，那一定是0，而当<code>sum &gt;= k</code> 时，如果 map[sum-k] 有值我们就加到结果中，没有值即为 0 ，也可以直接加到结果中，综上，代码非常简洁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">//相当于哈希表</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] &amp; <span class="number">1</span>;</span><br><span class="line">            ans += sum &gt;= k ? cnt[sum-k] : <span class="number">0</span>;</span><br><span class="line">            cnt[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-哈希表维护前缀和第三类"><a href="#2-3-哈希表维护前缀和第三类" class="headerlink" title="2.3 哈希表维护前缀和第三类"></a>2.3 哈希表维护前缀和第三类</h4><p>这一类问题中，key是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模 K）,value可能是最早出现的下标，也可能是出现的次数。</p>
<h5 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和</a></h5><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否存在同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小至少为 2 </li>
<li>子数组元素总和为 k 的整数倍</li>
</ul>
</blockquote>
<p>找好判定条件即可，这道题的判定条件的关键是数学上所谓的<strong>同余定理</strong>：如果两个数的差能被 k 整除，那么两个数关于 k 同余，同余即除以 k 的余数相同。因此前缀和计算关于 k 的余数，哈希表记录这个余数最早出现的下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; map;</span><br><span class="line">        map[0] = -1;</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            int </span><br><span class="line">            if(map.count(sum % k) &amp;&amp; i - map[sum % k] &gt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!map.count(sum % k))</span><br><span class="line">            &#123;</span><br><span class="line">                map[sum % k] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="和可被-K-整除的子数组"><a href="#和可被-K-整除的子数组" class="headerlink" title="和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">和可被 K 整除的子数组</a></h5><blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，返回其中元素之和可被 <code>k</code> 整除的（连续、非空） <strong>子数组</strong> 的数目。</p>
</blockquote>
<p>这道题现在这么一看就懂了，不赘述。直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; record = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem: nums) &#123;</span><br><span class="line">            sum += elem;</span><br><span class="line">            <span class="comment">//注意这里的取模运算处理</span></span><br><span class="line">            <span class="type">int</span> modulus = (sum % k + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (record.<span class="built_in">count</span>(modulus)) &#123;</span><br><span class="line">                ans += record[modulus];</span><br><span class="line">            &#125;</span><br><span class="line">            ++record[modulus];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中取模运算为什么要写成那样呢，因为直接在上一题的代码上修改会发现无法通过全部测试用例，这是因为<strong>C++取模运算的特性</strong>导致的，C++中如果对负数取模，输出将会是负数，但我们在这道题中希望输出是正数，否则当输入 nums &#x3D; [-1,2,9]，k &#x3D; 2时，第一个前缀和的余数是 -1，第二个前缀和余数是 1 ，对除数 2 来说这两个余数是等价的，但我们却会判断他们不相等而导致错误计数，因此我们把所有余数都取正数以方便判断。</p>
<blockquote>
<p><strong>为什么C++对负数取余输出是负数？</strong></p>
<p>这是一个经典的问题，用 C++ 或者 Java 语言计算 -7 % 3 得到的结果会是 -1，而 Python 中 -7 % 3 的结果为 2 ，当然答案都没问题，只是一个小于 0 ，一个大于 0 .</p>
<p>要了解结果不同的原因，首先要明白编程语言中是如何进行取模运算的：<code>a % b = a - (a / b) * b</code> </p>
<p>但是由于不同的计算机语言对于整数除法的处理不同，取模运算的结果也会不同。</p>
<ul>
<li><p>在 C++ 和 Java 中，整数除法是<strong>向零取整除法</strong>，也就是结果向靠近零的数取整，因此 -7 &#x2F; 3 &#x3D; -2. 于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-2) * 3 = -7 - (-6) = -1</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在 Python 中，整数除法是<strong>向下取整除法</strong>，也就是结果取小于它的最大整数，因此 -7 &#x2F; 3 &#x3D; -3.于是按照取模运算的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-7 % 3 = -7 - (-7 / 3) * 3 = -7 - (-3) * 3 = -7 - (-9) = 2</span><br><span class="line">7 % -3 = 7 - (7 / -3) * (-3) = 7 - (-3) * (-3) = 7 - 9 = -2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以是因为计算机语言对于整数除法的实现不同，导致了对于取模运算结果的不同。</p>
</blockquote>
<h4 id="2-4-同时维护前缀和与后缀和"><a href="#2-4-同时维护前缀和与后缀和" class="headerlink" title="2.4 同时维护前缀和与后缀和"></a>2.4 同时维护前缀和与后缀和</h4><p>在有些问题中，计算答案时同时需要用到前缀和和后缀和，下面是几道典型题目。</p>
<h5 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code>，返回数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>请<strong>不要使用除法，</strong>且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
</blockquote>
<p>题目中明确说了不要使用除法，不单单是为了避免最简单的做法，而是用除法的话当数组中出现 0 时就会出错，因此是一种不安全的做法。</p>
<p>稍加思考就会发现这道题可以维护<strong>前缀积</strong>和<strong>后缀积</strong>很轻松地解决，前缀积也是前缀和的推广，后面会专门总结这一类型。</p>
<p>我们只要用前缀积记录 nums[i] 左侧所有数字的积，用后缀积记录 nums[i] 右侧所有数字的积，把同一位置的前缀积和后缀积相乘就是这个位置的结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post[i] = post[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre[i] * post[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这道题用两个数组分别存放前缀积和后缀积太奢侈了，完全可以用 O(1) 额外空间完成上面的过程，因为前缀积的计算只依赖它前一个位置的前缀积，因此可以把数组优化掉只用一个整数来记录，这也是动态规划的常规优化思路了，之前见了很多，所以我们直接用结果数组 ans 存放前缀积和后缀积，先从左到右遍历，再从右到左遍历，就可以计算出最终结果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre *= nums[i<span class="number">-1</span>];</span><br><span class="line">            ans[i] *= pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> post = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;=<span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            post *= nums[i+<span class="number">1</span>];</span><br><span class="line">            ans[i] *= post;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a href="https://leetcode-cn.com/problems/find-pivot-index/">寻找数组的中心下标</a></h5><blockquote>
<p>给你一个整数数组 nums ，请计算数组的<strong>中心下标</strong> 。<br>数组中心下标是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。<br>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p>
</blockquote>
<p>如果用前缀和方法的话，和上面的题目是一样的思路，就不多说了。当然这是一道简单题，还有更简单的做法，如果一个位置是中心下标，那么它左右两侧数字和相等，也就是说<br>$$<br>sum_{left} + nums[i] + sum_{right} &#x3D; total \<br>由于 \   sum_{left} &#x3D; sum_{right} \<br>于是 \   nums[i] + 2sum &#x3D; total<br>$$<br>因此直接遍历每一个位置，动态的更新左侧数字和sum，判断是否满足上面的关系式就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] == total) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="找两个和为目标值且不重叠的子数组"><a href="#找两个和为目标值且不重叠的子数组" class="headerlink" title="找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">找两个和为目标值且不重叠的子数组</a></h5><blockquote>
<p>给你一个正整数数组 arr 和一个整数值 target 。<br>请你在 arr 中找 <strong>两个互不重叠的子数组</strong> 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。<br>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
</blockquote>
<p>这道题考查的相当综合，我们可以用之前的前缀和方法计算出所有满足条件的子数组然后取长度最短的两个，问题在于如何判断这两个子数组不重叠。最简单的方法是记录每一个子数组的左右边界然后进行比对判断，但这样太麻烦了，如果我们只考虑一个边界呢？比如我们从左到右扫描数组，找到符合条件的子数组就记录它的右边界和区间长度，那么要使两个子数组不重叠就需要另一个子数组的右边界<strong>小于当前子数组右边界减去当前区间长度</strong>，与此同时还要保证这两个子数组长度总和最小，自然想到动态规划。</p>
<p>定义 $dp[i]$ 表示<strong>以第 i 个数为右边界的和为 target 的子数组的最小长度</strong>。那么如果我们在当前位置没找到满足条件的子数组，$dp[i]$ 就等于上一个位置 $dp[i-1]$；而当我们找到一个满足条件的<br>$$<br>dp[i] &#x3D; min(len, dp[i-1])<br>$$<br>边界条件 $dp[0]$ 表示没有数字的子数组，无意义，但为了状态转移正确要初始化一个很大的值，为了避免计算溢出，只要比原数组长度大即可。</p>
<p>这样一来，我们最终需要的答案就是以当前位置为右边界的数组的最小长度 $dp[i]$ 加上和当前位置为右边界的最短子数组不重叠的子数组长度 $dp[i-len]$。</p>
<p>如果最终的结果比原数组长度大，那说明没有不重叠的子数组，返回 -1 .</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = arr.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> len = i - map[sum-target];</span><br><span class="line">                dp[i+<span class="number">1</span>] = <span class="built_in">min</span>(len, dp[i]);	<span class="comment">//更新动态规划状态</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i-len+<span class="number">1</span>] + len);	<span class="comment">//更新答案</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            map[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; arr.<span class="built_in">size</span>() ? <span class="number">-1</span> : ans;		<span class="comment">//最终答案不能比原数组长度大</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题还有可优化的空间，因为题目中明确说了是正整数数组，因此我们不需要用前缀和去找满足条件的数组，可以用之前学过的双指针滑动窗口，因为数组内都是正整数，那么当滑动窗口扩大的时候和一定会增大，因此我们维护两个指针，初始时都指向 0 位置，然后右指针右移计算区间和，如果区间和小于target，说明数字不够，继续右移扩大窗口，当区间和大于 target 说明数字多了，左指针右移收缩窗口，当区间和等于 target 就找到了一个符合条件的子数组，然后按照上面的流程更新状态和答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>(), left = <span class="number">0</span>, right, sum = <span class="number">0</span>, ans = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            sum += arr[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= arr[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="type">int</span> len = right - left + <span class="number">1</span>;  </span><br><span class="line">                dp[right + <span class="number">1</span>] = <span class="built_in">min</span>(dp[right], len);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, len + dp[left]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[right + <span class="number">1</span>] = dp[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; n ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-数据结构维护前缀和：二维情况"><a href="#2-5-数据结构维护前缀和：二维情况" class="headerlink" title="2.5 数据结构维护前缀和：二维情况"></a>2.5 数据结构维护前缀和：二维情况</h4><h5 id="元素和为目标值的子矩阵数量"><a href="#元素和为目标值的子矩阵数量" class="headerlink" title="元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">元素和为目标值的子矩阵数量</a></h5><blockquote>
<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>(x1, y1, x2, y2)</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;) </code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
</blockquote>
<p>按照之前的处理矩阵的经验，这道题可以通过枚举上下边界转化为一维的 “和为 K 的子数组” 问题，然后按照一维的方法做即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(cols, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; rows; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[k] += matrix[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">                map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; cols; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += sums[k];</span><br><span class="line">                    <span class="keyword">if</span>(map.<span class="built_in">count</span>(sum - target))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += map[sum - target];</span><br><span class="line">                    &#125;</span><br><span class="line">                    map[sum]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><a href="https://leetcode-cn.com/problems/matrix-block-sum/">矩阵区域和</a></h5><blockquote>
<p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 <code>answer[i][j]</code> 是所有满足下述条件的元素 <code>mat[r][c]</code> 的和： </p>
<ul>
<li>i - k &lt;&#x3D; r &lt;&#x3D; i + k,</li>
<li>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且</li>
<li>(r, c) 在矩阵内。</li>
</ul>
</blockquote>
<p>回顾之前的二维前缀和计算，那么把问题转化为对数组 <code>mat</code> 中的每个位置，计算以 <code>(i - K, j - K)</code> 为左上角，<code>(i + K, j + K)</code> 为右下角的矩形子数组的元素之和，再利用维护好的二维前缀和就很好解决了，只要注意下标位置越界的判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixBlockSum</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> rows = mat.<span class="built_in">size</span>(), cols = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pre</span>(rows+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i][j] = pre[i<span class="number">-1</span>][j] + pre[i][j<span class="number">-1</span>] - pre[i<span class="number">-1</span>][j<span class="number">-1</span>] + mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> endposx = <span class="built_in">min</span>(i+k+<span class="number">1</span>, rows);</span><br><span class="line">                <span class="type">int</span> endposy = <span class="built_in">min</span>(j+k+<span class="number">1</span>, cols);</span><br><span class="line">                <span class="type">int</span> beginposx = <span class="built_in">max</span>(i-k, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> beginposy = <span class="built_in">max</span>(j-k, <span class="number">0</span>);</span><br><span class="line">                ans[i][j] = pre[endposx][endposy] - pre[beginposx][endposy] - pre[endposx][beginposy] + pre[beginposx][beginposy];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最大子矩阵"><a href="#最大子矩阵" class="headerlink" title="最大子矩阵"></a><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">最大子矩阵</a></h5><blockquote>
<p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1, c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2, c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
</blockquote>
<p>之前做过的题目，现在再来看就非常简单了，同样是枚举上下边界转化为一维最大子数组问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getMaxMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">4</span>)</span></span>;<span class="comment">//保存最大子矩阵的左上角和右下角的行列坐标</span></span><br><span class="line">        <span class="type">int</span> N = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> M = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxsum=INT_MIN;<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> r1,c1;<span class="comment">//暂时记录左上角，相当于begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;     <span class="comment">//以i为上边，从上而下扫描</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(M, <span class="number">0</span>)</span></span>;    <span class="comment">//记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; N; j++)&#123;    <span class="comment">//子矩阵的下边，从i到N-1，不断增加子矩阵的高</span></span><br><span class="line">                <span class="comment">//每次循环都相当于求一次一维最大子序列和</span></span><br><span class="line">                <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; k++)&#123;</span><br><span class="line">                    b[k] += matrix[j][k];   </span><br><span class="line">                    <span class="keyword">if</span>(dp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp += b[k];     <span class="comment">//相当于dp[i] = dp[i-1] + nums[i]</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp = b[k];      <span class="comment">//相当于dp[i] = 0 + nums[i]</span></span><br><span class="line">                        r1 = i;</span><br><span class="line">                        c1 = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( dp &gt; maxsum)&#123;</span><br><span class="line">                        maxsum = dp;</span><br><span class="line">                        ans = &#123;r1, c1, j, k&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="矩形区域不超过-K-的最大数值和"><a href="#矩形区域不超过-K-的最大数值和" class="headerlink" title="矩形区域不超过 K 的最大数值和"></a><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">矩形区域不超过 K 的最大数值和</a></h5><blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 k 的矩形区域。</p>
</blockquote>
<p>也是之前做过的题目，现在看来同样是枚举上下边界转化为一维问题，难点在于对和不超过 k 的理解。我们在维护出的前缀和数组 sum 中要找到满足：<br>$$<br>sum[right]-sum[left] \leq k<br>$$<br>简单移项可以得到：<br>$$<br>sum[left] \geq sum[right]-k<br>$$<br>因此对于当前的 $sum[right]$ 来说，要找到满足上式的 $sum[left]$ ，同时为了保证 $sum[right]-sum[left]$ 尽可能大，我们找的满足条件的 $sum[left]$ 就要尽可能的小，然后结果取所有$sum[right]-sum[left]$ 中的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m; ++j) &#123; <span class="comment">// 枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                    sum[c] += matrix[j][c]; <span class="comment">// 更新每列的元素和</span></span><br><span class="line">                &#125;</span><br><span class="line">                set&lt;<span class="type">int</span>&gt; sumSet&#123;<span class="number">0</span>&#125;;		<span class="comment">//用有序哈希表方便查找满足条件的最小值</span></span><br><span class="line">                <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : sum) &#123;</span><br><span class="line">                    s += v;</span><br><span class="line">                    <span class="keyword">auto</span> lb = sumSet.<span class="built_in">lower_bound</span>(s - k);	<span class="comment">//查找满足条件的sum[left]中的最小值，即下边界</span></span><br><span class="line">                    <span class="keyword">if</span> (lb != sumSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, s - *lb);	<span class="comment">//取所有sum[right]-sum[left]中的最大值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    sumSet.<span class="built_in">insert</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-前缀和推广"><a href="#3-前缀和推广" class="headerlink" title="3 前缀和推广"></a>3 前缀和推广</h3><p>前缀和求的是数组 a 的前缀 [0..i-1] 的和，也就是对这些元素做加法结果，实际上对前缀 [0..i-1]，我们还可以做很多其它运算得到相应结果。<br>如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。</p>
<p>事实上这种运算是存在的，例如之前我们遇到过的前缀积，也就是乘法运算，再例如异或运算，对应每个前缀 [0..i-1] ，我们都可以求得一个异或值，称为前缀异或，而对于区间 [L, R]。我们可以用 [0..R] 的前缀异或减去 [0..L-1] 的前缀异或就可以得到区间上的异或值，这个逻辑与前缀和完全相同。这依赖于异或运算的性质。</p>
<h4 id="3-1-前缀积"><a href="#3-1-前缀积" class="headerlink" title="3.1 前缀积"></a>3.1 前缀积</h4><h5 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">乘积最大子数组</a></h5><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<p>乘积最大子数组和加法的区别在于要考虑负数的的情况，为了让负数相乘的结果尽可能大，我们还要维护一个最小乘积。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dpmax = nums[<span class="number">0</span>], dpmin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dpmax;</span><br><span class="line">            dpmax = <span class="built_in">max</span>(dpmax * nums[i], <span class="built_in">max</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            dpmin = <span class="built_in">min</span>(tmp * nums[i], <span class="built_in">min</span>(nums[i], dpmin * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dpmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">乘积小于K的子数组</a></h5><blockquote>
<p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> 。</p>
<p>请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
</blockquote>
<p>类似于 矩形区域不超过K的子矩阵 问题，相比之下还更简单一些。有时候我们可能直接去想一些优化后的算法不是那么容易，这时候我们就可以先按暴力的方法把代码写出来再观察。比如这道题我们就用最暴力的前缀积方法先把代码写出来，也不考虑额外空间，多重循环，乘积过大会溢出之类的问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = pre[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[i] / pre[j] &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += (i - j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这个方法是肯定无法通过测试的，但是我们观察代码可以获得更多的想法，因为题目给定的都是正整数，所以实际上在二重循环中我们只是在寻找 i 左边的使得 i 位置的前缀积能小于 k 的第一个 j ，那么之后的所有 j 就都可以和 i 形成一个乘积小于 k 的子区间，这不就是我们的优化方向吗。</p>
<p>这样一来也不需要使用数组维护前缀积了，上一次我们遇到正整数数组的时候用的是滑动窗口，那这里也是一样，对于每一个 right 指针指向的位置，如果它的前缀积不小 k ，那就说明数字多了，左移 left 指针收缩窗口，直到乘积小于 k ，那么 right 位置就可以提供 right - left + 1个乘积小于 k 的子数组。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, left = <span class="number">0</span>, plus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            plus *= nums[right];</span><br><span class="line">            <span class="keyword">while</span>(plus &gt;= k &amp;&amp; left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                plus /= nums[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="最后-K-个数的乘积"><a href="#最后-K-个数的乘积" class="headerlink" title="最后 K 个数的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-the-last-k-numbers/">最后 K 个数的乘积</a></h5><blockquote>
<p>请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法：</p>
<ol>
<li><p>add(int num)：将数字 num 添加到当前数字列表的最后面。</p>
</li>
<li><p>getProduct(int k)：返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终至少包含 k 个数字</p>
</li>
</ol>
</blockquote>
<p>简单的实现问题，注意对0的处理即可，当遇到数字0直接清空前缀积数组，如果要求的 k 大于当前的前缀积数组长度，说明后 k 个数中一定有 0，直接返回 0 即可，其他情况正常除法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pre;</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        pre.<span class="built_in">assign</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) pre.<span class="built_in">resize</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> pre.<span class="built_in">push_back</span>(pre.<span class="built_in">back</span>()*num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProduct</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &lt; pre.<span class="built_in">size</span>() ? pre.<span class="built_in">back</span>() / *(pre.<span class="built_in">end</span>()- k - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-前缀异或"><a href="#3-2-前缀异或" class="headerlink" title="3.2 前缀异或"></a>3.2 前缀异或</h4><h5 id="子数组异或查询"><a href="#子数组异或查询" class="headerlink" title="子数组异或查询"></a><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">子数组异或查询</a></h5><blockquote>
<p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] &#x3D; [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
</blockquote>
<p>只要知道了前缀异或成立，这道题目没什么难度。借这道题证明为什么异或运算也满足区间减法：<br>$$<br>\begin{split}<br>Q(left, right) &amp;&#x3D; arr[left] \oplus … \oplus arr[right] \\<br>&amp;&#x3D; (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[0] \oplus … \oplus arr[left-1]) \oplus (arr[left] \oplus … \oplus arr[right])\\<br>&amp;&#x3D;(arr[0] \oplus … \oplus arr[left-1]) \oplus(arr[0] \oplus … \oplus arr[right]) \\<br>\end{split}<br>$$<br>这里用到了异或的结合律，实际上也正因为异或满足结合律所以可以满足区间减法的性质。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xorQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">xors</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            xors[i + <span class="number">1</span>] = xors[i] ^ arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            ans[i] = xors[queries[i][<span class="number">0</span>]] ^ xors[queries[i][<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="形成两个异或相等数组的三元组数目"><a href="#形成两个异或相等数组的三元组数目" class="headerlink" title="形成两个异或相等数组的三元组数目"></a><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">形成两个异或相等数组的三元组数目</a></h5><blockquote>
<p>给你一个整数数组 arr 。现需要从数组中取三个下标 i、j 和 k ，其中 (<code>0 &lt;= i &lt; j &lt;= k &lt; arr.length</code>) 。</p>
<p>a 和 b 定义如下：</p>
<ul>
<li>a &#x3D; arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]</li>
<li>b &#x3D; arr[j] ^ arr[j + 1] ^ … ^ arr[k]</li>
</ul>
<p>请返回能够令 a &#x3D;&#x3D; b 成立的三元组 (i, j , k) 的数目。</p>
</blockquote>
<p>假设前缀异或数组为 $xors$，实际上 $a&#x3D;xors[i] \oplus xors[j]$，$b&#x3D;xors[j] \oplus xors[k+1]$，而 $a&#x3D;&#x3D;b$，那也就是 $xors[i]&#x3D;&#x3D;xors[k+1]$，因此只要找到前缀异或相等的两个位置 $i$ 和 $k$，这两个位置中的任意一个位置都可以是 $j$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt, total;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">            <span class="type">int</span> val = arr[k];</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(s ^ val)) &#123;</span><br><span class="line">                ans += cnt[s ^ val] * k - total[s ^ val];</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt[s];</span><br><span class="line">            total[s] += k;</span><br><span class="line">            s ^= val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-差分"><a href="#4-差分" class="headerlink" title="4 差分"></a>4 差分</h3><p>差分是对前缀和性质的一个巧妙运用，有时候能起到奇效。</p>
<p>前缀和序列 $S_{0}, S_{1}, …, S_{n}$ 的差分序列 $a_{0}, a_{1}, …, a_{n-1}$ 就等于原序列，其中 $a_{i} &#x3D; S_{i+1} - S_{i}$ 。</p>
<p>原序列 $a_{0}, a_{1}, …, a_{n-1}$ 的差分序列为 $b_{0}, b_{1}, …, b_{n-1}$，其中 $b_{0} &#x3D; a_{0} - 0, b_{i} &#x3D; a_{i} - a_{i-1}$。则对差分序列求前缀和序列，就能得到原序列。</p>
<p>差分序列的好处是如果要对原序列的一个区间 $[l, r]$ 上的所有值都加上一个 $val$，在原序列上要操作 $r-l+1$ 次（对应每个位置都加一次），而在差分序列上只需要操作 2 次（只需要 $b[l] + val, b[r+1] - val$）即可。</p>
<p>如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。</p>
<p><strong><a href="https://leetcode-cn.com/problems/range-addition/">区间加法</a></strong></p>
<blockquote>
<p>假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k 个更新的操作。</p>
<p>其中，每个操作会被表示为一个三元组：<code>[startIndex, endIndex, inc]</code>，你需要将子数组 <code>A[startIndex ... endIndex]</code>（包括 startIndex 和 endIndex）增加 <code>inc</code>。</p>
<p>请你返回 k 次操作后的数组。</p>
</blockquote>
<p>利用上面的差分性质这道题很容易解决，否则就要不停的遍历区间去加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">chafen</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            chafen[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) chafen[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) ans[i] = chafen[i];</span><br><span class="line">            <span class="keyword">else</span> ans[i] = ans[i<span class="number">-1</span>] + chafen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码还可以进一步优化，直接把 ans 数组当成差分数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getModifiedArray</span><span class="params">(<span class="type">int</span> length, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; updates)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> u : updates)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[u[<span class="number">0</span>]] += u[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(u[<span class="number">1</span>] + <span class="number">1</span> &lt; length) ans[u[<span class="number">1</span>]+<span class="number">1</span>] -= u[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] += ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（二）基础纹理</title>
    <url>/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</url>
    <content><![CDATA[<p>这一节我们将学习纹理映射的实现方式，包括单张图片纹理，以及在游戏中广泛应用的凹凸纹理、渐变纹理和遮罩纹理。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-单张纹理"><a href="#1-单张纹理" class="headerlink" title="1 单张纹理"></a>1 单张纹理</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Single Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用纹理代替之前的漫反射颜色，纹理的类型是2D，使用&quot;white&quot; &#123;&#125;将纹理默认值设为白色，可以在材质面板中选择其他纹理</span></span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="comment">// 纹理的类型是sampler2D</span></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="comment">// 在Unity中，我们需要使用纹理名_ST的方式来声明某个纹理的属性，其中，ST是缩放(scale)和平移(translation)的缩写</span></span><br><span class="line">            <span class="comment">// _MainTex_ST.xy 存储的是缩放值，_MainTex_ST.zw 存储的是偏移值，用于后续的纹理坐标变换</span></span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;    <span class="comment">//用第一组纹理坐标填充texcoord变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;        <span class="comment">//存储纹理坐标的变量</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对纹理坐标进行变换，因为顶点纹理坐标在[0,1]，因此要用缩放和平移对纹理坐标进行变换</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 也可以直接调用内置函数TRANSFORM_TEX，第一个参数是顶点纹理坐标，第二个参数是纹理名字</span></span><br><span class="line"><span class="comment">//                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用tex2D函数对纹理进行采样，第一个参数是被采样的纹理，第二个参数是纹理坐标</span></span><br><span class="line">                <span class="comment">// 将纹理颜色和颜色属性_Color的乘积作为反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">// 用反射率乘以环境光作为环境光项</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">// 用反射率作为漫反射颜色计算漫反射项</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// 高光项</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220402212721166.png" alt="image-20220402212721166"></p>
<h3 id="2-凹凸纹理"><a href="#2-凹凸纹理" class="headerlink" title="2 凹凸纹理"></a>2 凹凸纹理</h3><p>之前学习过凹凸纹理的实现有两种方式，一种是使用高度贴图，纹理中记录顶点法线的位移（高度），但是这样做不够逼真，物体边缘处还是平滑的，很容易看出破绽；另一种是法线贴图，纹理中直接记录每个顶点的法线方向，由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是：<br>$$<br>piexl &#x3D; \frac{normal + 1}{2}<br>$$<br>这就要求我们对法线纹理进行纹理采样后，还要进行一个反映射，即：<br>$$<br>normal &#x3D; pixel \times 2 - 1<br>$$<br>既然记录的是法线方向，那么一定有一个参考坐标系，最简单的当然是直接记录模型空间下的法线方向，这样我们可以正常转换到世界空间然后直接计算光照，这种纹理称为<strong>模型空间下的法线纹理</strong>；更好的方式是记录每个顶点的切线空间下的法线方向，所谓切线空间是指以顶点切线为 x 轴，副切线为 y 轴，顶点法线为 z 轴的空间，这种纹理称为<strong>切线空间下的法线纹理</strong>。为什么存储切线空间中的纹理更好呢？我们可以对比一下两种法线纹理的优缺点：</p>
<ul>
<li>使用模型空间的法线纹理实现简单，也更加直观。并且在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li>
<li>使用切线空间的法线纹理，首先，自由度很高，模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了，而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果；其次，可进行 UV 动画，比如，我们可以移动一个纹理的 UV 坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果，原因同上。这种 UV 动画在水或者火山熔岩这种类型的物体上会经常用到；再次，可以重用法线纹理，比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的 6 个面上；最后，可压缩，由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储 XY 方向，而推导得到 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储 3 个方向的值，不可压缩。</li>
</ul>
<p>显然切线空间下的法线纹理好处更多。</p>
<p>接下来实现凹凸纹理的效果。我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。  由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有两种选择：一种选择是在切线空间下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下；另一种选择是在世界空间下进行光照计算，此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向<br>进行计算。从效率上来说，第一种方法往往要优于第二种方法，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用 Cubemap 进行环境映射时，我们需要使用世界空间下的反射方向对 Cubemap 进行采样。</p>
<h4 id="2-1-在切线空间下计算"><a href="#2-1-在切线空间下计算" class="headerlink" title="2.1 在切线空间下计算"></a>2.1 在切线空间下计算</h4><p>我们首先来实现第一种方法，即在切线空间下计算光照模型。基本思路是：在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照结果。为此，我们首先需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中，即我们需要知道从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵是非常容易求得的，就只有坐标轴的旋转和原点的平移，而对于矢量变换，不需要平移，只有坐标轴的旋转，因此我们在顶点着色器中按切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按列</strong>排列即可得到从切线空间到模型空间的变换矩阵。如果一个变换中仅存在平移和旋转变换，那么这个变换的逆矩阵就等于它的转置矩阵，而从切线空间到模型空间的变换正是符合这样要求的变换。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，我们把切线 (x 轴）、副切线 (y 轴）、法线 (z 轴）的顺序<strong>按行</strong>排列即可。CG 中矩阵填充默认刚好是按行填充。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In Tangent Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//存储切线空间下的光照方向和视线方向</span></span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造模型空间到切线空间的矩阵</span></span><br><span class="line">                <span class="comment">// 副切线方向，由于法线和切线的叉乘有两个方向，因此切线的第4个分类w来决定使用哪个方向作为副切线方向</span></span><br><span class="line">                fixed3 Binormal = <span class="built_in">cross</span>(v.normal, v.tangent.xyz) * v.tangent.w;</span><br><span class="line">                <span class="comment">// 模型空间下的三个方向按行排列构成模型空间到切线空间的矩阵</span></span><br><span class="line">                float3x3 ObjToTangent = float3x3(v.tangent.xyz, Binormal, v.normal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将光线方向和视线方向从模型空间转换到切线空间</span></span><br><span class="line">                o.lightDir = mul(ObjToTangent, ObjSpaceLightDir(v.vertex));</span><br><span class="line">                o.viewDir = mul(ObjToTangent, ObjSpaceViewDir(v.vertex));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 别忘了归一化                </span></span><br><span class="line">                fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对法线纹理进行采样</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line">                <span class="comment">// 如果没有把法线纹理的类型在Unity中设置成 &quot;Normal map&quot;，我们就需要进行手动反映射</span></span><br><span class="line">                <span class="comment">// 我们首先把 packedNormal 的 xy 分量按之前提到的公式映射回法线方向</span></span><br><span class="line">                <span class="comment">// 然后乘以_BumpScale (控制凹凸程度) 来得到 tangentNormal 的 xy 分量</span></span><br><span class="line"><span class="comment">//                tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span></span><br><span class="line">                <span class="comment">// 由于法线都是单位矢量，因此 tangentNormal.z 分量可以由 tangentNonnal.xy 计算而得到</span></span><br><span class="line"><span class="comment">//                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 我们通常会把法线纹理的纹理类型标识成 Normal map，此时_BumpMap的 rgb 分量并不再是切线空间下法线方向的 xyz 值了</span></span><br><span class="line">                <span class="comment">// 因此如果我们再使用上面的方法来计算就会得到错误的结果</span></span><br><span class="line">                <span class="comment">// 在这种情况下，我们可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向</span></span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以调整材质面板中的 Bump Scale 属性控制凹凸程度，Bump Scale &#x3D; -1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150337945.png" alt="image-20220403150337945"></p>
<p>Bump Scale &#x3D; 1 时渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403150354630.png" alt="image-20220403150354630"></p>
<p>可以看出凹凸程度的正负决定了物体表面是“凸出来”还是“凹进去”。</p>
<h4 id="2-2-在世界空间下计算"><a href="#2-2-在世界空间下计算" class="headerlink" title="2.2 在世界空间下计算"></a>2.2 在世界空间下计算</h4><p>现在，我们在世界空间下计算光照。这时我们需要在片元着色器中把法线方向从切线空间变换到世界空间下。因此要先在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器。变换矩阵的计算可以由顶点的切线、副切线和法线在世界空间下的表示按列排列来得到。尽管这种方法需要更多的计算，但在需要使用 Cubemap 进行环境映射等情况下，我们就需要使用这种方法。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In World Space&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 使用 &quot;bump&quot; 作为法线纹理的默认值，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息</span></span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 用于控制凹凸程度的系数，当它为 0 时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;    <span class="comment">//法线纹理坐标的缩放和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">//切线的类型是float4，这是因为我们需要第4个分量w来确定副切线方向，即切线空间的y轴方向</span></span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// 因为要存储两个纹理坐标，因此定义为float4类型，xy存储纹理坐标，zw存储法线纹理坐标</span></span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">// 一个插值寄存器最多只能存储float4大小的变量，因此无法直接存储矩阵，需要按行存储</span></span><br><span class="line">                <span class="comment">// 切线空间到世界空间的矩阵只需要3x3，还可以将世界空间下的顶点坐标存在w分量中以充分利用寄存器</span></span><br><span class="line">                float4 TangentToWorld0 : TEXCOORD01;</span><br><span class="line">                float4 TangentToWorld1 : TEXCOORD02;</span><br><span class="line">                float4 TangentToWorld2 : TEXCOORD03;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//纹理坐标变换</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造切线空间到世界空间的矩阵</span></span><br><span class="line">                <span class="comment">// 将世界空间下的切线、副切线、法线按列排列即可，并将世界空间下的顶点坐标存入w分量</span></span><br><span class="line">                fixed3 WorldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 WorldTangent =  UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 WorldBiTangent = <span class="built_in">cross</span>(WorldNormal, WorldTangent) * v.tangent.w;</span><br><span class="line">                float3 WorldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.TangentToWorld0 = float4(WorldTangent.x, WorldBiTangent.x, WorldNormal.x, WorldPos.x);</span><br><span class="line">                o.TangentToWorld1 = float4(WorldTangent.y, WorldBiTangent.y, WorldNormal.y, WorldPos.y);</span><br><span class="line">                o.TangentToWorld2 = float4(WorldTangent.z, WorldBiTangent.z, WorldNormal.z, WorldPos.z);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到世界空间下的顶点坐标</span></span><br><span class="line">                float3 WorldPos = float3(i.TangentToWorld0.w, i.TangentToWorld1.w, i.TangentToWorld2.w);</span><br><span class="line">                <span class="comment">// 得到世界空间下的光照方向</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(WorldPos));</span><br><span class="line">                <span class="comment">// 得到世界空间下的视线方向和半程向量</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(WorldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对法线纹理进行采样得到切线空间下的法线</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">                <span class="comment">// 将法线转到世界空间下</span></span><br><span class="line">                float3x3 TangentToWorld = float3x3(i.TangentToWorld0.xyz, i.TangentToWorld1.xyz, i.TangentToWorld2.xyz);</span><br><span class="line">                fixed3 WorldNormal = <span class="built_in">normalize</span>(mul(TangentToWorld, tangentNormal));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//计算反射率</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                <span class="comment">//计算环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                <span class="comment">//使用法线纹理得到的法线计算漫反射和高光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, worldLightDir));</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(WorldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果和在切线空间下计算是完全一样的。这里需要特别说明结构体 v2f 中分别用三个向量存储矩阵，这是因为插值寄存器最多只能存储 float4 类型的变量，因此矩阵要分行从顶点着色器传递给片元着色器。从顶点着色器传递给片元着色器的过程中，插值寄存器中的值（顶点的属性）会被自动插值为片元的属性。</p>
<p>另外我们也可以导入高度纹理，然后在纹理面板勾选 Create from Grayscale 来自动生成切线空间的法线纹理。</p>
<h3 id="3-渐变纹理"><a href="#3-渐变纹理" class="headerlink" title="3 渐变纹理"></a>3 渐变纹理</h3><p>我们在图形学中学过，纹理在现代 GPU 中可以认为是一块可以支持快速查询的内存，因此不仅可以用来存储颜色，还可以用来存储任何属性，上面的法线贴图就是一个例子。另一个常见的用法就是使用渐变纹理来控制漫反射光照的结果。在之前计算漫反射光照时，我们都是使用表面法线和光照方向的点积结果与材质的反射率相乘来得到表面的漫反射光照。但有时，我们需要更加灵活地控制光照结果。</p>
<p>使用渐变纹理控制光照结果可以保证物体的轮廓线相比于之前使用的传统漫反射光照更加明显，而且能够提供多种色调变化，现在很多卡通风格的渲染中都使用了这种技术。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Ramp Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 定义一个纹理属性存储渐变纹理代替漫反射颜色</span></span><br><span class="line">        _RampTex (&quot;Ramp Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="comment">// 使用内置函数进行纹理坐标转换</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用半兰伯特模型</span></span><br><span class="line">                fixed halfLambert  = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">// 使用半兰伯特对渐变纹理进行采样得到漫反射颜色</span></span><br><span class="line">                <span class="comment">// 因为半兰伯特将夹角余弦从 [-1,1] 映射到了 [0,1]，所以可以作为纹理坐标</span></span><br><span class="line">                <span class="comment">// 渐变纹理本质上是一维纹理，纵坐标像颜色不变，所以纵坐标是多少实际上无所谓，这里同样使用halfLambert</span></span><br><span class="line">                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line">                </span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同渐变纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162805665.png" alt="image-20220403162805665"></p>
<p>需要注意的是我们要把渐变纹理的 Wrap Mode 设为 Clamp 模式，以防止对纹理进行采样时由于浮点数精度而造成的问题。下图是使用 Repeat 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403162942135.png" alt="image-20220403162942135"></p>
<p>下图是使用 Clamp 模式的渐变纹理效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403163013842.png" alt="image-20220403163013842"></p>
<p>可以看出在 Repeat 模式下高光区域存在一些黑点，这是由浮点精度造成的。当我们使用 fixed2(haIfLambert, halfLambert) 对渐变纹理进行采样时，虽然理论上 haIfLambert 的值在 [0, 1] 之间，但是可能会有 1.00001 这样的值出现。如果使用 Repeat 模式，此时就会舍<br>弃整数部分，只保留小数部分，得到的值就是 0.00001,  对应了渐变图中最左边的值，即黑色。因此，就会出现图中这样在高光区域有黑点的情况。所以我们只需要把渐变纹理的 Wrap Mode 设为 Clamp 模式就可以解决这种问题。超过 1 则截取到 1，就可以取到正常值。</p>
<h3 id="4-遮罩纹理"><a href="#4-遮罩纹理" class="headerlink" title="4 遮罩纹理"></a>4 遮罩纹理</h3><p>遮罩纹理 (mask texture) 是极其有用的一种纹理，在很多商业游戏中都可以见到它的身影。那么什么是遮罩呢？ 简单来讲，遮罩允许我们可以保护某些区域，使它们免于某些修改。例如，在之前的实现中，我们都是把高光反射应用到模型表面的所有地方，即所有的像素都使用同样大小的高光强度和高光指数。但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p>
<p>使用遮罩纹理的流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值（例如 texel.r）来与某种表面属性进行相乘，这样，当该通道的值为 0 时，可以保护表面不受该属性的影响。总而言之， 使用遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Mask Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale(&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// 定义一个高光反射遮罩纹理属性</span></span><br><span class="line">        _SpecularMask (&quot;Specular Mask&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 定义一个控制遮罩影响度的系数</span></span><br><span class="line">        _SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            <span class="type">sampler2D</span> _SpecularMask;</span><br><span class="line">            <span class="type">float</span> _SpecularScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir: TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算切线空间的光照方向和视线方向，使用了TANGENT_SPACE_ROTATION语义</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                 fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                tangentNormal.xy *= _BumpScale;</span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line">                </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">                 <span class="comment">// 获得高光遮罩纹理采样值并乘以遮罩影响系数得到掩码值</span></span><br><span class="line">                <span class="comment">// 由于本次使用的遮罩纹理的 rgb 值都是一样的，因此使用哪个分量计算都可以，这里使用 r 分量计算掩码值</span></span><br><span class="line">                 fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">                 <span class="comment">// 使用高光遮罩纹理计算高光项，将掩码值乘到原本的高光项上即可</span></span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未使用遮罩纹理的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165016553.png" alt="image-20220403165016553"></p>
<p>使用高光遮罩纹理的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/03/20220403-Shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20220403165056580.png" alt="image-20220403165056580"></p>
<p>可以看出，遮罩纹理可以让我们更加精细地控制光照细节，得到更细腻的效果。</p>
<p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的 RGBA 四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在 R 通道，把边缘光照的强度存储在 G 通道，把高光反射的指数部分存储在 B 通道，最后把自发光强度存储在 A 通道。</p>
<p>在游戏《DOTA2》的开发中，开发人员为每个模型使用了 4 张纹理：一张用于定义模型颜色，一张用于定义表面法线，另外两张则都是遮罩纹理。这样，两张遮罩纹理提供了共 8 种额外的表面属性，这使得游戏中的人物材质自由度很强，可以支持很多高级的模型属性。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】贪心算法</title>
    <url>/LycTechStack.github.io/2022/04/05/20220405-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法也是最常用的算法之一，很多困难问题使用贪心算法会大幅简化。贪心算法的思想很简单，贪心算法每一次都做出当前看起来最好的选择，而不用考虑其它可能的选择。</p>
<p>贪心算法的学习可以与动态规划算法进行比较，看看它到底比动态规划算法少考虑了哪些子问题，为什么可以少考虑那些子问题，而每次只专注于求解一个子问题，通过逐步递推得到原问题的答案。</p>
<p><em><span id="more"></span></em></p>
<p>一般来说，使用贪心算法也需要满足一定的条件：</p>
<ul>
<li>最优子结构：规模较大的问题的解由规模较小的子问题的解组成，区别于「动态规划」，可以使用「贪心算法」的问题「规模较大的问题的解」只由其中一个「规模较小的子问题的解」决定；</li>
<li>无后效性：后面阶段的求解不会修改前面阶段已经计算好的结果；</li>
<li>贪心选择性质：从局部最优解可以得到全局最优解。</li>
</ul>
<p>回顾动态规划解决问题时需要满足的条件，贪心算法多了一条贪心选择性质，因此一般来说能用贪心的题目都可以用动态规划解决，但能用动态规划的题目不一定能用贪心解决。</p>
<h3 id="1-最简单的贪心"><a href="#1-最简单的贪心" class="headerlink" title="1 最简单的贪心"></a>1 最简单的贪心</h3><p>首先通过一道最经典的贪心问题理解贪心算法的思路。</p>
<p><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></p>
<blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>解决这道问题的核心思想是，从最小胃口的孩子开始满足，如果连最小的胃口的孩子都满足不了，那么更大胃口的孩子也无法满足，因此对于每一个孩子，找到大于他的胃口值的最小饼干分发给他即可。所以对两个数组排序然后双指针分发饼干即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>() &amp;&amp; j &lt; s.<span class="built_in">size</span>(); ++i, ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; g[i] &gt; s[j]) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; s.<span class="built_in">size</span>()) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是最简单的贪心思想，至于为什么能这么做，我们甚至不需要证明也能想明白，当然也可以在<a href="https://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/">官方题解</a>中找到严格的证明。但对于一些困难的问题，有时不通过严谨的证明我们无法想清楚为什么可以使用贪心，也因此想不到用贪心算法去解决。所以贪心算法最困难的地方在于如何证明能够通过局部最优解得出全局最优解。</p>
<p>贪心算法几乎没有套路，到底如何贪心，贪什么与我们要解决的问题密切相关。因此学习贪心算法需要多做多练，然后才有直觉，猜测一个问题可能需要使用贪心算法，进而尝试证明，学会证明。</p>
<h3 id="2-找零钱问题"><a href="#2-找零钱问题" class="headerlink" title="2 找零钱问题"></a>2 找零钱问题</h3><p>可以使用贪心算法解决的一类经典问题是找零钱问题。在生活中，我们找给别人零钱，通常都是按照先给出尽可能多的面值较大的纸币（硬币），然后再给出尽可能多的面值第二大的纸币（硬币），直到凑成了我们需要凑出的金额为止，这样找零钱得到的纸币（硬币）的张数（个数）最少。</p>
<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零</a></h4><blockquote>
<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
</blockquote>
<p>由于只有三种面值，对于每一种面值有如下结论：</p>
<ul>
<li>如果顾客支付 5 美元，则无需找零，直接收下</li>
<li>如果顾客支付 10 美元，需要找零 5 美元，如果没有 5 美元则返回 false</li>
<li>如果顾客支付 20 美元，需要找零 15 美元，这时有两种情况，找零 1 张 10 美元和 1 张 5 美元，或者找零 3 张 5 美元，如果能够满足第一种情况，那我们优先按第一种方式找零，因为要尽可能保留 5 美元，5 美元在找零上需要的场合比 10 美元更多</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b : bills)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">5</span>) ++five;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five &gt; <span class="number">0</span>) --five, ++ten;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) --ten, --five;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five &gt; <span class="number">2</span>) five -= <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>这道题不能使用贪心算法，因为不满足贪心选择性质，如果每次我们都选择面值最大的硬币去凑成 amount，那么有可能存在使用较小面值的硬币组合可以成 amount，但是用较大面值的硬币无法凑成 amount 的情况，因此不能使用贪心算法。但是显然这道题满足最优子结构和无后效性，因此可以使用动态规划解决。</p>
<p>定义状态 <code>dp[amount]</code> 表示凑成 amount 所需的最少硬币数，边界条件显然是 <code>dp[0] = 0</code>，对于每一个amount，都可以选择任意一个硬币，如果选择硬币 c ，则 <code>dp[amount] = dp[amount - c] + 1</code>，遍历所有 c ，取最小值即可，注意前提是 amount 要比 c 大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= c &amp;&amp; dp[i-c] != INT_MAX) dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-区域选择问题"><a href="#3-区域选择问题" class="headerlink" title="3 区域选择问题"></a>3 区域选择问题</h3><p>有一类使用贪心算法解决的问题称为活动选择问题，解决这一类问题的核心思路是<strong>优先选择最早的活动</strong>。</p>
<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h4><blockquote>
<p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回需要移除区间的最小数量，使剩余区间互不重叠 。</p>
</blockquote>
<p>问题等价于寻找数量最多的互不重叠的子区间。使用动态规划很简单，按左端点排序，问题就变成了最长上升子序列问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[j][<span class="number">1</span>] &lt;= intervals[i][<span class="number">0</span>]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>动态规划的时间复杂度是 O(nlogn)，使用贪心法可以优化到 O(n)。我们按照区间右端点排序，然后遍历所有区间考虑下一步选择哪个区间。因为是按照区间右端点排序的，所以后面的区间右端点一定比当前区间右端点大，如果两个区间右端点相等，选择哪个区间都可以，对下一步区间选择不会产生影响，对最终结果也不会产生影响，所以只需要考虑左端点。如果下一个区间的左端点小于等于当前区间的右端点，说明两个区间不重叠，于是就选择这个区间作为下一个区间。这样只需要遍历一次数组就可以得出最多的不重叠的子区间数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h4><blockquote>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以<strong>沿着 x 轴</strong>从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆 。可以射出的弓箭的数量没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的最小弓箭数 。</p>
</blockquote>
<p>和上一题相反，这道题实际上是在找重叠子区间，并且要使重叠的子区间尽可能多，我们依然按照区间右端点排序，每次我们从右端点最小的区间射出一只箭，因为至少要保证当前所有气球中右端点最小的气球也得被引爆，然后向后扫描判断哪些气球会被引爆，显然与当前区间重叠的区间就会被引爆。如果一个区间左端点比当前区间右端点小，说明区间重叠会被引爆，直到区间的左端点比当前区间右端点大，说明与当前区间重叠的气球都被引爆了，这时这个区间作为就是右端点最小的区间，从这个区间的右端点射出一之箭继续判断，这样最终能够保证射出的箭最少，也就是每次重叠的子区间最多。<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/">官方题解</a>给出了生动的图描述这一过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>, right = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                right = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h4><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
</blockquote>
<p>按照左端点排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                left = <span class="built_in">min</span>(left, intervals[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-跳跃问题"><a href="#4-跳跃问题" class="headerlink" title="4 跳跃问题"></a>4 跳跃问题</h3><p>跳跃问题也是使用贪心算法解决的经典问题。</p>
<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h4><blockquote>
<p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>因为每个位置之间的间隔为 1 ，因此在当前位置 i 能到达的最远距离为 <code>i + nums[i]</code>，我们维护一个能达到的最远距离，然后对于每个位置判断能否到达，如果可以到达更新最远距离，如果最远距离比数组的最后一个位置远，直接返回 true即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> farest = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(farest &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(farest &gt;= i) farest = <span class="built_in">max</span>(farest, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h4><blockquote>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。假设你总是可以到达数组的最后一个位置。你的目标是使用最少的跳跃次数到达数组的最后一个位置。输出最少跳跃次数。</p>
</blockquote>
<p>核心思想是每次都跳跃都保证下一次跳跃能到达的最远距离最大，因此我们维护当前跳远所能到达的最远距离，在这个范围内不断更新下一次跳跃所能到达的最远距离，当到达这次跳跃的边界的时候，更新下一次跳跃的边界，并且步数加一，相当于跳到了下一次跳跃能到达最远距离的位置。更详细的思路解释可以查看<a href="https://leetcode-cn.com/problems/jump-game-ii/solution/45-by-ikaruga/">题解</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-其他简单贪心问题"><a href="#5-其他简单贪心问题" class="headerlink" title="5 其他简单贪心问题"></a>5 其他简单贪心问题</h3><h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/submissions/">判断子序列</a></h4><h4 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/">买卖股票的最佳时机 II</a></h4><h4 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h4><h4 id="卡车上的最大单元数"><a href="#卡车上的最大单元数" class="headerlink" title="卡车上的最大单元数"></a><a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">卡车上的最大单元数</a></h4><h4 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/">玩筹码</a></h4><h4 id="交换字符使得字符串相同"><a href="#交换字符使得字符串相同" class="headerlink" title="交换字符使得字符串相同"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-strings-equal/">交换字符使得字符串相同</a></h4><blockquote>
<p>有两个长度相同的字符串 s1 和 s2，且它们其中只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p>
<p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p>
<p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。</p>
</blockquote>
<p>统计 x 和 y 的个数，如果个数有奇数一定无法相同，同时统计 s1 中为 x ，s2 中为 y 的个数记为 xy， s1 中为 y ，s2 中为 x 的个数记为 yx，根据示例可以看出，两对 xy 或者两对 yx 需要交换一次变为相同， 一对 xy 和 一对 yx 需要两次交换变为相同，因此统计完之后尽量先用相同的 xy 和 yx 交换，就可以保证交换次数最少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSwap</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() != s2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, xy = <span class="number">0</span>, yx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) x += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) y += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;x&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;y&#x27;</span>) ++xy, ++x, ++y;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; s2[i] == <span class="string">&#x27;x&#x27;</span>) ++yx, ++x, ++y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> != <span class="number">0</span> || y % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> xy / <span class="number">2</span> + yx / <span class="number">2</span> + (xy % <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造-K-个回文字符串"><a href="#构造-K-个回文字符串" class="headerlink" title="构造 K 个回文字符串"></a><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings/">构造 K 个回文字符串</a></h4><blockquote>
<p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中所有字符构造 k 个非空回文串 。</p>
<p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。</p>
</blockquote>
<p>考虑整个字符串中能构建的最少的回文串个数和最多的回文串个数，如果 k 在这之间就返回 true。</p>
<p>最多的回文串个数就是 s 的长度，最少的回文串个数需要一定的思考。</p>
<p>注意到回文串只有两种情况，一种是以一个字母为回文中心，这样的回文串只有一个字母出现奇数次，其余字母都出现偶数次；另一种是以两个相同字母作为回文中心，这样的回文串所有字母都出现偶数次。因此统计 s 中出现奇数次和偶数次字母的个数，能构建的最少的回文串个数就是出现奇数次字母的个数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k : map)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k.second % <span class="number">2</span> != <span class="number">0</span>) ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= odd &amp;&amp; k &lt;= s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使括号有效的最少添加"><a href="#使括号有效的最少添加" class="headerlink" title="使括号有效的最少添加"></a><a href="https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/">使括号有效的最少添加</a></h4><blockquote>
<p>返回为使括号字符串 <code>s</code> 有效而必须添加的最少括号数。<code>s</code> 只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符。</p>
</blockquote>
<p>使用栈非常简单，如何使用常数空间解决？</p>
<p>记录一个平衡度 bal， 遇到左括号平衡度加 1，遇到右括号平衡度 - 1，平衡度为 0 说明括号全部匹配，如果平衡度为 -1， 说明需要在前面补一个左括号，如果平衡度大于 0 ，说明需要在后面补若干个右括号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, bal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            bal += s[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bal == <span class="number">-1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                bal++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + bal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两地调度"><a href="#两地调度" class="headerlink" title="两地调度"></a><a href="https://leetcode-cn.com/problems/two-city-scheduling/">两地调度</a></h4><blockquote>
<p>公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] &#x3D; [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。</p>
</blockquote>
<p>一般这种问题显然可以用贪心算法，而且问题的关键都是如何排序，也就是按什么值进行排序。</p>
<p>假设让所有人都先飞往 b 市，然后改变一部分人的行程使其飞往 a 市，这时要付出的代价是这部分人 costa - costb 的总和，使这部分代价最小就可以使总代价最小，因此按照 aCosti - bCosti 排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(costs.<span class="built_in">begin</span>(), costs.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; x, <span class="keyword">auto</span>&amp; y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> x[<span class="number">0</span>] - x[<span class="number">1</span>] &lt; y[<span class="number">0</span>] - y[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; costs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; costs.<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>) ans += costs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> ans += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="给定行和列的和求可行矩阵"><a href="#给定行和列的和求可行矩阵" class="headerlink" title="给定行和列的和求可行矩阵"></a><a href="https://leetcode-cn.com/problems/find-valid-matrix-given-row-and-column-sums/">给定行和列的和求可行矩阵</a></h4><blockquote>
<p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p>
<p>请找到大小为 rowSum.length x colSum.length 的任意非负整数矩阵，且该矩阵满足 rowSum 和 colSum 的要求。请你返回任意一个满足题目要求的二维矩阵，题目保证存在至少一个可行矩阵。</p>
</blockquote>
<p>关键在于题目保证一定存在满足条件的矩阵，因此 <code>sum(rowSum) == sum(colSum)</code>。所以对于位置 [i, j]，我们把第 i 行的和与第 j 列的和中的最小值填进去，然后更新第 i 行的和与第 j 列的和，这样永远可以保证 <code>sum(rowSum) == sum(colSum)</code>，因此这样填下去最后一定能找到满足条件的矩阵。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">restoreMatrix</span>(vector&lt;<span class="type">int</span>&gt;&amp; rowSum, vector&lt;<span class="type">int</span>&gt;&amp; colSum) &#123;</span><br><span class="line">        <span class="type">int</span> m = rowSum.<span class="built_in">size</span>(), n = colSum.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i][j] = <span class="built_in">min</span>(rowSum[i], colSum[j]);</span><br><span class="line">                rowSum[i] -= ans[i][j];</span><br><span class="line">                colSum[j] -= ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-其他进阶贪心问题"><a href="#6-其他进阶贪心问题" class="headerlink" title="6 其他进阶贪心问题"></a>6 其他进阶贪心问题</h3><h4 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h4><blockquote>
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
</blockquote>
<p>按照题目要求，每个孩子的糖果数量要满足两个条件：</p>
<ul>
<li>如果这个孩子评分高，那么他的糖果数量要比左边的孩子多</li>
<li>如果这个孩子评分高，那么他的糖果数量要比右边的孩子多</li>
</ul>
<p>因此我们可以维护一个数组 candy 存储每个孩子的糖果数量，先给每个孩子 1 个糖果，然后从左到右遍历，保证每个分数高的孩子都比他左边的孩子糖果数量多，因此如果 <code>ratings [i] &gt; ratings [i-1]</code>，那么 <code>candy[i] = candy[i-1] + 1</code>；然后再从右到左遍历使得每个孩子都满足第二个条件，也就是说如果当前孩子比他右边的孩子评分高，但是糖果数却没有右边的孩子多，即 <code>ratings [i] &gt; ratings [i+1] &amp;&amp; candy[i] &lt;= candy[i+1]</code>，那么 <code>candy[i] = candy[i+1] + 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ratings.<span class="built_in">size</span>(), res = <span class="number">0</span>;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candy</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//第一次遍历保证分数高的孩子比左边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>] &lt; ratings[i]) candy[i] = candy[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历保证分数高的孩子比右边的孩子糖果多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>] &amp;&amp; candy[i] &lt;= candy[i+<span class="number">1</span>]) candy[i] = candy[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candy.<span class="built_in">begin</span>(), candy.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于这道题，<a href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-leetcode-solution-f01p/">官方题解</a>给出了更巧妙的常数空间遍历方法。</p>
<h4 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子数组和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>之前用动态规划做过，这道题用贪心也很简单，如果当前的连续子数组和 sum 小于 0，则直接置 0，为了防止数组全是负数的情况，我们先计算到目前为止的连续子数组和，并更新答案，最后再判断是否小于 0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h4><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>子序列可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为摆动序列的最长子序列的长度 。</p>
</blockquote>
<p>显然想到用动态规划，对于每个数字 <code>nums[i]</code> 有下面两种情况：</p>
<ul>
<li>如果 <code>nums[i] - nums[i-1] &gt; 0</code>，那么以 <code>nums[i]</code> 结尾的最长摆动子序列长度有两种可能的情况：<ul>
<li><code>nums[i-1] - nums[i-2] &gt; 0</code>，说明连续的两对数的差值都大于 0，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
<li><code>nums[i-1] - nums[i-2] &lt; 0</code>，说明这三个数可以构成摆动序列，此时以 <code>nums[i]</code> 结尾的最长摆动子序列长度等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度加 1</li>
</ul>
</li>
<li>如果 <code>nums[i] - nums[i-1] &lt; 0</code>，推导同上</li>
<li>如果 <code>nums[i] - nums[i-1] = 0</code>，说明两数相等，此时 <code>nums[i]</code>无作用，以 <code>nums[i]</code> 结尾的最长摆动子序列长度就等于以 <code>nums[i-1]</code> 结尾的最长摆动子序列长度</li>
</ul>
<p>因此我们定义状态 <code>dp[i][j]</code> （j &#x3D; 0 或 1）表示以 <code>nums[i]</code> 结尾的最长摆动子序列长度，j &#x3D; 0 时表示<code>nums[i] - nums[i-1] &gt; 0</code>，j &#x3D; 1 时表示 <code>nums[i] - nums[i-1] &lt; 0</code> ，根据上面的推导我们可以写出状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(nums[i] - nums[i-1] &gt; 0) dp[i][0] = max(dp[i-1][0], dp[i-1][1] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] &lt; 0) dp[i][1] = max(dp[i-1][1], dp[i-1][0] + 1);</span><br><span class="line">if(nums[i] - nums[i-1] == 0) dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1];</span><br></pre></td></tr></table></figure>

<p>边界条件是只有一个数时也是摆动序列，因此 <code>dp[0][0] = dp[0][1] = 1</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然状态 i 只与状态 i - 1 有关，因此可以只用两个数 pos 和 neg 表示状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">1</span>, neg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>) pos = <span class="built_in">max</span>(pos, neg + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>) neg = <span class="built_in">max</span>(neg, pos + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(pos, neg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 这道题的贪心方法也比较容易想到，我们只要从左到右扫描数组，同时记录相邻两个数之间的差值，然后每次的差值和上一次的差值判断是否异号，只要异号就可以构成摆动序列，因此长度加 1 ，对于特殊情况如果两数差值为 0，则当前数字无用，记录的差值不能改变为0 ，依然记录之前的差值即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>, ans = <span class="number">1</span>;	<span class="comment">//初始化时差值设置为0，序列长度设置为1，相当于直接取第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断flag时用 &lt;= 和 &gt;= </span></span><br><span class="line">            <span class="comment">//这是因为无论第二个数和第一个的差值如何，都可以取第二个数，除非二者差值也为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; flag &lt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &lt; <span class="number">0</span> &amp;&amp; flag &gt;= <span class="number">0</span>) ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            flag = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">单调递增的数字</a></h4><blockquote>
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回小于或等于 n 的最大数字，且数字呈单调递增 。</p>
</blockquote>
<p>我们可以从左到右扫描数字的每一位，如果遇到不递增的位 n[i] 使得 n[i] &gt; n[i-1]，此时可以让 n[i-1] - 1，然后 n[i] 及之后的所有位都设为 9 即可得到小于 n 的最大单调递增数字。需要处理的重点是 n[i-1] - 1 后可能会使前面已经扫描过的位不满足单调递增关系，因此我们再从 n[i-1] 向前扫描找到不会影响单调递增的最后一位，使其减去 1，再把之后的所有位设置为 9 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string nums = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j] - <span class="number">1</span> &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                --nums[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; nums.<span class="built_in">size</span>(); ++k) nums[k] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移掉-K-位数字"><a href="#移掉-K-位数字" class="headerlink" title="移掉 K 位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">移掉 K 位数字</a></h4><blockquote>
<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
</blockquote>
<p>贪心的思考这道题，实际上只需要在原字符串中找到 <code>num.size() -  k</code> 个最小的数字组成新的数字，并且数字的顺序不改变即可，显然可以用单调栈解决。为了减少开销，我们用双端队列代替栈，这样可以方便最后组成答案，否则还要倒序插入每个数字。关于前导 0 的处理，<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/yi-diao-kwei-shu-zi-by-leetcode-solution/">官方题解</a>使用一个 bool 类型去处理，我们也可以使用 c++ 字符串自带的方法找到字符串中第一个不为 0 的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() &gt; x &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> x : s) ans += x;</span><br><span class="line">        <span class="type">int</span> pos = ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> pos == string::npos ? <span class="string">&quot;0&quot;</span> : ans.<span class="built_in">substr</span>(pos, ans.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="翻转矩阵后的得分"><a href="#翻转矩阵后的得分" class="headerlink" title="翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">翻转矩阵后的得分</a></h4><blockquote>
<p>有一个二维矩阵 A ，其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。</p>
</blockquote>
<p>这道题比较困难。因为通过分析题意我们需要掌握两个重要的认识，而这都是不容易想到的：</p>
<ul>
<li>给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</li>
<li>为了得到最高的分数，矩阵的每一行的最左边的数都必须为 1。</li>
</ul>
<p>因此我们先把所有最左边的数不为 1 的行进行翻转，然后开始进行列翻转，列翻转只要保证每一列的 1 数量更多即可保证最终所有行的数字总和最大。因此从第二列开始，计算这一列中 0 的个数和 1 的个数，如果 0 多则翻转这一列，如果 1 多则无需翻转。</p>
<p>实际编码时我们不需要模拟这个过程，只要按列计算对总和的贡献即可。第一列如果是 1 ，那么对总和的贡献就是 $2^{n-1}$，因为第一列全为 1 ，因此总贡献为 $m·2^{n-1}$，之后第 $j$ 列如果为 1 ，则贡献为 $2^{n-j-1}$，我们统计第 $j$ 列 0 的个数和 1 的个数，个数更多的作为最终的 1 的个数 k，那么这一列的总贡献即为 $k·2^{n-j-1}$。</p>
<p>另外需要注意的是，每一列在统计个数时要考虑行翻转的情况，我们要判断每行做左边的数是否为 1 ，如果为 1 说明这行没有进行翻转，如果不为 1 说明这行经过了翻转，因此该行中每个元素 x 的实际取值应该是 1 - x。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matrixScore</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> nOnes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;  <span class="comment">//当前行首元素为1，无需翻转</span></span><br><span class="line">                    nOnes += grid[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//说明这一行进行了翻转，因此该行每个数字的取值为1-x</span></span><br><span class="line">                    nOnes += (<span class="number">1</span> - grid[i][j]); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">max</span>(nOnes, m - nOnes);</span><br><span class="line">            ans += k * (<span class="number">1</span> &lt;&lt; (n - j - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（七）基础屏幕特效</title>
    <url>/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>屏幕后处理效果（screen post-processing  effects）是游戏中实现屏幕特效的常见方法。在本章中，我们将学习如何在 Unity 中利用渲染纹理来实现各种常见的屏幕后处理效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-建立一个基本的屏幕后处理脚本系统"><a href="#1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="1 建立一个基本的屏幕后处理脚本系统"></a>1 建立一个基本的屏幕后处理脚本系统</h3><p>屏幕后处理，顾名思义，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深、模糊等。</p>
<p>因此想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口——<strong>OnRenderImage</strong> 函数，它的函数声明如下：</p>
<blockquote>
<p>MonoBehaviour.OnRenderimage (RenderTexture src, RenderTexture dest)</p>
</blockquote>
<p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnReoderlmage 函数中，通常是利用 Grapbics.Blit 函数来完成对渲染纹理的处理。它有 3 种函数声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span> <span class="params">(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为_MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass 。否则，只会调用给定索引的 Pass 。</p>
<p>在默认情况下，OnRenderlmage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、  Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderlmage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderlmage 函数前添加 ImageEffectOpaque 属性来实现这样的目的，之后我们会遇到这种情况。</p>
<p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderlmage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p>
<p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。<br>PostEffectsBase.cs 的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有屏幕后处理效果都需要绑定在某个摄像机上</span></span><br><span class="line"><span class="comment">// 并且我们希望在编辑器状态下也可以执行该脚本来查看效果</span></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查资源和条件是否满足，在start函数中调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查平台是否支持渲染纹理和屏幕后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于每个屏幕后处理效果通常都需要指定一个 Shader 来创建一个用于处理渲染纹理的材质</span></span><br><span class="line">    <span class="comment">// 因此基类中也需要提供这样的方法</span></span><br><span class="line">    <span class="comment">// 第一个参数指定了该特效需要使用的Shader，第二个参数则是用于后期处理的材质</span></span><br><span class="line">    <span class="comment">// 该函数检查shader可用性，shader可用则返回一个使用了该shader的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面我们就可以通过继承这个基类来实现一些屏幕后处理效果。</p>
<h3 id="2-调整屏幕的亮度、饱和度和对比度"><a href="#2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="2 调整屏幕的亮度、饱和度和对比度"></a>2 调整屏幕的亮度、饱和度和对比度</h3><p>首先来编写 C# 脚本，继承上面的基类：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明该效果需要使用的shader，并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整亮度、饱和度、对比度的参数，Range可以指定参数的变化区间</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义OnRenderImage来实现屏幕特效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查材质是否可用，可用则将上面的参数传递给材质进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果材质不可用则直接显示原图像</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Brightness Saturation And Contrast&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 这里的纹理就是脚本中Blit函数的第一个参数传入的纹理</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        <span class="comment">// 三个属性</span></span><br><span class="line">        _Brightness (&quot;Brightness&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(&quot;Saturation&quot;, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(&quot;Contrast&quot;, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片</span></span><br><span class="line">            <span class="comment">// 因此为了防止它对其他物体产生影响，我们需要设置相关的渲染状态</span></span><br><span class="line">            <span class="comment">// 关闭深度写入是为了防止如果在之后渲染透明物体出现错误</span></span><br><span class="line">            <span class="comment">// 这些设置可以认为是屏幕后处理的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">              </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// 使用了Unity内置的appdata_img 结构体作为顶点着色器的输入</span></span><br><span class="line">            <span class="comment">// 它只包含了图像处理时必需的顶点坐标和纹理坐标等变量</span></span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);  </span><br><span class="line">                  </span><br><span class="line">                <span class="comment">// 调整亮度</span></span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 调整饱和度</span></span><br><span class="line">                <span class="comment">// 先得到该像素的亮度值，用每个颜色分量乘以一个特定的系数得到</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                <span class="comment">// 使用该亮度值创建一个饱和度为 0 的颜色值</span></span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                <span class="comment">// 使用_Saturation属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 先创建一个对比度为0的颜色</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">// 用_Contrast属性在其和上一步得到的颜色颜色之间进行插值从而得到希望的对比度颜色</span></span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125;  </span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在返回 Unity 中，将 cs 脚本赋给摄像机，然后在摄像机属性面板中的脚本组件中将上面的 Shader 赋给 Bri Sat Con Shader 属性：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170634205.png" alt="image-20220407170634205"></p>
<p>然后调整各个参数就可以调整屏幕效果，原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170806951.png" alt="image-20220407170806951"></p>
<p>调整部分参数后：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407170829444.png" alt="image-20220407170829444"></p>
<h3 id="3-边缘检测"><a href="#3-边缘检测" class="headerlink" title="3 边缘检测"></a>3 边缘检测</h3><p>边缘检测是一个常见的屏幕后处理效果，用于实现描边效果。常用的边缘检测算子有：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407171016814.png" alt="image-20220407171016814"></p>
<p>在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根操作：<br>$$<br>G &#x3D; |G_x| + |G_y|<br>$$<br>当得到梯度 G 后，我们就可以据此来判断哪些像素对应了边缘。</p>
<p>下面我们使用 Sobel 算子进行边缘检测，cs 脚本和上面类似：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整边缘线强度的参数，当值为0时，边缘会叠加到原图像上，值为1时只显示边缘</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">// 边缘颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="comment">// 背景颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            <span class="comment">// 将src作为纹理用material对应的shader处理，结果保存到dest纹理中</span></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Edge Detection&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 对应的参数，也可以不定义，因为在这里定义属性是为了显示在材质的属性面板上</span></span><br><span class="line">        <span class="comment">// 但这里我们是脚本自动生成材质，不需要我们创建材质</span></span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            <span class="comment">// 屏幕后处理标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">            <span class="comment">// xxx_TexelSize是 Unity 内置的访问纹理纹素大小的变量</span></span><br><span class="line">            <span class="comment">// 例如512 * 512 的纹理的纹素大小就是 1/512</span></span><br><span class="line">            <span class="comment">// 因为卷积要对相邻纹素操作，所以要用纹素大小计算得到当前纹素相邻的纹素的位置</span></span><br><span class="line">            <span class="keyword">uniform</span> half4 _MainTex_TexelSize;</span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">              </span><br><span class="line">            v2f vert(appdata_img v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算每个纹理坐标周围的用于卷积的纹理坐标</span></span><br><span class="line">                <span class="comment">// 这一步最好在顶点着色器计算以减少性能开销</span></span><br><span class="line">                <span class="comment">// 因为顶点到片元的线性插值不会影响相邻坐标的结果</span></span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                         </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算每个像素的亮度值</span></span><br><span class="line">            fixed luminance(fixed4 color) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算当前像素的梯度值</span></span><br><span class="line">            half Sobel(v2f i) &#123;</span><br><span class="line">                <span class="comment">// Sobel算子</span></span><br><span class="line">                <span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">                                        <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                        <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">                                        <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                <span class="comment">// 两个方向的滤波结果</span></span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 滤波</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">                    edgeX += texColor * Gx[it];</span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 得到最终滤波结果，这里的edge显然值越小越可能是边缘</span></span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 得到当前像素的梯度值</span></span><br><span class="line">                half edge = Sobel(i);</span><br><span class="line">                <span class="comment">// 计算背景分别为原图和纯色下的边缘颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">// 利用_EdgeOnly在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_EdgeOnly 为 0 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173137539.png" alt="image-20220407173137539"></p>
<p>_EdgeOnly 为 1 时的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173211757.png" alt="image-20220407173211757"></p>
<h3 id="4-高斯模糊"><a href="#4-高斯模糊" class="headerlink" title="4 高斯模糊"></a>4 高斯模糊</h3><p>高斯模糊我们非常熟悉，但还是有一个小技巧需要说明，那就是存储高斯模糊核时不需要全部存储，只需要存储极少的权重即可，因为：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407173403469.png" alt="image-20220407173403469"></p>
<p>所以一个 5 * 5 的高斯模糊核我们只需要存储 3 个权重即可。</p>
<p>并且为了提高性能，我们使用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。同时还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度。</p>
<p>cs 脚本如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波次数</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面两个参数都是出于性能考虑</span></span><br><span class="line">    <span class="comment">// 模糊范围，在高斯核维数不变的情况下，模糊范围越大模糊程度越高，但过高会造成虚影</span></span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="comment">// 下采样倍数越高，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化</span></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第一个版本，最简单的实现</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            // 分配了一块与屏幕图像大小相同的缓冲区，因为有两个Pass，因此需要一个缓冲存储中间结果</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第1个Pass进行竖直方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            // 使用Shader中的第2个Pass进行水平方向一维高斯滤波</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            // 释放缓冲区</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第二个版本，利用缩放对图像下采样，减少需要处理的像素个数</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            // 声明缓冲区大小是进行缩放，并设置该临时纹理的滤波模式为双线性</span></span><br><span class="line"><span class="comment">//            // 这样在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 最终版本，还考虑了滤波次数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 降采样</span></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直方向滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存交替</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// CGINCLUDE包含的代码相当于头文件的功能，包含在CGINCLUDE内的代码块不需要写在任何Pass中</span></span><br><span class="line">        <span class="comment">// 在后面的Pass中可以直接用函数名调用这当中的函数</span></span><br><span class="line">        <span class="comment">// 由于我们要用到两个Pass ，并且它们的片元着色器代码是完全相同的，因此这样可以避免代码重复</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 垂直滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurVertical(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//垂直方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 水平滤波的顶点着色器</span></span><br><span class="line">        v2f vertBlurHorizontal(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 水平方向的五个纹素坐标，用_BlurSize控制采样距离，采样距离越远模糊越严重</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共用的片元着色器</span></span><br><span class="line">        fixed4 fragBlur(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 模糊核权值</span></span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;</span><br><span class="line">            <span class="comment">// 滤波</span></span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 Pass 中直接调用上面的函数名即可</span></span><br><span class="line">        <span class="comment">// 为Pass定义了一个名字，这使得其他Shder可以通过改名字来直接使用该Pass</span></span><br><span class="line">        <span class="comment">// 因为高斯模糊很常用，定义名字为了方便其他Shader调用</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205453483.png" alt="image-20220407205453483"></p>
<h3 id="5-Bloom-效果"><a href="#5-Bloom-效果" class="headerlink" title="5 Bloom 效果"></a>5 Bloom 效果</h3><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407205959390.png" alt="image-20220407205959390"></p>
<p>Bloom 的实现原理非常简单：我们首先根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和高斯模糊的参数一样</span></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取较亮区域时使用的阈值大小</span></span><br><span class="line">    <span class="comment">// 尽管在绝大多数情况下，图像的亮度值不会超过1</span></span><br><span class="line">    <span class="comment">// 但如果我们开启了HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1 </span></span><br><span class="line">    <span class="comment">// 因此，在这里我们把 luminanceThreshold 的值规定在[O, 4]范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 提取阈值传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">            </span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用Shader中第一个Pass来提取图像中的较亮区域</span></span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 使用第二个Pass进行垂直滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//使用第三个Pass进行水平滤波</span></span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将模糊后的较亮区域设为纹理</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0); </span><br><span class="line">            <span class="comment">// 使用第四个Pass将处理后的亮部叠加到原图上 </span></span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);  </span><br><span class="line"></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;</span><br><span class="line">        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span></span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提取亮部区域时的结构体和着色器</span></span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line">        </span><br><span class="line">        v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed luminance(fixed4 color) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">// 用采样得到的亮度值减去_LuminanceThreshold阈值并截取到[0,1]范围内</span></span><br><span class="line">            <span class="comment">// 这样比阈值小的部分就置为0，只剩下了较亮区域</span></span><br><span class="line">            fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            <span class="comment">// 和原像素相乘得到提取后的亮部图像</span></span><br><span class="line">            <span class="keyword">return</span> c * val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混合亮部图像和原图时的结构体和着色器</span></span><br><span class="line">        struct v2fBloom &#123;</span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            </span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">// xy存储主纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;    </span><br><span class="line">            <span class="comment">// zw存储模糊后的亮部图像纹理坐标    </span></span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对zw进行平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 对两个纹理采样直接相加即可</span></span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里可以直接使用之前的高斯模糊中的Pass</span></span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">        </span><br><span class="line">        UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211732586.png" alt="image-20220407211732586"></p>
<p>Bloom 效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220407211752023.png" alt="image-20220407211752023"></p>
<h3 id="6-运动模糊"><a href="#6-运动模糊" class="headerlink" title="6 运动模糊"></a>6 运动模糊</h3><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都棱角分明，缺少运动模糊。而在现在的许多第一人称或者赛车游戏中，运动模糊是一种必不可少的效果。</p>
<p>运动模糊实现的一种方法是使用<strong>累积缓存</strong>记录多张连续图像，然后取平均作为运动模糊图像，但是这种方法对于性能的消耗很大，因为想要获取多帧连续图像意味着要渲染一个场景多次。另一种广泛应用的方法是创建和使用<strong>速度缓存</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p>
<p>这一节我们使用类似于第一种方法来实现运动模糊，但不需要在一帧中把场景渲染多次，只要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图上，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累积缓存的方法相比性能更好，但模糊效果可能会略有影响。</p>
<p>为此，我们先编写一个脚本让摄像机运动：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line">        <span class="keyword">if</span> (pingpong) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>) &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写运动模糊的脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义运动模糊在混合图像时使用的混合参数</span></span><br><span class="line">    <span class="comment">// blurAmount 的值越大，运动拖尾的效果就越明显</span></span><br><span class="line">    <span class="comment">// 为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在0.0到0.9范围内</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义保存之前图像叠加的结果的纹理</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line">    <span class="comment">// 我们在该脚本不运行时，即调用 OnDisable 函数时立即销毁之前叠加的结果</span></span><br><span class="line">    <span class="comment">// 这是因为我们希望在下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前accumulationTexture是否满足条件按，不满足则创建满足条件的纹理并初始化为当前帧图像</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个函数表明我们需要进行一个渲染纹理的恢复操作</span></span><br><span class="line">            <span class="comment">// 恢复操作发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下</span></span><br><span class="line">            <span class="comment">// 我们要用accumulationTexture混合当前图像，因此不能提前清空</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 参数传递给材质</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line">            <span class="comment">// 把当前屏幕图像叠加到accumulationTexture</span></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            <span class="comment">// 把结果显示到屏幕上</span></span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shader 代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Motion Blur&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurAmount (&quot;Blur Amount&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 采样RGB，并将其A通道设为_BlurAmount</span></span><br><span class="line">        <span class="comment">// 以便在后面混合时可以使用它的透明通道进行混合</span></span><br><span class="line">        fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接返回采样值</span></span><br><span class="line">        <span class="comment">// 这是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响</span></span><br><span class="line">        half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理RGB通道</span></span><br><span class="line">        <span class="comment">// 更新RGB时我们需要设置它的A通道来混合图像，但又不希望A通道的值写入渲染纹理中</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理A通道，保证A通道还是原来的值</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Blur Amount 设置为 0 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p>
<p>Blur Amount 设置为 1 时的效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/07/20220407-Shader-%E5%9F%BA%E7%A1%80%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p>
<p>明显看到了运动模糊。当然这只是一种简单的实现，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。之后我们会学习如何利用深度纹理重建速度来模拟运动模糊效果。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（八）高级屏幕特效</title>
    <url>/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>在上一节中，我们学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。例如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多我们不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。在本节中，我们将学习如何在 Unity 中获取深度纹理和法线纹理来实现特定的屏幕后处理效果。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-获取深度和法线纹理"><a href="#1-获取深度和法线纹理" class="headerlink" title="1 获取深度和法线纹理"></a>1 获取深度和法线纹理</h3><p>虽然在 Unity 里获取深度和法线纹理的代码非常简单，但是我们有必要在这之前首先了解它们背后的实现原理。</p>
<h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h4><p>深度纹理实际就是一张渲染纹理，只不过他里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是 [0, 1]，而且通常是非线性分布的。这些深度值来自于顶点变换后得到的归一化设备坐标 NDC，回顾之前学习过的投影变换，下图显示了正交投影过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142854239.png" alt="image-20220409142854239"></p>
<p>下图显示了透视投影过程：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409142931627.png" alt="image-20220409142931627"></p>
<p>深度值就来自于经过透视除法后的 NDC 中顶点坐标的 z 分量的值，由于 NDC 中 z 分量的范围在 [-1, 1]，因此还要把它映射到 [0, 1] 以存储在纹理中。</p>
<p>那么 Unity 是怎么得到这样一张深度纹理的呢？在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。通常来讲，当使用延迟渲染路径时，深度纹理理所当然可以访问到，因为延迟渲染会把这些信息渲染到 G-buffer 中 。而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染而得的 。具体实现是，Unity 会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断他们使用的渲染队列是否小于等于 2500（(内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件就把它渲染到深度和法线纹理中，因此，要想让物体能够出现在深度和法线纹理中，就必须正确设置 RenderType 标签。</p>
<p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度＋法线纹理。当选择前者，即只需要一张单独的深度纹理时， Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass（即 LightMode 被设置为ShadowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass, 那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。如果选择生成一张深度＋法线纹理， Unity 会创建一张和屏幕分辨率相同、精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。</p>
<p>法线信息的获取在延迟渲染中是可以非常容易就得到的， Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。这个 Pass 被包含在 Unity 内置的一个 Unity Shader 中，我们可以在内置的 <code>builtin_ shaders-xxx/DefaultResources/Camera-DepthNormaITexture.shader</code> 文件中找到这个用于渲染深度和法线信息的 Pass。</p>
<h4 id="1-2-获取"><a href="#1-2-获取" class="headerlink" title="1.2 获取"></a>1.2 获取</h4><p>在 Unity 中，获取深度纹理是非常简单的，只需要在在脚本中设置摄像机的 <code>depthTextureMode</code> 即可，然后就可以在 Shader 中直接访问特定的纹理属性了。我们可以使用下面的代码获取深度纹理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;</span><br></pre></td></tr></table></figure>

<p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 <code>_CameraDepthTexture</code> 变量来访问它。</p>
<p>同理，如果想要获取深度＋法线纹理，我们只需要在代码中这样设置：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure>

<p>然后在 Shader 中通过声明 <code>_CameraDepthNormalsTexture</code> 变量来访问它。</p>
<p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度 + 法线纹理：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">camera.depthTextureMode |= DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure>

<p>当在 Shader 中访问到深度纹理 <code>_CameraDepthTexture</code> 后，我们就可以使用当前像素的纹理坐标对它进行采样，绝大多数情况下直接使用 <code>Tex2D</code> 即可，但在某些平台可能需要一些特殊处理， Unity 为我们提供了一个统一的宏 <code>SAMPLE_DEPTH_TEXTURE</code>，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用即可：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE (_CameraDepthTexture, i.uv);</span><br></pre></td></tr></table></figure>

<p>当通过纹理采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使 用的裁剪矩阵。 然而，在我们的计算过程中通常是需要线性的深度值，也就是说，我们需要把投 影后的深度值变换到线性空间下，例如视角空间下的深度值。Unity 提供了两个辅助函数来进行转换，<code>LinearEyeDepth</code> 负责把深度纹理的采样结果转换到视角空间下的深度值，<code>Linear01Depth</code> 则会返回一个范围在 [0, 1] 的线性深度值。转换这部分的推导可以查看《Unity Shader 入门精要》13.1.2 节的内容。</p>
<p>如果我们需要获取深度＋法线纹理，可以直接使用 tex2D 函数对 <code>_CameraDepthNormalsTexture</code> 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 <code>DecodeDepthNormal</code>，该函数的第一个参数是对深度＋法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是视角空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 <code>DecodeDepthNormal</code> 函数对采样结果解码后，我们就可以得到解码后的深度值和法线。这个深度值是范围在 [0, 1] 的线性深度值（这与单独的深度纹理中存储的深度值不同），而得到的法线则是视角空间下的法线方向。<code>DecodeDepthNormal</code> 函数如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">inline <span class="type">void</span> DecodeDepthNormal (float4 enc, <span class="keyword">out</span> <span class="type">float</span> depth, <span class="keyword">out</span> float3 normal)</span><br><span class="line">&#123;</span><br><span class="line">    depth = DecodeFloatRG(enc.ze);</span><br><span class="line">    normal = DecodeViewNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以自己用 <code>DecodeFloatRG</code> 和 <code>DecodeViewNormalStereo</code> 函数解码。</p>
<h3 id="2-再谈运动模糊"><a href="#2-再谈运动模糊" class="headerlink" title="2 再谈运动模糊"></a>2 再谈运动模糊</h3><p>在上一节中，我们学习了如何通过混合多张屏幕图像来模拟运动模糊的效果。但是，另一种应用更加广泛的技术则是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。速度缓冲的生成有多种方法，一种方法是把场景中所有物体的速度渲染到一张纹理中。但这种方法的缺点在于需要修改场景中所有物体的 Shader 代码，使其添加计算速度的代码并输出到一个渲染纹理中。</p>
<p>《GPU Gems3》在<a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch27.html">第 27 章</a>中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角＊投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的，当得到世界空间中的顶点坐标后，我们使用前一帧的视角＊投影矩阵对其进行变换， 得到该位置在前一帧中的 NDC 坐标。然后，我们计算前一帧和当前帧的位置差，生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p>
<p>我们首先来编写 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlurWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于要用到摄像机的视角和投影矩阵，因此要定义一个Cmaera类型的变量以获取该脚本所在的摄像机组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊时模糊图像使用的大小</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于保存前一帧的视角*投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当脚本可用时，设置摄像机的状态以获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">        previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line">            <span class="comment">// 给材质传递前一帧的视角 * 投影矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);</span><br><span class="line">            <span class="comment">// 计算当前帧的视角 * 投影矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">// 求逆</span></span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            <span class="comment">// 给材质传递前帧的视角 * 投影矩阵的逆矩阵</span></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">            <span class="comment">// 更新前一帧的视角 * 投影矩阵</span></span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Motion Blur With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="comment">// Unity提供的深度纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        <span class="comment">// 两个矩阵由脚本传递而来</span></span><br><span class="line">        float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">        float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">        half _BlurSize;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            <span class="comment">// 主纹理和深度纹理采样坐标是一样的</span></span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="comment">// 平台差异化处理</span></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">// 获取当前像素的深度值，通过对深度纹理采样得到</span></span><br><span class="line">            <span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);</span><br><span class="line">            <span class="comment">// 构造该像素的NDC坐标，通过对深度纹理进行反映射得到</span></span><br><span class="line">            <span class="comment">// 因为深度纹理的深度是从NDC的z坐标映射到[0, 1]范围的，所以再映射回去作为z分量</span></span><br><span class="line">            <span class="comment">// NDC的xy分量通过纹理坐标的xy映射而来</span></span><br><span class="line">            float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对NDC进行VP变换的逆变换并将结果除以w分量，以得到世界空间下的顶点坐标</span></span><br><span class="line">            float4 D = mul(_CurrentViewProjectionInverseMatrix, H);</span><br><span class="line">            float4 worldPos = D / D.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前屏幕空间坐标</span></span><br><span class="line">            float4 currentPos = H;</span><br><span class="line">            <span class="comment">// 用计算得到的世界空间坐标乘以前一帧的VP变换矩阵得到前一帧的屏幕空间坐标，同样要记得除以w分量  </span></span><br><span class="line">            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);</span><br><span class="line">            previousPos /= previousPos.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算前一帧和后一帧屏幕坐标的差以得到该像素的速度</span></span><br><span class="line">            float2 velocity = (currentPos.xy - previousPos.xy)/<span class="number">2.0</span>f;</span><br><span class="line">            </span><br><span class="line">            float2 uv = i.uv;</span><br><span class="line">            float4 c = tex2D(_MainTex, uv);</span><br><span class="line">            <span class="comment">// 利用该速度值对该像素的邻域像素进行采样，_BlurSize控制采样距离</span></span><br><span class="line">            <span class="comment">// 采样结果相加后取平均得到模糊效果</span></span><br><span class="line">            uv += velocity * _BlurSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">                float4 currentColor = tex2D(_MainTex, uv);</span><br><span class="line">                c += currentColor;</span><br><span class="line">            &#125;</span><br><span class="line">            c /= <span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;      </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                    </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有运动模糊的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion1.gif" alt="motion1"></p>
<p>使用上面的方法得到的运动模糊效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/motion2.gif" alt="motion2"></p>
<h3 id="3-全局雾效"><a href="#3-全局雾效" class="headerlink" title="3 全局雾效"></a>3 全局雾效</h3><p>雾效（Fog）是游戏里经常使用的一种效果。 Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点／片元着色器中实现这些雾效，我们需要在 Shader 中添加 <code>#pragma multi_compile_fog</code> 指令，同时还需要使用相关的内置宏，例如 <code>UNITY_FOG_COORDS</code> 、<code>UNITY_TRANSFER_FOG</code> 和 <code>UNTTY_APPLY_FOG</code> 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p>
<p>在本节中，我们将会学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染的物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性&#x2F;指数雾效、基于高度的雾效等。</p>
<p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。尽管我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机的视角＊投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。在本节中，我们将会学习一个快速从深度纹理中重建世界坐标的方法。</p>
<p>这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</p>
<h4 id="3-1-重建世界坐标"><a href="#3-1-重建世界坐标" class="headerlink" title="3.1 重建世界坐标"></a>3.1 重建世界坐标</h4><p>我们知道，坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得建像素的世界坐标就是基于这样的思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标。整个过程可以使用下面的代码来表示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;</span><br></pre></td></tr></table></figure>

<p>其中，<code>_WorldSpaceCameraPos</code> 可以通过内置变量直接访问，<code>linearDepth * interpolatedRay</code> 则可以计算得到该像素相对于摄像机的偏移量，<code>linearDepth</code> 是由深度纹理得到的线性深度值， <code>interpolatedRay</code> 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。<code>linearDepth</code> 的获取我们已经学习过了，因此，现在来看 <code>interpolatedRay</code> 的求法。</p>
<p><code>interpolatedRay</code> 来源于对近裁剪平面的 4 个角的某个特定向量的插值，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、 FOV、横纵比计算而得，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409154810612.png" alt="image-20220409154810612"></p>
<p>为了方便计算，我们可以先计算两个辅助向量—— $toTop$ 和 $toRight$，他们是起点位于近裁剪平面中心，分别指向摄像机正上方和正右方的向量，计算公式如下：<br>$$<br>halfHeight &#x3D; Near \times tan(\frac{FOV}{2})    \<br>toTop &#x3D; HalfHeight · camera.up    \<br>toRight &#x3D; HalfHeight · camera.right<br>$$<br>其中，$Near$ 是近裁剪平面的距离，$FOV$ 是竖直方向的视角范围，$camera.up$ 、 $camera.right$ 分别对应了摄像机的正上方和正右方。当得到这两个辅助向量后，我们就可以计算 4 个角相对于摄像机的方向了。以左上角TL为例：<br>$$<br>TL &#x3D; camera.forward · Near + toTop - toRight<br>$$<br>通过看图，上式很容易理解，同理其他三个角的向量：<br>$$<br>TR &#x3D; camera.forward · Near + toTop + toRight    \<br>BL &#x3D; camera.forward · Near - toTop - toRight    \<br>BR &#x3D; camera.forward · Near - toTop + toRight<br>$$<br>注意，上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点到摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409155500256.png" alt="image-20220409155500256"></p>
<p>因此我们不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到摄像机的偏移量，不过想要把深度值转换成到摄像机的欧式距离也很简单，我们以 TL 点为例，根据相似三角形原理，<strong>TL 所在的射线上</strong>，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即：<br>$$<br>\frac{depth}{dist} &#x3D; \frac{Near}{|TL|}<br>$$<br>由此即可得到 TL 射线上的点距离摄像机的欧氏距离：<br>$$<br>dist &#x3D; depth \times \frac{|TL|}{Near}<br>$$<br>由于 4 个点相互对称，因此其他 3 个向量的模和 TL 相等，即我们可以使用同一个因子：<br>$$<br>scale &#x3D; \frac{|TL|}{|Near|}<br>$$<br>和单位向量相乘，得到它们对应的向量值：<br>$$<br>Ray_{TL} &#x3D; \frac{TL}{|TL|}\times scale \<br>Ray_{TR} &#x3D; \frac{TR}{|TR|}\times scale \<br>Ray_{BL} &#x3D; \frac{BL}{|BL|}\times scale \<br>Ray_{BR} &#x3D; \frac{BR}{|BR|}\times scale<br>$$<br>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到 interpolatedRay，我们就可以直接利用一开始提到的公式重建该像素在世界空间的位置了。</p>
<h4 id="3-2-雾的计算"><a href="#3-2-雾的计算" class="headerlink" title="3.2 雾的计算"></a>3.2 雾的计算</h4><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原颜色和雾的颜色的混合系数：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float3 afterFog = f * fogColor + (<span class="number">1</span> - f) * oriColor</span><br></pre></td></tr></table></figure>

<p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支待三种雾的计算方式，给定距离 z 后，f 的计算方式如下:</p>
<ul>
<li>线性：</li>
</ul>
<p>$$<br>f &#x3D; \frac{d_{max} - |z|}{d_{max} - d_{min}}<br>$$</p>
<p>其中 $d_{min}$ 和 $d_{max}$ 分别表示受雾影响的最小距离和最大距离。</p>
<ul>
<li>指数：</li>
</ul>
<p>$$<br>f &#x3D; e^{-d·|z|}<br>$$</p>
<p>其中 d 是控制雾的浓度的参数。</p>
<ul>
<li>指数平方：</li>
</ul>
<p>$$<br>f &#x3D; e^{-(d-|z|)^2}<br>$$</p>
<p>其中 d 是控制雾的浓度的参数。</p>
<p>在本节中，我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，用给定一点在世界空间下的高度 y 后替换线性计算公式中的距离 z。</p>
<h4 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h4><p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们需要获取摄像机的相关参数，如近裁剪平面的距离、FOV等，同时还需要获取摄像机在世界空间下的前方、上方和右方等方向</span></span><br><span class="line">    <span class="comment">//因此我们用两个变量存储摄像机的Camera组件和Transform组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义模拟雾效的各个参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line">    <span class="comment">//受雾效影响的最小高度和最大高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="comment">//设置相机状态获取深度纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//计算近裁剪平面4个角对应的向量</span></span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Fog With Depth Texture&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">// 找到对应的顶点的向量，虽然有很多if判断，但实际上我们渲染的四边形只有4个顶点，因此对性能不会有太大影响</span></span><br><span class="line">            <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">                      </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">            <span class="comment">//得到像素的线性深度</span></span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">            <span class="comment">//按照公式计算该像素对应的世界空间坐标</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">            <span class="comment">// 按照公式计算雾效系数f，使用_FogDensity控制雾效浓度</span></span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line">            </span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            <span class="comment">//利用雾效系数混合原颜色和雾效颜色</span></span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                     </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/fog.gif" alt="fog"></p>
<h3 id="4-再谈边缘检测"><a href="#4-再谈边缘检测" class="headerlink" title="4 再谈边缘检测"></a>4 再谈边缘检测</h3><p>之前我们使用 Sobel 算子对屏幕图像进行边缘检测，实现描边的效果。但是，这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163748909.png" alt="image-20220409163748909"></p>
<p>可以看出，物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。在本节中我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163828336.png" alt="image-20220409163828336"></p>
<p>本节使用 Roberts 算子来进行边缘检测，它使用的卷积核如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409163911506.png" alt="image-20220409163911506"></p>
<p>Roberts 算子的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。我们在实现中取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值（可由参数控制），就认为它们之间存在一条边。</p>
<p>首先是 cs 脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectNormalsAndDepth</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line">    <span class="comment">//采样距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的深度相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//邻域的法线相差多少会认为存在一条边，灵敏度如果很大，那么很小的变化也会认为是边缘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//设置摄像机产生深度+法线纹理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常情况下OnRenderImage函数会在所有不透明和透明物体渲染完后被调用</span></span><br><span class="line">    <span class="comment">//但我们希望边缘检测只对不透明物体描边，因此使用下面的ImageEffectOpaque声明</span></span><br><span class="line">    <span class="comment">//使得OnRenderImage函数在不透明物体渲染完后立即调用</span></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是 Shader：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        half4 _Sensitivity;</span><br><span class="line">        <span class="comment">//深度+法线纹理</span></span><br><span class="line">        <span class="type">sampler2D</span> _CameraDepthNormalsTexture;</span><br><span class="line">        </span><br><span class="line">        struct v2f &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        v2f vert(appdata_img v) &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            </span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#endif</span></span><br><span class="line">            <span class="comment">//四个对角线邻域的纹理坐标，在顶点着色器计算出坐标之后插值传递给片元着色器以减少性能开销</span></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用来判断深度+法线纹理上的两个采样点的深度和法线的差异</span></span><br><span class="line">        half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">            <span class="comment">//解码得到两个采样点的法线和深度值</span></span><br><span class="line">            <span class="comment">//法线并没有解码成真正的法线值，直接使用了xy分量</span></span><br><span class="line">            <span class="comment">//这是因为我们只需要两个法线的差异，不需要知道真正的法线是什么</span></span><br><span class="line">            half2 centerNormal = center.xy;</span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">            half2 sampleNormal = <span class="keyword">sample</span>.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算法线的差异乘以灵敏度</span></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="comment">// 差异的xy分量相加和阈值比较，如果小于该阈值返回1，否则返回0</span></span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line">            <span class="comment">// 计算深度差异乘以灵敏度</span></span><br><span class="line">            <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="comment">// 同上对比两个深度值差异是否满足条件</span></span><br><span class="line">            <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将法线和深度差异的结果相乘返回</span></span><br><span class="line">            <span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            </span><br><span class="line">            edge *= CheckSame(sample1, sample2);</span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line">            </span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM      </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert  </span></span><br><span class="line">            <span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170023348.png" alt="image-20220409170023348"></p>
<p>只显示描边：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170127466.png" alt="image-20220409170127466"></p>
<p>当我们增大采样距离，得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/09/20220409-Shader-%E9%AB%98%E7%BA%A7%E5%B1%8F%E5%B9%95%E7%89%B9%E6%95%88/image-20220409170051494.png" alt="image-20220409170051494"></p>
<p>视觉上就是描边更粗了。</p>
<p>本节实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后， 我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity 提供的 <code>Graphics.DrawMesh</code> 或 <code>Graphics.DrawMeshNow</code> 函数把需要描边的物体再次渲染一遍（在所有不透明物体渲染完毕之后），然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于某个阈值，如果是，就在 Shader 中使用 clip 函数将该像素剔除掉，从而显示出原来的物体颜色。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【动态规划】（七）背包动态规划</title>
    <url>/LycTechStack.github.io/2022/04/22/20220422-%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>背包问题是动态规划中最经典的问题之一，也是机试中最常出现的问题。背包问题大体可分为九种类型。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-0-1背包问题"><a href="#1-0-1背包问题" class="headerlink" title="1 0-1背包问题"></a>1 0-1背包问题</h3><p><a href="https://www.acwing.com/problem/content/2/">AcWing02. 01背包问题</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品<strong>只能使用一次</strong>。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>0-1 背包是最简单的背包问题，定义状态 $dp[i][curv]$ 表示将前 i 件物品放入体积为 curv 的背包所能获得的最大价值，其中 $(curv \leq V)$，对于第 i 件物品，只存在拿与不拿两种情况，如果不拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入容量为 curv 的背包中所能获得的最大价值”，于是价值为 $dp[i-1][curv]$；如果拿第 i 件物品，那么问题就转化为“前 i - 1 件物品放入剩下的容量为 curv - vi 的背包中所能获得的最大价值”，此时能获得的最大价值就是 $dp[i-1][curv-vi]$ 再加上通过放入第 i 件物品获得的价值 wi，因此状态转移方程如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv-v[i]] + w[i]);</span><br></pre></td></tr></table></figure>

<p>于是可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][curv] = dp[i<span class="number">-1</span>][curv];</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= volume[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i<span class="number">-1</span>][curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">ZeroOnePack</span>(volume, value, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为状态 i 至于状态 i - 1 有关，因此可以使用一维数组优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意体积必须逆序遍历，否则就需要一个额外的数组来存储上一次的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用一维数组的话，遍历体积 curv 的时候要从大到小遍历，因为如果从小到大遍历，那么后面需要的 <code>dp[curv - volume[i-1]] + value[i-1]</code> 就不是第 i - 1 的状态了，而是更新过的第 i 次的状态。此外遍历体积 curv 只需要遍历到当前物品的体积 <code>volume[i-1]</code> 即可，因为背包体积比当前物品体积小的话，一定装不进去，状态不需要更新，沿用前一次的状态即可。</p>
<p>如果将题目的要求改为<strong>必须将背包装满所能获得的最大价值</strong>，只需要修改动态规划的边界条件即可。现在的边界条件是 dp 数组全部初始化为 0 ，因为题目没有要求全部装满，只要不超过就可以，所以对于任意体积的背包，初始时都不装物品，最大价值都是 0；当要求背包必须装满时，初始化动态数组 dp 只有 $dp[0][0] &#x3D; 0$，这代表将体积为 0 的背包用一个体积为0 的物体装满获得的最大价值为 0，而其它情况都初始化为 <code>INT_MIN</code> ，这代表其他体积的背包还没有装满，不符合要求，所以获得的价值也不存在。</p>
<p>0-1 背包问题虽然简单，但后面几乎所有的背包问题都是 0-1 背包问题的变体，都要用到 0-1 背包的方法去解决，因此 0-1 背包是最重要的背包问题。</p>
<h3 id="2-完全背包问题"><a href="#2-完全背包问题" class="headerlink" title="2 完全背包问题"></a>2 完全背包问题</h3><p><a href="https://www.acwing.com/problem/content/3/"> AcWing03. 完全背包问题</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包，每种物品都有<strong>无限件可用</strong>。第 i 种物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>完全背包问题与 0-1 背包非常相似，只是这一次每件物品可以无限次数使用，如果还按照求解 0-1 背包时的思路，定义状态 $dp[i][curv]$ 表示将前 i 种物品放入体积为 curv 的背包所能获得的最大价值，这时要求解的总状态数还是 NV 个，但求解每个状态时就不是 $O(1)$ 复杂度了，而是 $O(curv &#x2F; vi)$ 的复杂度，因为一个物体最多可以放入 curv &#x2F; vi 次。于是总复杂度就是：<br>$$<br>O(NV \times \sum{\frac{curv}{vi}} )<br>$$<br>是比较大的。因此我们要考虑对它进行一些优化，稍微试用一下贪心的思想，对于每件物品 i，如果有物品 j 比它的重量小，价值大，那么就不需要考虑物品 i 了，因为我们任何情况下都可将价值小费用高的 i 换成物美价廉的 j，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据会一件物品也去不掉。而且这个优化方案往往需要 $O(N^2)$ 的时间。</p>
<p>一个更好的优化方案是，首先将费用大于容量 V 的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，这个过程只需要 $O(V+N)$ 时间，但可能会需要额外的空间，比如借助哈希表。</p>
<p>一般来说，我们不需要用上面如此复杂的思路，但是经过这些推导可以加深对问题的理解。同时也说明了 0-1 背包的重要性，因为以上思路全都是基于 0-1 背包，针对完全背包问题进行优化的。</p>
<p>解决这个问题更直接的思路一般是转化为 0-1 背包问题，事实上大多数的背包问题都可以这样做，再一次说明了 0-1 背包有多重要。</p>
<p>具体思路是：因为每件物品 i 最多只能选 V &#x2F; vi 件，因此我们可以把物品 i 拆分成 V &#x2F; vi 件体积和价值完全一样的物品，然后就转化成了一个 0-1 背包问题。</p>
<p>这样的思路完全没有改进基本思路的时间复杂度，但这却给了我们将完全背包问题转化为 0-1 背包问题的基本思路：将一种物品拆成多件物品。</p>
<p>于是我们可以进一步优化，将物品 i 拆成体积为 $vi * 2^k$ ，价值为 $wi*2^k$ 的若干件物品，这里用了二进制的思想，因为不管最优策略选几件第 i 种物品，总可以表示成若干个$2^k$ 件物品的和。这样我们把物品拆成了 $O(logV &#x2F; vi)$ 件物品，是一个很大的优化。</p>
<p>但还有更好的方法，和 0-1 背包问题一样的 $O(NV)$ 复杂度的方法。我们只需要把 0-1 背包问题的一维数组解法遍历体积 curv 的顺序从逆序改为正序即可。之前逆序遍历是因为每件物品只能选一次，所以第 i 件物品的状态必须从没有选择第 i 件物品的状态 i - 1 得来，而现在物品 i 可以选择多次，所以第 i 种物品的状态恰好需要从已选入第 i 种物品的子结果转移而来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = volume[i<span class="number">-1</span>]; curv &lt;= v; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的两种遍历顺序可以颠倒，这在特定数据量的情况下可以做出常数级别的优化。</p>
<p>完全背包问题也是一个简单问题，但往往简单问题才更需要深刻理解，因为复杂的问题也都只是简单问题的变体。</p>
<p>因为 0-1 背包和完全背包是两个最基础的背包问题，因此我们可以将这两个问题的求解方法抽象成两个函数，在之后更复杂的问题中，可能会转换成这两种问题，直接调用这两个函数即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多重背包问题"><a href="#3-多重背包问题" class="headerlink" title="3 多重背包问题"></a>3 多重背包问题</h3><p><a href="https://www.acwing.com/problem/content/4/">AcWing04. 多重背包问题 I</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
</blockquote>
<p>多重背包问题同样可以转化为 0-1 背包实现，只需要把物品 i 拆分成 si 件同样的物品即可，然后我们按照 0-1 背包的方法求解。因此对于每件物品，只需要增加一重循环，遍历物品数量，代表这个物品拿几次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为是基于0-1背包，所以要逆序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume[i<span class="number">-1</span>]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= amount[i<span class="number">-1</span>] &amp;&amp; curv &gt;= s * volume[i<span class="number">-1</span>]; ++s)</span><br><span class="line">                    dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - s * volume[i<span class="number">-1</span>]] + s * value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">amount</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i] &gt;&gt; amount[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solution ans;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">MultiPack</span>(volume, value, amount, n, v) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.acwing.com/problem/content/description/5/">AcWing05. 多重背包问题 II</a></p>
<blockquote>
<p>问题相同，但数据范围变为：<br>0 &lt; N ≤ 1000<br>0 &lt; V ≤ 2000<br>0 &lt; vi, wi, si ≤ 2000</p>
</blockquote>
<p>数据量过大的时候，上面的方法将物品拆分成了 si 件，复杂度太高，于是可以借鉴之前的二进制优化，将物品拆分成 $O(logsi)$ 件，具体的做法是将物品 i 拆分成系数为 $1, 2, 4, … , 2^{k-1},si-2^k+1$ 的若干件物品，其中 $si-2^k+1$ 其实就是物品总数减去之前拆分的数量总和，这样可以保证所有拆分的物品的系数加起来等于物品 i 的数量 si。例如，物品 i 的数量为 13 件，那么就拆分成系数为 1，2，4，6 的四件物品，四件物品的体积和价值为物品 i 的体积和价值乘以对应的系数。然后再利用 0-1 背包求解。另外如果物品 i 的数量 si 使得 si * vi 大于了背包总容量 V，那么问题就转化成了一个完全背包问题，因为相当于物品 i 可以在不超过背包容量的前提下无限次使用。于是可以写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = v; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, vector&lt;<span class="type">int</span>&gt;&amp; amount, <span class="type">int</span> n, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(volume[i<span class="number">-1</span>] * amount[i<span class="number">-1</span>] &gt; v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CompletePack</span>(dp, volume[i<span class="number">-1</span>], value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k = <span class="number">1</span>, s = amount[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">while</span>(s - k &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ZeroOnePack</span>(dp, k * volume[i<span class="number">-1</span>], k * value[i<span class="number">-1</span>], v);</span><br><span class="line">                    s -= k;</span><br><span class="line">                    k *= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, s * volume[i<span class="number">-1</span>], s * value[i<span class="number">-1</span>], v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二进制拆分方法是求解多重背包问题的一般写法，时间复杂度较好并且不难理解。实际上多重背包问题也有 $O(NV)$ 的解法，利用了单调队列优化状态求解过程，但已经超出了常规算法的范畴，证明起来也比较困难，不在我们的讨论范围内。</p>
<h3 id="4-混合背包问题"><a href="#4-混合背包问题" class="headerlink" title="4 混合背包问题"></a>4 混合背包问题</h3><p><a href="https://www.acwing.com/problem/content/7/">AcWing07. 混合背包问题</a></p>
<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。<br>物品一共有三类：</p>
<ul>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 sisi 次（多重背包）；</li>
</ul>
<p>每种体积是 vi，价值是 wi。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p>
<p>输入第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p>
<p>接下来有 N 行，每行三个整数 vi, wi, si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p>
<ul>
<li>si &#x3D; −1 表示第 i 种物品只能用1次；</li>
<li>si &#x3D; 0 表示第 i 种物品可以用无限次；</li>
<li>si &gt; 0 表示第 i 种物品可以使用 si 次；</li>
</ul>
</blockquote>
<p>混合背包是较为困难的背包问题，但经过前面的推导，实际上只要对三类物品分别应用上面的三个过程就可以。之前的代码都是全部读取数据后再处理，但实际上不需要全部读取，每读一件物品就可以更新一次 dp 数组了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 0-1 背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CompletePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = volume; curv &lt;= total; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - volume] + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 多重背包</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MultiPack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> amount, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount * volume &gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CompletePack</span>(dp, volume, value, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(amount - k &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ZeroOnePack</span>(dp, k * volume, k * value, total);</span><br><span class="line">                amount -= k;</span><br><span class="line">                k *= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ZeroOnePack</span>(dp, amount * volume, amount * value, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="comment">// 不要求必须装满，所以初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value, amount;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value &gt;&gt; amount;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) ans.<span class="built_in">ZeroOnePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (amount == <span class="number">0</span>) ans.<span class="built_in">CompletePack</span>(dp, volume, value, v);</span><br><span class="line">        <span class="keyword">else</span> ans.<span class="built_in">MultiPack</span>(dp, volume, value, amount, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-二维费用的背包问题"><a href="#5-二维费用的背包问题" class="headerlink" title="5 二维费用的背包问题"></a>5 二维费用的背包问题</h3><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价 1 和代价 2 ，第 i 件物品所需的两种代价分别为 a[i] 和 b[i]。两种代价可付出的最大值（两种背包容量）分别为 V 和 U。物品的价值为 value[i]。</p>
<p>这相当于在之前的基础上费用增加了一维，所以动态规划的状态也增加一维即可，于是原来的状态转移方程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][curv], dp[i<span class="number">-1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>就可以改写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][cur_v][cur_u] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][cur_v][cur_u], dp[i<span class="number">-1</span>][cur_v - a[i]][cur_u - b[i]] + value[i])</span><br></pre></td></tr></table></figure>

<p>显然也可以不用三维数组，改用二维数组，当问题类似于 0-1 背包时，逆序遍历，类似于完全背包时，正序遍历，类似于多重背包时应用多重背包的解法。</p>
<p>当然，实际的题目中往往不会显式的告诉我们有两种代价，题目一般是这样描述的：</p>
<p><a href="https://www.acwing.com/problem/content/8/">AcWing08. 二维费用的背包问题</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。<br>每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。</p>
</blockquote>
<p>背包能承受的最大重量就相当于增加了一个代价——重量。于是我们就要同时考虑体积和重量两种代价。按照上面的思路，只要在 0-1 背包的基础上增加一重循环，遍历重量即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dp, <span class="type">int</span> volume, <span class="type">int</span> weight, <span class="type">int</span> value, <span class="type">int</span> total_v, <span class="type">int</span> total_w</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= volume; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_w = total_w; cur_w &gt;= weight; --cur_w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[cur_v][cur_w] = <span class="built_in">max</span>(dp[cur_v][cur_w], dp[cur_v - volume][cur_w - weight] + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, weight, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; weight &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, volume, weight, value, v, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v][m] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-分组背包问题"><a href="#6-分组背包问题" class="headerlink" title="6 分组背包问题"></a>6 分组背包问题</h3><p><a href="https://www.acwing.com/problem/content/description/9/">AcWing09. 分组背包问题</a></p>
<blockquote>
<p>有 N 组物品和一个容量是 V 的背包。<br>每组物品有若干个，同一组内的物品最多只能选一个。<br>每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。<br>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<p>同样是 0-1 背包问题的变体，只是这次的一个物品变成了一组物品，相当于我们每次拿一个物品的时候，可以用同组内的其他物品替换。因此只要遍历所有组，更新 dp 状态，在更新时遍历组内每一个物品即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GroupPack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        vector&lt;<span class="type">int</span>&gt;&amp; dp, <span class="type">int</span> amount_in_group, vector&lt;<span class="type">int</span>&gt;&amp; volume, vector&lt;<span class="type">int</span>&gt;&amp; value, <span class="type">int</span> total_v</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cur_v = total_v; cur_v &gt;= <span class="number">0</span>; --cur_v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> cur_index = <span class="number">0</span>; cur_index &lt; amount_in_group; ++cur_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cur_v &gt;= volume[cur_index])</span><br><span class="line">                    dp[cur_v] = <span class="built_in">max</span>(dp[cur_v], dp[cur_v - volume[cur_index]] + value[cur_index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> amount;</span><br><span class="line">        cin &gt;&gt; amount;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(amount)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; amount; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; volume[j] &gt;&gt; value[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">GroupPack</span>(dp, amount, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[v] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-有依赖的背包问题"><a href="#7-有依赖的背包问题" class="headerlink" title="7 有依赖的背包问题"></a>7 有依赖的背包问题</h3><p><a href="https://www.acwing.com/problem/content/10/">AcWing10. 有依赖的背包问题</a></p>
<p>背包问题的终极难度，对于机试、面试来说，属实没必要，碰到就算倒霉。</p>
<h3 id="8-背包问题求方案数"><a href="#8-背包问题求方案数" class="headerlink" title="8 背包问题求方案数"></a>8 背包问题求方案数</h3><p><a href="https://www.acwing.com/problem/content/11/">AcWing11. 背包问题求方案数</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>最优选法的方案数</strong>。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。</p>
</blockquote>
<p>求解方案数一般都要用的动态规划状态之间的递加，主要思考如何递加。除了之前的记录最大价值的数组 dp 外，再定义一个记录达到最大价值的方案数的数组 cnt，因为是 0-1 背包问题，只有两种可能的情况：</p>
<ul>
<li>选择当前物品得到的总价值比之前的价值高，即 <code>dp[curv] &lt; dp[curv-volume] + value</code>，此时最大价值的方案数和之前一样，不会发生改变，相当于用当前物品替换之前的一件物品，即 <code>cnt[curv] = cnt[curv - volume]</code></li>
<li>选择当前物品得到的总价值和之前的价值一样高，即 <code>dp[curv] == dp[curv-volume] + value</code>，这时达到最大价值的方案数增加了 <code>cnt[curv - volume]</code>，因为原本不超过 curv 的最大总价值方案数是 <code>cnt[curv]</code>，现在选择当前物品也可以达到这个最大价值，因此达到这个最大价值的方案总数就增加了  <code>cnt[curv - volume]</code> 种，即 <code>cnt[curv] += cnt[curv - volume]</code></li>
</ul>
<p>初始化 cnt 数组每一项都为 1， 因为每一个体积都不装物品也至少是一种方案，最后编码时记得取模即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ZeroOnePack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dp, vector&lt;<span class="type">int</span>&gt;&amp; cnt, <span class="type">int</span> volume, <span class="type">int</span> value, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= volume; --curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[curv] &lt; dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv - volume] + value;</span><br><span class="line">                cnt[curv] = cnt[curv - volume] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[curv] == dp[curv - volume] + value)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[curv] = (cnt[curv] + cnt[curv - volume]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(v + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    solution ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> volume, value;</span><br><span class="line">        cin &gt;&gt; volume &gt;&gt; value;</span><br><span class="line">        ans.<span class="built_in">ZeroOnePack</span>(dp, cnt, volume, value, v);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt[v] % mod &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-背包问题求具体方案"><a href="#9-背包问题求具体方案" class="headerlink" title="9 背包问题求具体方案"></a>9 背包问题求具体方案</h3><p><a href="https://www.acwing.com/problem/content/12/">AcWing12. 背包问题求具体方案</a></p>
<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N</p>
</blockquote>
<p>因为要保证字典序最小，那我们就要保证编号小的物品优先选到，也就是说，假设存在一个包含第 1 个物品的最优解，为了确保字典序最小那么我们必然要选该物品。那么问题就转化成从 2～N 这些物品中找到最优解。于是状态定义应该稍作修改，<code>dp[i][curv]</code> 表示从第 i 个物品到第 n 个物品总容量为 curv 的最大价值，于是状态转移也要相应的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][curv] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>显然遍历物品的次序也要变为从后向前遍历。那么如何根据结果还原出路径呢？</p>
<p>我们拿着背包，即总体积 V，从第一个物品开始遍历，如果 <code>dp[i][curv] == dp[i+1][curv - volume[i]] + value[i] </code>，说明选择了第 i 个物品，于是将 i 加入结果，总体积 V 减去物品 i 的体积，这样就可以还原出字典序最小的一个物品选取方案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">volume</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; volume[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">0</span>; curv &lt;= v; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][curv] = dp[i+<span class="number">1</span>][curv];</span><br><span class="line">            <span class="keyword">if</span>(curv &gt;= volume[i])</span><br><span class="line">                dp[i][curv] = <span class="built_in">max</span>(dp[i][curv], dp[i+<span class="number">1</span>][curv - volume[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> curv = v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curv - volume[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][curv] == dp[i+<span class="number">1</span>][curv - volume[i]] + value[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            curv -= volume[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-相关题目"><a href="#10-相关题目" class="headerlink" title="10 相关题目"></a>10 相关题目</h3><h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>完全背包问题，并且背包必须被装满。唯一的区别是，这次不是求最大价值，而是求最小数量，这相当于每个硬币的体积是 coins[i]，价值都是 1，求把背包装满的最小价值，只要把 max 改为 min 即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv-coins[i]] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求装满，初始化只有dp[0] = 0</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 完全背包，顺序遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[curv - c] != INT_MAX)	<span class="comment">//防止越界</span></span><br><span class="line">                    dp[curv] = <span class="built_in">min</span>(dp[curv], dp[curv - c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></h4><blockquote>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的长度，该子集中最多有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的子集 。</p>
</blockquote>
<p>经典的二维费用 0-1 背包，两种费用分别是 0 和 1 的最大数量，每个物品的价值都是 1，直接写出优化后的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calone</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ones = <span class="built_in">calone</span>(s);</span><br><span class="line">            <span class="type">int</span> zeros = s.<span class="built_in">size</span>() - ones;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= zeros; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= ones; --j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h4><blockquote>
<p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</li>
<li>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量 。如果没有石头剩下，就返回 0</p>
</blockquote>
<p>题目的难点在于如何转化为背包问题，原问题相当于把石头分为两堆，使得两堆石头的差值最小，进一步可以转化为：如果所有石头的总重量是 sum，那么我们要把所有石头装入容量为 sum&#x2F;2 的背包，并使背包内石头的总重量尽可能大，最终剩下的石头的最小重量就是 sum 减去两倍的背包内石头重量。这样转化的具体思路见<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/">详解为何能转换为背包问题</a>。</p>
<p>转化后就是一个普通的 0-1 背包问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= stones[i]; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = <span class="built_in">max</span>(dp[curv], dp[curv - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4><blockquote>
<p>给你一个<strong>只包含正整数</strong>的<strong>非空</strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<p>0-1 背包问题，并且要求把背包装满，这道题只问了是否可以，因此状态转移更简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> total = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] = dp[curv] || dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个表达式。</p>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同表达式的数目。</p>
</blockquote>
<p>问题可以转化为将数组中的数分为两组，且两组数字的和的差值为 target。假设数组中所有数字总和为 sum，那么问题等价于将数组中的数放入容量为 (sum+target)&#x2F;2 的背包中，且必须装满的方案总数。于是就是一个简单的 0-1 背包求方案总数的问题。只要注意特殊情况的判断即可，如果 (sum+target)&#x2F;2 不是整数则无法分配，如果 target 的绝对值比数组中所有数字的总和都大也无法分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> total = sum + target;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(target) &gt; sum || total % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        total /= <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(total + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = total; curv &gt;= x; --curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[total];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h4><blockquote>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
</blockquote>
<p>完全背包求方案数，且背包必须装满：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : coins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> curv = c; curv &lt;= amount; ++curv)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[curv] += dp[curv - c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h4><blockquote>
<p>给你一个由不同整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
</blockquote>
<p>由于每个数字可以使用多次，因此这也是一个完全背包求方案数问题。与上面的完全背包求方案数问题稍有不同的是，这里不同顺序代表不同的组合，也就是物品的顺序不同也代表一种不同的方案，所以对于每一个当前容积的背包 curv，把背包装满的方案数等于所有 curv-x 的背包的方案数的总和，x 是每个体积小于 curv 的物品，即：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= curv) dp[curv] += dp[curv - x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我们只需要改变完全背包原本的内外层遍历即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> curv = <span class="number">1</span>; curv &lt;= target; ++curv)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curv &gt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[curv] += dp[curv - x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="盈利计划"><a href="#盈利计划" class="headerlink" title="盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/">盈利计划</a></h4><blockquote>
<p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 minProfit 利润的子集称盈利计划 。并且工作的成员总数最多为 n 。</p>
<p>有多少种计划可以选择？因为答案很大，所以返回结果模 10^9 + 7 的值。</p>
</blockquote>
<p>显然是一个二维费用的 0-1 背包问题，但第二个费用限制是<strong>至少</strong>产生 minProfit 的价值，与之前稍有不同，但总体思路还是完全一样的，注意对于至少产生 minProfit 的处理，非常巧妙：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, vector&lt;<span class="type">int</span>&gt;&amp; group, vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(minProfit + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = group.<span class="built_in">size</span>(), MOD = (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> members = group[i - <span class="number">1</span>], earn = profit[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= members; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = minProfit; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    dp[j][k] = (dp[j][k] + dp[j - members][<span class="built_in">max</span>(<span class="number">0</span>, k - earn)]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][minProfit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识汇总】C++相关</title>
    <url>/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>本篇总结 C++ 相关知识点，提供之前笔记的索引，并补充部分内容，方便查找，将持续更新。</p>
<p><em><span id="more"></span></em></p>
<h2 id="1-多态"><a href="#1-多态" class="headerlink" title="1 多态"></a>1 多态</h2><h4 id="多态的定义、种类、如何实现"><a href="#多态的定义、种类、如何实现" class="headerlink" title="多态的定义、种类、如何实现"></a>多态的定义、种类、如何实现</h4><p>多态简单概括就是“一种接口，多种方法”，是面向对象编程的核心，主要指不同的对象收到相同的消息做出不同的动作。C++ 通过指针或引用实现多态，具体查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/">【C++ 对象模型】（一）关于对象</a>。</p>
<h4 id="虚函数如何实现多态"><a href="#虚函数如何实现多态" class="headerlink" title="虚函数如何实现多态"></a>虚函数如何实现多态</h4><p>基类指针指向派生类对象，可以调用不同派生类的方法，这是通过虚函数来实现的。每一个类都有一张虚函数表，类的对象中包含指向虚函数表的指针，派生类对象中包含基类子对象并且在内存布局的最前面，而虚函数表指针又位于实例对象内存的最前面，因此使用基类指针可以指向任何派生类对象并且正确寻址到虚函数表，这样通过一个基类指针就可以在运行时找到不同派生类的虚函数表从而调用对应的函数，实现多态。</p>
<h4 id="虚表指针什么时候产生"><a href="#虚表指针什么时候产生" class="headerlink" title="虚表指针什么时候产生"></a>虚表指针什么时候产生</h4><p>首先每一个类的虚函数表在编译期间确定，虚函数表指针在虚函数表确定后，对象被构造出来的时候就可以确定了，实际上编译器会在构造函数时中加入对虚函数表指针的赋值操作，并且这些操作会在用于自己定义的初始化操作之前执行。同样的，虚基类指针也在编译期确定。</p>
<h4 id="关于纯虚函数"><a href="#关于纯虚函数" class="headerlink" title="关于纯虚函数"></a>关于纯虚函数</h4><p>纯虚函数没有定义，必须在派生类中实现，在虚函数表中会存在一个纯虚函数调用（<code>pure_virtual_called()</code> ）实体，它既可以扮演纯虚函数的空间占用者，也可以当作执行期的异常处理函数，当调用一个基类中的纯虚函数（即未被定义）时，会抛出异常并终止程序。</p>
<h4 id="重载、重写与覆盖"><a href="#重载、重写与覆盖" class="headerlink" title="重载、重写与覆盖"></a>重载、重写与覆盖</h4><p>重载允许有多个同名的函数，而这些函数可以参数列表不同，返回类型不同，参数个数不同，参数类型不同等等。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。重写可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性。在派生类中重写了基类中的函数会覆盖基类中定义的函数，重写虚函数会覆盖虚函数表对应位置的函数指针。</p>
<h4 id="多继承的实现及可能出现的问题"><a href="#多继承的实现及可能出现的问题" class="headerlink" title="多继承的实现及可能出现的问题"></a>多继承的实现及可能出现的问题</h4><p>多继承会将基类子对象按照继承顺序放在派生类对象中。菱形继承中可能出现重复继承同一个基类的情况。解决办法是使用虚继承。</p>
<h4 id="菱形继承类大小的计算"><a href="#菱形继承类大小的计算" class="headerlink" title="菱形继承类大小的计算"></a>菱形继承类大小的计算</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第2部分</p>
<h4 id="类对象的内存存储形式"><a href="#类对象的内存存储形式" class="headerlink" title="类对象的内存存储形式"></a>类对象的内存存储形式</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第3部分</p>
<h4 id="override-和-final"><a href="#override-和-final" class="headerlink" title="override 和 final"></a>override 和 final</h4><p>override 关键字告诉编译器这个函数是重写基类的函数，如果该函数和基类函数的标识不是完全一样就会报错，比如基类函数中有 const 修饰，派生类重写的时候忘记了 const，如果没有 override，就会导致我们以为重写了基类的函数，但实际上因为没有加 const ，这是两个完全不同的函数而产生错误。同时因为 override 可以说明这是一个重写的基类虚函数，因此派生类中函数的 virtual 关键字就可以去掉了。</p>
<p>final 关键字用于类声明可以禁止继承该类，用于方法可以禁止该方法在派生类中被重写。</p>
<h4 id="为什么构造函数不能是虚函数"><a href="#为什么构造函数不能是虚函数" class="headerlink" title="为什么构造函数不能是虚函数"></a>为什么构造函数不能是虚函数</h4><p>因为虚函数会在放在虚函数表中，构造对象时给对象的 vptr 赋值，如果构造函数是虚函数，那调用构造函数的时候就要用 vptr 去找构造函数，但此时 vptr 还没有被赋值。</p>
<h4 id="为什么析构函数可以是虚函数"><a href="#为什么析构函数可以是虚函数" class="headerlink" title="为什么析构函数可以是虚函数"></a>为什么析构函数可以是虚函数</h4><p>与构造函数不同，vptr 已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。</p>
<p>当我们使用基类指针可以指向派生类的对象时，如果删除该指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。而如果析构函数不定义为虚函数，编译器会实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，从而存在内存泄露的风险。</p>
<p>更多关于析构函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%9E%90%E6%9E%84/">【C++ 对象模型】（五）对象复制和析构</a></p>
<h4 id="关于构造函数和析构函数的细节"><a href="#关于构造函数和析构函数的细节" class="headerlink" title="关于构造函数和析构函数的细节"></a>关于构造函数和析构函数的细节</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 1 部分</p>
<h4 id="关于拷贝构造函数"><a href="#关于拷贝构造函数" class="headerlink" title="关于拷贝构造函数"></a>关于拷贝构造函数</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分</p>
<h4 id="new、placement-new-和-malloc"><a href="#new、placement-new-和-malloc" class="headerlink" title="new、placement new 和 malloc"></a>new、placement new 和 malloc</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/">【C++ 对象模型】（六）关于执行期</a></p>
<h2 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2 智能指针"></a>2 智能指针</h2><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>指针指向内存后在使用完毕不释放内存导致这块内存既没有用处也无法再被分配出去。智能指针会在对象生命周期结束后自动释放内存。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>它持有对对象的独有权——两个unique_ptr 不能指向一个对象，即 unique_ptr 不共享它所管理的对象。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个 unique_ptr，并且原始 unique_ptr 不再拥有此资源。</p>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象。shared_ptr 对资源做引用计数，当引用计数为 0 的时候，自动释放资源。</p>
<p>shared_ptr 需要维护的信息有两部分：</p>
<ol>
<li>指向共享资源的指针。</li>
<li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li>
</ol>
<p>所以，一个 shared_ptr 对象有两个指针。一个是指向共享资源的指针，一个是指向控制信息的指针。shared_ptr 的自定义 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/06/25/20220626-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-C++%E9%83%A8%E5%88%86/image-20220625132147566.png" alt="image-20220625132147566"></p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载 operator* 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</p>
<p>总结一下，std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p>
<ol>
<li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li>
<li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li>
</ol>
<h4 id="为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？"><a href="#为什么-shared-ptr-的控制信息中也要保存指向共享资源的指针？可不可以去掉-shared-ptr-对象中指向共享资源的指针，以节省内存开销？" class="headerlink" title="为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？"></a>为什么 shared_ptr 的控制信息中也要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？</h4><p>不能。 因为在存在继承的情况下，shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</p>
<p>比如基类指针指向派生类对象，基类指针指向的是派生类中的基类子对象，但控制信息中该基类指针也会为派生类对象的引用计数加 1，并且控制信息中指向的共享资源不是基类子对象，而是派生类对象本身。</p>
<h4 id="关于循环引用"><a href="#关于循环引用" class="headerlink" title="关于循环引用"></a>关于循环引用</h4><p>引用计数的一个问题就是不能处理循环引用的情况，当两个对象互相引用的时候，引用计数永远为 1，导致二者都无法释放从而造成内存泄露。这时将其中一个 shared_ptr 改为 weak_ptr，在需要获取操作权的时候使用 <code>weak_ptr.lock()</code>函数将 weak_ptr 提升为 shared_ptr 即可，这样既解决了循环引用问题也达到了原本的目的。</p>
<p>关于循环引用的例子可以查看<a href="https://blog.csdn.net/u012442719/article/details/55045583">c++ weak ptr解除指针循环引用</a>加深理解。</p>
<h4 id="shared-ptr-的实现"><a href="#shared-ptr-的实现" class="headerlink" title="shared_ptr 的实现"></a>shared_ptr 的实现</h4><p>查看<a href="https://blog.csdn.net/xiaodu655/article/details/85780240">智能指针（shared_ptr的实现）</a>。</p>
<h4 id="关于野指针"><a href="#关于野指针" class="headerlink" title="关于野指针"></a>关于野指针</h4><p>初始化指针时没有给初始值或者释放内存后没有将指针置空就会产生野指针，具体可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%89%A7%E8%A1%8C%E6%9C%9F/">【C++ 对象模型】（六）关于执行期</a>中 2.2 部分。</p>
<p>避免野指针的方法是：</p>
<ul>
<li>初始化指针的时候将其置为 nullptr，之后再对其操作</li>
<li>释放指针的时候将其置为 nullptr</li>
</ul>
<h2 id="3-STL"><a href="#3-STL" class="headerlink" title="3 STL"></a>3 STL</h2><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8/">【STL】迭代器</a></p>
<h4 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/04/30/20220430-STL-%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8/">【STL】序列式容器</a></p>
<h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/03/20220503-STL-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/">【STL】关联式容器</a></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><h4 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h4><ol>
<li><strong>预编译</strong>（.cpp -&gt; .i），预编译主要进行代码文本替换工作。编译器执行预编译指令（以 # 开头，例如 #include），这个过程会得到不包含 # 指令的 .i 文件。这个过程会拷贝 #include 包含的文件代码，进行 #define 宏定义的替换 ， 处理条件编译指令（#ifndef、#ifdef、#endif）等等。</li>
<li><strong>编译优化</strong>（.i -&gt; .s），通过预编译输出的 .i 文件中，只包含常量、字符串、变量的定义，以及关键字：main、if、else、for、while等。编译优化阶段则是通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</li>
<li><strong>汇编</strong>（.s -&gt; .o 或 .obj），汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件。目标文件中存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成，通常至少有两个段：<ul>
<li>代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写</li>
<li>数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行</li>
</ul>
</li>
<li><strong>链接</strong>（.o -&gt; .exe &#x2F; .a &#x2F; .so &#x2F; .lib &#x2F; .dll 等），由汇编程序生成的目标文件并不能立即就执行，还要通过链接过程。这是因为某个源文件调用了另一个源文件中的函数或常量或在程序中调用了某个库文件中的函数，链接的主要工作就是将有关的目标文件连接起来，形成最终的可执行文件。</li>
</ol>
<h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>堆是由程序员控制的内存区域，通过 new 和 delete 来申请堆上的内存和释放堆上的内存。</p>
<p>栈是由编译器管理的内存，在需要时自动分配，不需要时自动清除。栈通常存放局部变量、函数参数等。</p>
<p>除了堆和栈之外，还有存储全局变量和静态变量的存储区以及存放常量的存储区。</p>
<p>堆和栈的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>堆（Heap）</th>
<th>栈（Stack）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理方式</strong></td>
<td>堆中资源由程序员控制（需要注意内存泄漏）</td>
<td>栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr>
<td><strong>内存管理机制</strong></td>
<td>系统维护一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序，系统还会将多余的部分重新放入空闲链表中，释放内存时将内存重新加入空闲内存链表中。</td>
<td>栈是一块连续的内存空间，只要栈的剩余空间大于所申请空间，系统就为程序提供栈内存，否则报错 stack overflow。</td>
</tr>
<tr>
<td><strong>空间大小</strong></td>
<td>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</td>
<td>在Windows下，栈是向低地址扩展的数据结构，栈是一块连续的内存区域，大小是操作系统预定好的，在编译时确定，可设置。</td>
</tr>
<tr>
<td><strong>碎片问题</strong></td>
<td>对于堆，频繁的 new &#x2F; delete 会造成大量内存碎片，使程序效率降低。</td>
<td>对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。</td>
</tr>
<tr>
<td><strong>分配方式</strong></td>
<td>堆都是动态分配，没有静态分配的堆</td>
<td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由 alloca() 函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>堆由 C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多。</td>
<td>栈是极其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody></table>
<h4 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h4><p>查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/07/20220507-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98/">【C++ 对象模型】（三）关于数据成员</a>第 1 部分。</p>
<h4 id="内联函数与宏的区别"><a href="#内联函数与宏的区别" class="headerlink" title="内联函数与宏的区别"></a>内联函数与宏的区别</h4><p>宏在预编译时在调用处执行字符串的原样替换（宏展开）。而内联函数在编译时在调用处展开，同时进行<strong>参数类型检查，宏定义不会进行参数类型检查。</strong></p>
<p>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</p>
<p>一般来说内联函数可以完全替代宏，更多关于内联函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/09/20220509-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98/">【C++ 对象模型】（四）关于函数成员</a>第 3 部分。</p>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝就是在拷贝时直接进行简单的对应赋值操作，类似于参数的引用传递，源对象与拷贝对象共用一份实体，对其中任何一个对象的改动都会影响另外一个对象。</p>
<p>深拷贝则类似于参数的值传递，源对象与拷贝对象互相独立 ，其中任何一个对象的改动都不会对另外一个对象造成影响。</p>
<h4 id="什么时候需要深拷贝"><a href="#什么时候需要深拷贝" class="headerlink" title="什么时候需要深拷贝"></a>什么时候需要深拷贝</h4><p>当一个类中有对其他类对象成员时需要深拷贝，也就是不能直接将一个类对象的某个对象成员赋值给另一个类对象，而是要单独开辟一块内存，重新构造一个相同的对象成员，否则当类对象析构时，拷贝的类对象的该对象成员也被析构掉了就会产生错误。</p>
<p>关于拷贝构造函数可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/06/20220506-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">【C++ 对象模型】（二）关于构造函数</a>第 2 部分。</p>
<h4 id="C-的强制类型转换"><a href="#C-的强制类型转换" class="headerlink" title="C++ 的强制类型转换"></a>C++ 的强制类型转换</h4><p>C++ 提供四种强制类型转换关键字：static_cast、const_cast、reinterpret_cast 和 dynamic_cast。</p>
<ul>
<li><strong>static_cast</strong> 用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型。主要用于内置类型之间的转换或者将空指针转化为对应类型的指针。static_cast 也可以用于类层次结构中基类和派生类之间指针或引用的转换，但<strong>需要注意</strong>：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的，但进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</li>
<li><strong>const_cast</strong> 用于强制去掉 const 修饰的常量特性，但需要特别注意的是 const_cast 不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。具体的例子可以查看<a href="https://blog.csdn.net/q610098308/article/details/115915802">C++强制类型转换</a>第 2 部分，总之非必要情况下尽量不要使用 const_cast。</li>
<li><strong>reinterpret_cast</strong> 主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。reinterpret_cast 可以将指针或引用转换为一个足够长度的整形，这里的足够长度具体是多少则取决于操作系统，如果是 32 位的操作系统，就需要 4 个字节及以上的整型，如果是 64 位的操作系统则需要 8 个字节及以上的整型。 </li>
<li><strong>dynamic_cast</strong> 是 C++ 支持多态的方式之一，其他三种类型转换都是在编译时进行，而 dynamic_cast 则是在运行时处理。 在 C++ 中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。dynamic_cast 操作符则可以在运行期对可能产生问题的类型转换进行判定。dynamic_cast 具有以下特性：<ul>
<li>不能用于内置的基本数据类型的强制转换。</li>
<li>dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr。</li>
<li>使用 dynamic_cast 进行转换时，基类中一定要有虚函数，否则编译不通过。这是因为类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</li>
<li>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是完全一样的。在进行下行转换时，由于 dynamic_cast 具有运行时类型检查的功能，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败，因此要比 static_cast 更安全。运行时类型检查需要运行时类型信息，这个信息存储在虚函数表中，关于这部分可以查看笔记<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/05/20220505-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/">【C++ 对象模型】（一）关于对象</a>第 2 部分和<a href="https://lz328.github.io/LycTechStack.github.io/2022/05/11/20220511-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E5%92%8CRTTI/">【C++ 对象模型】（七）模板和 RTTI</a>第 2 部分。</li>
</ul>
</li>
</ul>
<h4 id="关于模板的声明和实现"><a href="#关于模板的声明和实现" class="headerlink" title="关于模板的声明和实现"></a>关于模板的声明和实现</h4><p>C++ 在写模版函数时（<code>template&lt;class T&gt;</code>之类的），头文件不能与 cpp 文件分离。这就意味者，你头文件定义的含模版的地方必须在头文件中实现，没用模版定义的地方可以放在 cpp 中实现。为什么会这样呢？</p>
<p>C++ 中每一个对象所占用的空间大小，是在编译的时候就确定的，在模板类没有真正的被使用之前，编译器是无法知道模板类中使用模板类型的对象的所占用的空间的大小的。只有模板被真正使用的时候，编译器才知道，模板套用的是什么类型，应该分配多少空间。这也就是模板类为什么只是称之为模板，而不是泛型的缘故。</p>
<p>既然是在编译的时候，根据套用的不同类型进行编译，那么，套用不同类型的模板类实际上就是完全不同的类型，也就是说 <code>stack&lt;int&gt;</code> 和 <code>stack&lt;char&gt;</code> 是两个不同的数据类型，他们共同的成员函数也不是同一个函数，只不过具有相似的功能罢了。因此这两个模板类的成员函数也会被编译出完全不同的代码。</p>
<p>所以模板类的实现，脱离具体的使用，是无法单独的编译的；把声明和实现分开的做法也是不可取的，必须把实现全部写在头文件里面。为了清晰，实现可以不写在 class 后面的花括号里面，可以写在 class 的外面。</p>
<p>但也可以实现模板声明和实现分离，比如有下面的模板类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Node&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestTemplate</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">TestTemplate</span>(Node node):</span><br><span class="line">  <span class="built_in">data</span>(node) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">  Node data;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> node&gt;</span><br><span class="line"><span class="type">void</span> TestTemplate&lt;node&gt;::<span class="built_in">print</span>()&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;TestTemplate &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把它们分别放在 .h 和 .cpp 文件中，链接器会报错，提示找不到实现。但在 .h 文件中模板类的声明下加这一句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestTemplate.tpp&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>然后把实现放在名为 TestTemplate.tpp 文件中，即可实现模板声明和实现的文件分离。</p>
<h4 id="类的静态成员变量何时初始化"><a href="#类的静态成员变量何时初始化" class="headerlink" title="类的静态成员变量何时初始化"></a>类的静态成员变量何时初始化</h4><p>在 main 函数运行前，程序加载时进行初始化，分为静态初始化和动态初始化。</p>
<p>静态初始化是用常量堆静态成员初始化，静态初始化在程序加载的过程中完成。</p>
<p>动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：int a &#x3D; foo()，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。</p>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p>
<p>左值是可寻址的变量，有持久性；右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。</p>
<p>左值和右值主要的区别之一是左值可以被修改，而右值不能。</p>
<h4 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h4><p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。</p>
<p>能指向左值，不能指向右值的就是左值引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref_a = a; <span class="comment">// 左值引用指向左值，编译通过</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a = <span class="number">5</span>; <span class="comment">// 左值引用指向了右值，会编译失败</span></span><br></pre></td></tr></table></figure>

<p>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。但是，const 左值引用是可以指向右值的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref_a = <span class="number">5</span>;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<p>const 左值引用不会修改指向值，因此可以指向右值，这也是为什么通常要使用 <code>const &amp;</code> 作为函数参数的原因之一，如 <code>std::vector </code>的 <code>push_back</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>const</code>，<code>vec.push_back(5)</code> 这样的代码就无法编译通过了。</p>
<p>右值引用的标志是 <code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"> </span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>

<h4 id="move-和-forward-的作用"><a href="#move-和-forward-的作用" class="headerlink" title="move 和 forward 的作用"></a>move 和 forward 的作用</h4><p><code>std::move</code> 可以将左值强制转化为右值，从而让右值引用可以指向左值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = std::<span class="built_in">move</span>(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>

<p>那么 move 到底有什么用处呢？首先来总结一下左右值引用：</p>
<ol>
<li>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</li>
<li>右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值，但 const 左值引用也能指向右值。</li>
<li>作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</li>
</ol>
<p>上面已经给出了 move 的作用之一，就是比左值引用更加灵活，但其本身只是一个类型转换工具，不会对性能有任何提升，但使用 move 可以实现移动语义从而提升性能。</p>
<p>在没有右值引用之前，当一个类中有其他对象成员的时候，拷贝构造或者赋值运算都需要深拷贝，相当于复制了一份对象成员，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝构造</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 深拷贝赋值</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; temp_array) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然拷贝构造函数的参数是左值引用的，左值引用就是为了防止拷贝，但函数内还是进行了深拷贝，如果被拷贝者之后就不需要了，那这样的拷贝函数会显得非常呆，于是有人提出是不是可以写一个移动构造函数，进行浅拷贝：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数，可以浅拷贝</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="type">const</span> Array&amp; temp_array, <span class="type">bool</span> move) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用 const 左值引用实现移动构造函数有两个问题：</p>
<ul>
<li>不优雅，表示移动语义还需要一个额外的参数(或者其他方式)</li>
<li>实际根本无法实现，<code>temp_array</code>是个 const 左值引用，无法被修改，所以 <code>temp_array.data_ = nullptr;</code> 这行根本无法编译通过。当然函数参数可以改成非 const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，但这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li>
</ul>
<p>可以看出左值引用使用起来非常不方便，而使用右值引用作为参数可以完美的解决这个问题，实现成员数据的移动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止 temp_array 析构时 delete data，提前置空其data_      </span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用时使用 move 转化为右值传入函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做一些操作</span></span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上在 STL 的很多容器中都使用了以右值引用为参数的移动构造函数和移动赋值重载函数，或者其他函数，最常见的如 std::vector 的 <code>push_back</code> 和 <code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;aacasxs&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;axcsddcas&quot;</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非设计不允许移动，STL 中的类大都支持移动语义函数。另外，编译器会默认在用户自定义的类和结构体中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数。因此，<strong>可移动对象在需要拷贝且被拷贝者之后不再被需要的场景中，建议使用 <code>std::move</code> 触发移动语义，提升性能。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line"><span class="comment">// 改为： </span></span><br><span class="line">moveable_objecta = std::<span class="built_in">move</span>(moveable_objectb);</span><br></pre></td></tr></table></figure>

<p>还有些 STL 类是 <code>move-only</code> 的，比如智能指针中的 <code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动（转移内部对象所有权，或者叫浅拷贝），不能拷贝（深拷贝）。</p>
<p>与 move 相比，forward 更强大，move 只能将左值转化为右值，forward 都可以。</p>
<p><code>std::forward&lt;T&gt;(u)</code> 有两个参数 T 与 u。当 T 为左值引用类型时，u 将被转换为 T 类型的左值；否则 u 将被转换为 T 类型右值。</p>
<h4 id="什么是引用折叠"><a href="#什么是引用折叠" class="headerlink" title="什么是引用折叠"></a>什么是引用折叠</h4><p>右值引用比左值引用更加灵活，但如果右值引用绑定的对象类型是未知的话，就既可能是左值，又可能是右值。比如模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">// 10是右值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);  <span class="comment">// x是左值</span></span><br></pre></td></tr></table></figure>

<p>由于存在 <code>T&amp;&amp;</code> 这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这时相比普通的右值引用(&amp;&amp;)会发生类型的变化，这种变化就称为引用折叠。</p>
<p>引用折叠规则如下：</p>
<p>1.所有右值引用折叠到右值引用上仍然是一个右值引用。（A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;）</p>
<p>2.所有的其他引用类型之间的折叠都将变成左值引用。 （A&amp; &amp; 变成 A&amp;; A&amp; &amp;&amp; 变成 A&amp;; A&amp;&amp; &amp; 变成 A&amp;）</p>
<h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>C++ 中 static 修饰不同的内容会有不同的效果：</p>
<ul>
<li>static 修饰变量的时候，被修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li>
<li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li>
<li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。</li>
<li>static 修饰类中的成员变量的时候，可以直接通过类名访问改变量，该变量值初始化一次，被所有对象共享</li>
<li>static 修饰类中的函数的时候，该函数可以直接通过类名调用，且静态成员函数只能访问类中的静态成员变量</li>
</ul>
<h4 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h4><ul>
<li>定义常量</li>
<li>防止内容被修改（const char* p 是指针指向的内容不可变，而 char* const p 是指针本身不可变）</li>
<li>左值引用指向右值</li>
</ul>
<h4 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h4><p>extern 可以引用不在同一个文件中的变量或者函数</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>指针是一个地址，是一个单独的变量，指针本身和其指向的内容都可以被改变；而引用是对象的别名，依附于某一个对象，可以通过引用改变对象的内容，但引用本身不能改变，即引用在其生命周期内只能依附于固定的对象。</p>
<p>因此可以有空指针，但不能有空的引用。</p>
<h4 id="auto-和-decltype"><a href="#auto-和-decltype" class="headerlink" title="auto 和 decltype"></a>auto 和 decltype</h4><ul>
<li><a href="http://c.biancheng.net/view/6984.html">C++ auto类型推导</a></li>
<li><a href="http://c.biancheng.net/view/7151.html">C++ decltype类型推导</a></li>
<li><a href="https://blog.csdn.net/tcy23456/article/details/110530204?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_antiscanv2&spm=1001.2101.3001.4242.2&utm_relevant_index=4">C++20 decltype和decltype(auto)用法</a></li>
</ul>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><ul>
<li><a href="https://blog.csdn.net/A1138474382/article/details/111149792">C++ Lambda表达式原理及应用</a></li>
<li><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲</a></li>
<li><a href="http://c.biancheng.net/view/7818.html">C++11 lambda匿名函数用法详解</a></li>
</ul>
<h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><ul>
<li><a href="https://blog.csdn.net/JMW1407/article/details/107130600">仿函数(functors)</a></li>
<li><a href="https://blog.csdn.net/toby54king/article/details/105103111">C++中的仿函数有点难，这篇文章却讲的通俗易懂</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/362323211">C++ 仿函数为何而生</a></li>
</ul>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/64985296">C++17 新特性之 std::optional（上）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/251306766">C++干货系列——C++17新特性之std::optional</a></li>
</ul>
<h4 id="游戏引擎常用的设计模式"><a href="#游戏引擎常用的设计模式" class="headerlink" title="游戏引擎常用的设计模式"></a>游戏引擎常用的设计模式</h4><p>关于设计模式具体的可以查看<a href="https://zhuanlan.zhihu.com/p/431714886">C++各类设计模式及实现详解</a>，这里简单总结游戏引擎中可能用到的几种：</p>
<ul>
<li>单例模式（SingletonDesign Pattern）：只允许创建一个类的一个实例。在游戏中，就像在电影里，应该只有一个导演。导演是一个类，这个类在游戏中指挥发生的事情。它控制对象的呈现。它控制位置更新。它将玩家的输入指向正确的游戏角色。引擎应该阻止创建一个以上的导演类的实例，通过单例设计模式来实现。此设计模式确保为给定类实例化有且只有一个对象。</li>
<li>策略模式（StrategyDesign Pattern）：通过解耦类行为从而提供灵活性。在游戏中，你应该将输入控制器和游戏逻辑之间的交互进行解耦。游戏的逻辑应该接收相同类型的输入，而不管输入控制器是什么（按钮，手势，操纵杆）。尽管对用户每个输入控制器的行为表现不同，但它们必须向游戏的逻辑提供相同的数据。此外，添加或删除输入控制器不应导致游戏崩溃。这种解耦行为和灵活性是可能的，这归功于策略设计模式。这种设计模式允许通过动态方式来改变行为，而不需要修改游戏的任何逻辑，为你的游戏提供了很高的灵活性。</li>
<li>观察者模式（Observer Design Pattern）：允许类在不知道任何事情的情况下相互交互。在游戏中，你的所有类耦合度应该设计的很低。这意味着你的类应该能够彼此交互且彼此之间应该知道对方尽量少的内容。使得你的类具有低耦合度，使得你的游戏可以模块化和灵活性的添加新的功能，且不会有意外的错误。</li>
<li>组合模式（CompositeDesign Pattern）：为所有类提供了统一的接入点。游戏通常包含许多视图。主视图中显示角色。有一个子视图，显示玩家的积分。有一个子视图，显示游戏中剩下的时间。如果你在移动设备上玩游戏，那么每个按钮都是一个视图。可维护性应该是游戏开发过程中的主要关注点。每个视图不应具有不同的函数名称或不同的访问点。相反，你想要为每个视图提供一个统一的访问点，即相同的函数调用应该既能够访问主视图也能够访问子视图。这种统一的接入点可以使用复合设计模式。此模式将每个视图放置在树状结构中，从而为每个视图提供统一的访问点。取代了需要用不同的函数来访问不同的子视图，组合模式可以用相同的函数访问任何视图。</li>
</ul>
]]></content>
      <categories>
        <category>知识汇总</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【Unity Shader】（四）阴影和衰减</title>
    <url>/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/</url>
    <content><![CDATA[<p>在前面的学习中，我们的场景中都仅有一个光源且光源类型是平行光。但在实际的游戏开发过程中，我们往往需要处理数目更多、类型更复杂的光源。更重要的是，我们想要得到阴影、光照衰减等更加逼真的效果。这一节我们先学习 Unity 中不同的渲染路径和重要的光源类型，再学习如何在前向渲染路径中实现包含了光照衰减、阴影等效果的完整的光照计算。</p>
<p><em><span id="more"></span></em></p>
<h3 id="1-Unity-的渲染路径"><a href="#1-Unity-的渲染路径" class="headerlink" title="1 Unity 的渲染路径"></a>1 Unity 的渲染路径</h3><p>在我们之前的代码中，每个 Pass 都有一行重要的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br></pre></td></tr></table></figure>

<p>这就是用来设置渲染路径的代码。在 Unity 里，渲染路径（Rendering Path）决定了光照是如何应用到 Unity Shader 中的。因此，如果要和光源打交道，我们需要为每个 Pass 指定它使用的渲染路径，只有这样才能让 Unity 知道：“哦，原来这个程序员想要这种渲染路径，那么好的，我把光源和处理后的光照信息都放在这些数据里，你可以访问啦！” 也就是说，我们只有为 Shader 正确地选择和设置了需要的渲染路径，该 Shader 的光照计算才能被正确执行。</p>
<p>Unity 支持多种类型的渲染路径，最常用的两种是<strong>前向渲染路径（Forward Rendering Path）</strong>和<strong>延迟渲染路径（Deferred Rendering Path）</strong>。我们可以对整个项目设置统一的渲染路径也可以单独为相机指定渲染路径。</p>
<p>上面的代码将告诉 Unity，该 Pass 使用前向渲染路径中的 ForwardBase 路径。而前向渲染路径还有一种路径叫做 ForwardAdd。下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403210148354.png" alt="image-20220403210148354"></p>
<p>我们在 Pass 中制定了渲染路径后，就可以在后面的代码中通过 Unity 提供的内置光照变量来访问光照属性。如果我们没有指定任何渲染路径，那么一些光照变量很可能不会被正确赋值，我们计算出的效果也就很有可能是错误的。</p>
<p>接下来我们详细认识一下不同的渲染路径是如何实现的。</p>
<h4 id="1-1-前向渲染"><a href="#1-1-前向渲染" class="headerlink" title="1.1 前向渲染"></a>1.1 前向渲染</h4><p>前向渲染路径是传统的渲染方式，也是我们最常用的一种渲染路径。每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区， 一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。我们可以用下面的伪代码来描述前向渲染路径的大致过程：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span> this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="comment">// 如果没有通过深度测试，说明该片元不可见，舍弃</span></span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果该片元可见，就进行光照计算</span></span><br><span class="line">                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">                <span class="comment">//更新帧缓冲</span></span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N 个物体，每个物体受 M 个光源的影响，那么要渲染整个场景一共需要 N*M 个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的 Pass 数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p>
<p>事实上，一个 Pass 不仅仅可以用来计算逐像素光照，它也可以用来计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当我们渲染一个物体时，Unity 会计算哪些光源照亮了它，以及这些光源照亮该物体的方式。在 Unity 中，前向渲染路径有 3 种处理光照（即照亮物体）的方式：逐顶点处理、逐像素处理、球谐函数（Spherical Harmonics, SH）处理。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。光源类型指的是该光源是平行光还是其他类型的光源，而光源的渲染模式指的是该光源是否是<strong>重要的（Important）</strong>。光源的渲染模式可以在光源面板的 Render Mode 属性中设置。</p>
<p>在前向渲染中，当我们渲染 一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（例如，距离该物体的远近、 光源强度等）对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理。Unity使用的判断规则如下：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理的</li>
<li>渲染模式被设置成 NotImportant 的光源，会按逐顶点或者 SH 处理</li>
<li>渲染模式被设置成 Important 的光源，会按逐像素处理</li>
<li>如果根据以上规则得到的逐像素光源数量小于 Quality  Setting 中的逐像素光源数量（Pixel Light Count），则会有更多的光源以逐像素的方式进行渲染</li>
</ul>
<p>那么在哪里进行光照计算呢？当然是在Pass里。前面提到过，前向渲染有两种Pass：Base Pass 和 Additional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403212358300.png" alt="image-20220403212358300"></p>
<p>需要注意的有以下几点：</p>
<ul>
<li>除了在 Pass 中设置标签为对应的渲染路径外，还要使用 <code>#pragma multi_compile_fwdbase</code> 和 <code>pragma multi_compile_fwdadd</code> 这样的编译指令，概括来说这些编译指令保证 Unity 可以为相应类型的 Pass 生成所有需要的 Shader 变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图（lightmap）、当前使用哪种光源类型等。因此使用了正确的编译指令我们才可以在相关的 Pass 中得到一些正确的光照变量，例如光照衰减值等。</li>
<li>Base Pass 中渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而 Additional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 Shadow Type。但我们可以在 Additional Pass 中使用 <code>#pragma multi_compile_fullshadows</code> 代替 <code>pragma multi_compile_fwdadd</code> 编译指令，为点光源和聚光灯开启阴影效果。</li>
<li>环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果我们在 Additional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，这不是我们想要的。</li>
<li>在 Additional Pass 的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个 Additional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Additional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源的影响。通常情况下，我们选择的混合模式是 <strong>Blend One One</strong>。</li>
<li>对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass（Base Pass 也可以定义多次，例如需要双面渲染等情况）以及一个 Additional Pass。一个 Base  Pass 仅会执行一次（定义了多个 Base Pass 的情况除外），而 一个 Additional Pass 会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次 Additional Pass。</li>
</ul>
<p>实际上，渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一 些内置变量（如 _LightColor0 等），如何使用这些内置变量进行计算完全取决于开发者的选择。 例如，我们完全可以利用 Unity 提供的内置变量在 Base Pass 中只进行逐顶点光照；同样，我们也完全可以在 Additional Pass 中按逐顶点的方式进行光照计算，不进行任何逐像素光照计算。</p>
<p>下表列出了前向渲染中我们可以在 Shader 中访问到的光照变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213901931.png" alt="image-20220403213901931"></p>
<p>下表列出了部分前向渲染中可以用的函数：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220403213955807.png" alt="image-20220403213955807"></p>
<p>需要说明的是，上面给出的变量和函数并不是完整的，在后面的学习中，我们会使用到一些不在这些表中的变量和函数。   </p>
<h4 id="1-2-延迟渲染"><a href="#1-2-延迟渲染" class="headerlink" title="1.2 延迟渲染"></a>1.2 延迟渲染</h4><p>前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终的光照效果，我们就需要为该区域内的每个物体执行多个 Pass 来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass 我们都需要重新渲染一遍物体，但很多计算实际上是重复的 。</p>
<p>延迟渲染是一种更古老的渲染方法，但由于上述前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲（G-buffer），其中 G 是英文 Geometry 的缩写。 G 缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等。</p>
<p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，我们利用 G 缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p>
<p>延迟渲染的过程大致可以用下面的伪代码来描述：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个 Pass 不进行光照计算</span></span><br><span class="line">    <span class="comment">// 仅仅把光照计算所需的信息存储到 G 缓冲中</span></span><br><span class="line">    <span class="keyword">for</span> (each primitive <span class="keyword">in</span>  this model) &#123;</span><br><span class="line">        <span class="keyword">for</span> (each fragment covered by this primitive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed <span class="keyword">in</span> depth test) &#123;</span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                writeGBuffer(materialinfo, pos, normal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 G 缓冲中的信息进行真正的光照计算</span></span><br><span class="line">    <span class="keyword">for</span> (each pixel <span class="keyword">in</span> the screen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (the pixel is valid) &#123;</span><br><span class="line">            <span class="comment">// 如果该像素有效，读取它对应的 G 缓冲中的信息</span></span><br><span class="line">            readGBuffer(materialinfo, pos, normal);</span><br><span class="line">            <span class="comment">// 根据读取到的信息进行光照计算</span></span><br><span class="line">            float4 color = Shading(materia1Info, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">// 更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张 2D 图像，我们的计算实际上就是在这些图像空间中进行的。</p>
<p>对于延迟渲染来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点：</p>
<ul>
<li>不支持真正的反走样（抗锯齿）功能，这一点我们在图形学中学习反走样时也提到过</li>
<li>不能处理半透明物体</li>
<li>对显卡有一定要求</li>
</ul>
<p>Unity 中使用延迟渲染需要我们提供两个 Pass。第一个 Pass 用于渲染 G 缓冲。在这个 Pass 中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中。对于每个物体来说，这个 Pass 仅会执行一次；第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p>
<p>默认的G缓冲区（不同 Unity 版本的渲染纹理存储内容会有所不同）包含了以下几个渲染纹理（Render Texture，RT）：</p>
<ul>
<li>RT0：格式是 ARGB32，RGB 通道用于存储漫反射颜色，A 通道没有被使用</li>
<li>RT1：格式是 ARGB32，RGB 通道用千存储高光反射颜色，A 通道用于存储高光反射的指数部分</li>
<li>RT2：格式是 ARGB2101010，RGB 通道用于存储法线，A 通道没有被使用</li>
<li>RT3：格式是 ARGB32（非 HDR ）或 ARGBHalf（HDR），用于存储自发光 + lightmap + 反射探针（reflection probes）</li>
<li>深度缓冲和模板缓冲</li>
</ul>
<p>当在第二个 Pass 中计算光照时，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。如果我们想要使用其他的光照模型，就需要替换掉原有的 lnternal-DeferredShading.shader 文件。</p>
<p>延迟渲染中可访问的内置变量：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404161402442.png" alt="image-20220404161402442"></p>
<h3 id="2-Unity-的光源类型"><a href="#2-Unity-的光源类型" class="headerlink" title="2 Unity 的光源类型"></a>2 Unity 的光源类型</h3><p>Unity 一共支持 4 种光源类型：平行光、点光源、聚光灯和面光源。由于每种光源的几何定义不同，因此它们对应的光源属性也就各不相同。这就要求我们要区别对待它们。本节主要讨论前三种类型的光源。</p>
<p>在此之前先明确我们的 Shader 中使用了哪些光源属性。最常使用的光源属性有光源的位置、方向（更具体说就是，到某点的方向）、颜色、强度以及衰减（更具体说就是，到某点的衰减，与该点到光源的距离有关）这 5 个属性。而这些属性和它们的几何定义息息相关。</p>
<h4 id="2-1-平行光"><a href="#2-1-平行光" class="headerlink" title="2.1 平行光"></a>2.1 平行光</h4><p>我们之前使用的都是平行光，它的几何定义是最简单的。平行光可以照亮的范围是没有限制的，它通常是作为太阳这样的角色在场景中出现的。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162749907.png" alt="image-20220404162749907"></p>
<p>平行光之所以简单，是因为它没有一个唯一的位置，也就是说，它可以放在场景中的任意位置。它的几何属性只有方向，我们可以调整平行光的 Transform 组件中的 Rotation 属性来改变它的光源方向，而且平行光到场景中所有点的方向都是一样的，这也是平行光名字的由来。除此之外，由于平行光没有一个具体的位置，因此也没有衰减的概念，也就是说，光照强度不会随着距离而发生改变。</p>
<h4 id="2-2-点光源"><a href="#2-2-点光源" class="headerlink" title="2.2 点光源"></a>2.2 点光源</h4><p>点光源的照亮空间则是有限的，它是由空间中的一个球体定义的。  点光源可以表示由一个点发出的、向所有方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162727091.png" alt="image-20220404162727091"></p>
<p>球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框（如球体上的黄色控制点)来修改它的属性。点光源是有位置属性的，它是由点光源的 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用点光源的位置减去某点的位置来得到它到该点的方向。而点光源的颜色和强度可以在 Light 组件面板中调整。同时，点光源也是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。点光源球心处的光照强度最强，球体边界处的最弱，值为 0 。其中间的衰减值可以由一个函数定义。</p>
<h4 id="2-3-聚光灯"><a href="#2-3-聚光灯" class="headerlink" title="2.3 聚光灯"></a>2.3 聚光灯</h4><p>聚光灯是这 3 种光源类型中最复杂的一种。它的照亮空间同样是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义的。聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404162711673.png" alt="image-20220404162711673"></p>
<p>这块锥形区域的半径由面板中的 Range 属性决定，而锥体的张开角度由 Spot Angle 属性决定。我们同样也可以在 Scene 视图中直接拖拉聚光灯的线框（如中间的黄色控制点以及四周的黄色控制点）来修改它的属性。聚光灯的位置同样是由 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用聚光灯的位置减去某点的位置来得到它到该点的方向。聚光灯的衰减也是随着物体逐渐远离点光源而逐渐减小，在锥形的顶点处光照强度最强，在锥形的边界处强度为 0 。其中间的衰减值可以由一个函数定义，这个函数相对于点光源衰减计算公式要更加复杂，因为我们需要判断一个点是否在锥体的范围内。</p>
<h4 id="2-4-在前向渲染中处理不同类型的光源"><a href="#2-4-在前向渲染中处理不同类型的光源" class="headerlink" title="2.4 在前向渲染中处理不同类型的光源"></a>2.4 在前向渲染中处理不同类型的光源</h4><p>首先我们渲染一个有两个点光源（一个绿色、一个红色）和一个平行光（黄色）的场景，场景的 2D 视图如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404163828406.png" alt="image-20220404163828406"></p>
<p>为此我们需要分别编写 Base Pass 和 Additional Pass：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Forward Rendering&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Base Pass计算环境光和最重要的平行光</span></span><br><span class="line">            <span class="comment">// 如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素计算</span></span><br><span class="line">            <span class="comment">// 其他平行光会按照逐顶点或在Additional Pass中按逐像素的方式处理</span></span><br><span class="line">            <span class="comment">// 如果场景中没有任何平行光，那么Base Pass会当成全黑的光源处理</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="comment">// Base Pass中一定处理的是平行光，因此只需要获取光线方向</span></span><br><span class="line">                <span class="comment">// 使用_WorldSpaceLightPos0获取光线方向，平行光的光线方向到场景中任何顶点都一样</span></span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="comment">// 环境光只在 Base Pass 中计算一次，后面的 Additional Pass 不再计算</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                <span class="comment">// 漫反射，通过_LightColor0获取平行光的强度和颜色（已经是二者相乘后的结果） </span></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                <span class="comment">//平行光没有衰减，因此衰减因子设为 1 即可</span></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Additional Pass 计算其他光照，不再计算环境光</span></span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            <span class="comment">// 定义混合因子，同时开启颜色混合</span></span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 别忘了声明编译指令</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 如果是平行光，光线方向到场景中任何点都一样，_WorldSpaceLightPos0存储的是光照方向</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的光线方向要根据顶点位置计算，_WorldSpaceLightPos0存储的是光源位置</span></span><br><span class="line">                    fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line">                <span class="comment">// 漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                <span class="comment">// Blinn-Phong 高光</span></span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 处理不同光源的衰减</span></span><br><span class="line">                <span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 平行光无衰减</span></span><br><span class="line">                    fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="meta">#else</span></span><br><span class="line">                    <span class="comment">// 点光源和聚光灯的衰减因子计算非常复杂，因此 Unity 使用一张衰减纹理来作为查找表得到衰减因子</span></span><br><span class="line">                    <span class="comment">// 使用光源空间下的坐标对衰减纹理采样</span></span><br><span class="line">                    <span class="meta">#if defined (POINT)</span></span><br><span class="line">                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">                        fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#elif defined (SPOT)</span></span><br><span class="line">                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br><span class="line">                        fixed atten = (lightCoord.z &gt; <span class="number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="number">0.5</span>).w * tex2D(_LightTextureB0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                    <span class="meta">#else</span></span><br><span class="line">                        fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                    <span class="meta">#endif</span></span><br><span class="line">                <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用上面的场景时，得到的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404170534630.png" alt="image-20220404170534630"></p>
<p>可以看到左边绿色的光照，右边红色的光照和整体的黄色的平行光。</p>
<p>现在我们在场景中重新定义一些光源，包含 1 个绿色的平行光和 4 个红色的点光源，他们的布局如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171010142.png" alt="image-20220404171010142"></p>
<p>同样使用上面的 Shader 得到的渲染效果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171047163.png" alt="image-20220404171047163"></p>
<p>都得到这样的结果，是由于当我们创建一个光源时，默认情况下它的 Render Mode 是 Auto，这意味着 Unity 会自动判断哪些光源逐像素处理哪些光源逐顶点处理或 SH 处理，由于我们也没有更改 Pixel Light Count 中的数值，因此默认会处理 4 个逐像素光照，而我们的场景中有 5 个光源，其中绿色的平行光会在 Base Pass 中逐像素处理，剩下四个光源刚好不超过 Pixel Light Count ，因此会在 Additional Pass 中逐像素处理。4 个光源会调用 4 次 Additional Pass，这可以在帧调试器中看到：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171558807.png" alt="image-20220404171558807"></p>
<p>可以看到相机的渲染一共有 6 个渲染事件，其中第一个事件是 Clear，是为了清除颜色、深度和模板缓冲，为后面的渲染做准备，之后的 5 个渲染事件分别是一个 Base Pass 和 4 个 Additional Pass。</p>
<p>如果我们把点光源的 Render Mode 设置为 Not Important：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404171859381.png" alt="image-20220404171859381"></p>
<p>那么意味着我们不希望把该光源当作逐像素光照去处理，因此也就不会再调用 Additional Pass 去计算这个光源。当我们把四个点光源全部设置为不重要时，得到的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404172100048.png" alt="image-20220404172100048"></p>
<p>就只有绿色的平行光了。至于多个 Auto 光源之间 Unity 如何自动判断重要程度，与光源的强度、距离物体的远近有关。</p>
<h3 id="3-Unity-的光照衰减"><a href="#3-Unity-的光照衰减" class="headerlink" title="3 Unity 的光照衰减"></a>3 Unity 的光照衰减</h3><p>在上面的代码中我们提到 Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于，计算衰减不依赖千数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度</li>
<li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减</li>
</ul>
<p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p>
<p>Unity 在内部使用一张名为 <code>_LightTexture0</code> 的纹理来计算光源衰减，我们通常只关心 <code>_LightTexture0</code> 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。例如，(0, 0) 点表明了与光源位置重合的点的衰减值，而 (1, 1) 点表明了在光源空间中所关心的距离最远的点的衰减。</p>
<p>为了对 <code>_LightTexture0</code> 纹理采样得到给定点到该光源的衰减值，我们首先需要得到该点在光源空间中的位置，这可以通过 <code>unity_WorldToLight</code> 矩阵直接计算得到：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>然后，我们使用这个坐标模的平方对衰减纹理进行采样得到衰减值：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>可以发现，在上面的代码中，我们使用了光源空间中顶点距离的平方（通过 dot 函数来得到）来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。  然后，我们使用宏 <code>UNITY_ATTEN_CHANNEL</code> 来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值。</p>
<h3 id="4-Unity-的阴影"><a href="#4-Unity-的阴影" class="headerlink" title="4 Unity 的阴影"></a>4 Unity 的阴影</h3><p>之前我们已经学习过阴影映射（Shadow Mapping）的知识，Unity 的阴影使用的就是这种方法。</p>
<h4 id="4-1-阴影的实现原理"><a href="#4-1-阴影的实现原理" class="headerlink" title="4.1 阴影的实现原理"></a>4.1 阴影的实现原理</h4><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影， Unity 就会为该光源计算它的阴影映射纹理（Shadow Map）。 这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>那么，在计算阴影映射纹理时，我们如何判定距离它最近的表面位置呢？一种方法是，先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息，得到阴影映射纹理。但这种方法会对性能造成一定的浪费，因为我们实际上仅仅需要深度信息而已，而 Base Pass 和 Additional Pass 中往往涉及很多复杂的光照模型计算。因此，Unity 选择使用一个额外的 Pass 来专门更新光源的阴影映射纹理，这个 Pass 就是 LightMode 标签被设置为 <strong>ShadowCaster</strong> 的 Pass 。这个 Pass 的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity 首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。 因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 LightMode 为 ShadowCaster 的 Pass，如果没有，它就会在 Fallback 指定的 Unity Shader 中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影（但它仍然可以接收来自其他物体的阴影）。当找到了一个 LightMode 为 ShadowCaster 的 Pass 后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p>
<p>传统的阴影映射纹理的实现中，我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后，我们使用 xy 分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值（通常由 z 分量得到），那么说明该点位于阴影中。</p>
<p>在高版本的 Unity 中，使用的是不同于传统方法的阴影映射——<strong>屏幕空间的阴影映射技术（Screenspace Shadow Map）</strong>，屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。当使用了屏幕空间的阴影映射技术时，Unity 首先会通过调用 LightMode 为 ShadowCaster 的 Pass 来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理。然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在 Shader 中对阴影图进行采样。由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p>
<p>总结来说，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程：</p>
<ul>
<li>如果我们想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li>
<li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 在 Unity 中，这个过程是通过为该物体执行 LightMode 为 ShadowCaster 的 Pass 来实现的。如果使用了屏幕空间的阴影映射技术，Unity 还会使用这个 Pass 产生一张摄像机的深度纹理。</li>
</ul>
<h4 id="4-2-不透明物体的阴影实现"><a href="#4-2-不透明物体的阴影实现" class="headerlink" title="4.2 不透明物体的阴影实现"></a>4.2 不透明物体的阴影实现</h4><p>首先在光源属性面板设置阴影类型，这里使用软阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175527903.png" alt="image-20220404175527903"></p>
<p>然后要在物体的 Mesh Render 组件中设置物体是否投射阴影和接收阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404175627624.png" alt="image-20220404175627624"></p>
<p>如果开启了 Cast Shadows 属性，那么 Unity 就会把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。这里正方体先使用我们之前的代码定义的材质，做完这些设置后我们就可以看到如下场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180300107.png" alt="image-20220404180300107"></p>
<p>因为地面和墙面的材质是默认的材质，所以已经可以接收到正方体投射的阴影效果，但是为什么正方体会向其他物体投射阴影呢？我们之前的代码并没有为物体定义 LightMode 为 ShadowCaster 的 Pass，但是最后的 Fall Back 中我们回调了默认的 Specular Shader，而 Specular Shader 又回调了默认的 VertexLit Shader，在 VertexLit.shader 中定义了 LightMode 为 ShadowCaster 的 Pass：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404183015901.png" alt="image-20220404183015901"></p>
<p>上面的代码非常短， 尽管有一些宏和指令是我们之前没有遇到过的，但它们的用处实际上就是为了把深度信息写入渲染目标中。在 Unity 中这个 Pass 的渲染目标可以是光源的阴影映射纹理，也可以是摄像机的深度纹理。</p>
<p>同时我们注意到上面的渲染结果中，右边的墙面并没有正确的投射阴影，这是因为在默认情况下，我们在计算光源的阴影映射纹理时会剔除掉物体的背面。但对于内置的平面来说，它只有一个面，因此在本例中当计算阴影映射纹理时，由于右侧的平面在光源空间下没有任何正面，因此就不会添加到阴影映射纹理中。我们可以将 Cast Shadows 设置为 Two Sided 来允许对物体的所有面都计算阴影信息：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180534729.png" alt="image-20220404180534729"></p>
<p>更改设置后就可以正确投射阴影了：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404180607465.png" alt="image-20220404180607465"></p>
<p>接下来我们自己编写代码使得正方体也可以接受其他物体投射的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="comment">// 计算阴影需要的文件</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 声明一个用于对阴影纹理采样的坐标</span></span><br><span class="line">                <span class="comment">// 需要注意的是，这个宏的参数是下一个可用的插值寄存器的索引值，在这里就是2</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;    </span><br><span class="line">                 <span class="comment">// 阴影纹理坐标转换，传递给片元着色器</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="comment">// 计算阴影</span></span><br><span class="line">                fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">                <span class="comment">// 阴影值和漫反射、高光反射相乘即可</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 和之前的代码完全相同</span></span><br><span class="line">            <span class="comment">// Additional Pass的阴影处理和 Base Pass 是一样的，这里就不写了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们使用了三个宏定义：<code>SHADOW_COORDS</code>、<code>TRANSFER_SHADOW</code>、<code>SHADOW_ATTENUATION</code>，这些内置宏帮助我们在必要时计算光源的阴影，他们的定义都可以在 AutoLight.cginc 中找到。在前向渲染中，宏 <code>SHADOW_COORDS</code> 实际上就是声明了一个名为<code>_ShadowCoord</code> 的阴影纹理坐标变量。而 <code>TRANSFER_SHADOW</code> 的实现会根据平台不同而有所差异。如果当前平台可以使用屏幕空间的阴影映射技术（通过判断是否定义了 <code>UNITY_NO_SCREENSPACE_SHADOWS</code> 来得到），<code>TRANSFER_SHADOW</code> 会调用内置的 <code>ComputeScreenPos</code> 函数来计算 <code>_ShadowCoord</code>；如果该平台不支持屏幕空间的阴影映射技术，就会使用传统的阴影映射技术，<code>TRANSFER_SHADOW</code> 会把顶点坐标从模型空间变换到光源空间后存储到 <code>_ShadowCoord</code>中。然后，<code>SHADOW_ATTENUATION</code> 负责使用 <code>_ShadowCoord</code> 对相关的纹理进行采样，得到阴影信息。此外，当关闭了阴影后，<code>SHADOW_ COORDS</code> 和 <code>TRANSFER_SHADOW</code> 实际没有任何作用，而 <code>SHADOW_ATTENUATION</code> 会直接等同于数值1。</p>
<p><strong>需要格外注意的是</strong>，由于这些宏中会使用上下文变量来进行相关计算，例如 <code>TRANSFER_SHADOW</code> 会使用 <code>v.vertex</code> 或 <code>a.pos</code> 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2v 结构体中的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体 v2f 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。</p>
<p>最后的渲染效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404182349779.png" alt="image-20220404182349779"></p>
<p>我们可以在帧调试器中详细看到渲染过程。首先是绘制摄像机深度纹理和阴影贴图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184251457.png" alt="image-20220404184251457"></p>
<p>然后根据摄像机深度纹理和平行光的阴影贴图生成屏幕空间的阴影图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184342934.png" alt="image-20220404184342934"></p>
<p>最后是逐个物体的渲染整个场景：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184409860.png" alt="image-20220404184409860"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184419098.png" alt="image-20220404184419098"></p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404184432084.png" alt="image-20220404184432084"></p>
<h4 id="4-3-统一管理光照衰减和阴影"><a href="#4-3-统一管理光照衰减和阴影" class="headerlink" title="4.3 统一管理光照衰减和阴影"></a>4.3 统一管理光照衰减和阴影</h4><p>在前面的代码中我们了解到，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果，因此 Unity 提供了同时计算两个信息的方式，这主要是通过内置的 <code>UNITY_LIGHT_ATTENUATION</code> 宏来实现的。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Attenuation And Shadow Use Build-<span class="keyword">in</span> Functions&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 同样要使用SHADOW_COORDS定义阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 <span class="comment">// 同样使用TRANSFER_SHADOW进行阴影纹理坐标转换</span></span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唯一的不同是使用UNITY_LIGHT_ATTENUATION计算阴影和衰减</span></span><br><span class="line">                <span class="comment">// 第一个参数是阴影和衰减的乘积，UNITY_LIGHT_ATTENUATION内部会帮我们声明，因此我们无需声明</span></span><br><span class="line">                <span class="comment">// 第二个参数是 v2f 结构体，用来传递给SHADOW_ATTENUATION计算阴影</span></span><br><span class="line">                <span class="comment">// 第三个参数是世界空间的顶点位置，用于转换到光源空间在衰减纹理中采样衰减值</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用下面的声明将为额外的逐像素光源计算阴影</span></span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                 fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用内置函数使得我们可以不用自己判断光源类型，只需要一行代码</span></span><br><span class="line">                <span class="comment">// 同时这一行代码是Base Pass和Additional Pass通用的，对我们来说不必考虑其他细节</span></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-透明物体的阴影实现"><a href="#4-4-透明物体的阴影实现" class="headerlink" title="4.4 透明物体的阴影实现"></a>4.4 透明物体的阴影实现</h4><p>对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的 Fallback。</p>
<p>透明度测试的处理比较简单，但如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影。这是因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影投射纹理并没有进行这样的操作。我们先使用 VertexLit 回调实现透明度测试的阴影：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Test With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                <span class="comment">// 由于我们已经使用了 3 个插值寄存器TEXCOORD0，TEXCOORD1，TEXCOORD2</span></span><br><span class="line">                <span class="comment">// 因此SHADOW_COORDS传入的参数是3，表明使用TEXCOORD3存储阴影纹理坐标</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                clip (texColor.a - _Cutoff);</span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));                 </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阴影效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404195958714.png" alt="image-20220404195958714"></p>
<p>可以看到镂空区域也存在阴影，整个物体像是一个完整的正方体，这是因为我们使用内置的 VertexLit 中提供的 ShadowCaster 来投射阴影，而这个 Pass 中并没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息渲染到深度图和阴影映射纹理中。所以如果我们想要得到经过透明度测试后的阴影效果，就需要提供一个有透明度测试功能的 Shadow Caster Pass，于是我们把回调改为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<p>就得到了正确的阴影：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200813976.png" alt="image-20220404200813976"></p>
<p><strong>但需要注意的是，</strong>由于 Transparent&#x2F;Cutout&#x2F;VertexLit 中计算透明度测试时，使用了名为 <code>_Cutoff</code> 的属性来进行透明度测<br>试，因此，这要求我们的 Shader 中也必须提供名为 <code>_Cutoff</code> 的属性。否则，同样无法得到正确的阴影结果。</p>
<p>但是，这样的结果仍然有一些问题，例如出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。但对于本例的正方体来说，由于一些面完全背对光源，因此这些面的深度信息没有加入到阴影映射纹理的计算中。为了得到正确的结果，我们可以将正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 Two Sided，强制 Unity 在计算阴影映射纹理时计算所有面的深度信息。然后就得到了正确的渲染结果：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404200138111.png" alt="image-20220404200138111"></p>
<p>与透明度测试的物体相比，想要为使用透明度混合的物体添加阴影是一件比较复杂的事情。事实上，所有内置的透明度混合的 Unity Shader,  如 Transparent&#x2F;VertexLit 等，都没有包含阴影投射的 Pass。这意味着，这些半透明物体不会参与深度图和阴影映射纹理的计算，也就是说，它们不会向其他物体投射阴影，同样它们也不会接收来自其他物体的阴影。下面是使用 Transparent&#x2F;VertexLit 回调的透明度混合代码，在以前的透明度混合代码中加上了阴影计算：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Alpha Blend With Shadow&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);                 </span><br><span class="line">                 o.worldNormal = UnityObjectToWorldNormal(v.normal);                 </span><br><span class="line">                 o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                 o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);                 </span><br><span class="line">                 TRANSFER_SHADOW(o);                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));                </span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);                </span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);                 </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse * atten, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">    <span class="comment">// Or  force to apply shadow</span></span><br><span class="line"><span class="comment">//    FallBack &quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201541037.png" alt="image-20220404201541037"></p>
<p>Unity 会这样处理半透明物体是有它的原因的。由千透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。</p>
<p>当然，我们可以使用一些 dirty trick 来强制为半透明物体生成阴影，这可以通过把它们的 Fallback 设置为 VertexLit、 Diffuse 这些不透明物体使用的 Unity Shader,  这样 Unity 就会在它的 Fallback 找到 一个阴影投射的 Pass。然后，我们可以通过物体的 Mesh Renderer 组件上的 Cast Shadows 和 Receive Shadows 选项来控制是否需要向其他物体投射或接收阴影。下图是把Fallback 设为 VertexLit 并开启阴影投射和接收阴影后的半透明物体的渲染效果。</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/04/20220404-Shader-%E9%98%B4%E5%BD%B1%E5%92%8C%E8%A1%B0%E5%87%8F/image-20220404201901772.png" alt="image-20220404201901772"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>到此为止我们已经学习了全部的基础光照计算，包括多光源、阴影、光照衰减，现在我们可以实现一个标准的光照着色器了，使用的都是之前学习过的代码，下面是使用 Blinn-Phong 光照模型、法线纹理、阴影和光照衰减的完整的着色器代码：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Common/Bumped Specular&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _Specular (&quot;Specular Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdbase    </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3; </span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                  </span><br><span class="line">                  TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">            </span><br><span class="line">            Blend One One</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">            <span class="comment">// Use the line below to add shadows for point and spot lights</span></span><br><span class="line"><span class="comment">//            #pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">            <span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line">            </span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                 v2f o;</span><br><span class="line">                 o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">             </span><br><span class="line">                 o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                 o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">    </span><br><span class="line">                  o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                 </span><br><span class="line">                 TRANSFER_SHADOW(o);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">                </span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                 fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">                 </span><br><span class="line">                 fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">            </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>Shader</tag>
        <tag>CG/HLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】排序算法</title>
    <url>/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序是最基础的算法，也是应用最广泛的算法。对排序算法的掌握程度很能体现算法与数据结构的基本功，所以也是面试中最常问到的算法。这一节对十大常见排序算法做一个全面总结。十大排序算法可以按照时间复杂度分为三类：</p>
<ul>
<li>时间复杂度为 $O(n^2)$ 的排序：冒泡排序、选择排序、插入排序</li>
<li>时间复杂度为 $O(nlogn)$ 的排序：快速排序、归并排序、希尔排序、堆排序</li>
<li>时间复杂度为 $O(n)$ 的排序：桶排序、计数排序、基数排序</li>
</ul>
<p>可以通过<a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a>题目实践这些算法。在最后，学习 C++ STL 的排序算法 <code>sort()</code>的具体实现。</p>
<p><em><span id="more"></span></em></p>
<h2 id="1-时间复杂度为-O-n-2-的排序"><a href="#1-时间复杂度为-O-n-2-的排序" class="headerlink" title="1 时间复杂度为 $O(n^2)$ 的排序"></a>1 时间复杂度为 $O(n^2)$ 的排序</h2><p>这一类排序算法属于入门算法，性能较差，在实际工程中几乎不会用到，但他们的思想对解决一些特定问题还是很有启发的。</p>
<h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><h4 id="1-1-1-算法思想"><a href="#1-1-1-算法思想" class="headerlink" title="1.1.1 算法思想"></a>1.1.1 算法思想</h4><p>冒泡排序是入门级排序算法，但也有一些优化的写法，首先来看最简单的冒泡排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-算法优化"><a href="#1-1-2-算法优化" class="headerlink" title="1.1.2 算法优化"></a>1.1.2 算法优化</h4><p>稍微优化一下，因为在每一次冒泡的过程中，多次交换不仅会把最大&#x2F;最小的数放到末尾，还会使中间一部分变得有序，这样会导致在后面的冒泡过程中没有任何交换，但还是进行了遍历，从而造成性能的浪费。因此使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;	<span class="comment">//初始化为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!swapped) <span class="keyword">break</span>;	<span class="comment">//如果前一轮没有发生过交换说明已经有序，无需继续进行下去</span></span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进一步进行优化，除了记录当前轮次是否发生过交换外，再用一个变量记录最后一次发生交换的位置，下一次遍历只要到该位置即可，因为该位置之后必然都已经有序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 最后一个没有经过排序的元素的下标</span></span><br><span class="line">    <span class="type">int</span> indexOfLastUnsortedElement = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 上次发生交换的位置</span></span><br><span class="line">    <span class="type">int</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                <span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 表示发生了交换</span></span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 更新交换的位置</span></span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-swap-函数"><a href="#1-1-3-swap-函数" class="headerlink" title="1.1.3 swap 函数"></a>1.1.3 swap 函数</h4><p>优化后的冒泡排序的平均时间复杂度实际上还是 $O(n^2)$，所以这些优化对算法的性能并没有质的提升，因此冒泡排序也并不会在实际工程中使用，面试中也几乎不可能会问到，但是现在学习冒泡排序的另一个价值是关于上面的 swap 函数，这是面试中一个经典的问题：<strong>不使用额外空间交换数组中的两个数</strong>。做法非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>] - nums[i];</span><br></pre></td></tr></table></figure>

<p>另一种实现，先减后加，原理一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nums[i+<span class="number">1</span>] -= nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>] + nums[i];</span><br><span class="line">nums[i+<span class="number">1</span>] = nums[i] - nums[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面两种方法都可能会数字越界，最好的方法是位运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[j] ^ arr[i];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-相关练习"><a href="#1-1-4-相关练习" class="headerlink" title="1.1.4 相关练习"></a>1.1.4 相关练习</h4><h5 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h5><blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<p>自己定义一个比较函数即可，如果两个数字的字符串拼接 <code>sx + xy &lt; sy + sx</code>，则可以认为 sx 小于 sy ，即 sx 应该排在前面。</p>
<p>至于排序算法的选择，可以用任意排序，冒泡就不再重新写了，这里直接用 c++ 的 sort 函数，如果不用 sort 函数可以不使用额外空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; strs;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            strs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line">        <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), [](string&amp; x, string&amp; y)&#123; <span class="keyword">return</span> x + y &lt; y + x; &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res += strs[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/">移动零</a></h5><p>在双指针时做过，双指针自然是最好的解法，不过显然用冒泡的思想更加直观。</p>
<h3 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h3><h4 id="1-2-1-算法思想"><a href="#1-2-1-算法思想" class="headerlink" title="1.2.1 算法思想"></a>1.2.1 算法思想</h4><p>选择排序的思想是，双重遍历数组，每一轮遍历都将数组中最小&#x2F;最大的值交换到数组首位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序与冒泡排序时间复杂度和空间复杂度完全一致，但二者有一个非常大的差异就是冒泡排序是稳定的，而选择排序是不稳定的。</p>
<h4 id="1-2-2-排序的稳定性"><a href="#1-2-2-排序的稳定性" class="headerlink" title="1.2.2 排序的稳定性"></a>1.2.2 排序的稳定性</h4><p>对于排序算法来说，<strong>稳定</strong>是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>在冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。</p>
<p>那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。</p>
<p>举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。</p>
<p>当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。同样地，不稳定排序算法也可以经过修改，达到稳定的效果。比如选择排序算法实现稳定排序一种最简单的思路是：新开一个数组，将每轮找出的最小值依次添加到新数组中，这样选择排序算法就变成稳定的了。</p>
<p>但如果将寻找最小值的比较条件由 arr[minIndex] &gt; arr[j] 修改为 arr[minIndex] &gt;&#x3D; arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。</p>
<h4 id="1-2-3-算法优化"><a href="#1-2-3-算法优化" class="headerlink" title="1.2.3 算法优化"></a>1.2.3 算法优化</h4><p>选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想，每轮选择时记录最小值和最大值，这样可以把数组需要遍历的范围缩小一倍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex, maxIndex;</span><br><span class="line">    <span class="comment">// i 只需要遍历一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>() - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 记录最大值的下标</span></span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 minIndex 和 maxIndex 相等，说明当前遍历范围内所有元素都相等，整个数组已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">        <span class="comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 刚已经交换了，所以这里 maxIndex 的值要更新一下</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) maxIndex = minIndex;</span><br><span class="line">        <span class="comment">// 将最大元素交换至末尾</span></span><br><span class="line">        <span class="type">int</span> lastIndex = arr.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">        temp = arr[lastIndex];</span><br><span class="line">        arr[lastIndex] = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二元选择排序中，需要遍历的数组范围缩小了一倍，但效率并不能提高一倍，这是因为在内层循环中普通选择排序只要做一次比较，而二元选择循环需要做两次比较，因此提升的效率并不是线性的。不过由于在上面的二元选择排序中，我们使用了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (minIndex == maxIndex) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>来做优化，因此当数组中重复元素很多时，二元选择排序效率将远高于选择排序。</p>
<h3 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h3><h4 id="1-3-1-算法思想"><a href="#1-3-1-算法思想" class="headerlink" title="1.3.1 算法思想"></a>1.3.1 算法思想</h4><p>插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。</p>
<p>插入排序的基本思想就是：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// j 记录当前数字下标</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新当前数字下标</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-算法优化"><a href="#1-3-2-算法优化" class="headerlink" title="1.3.2 算法优化"></a>1.3.2 算法优化</h4><p>我们发现，在上面的插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。</p>
<p>由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 记录当前新插入的数字</span></span><br><span class="line">        <span class="type">int</span> cur = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 前面已经有序的数字如果比当前数字大，就往后移动</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序时间复杂度同样是 $O(n^2)$，空间复杂度为 $O(1)$，且插入排序是稳定的排序算法。</p>
<h4 id="1-3-3-相关练习"><a href="#1-3-3-相关练习" class="headerlink" title="1.3.3 相关练习"></a>1.3.3 相关练习</h4><h5 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序</a></h5><blockquote>
<p>给定单个链表的头 <code>head</code> ，使用<strong>插入排序</strong>对链表进行排序，并返回排序后链表的头。</p>
</blockquote>
<p>单向链表的插入排序比数组困难一些，我们无法从插入的新元素的位置向前遍历寻找插入位置，只能从头开始寻找插入位置，为此我们需要记录链表有序部分的最后一个节点，先判断该节点和当前待插入节点的大小，如果待插入节点比链表有序部分的最后一个节点的值大，那么无需插入，直接向后继续即可，否则从头结点开始寻找插入位置。</p>
<p>为了方便在头节点前插入节点，事先定义一个哑节点，这是链表题目的常规操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(INT_MIN, head);</span><br><span class="line">        ListNode* last_sorted = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt;= last_sorted-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                last_sorted = last_sorted-&gt;next;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *pre = dummy, *t = pre-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(t-&gt;val &lt;= cur-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = t-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                last_sorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">                cur = last_sorted-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-时间复杂度为-O-nlogn-的排序"><a href="#2-时间复杂度为-O-nlogn-的排序" class="headerlink" title="2 时间复杂度为 $O(nlogn)$ 的排序"></a>2 时间复杂度为 $O(nlogn)$ 的排序</h2><p>这一类排序是排序中最为重要的算法，因为他们普适性好，效率高，许多编程语言内置的排序函数的实现就综合了这里面的各类算法。</p>
<h3 id="2-1-希尔排序"><a href="#2-1-希尔排序" class="headerlink" title="2.1 希尔排序"></a>2.1 希尔排序</h3><p>希尔排序本质上是对插入排序的一种优化，虽然现在几乎不被使用，但作为第一批将时间复杂度降到 $O(n^2)$ 以下的排序算法，还是有必要了解一下。</p>
<h4 id="2-1-1-算法思想"><a href="#2-1-1-算法思想" class="headerlink" title="2.1.1 算法思想"></a>2.1.1 算法思想</h4><p>希尔排序的基本思想是：</p>
<ul>
<li>将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组</li>
<li>逐渐缩小间隔进行下一轮排序</li>
<li>最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的宏观调控，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成</li>
</ul>
<p>其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，增量依次递减，最后一个增量必须为 1，所以希尔排序又被称为「缩小增量排序」。</p>
<p>增量序列的选择会极大地影响希尔排序的效率。本例中，我们采用的增量序列为 $D_m &#x3D; N&#x2F;2$，$D_k &#x3D; D_{k+1} &#x2F; 2$ 。这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 间隔序列，在希尔排序中我们称之为增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> groupStartIndex = <span class="number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;</span><br><span class="line">            <span class="comment">// 插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> currentIndex = groupStartIndex + gap; currentIndex &lt; arr.<span class="built_in">size</span>(); currentIndex += gap) &#123;</span><br><span class="line">                <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">                <span class="type">int</span> currentNumber = arr[currentIndex];</span><br><span class="line">                <span class="type">int</span> preIndex = currentIndex - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                    <span class="comment">// 向后挪位置</span></span><br><span class="line">                    arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">                arr[preIndex + gap] = currentNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-算法优化"><a href="#2-1-2-算法优化" class="headerlink" title="2.1.2 算法优化"></a>2.1.2 算法优化</h4><p>实际上，这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// currentNumber 站起来，开始找位置</span></span><br><span class="line">            <span class="type">int</span> currentNumber = arr[i];</span><br><span class="line">            <span class="comment">// 该组前一个数字的索引</span></span><br><span class="line">            <span class="type">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;</span><br><span class="line">                <span class="comment">// 向后挪位置</span></span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// currentNumber 找到了自己的位置，坐下</span></span><br><span class="line">            arr[preIndex + gap] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与插入排序非常相似，但多了一层外层的间隔序列循环。</p>
<h4 id="2-1-3-算法性能"><a href="#2-1-3-算法性能" class="headerlink" title="2.1.3 算法性能"></a>2.1.3 算法性能</h4><p>之前说过，增量序列的选择将直接影响希尔排序的性能，因此它也是希尔排序的核心优化点，学界有不少的大牛做过这方面的研究。比较著名的有 <code>Hibbard</code> 增量序列、<code>Knuth</code> 增量序列、<code>Sedgewick</code> 增量序列。由于希尔排序已经逐渐不被使用，因此这部分内容也不是我们学习的重点。</p>
<p>事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n)$ 到 $O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。</p>
<p>我们现在学习希尔排序的意义在于，要理解希尔排序为什么能打破排序算法 $O(n^2)$ 的壁障，理解了这一点就明白了为什么希尔排序能承上启下，引发出之后一系列 $O(n^2)$ 以下的排序算法。</p>
<p>这可以通过逆序对来理解，所谓逆序对是指：当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。排序算法本质上就是一个消除逆序对的过程。对于随机数组，逆序对的数量是 $O(n^2)$ 级的，如果采用交换相邻元素的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$ 级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$ 级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>
<p>希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度为 $O(n^2)$ 的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。</p>
<h3 id="2-2-堆排序"><a href="#2-2-堆排序" class="headerlink" title="2.2 堆排序"></a>2.2 堆排序</h3><h4 id="2-2-1-算法思想"><a href="#2-2-1-算法思想" class="headerlink" title="2.2.1 算法思想"></a>2.2.1 算法思想</h4><p>我们之前已经学习过优先队列和堆，并且自己动手实现了一个堆，因此堆排序的思想现在并不难理解。我们将该数组初始构建为一个大顶堆，然后每次将堆顶元素交换到数组末尾，剩下的元素调整形成新的大顶堆，重复以上过程即可。我们之前自己动手实现堆的时候已经知道了如何调整数组元素，现在只需要了解如何通过给定数组高效的构建一个大顶堆。</p>
<p>我们可以把给定数组直接视作一个大顶堆，而不要再开辟额外空间，直接在该数组上调整元素使其成为大顶堆就行了。 对于一个长度为 n 的数组形成的堆，它的最后一个非叶子节点的编号为 <code>n / 2 - 1</code>，我们从最后一个非叶子节点开始向前遍历，每个节点和它的孩子节点比较，并作相应的交换，所以叶子节点不需要调整，直接从最后一个非叶子节点开始即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构建大顶堆,从最后一个非叶子节点开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AdjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> root, <span class="type">int</span> heapsize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftchild = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightchild = leftchild + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxindex = root;</span><br><span class="line">        <span class="keyword">if</span>(leftchild &lt; heapsize &amp;&amp; nums[leftchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightchild &lt; heapsize &amp;&amp; nums[rightchild] &gt; nums[maxindex])</span><br><span class="line">        &#123;</span><br><span class="line">            maxindex = rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxindex == root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[root], nums[maxindex]);</span><br><span class="line">        <span class="comment">//保证交换后下面的子树也是一个大顶堆</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(nums, maxindex, heapsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> heapsize = nums.<span class="built_in">size</span>() - <span class="number">1</span>; heapsize &gt; <span class="number">0</span>; --heapsize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[heapsize]);</span><br><span class="line">            <span class="built_in">AdjustHeap</span>(nums, <span class="number">0</span>, heapsize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-算法性能"><a href="#2-2-2-算法性能" class="headerlink" title="2.2.2 算法性能"></a>2.2.2 算法性能</h4><p>根据数学运算可以推导出初始化建堆的时间复杂度为 $O(n)$，重建堆的时间复杂度为 $O(n\log n)$，所以堆排序总的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$。堆排序是一个优秀的排序算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p>
<h4 id="2-2-3-相关练习"><a href="#2-2-3-相关练习" class="headerlink" title="2.2.3 相关练习"></a>2.2.3 相关练习</h4><h5 id="相对名次"><a href="#相对名次" class="headerlink" title="相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/">相对名次</a></h5><blockquote>
<p>给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都互不相同 。</p>
<p>运动员将根据得分决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：</p>
<ul>
<li>名次第 1 的运动员获金牌 “Gold Medal” 。</li>
<li>名次第 2 的运动员获银牌 “Silver Medal” 。</li>
<li>名次第 3 的运动员获铜牌 “Bronze Medal” 。</li>
<li>从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 “x”）。</li>
</ul>
<p>使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况.</p>
</blockquote>
<p>比较简单，堆排序记录下标即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRelativeRanks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; score)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = score.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 大顶堆</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pair</span>(score[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxscore = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) ans[maxscore.second] = <span class="string">&quot;Gold Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) ans[maxscore.second] = <span class="string">&quot;Silver Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>) ans[maxscore.second] = <span class="string">&quot;Bronze Medal&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[maxscore.second] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/">多数元素</a></h5><blockquote>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<p>这是一道很简单的题目，排序后数组的中位数一定是多数元素，因此只需要对数组排序即可，自己手写堆排序可以不使用额外空间。</p>
<p>对于上述结论的证明以及这道题更好的解法——摩尔投票法，参考<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解方法五</a>。</p>
<h3 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h3><h4 id="2-3-1-算法思想"><a href="#2-3-1-算法思想" class="headerlink" title="2.3.1 算法思想"></a>2.3.1 算法思想</h4><p>快速排序在时间复杂度为 $O(nlogn)$ 级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。</p>
<p>快速排序算法的基本思想是：</p>
<ul>
<li>从数组中取出一个数，称之为基数（pivot）</li>
<li>遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域</li>
<li>将左右两个区域视为两个数组，重复前两个步骤，直到排序完成</li>
</ul>
<p>依据上面的思路，我们可以先写出快速排序的框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个框架存在一个严重的问题，就是没有退出递归的边界条件，显然当某个分区内只有一个数字或者没有数字的时候就不需要继续排序了，分区内只有一个数字即 <code>start == end</code>，分区内没有数字即 <code>start &gt; end</code>，因此退出递归的条件是 <code>start &gt;= end</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前区间只有一个数字或者没有数字的时候，退出递归</span></span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将数组分区，并获得中间值的下标</span></span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="comment">// 对左边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对右边区域快速排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现最关键的分区函数，分区函数的目的是选择一个基数，然后将所有小于基数的数都放到基数左边，将所有大于基数的数都放到基数右边，最后返回基数所在的下标。</p>
<p>因此如何选择基数就成为了一个问题，一般来说有三种选择方案：</p>
<ul>
<li>选择第一个数作为基数</li>
<li>选择最后一个数作为基数</li>
<li>随机选择一个数作为基数</li>
</ul>
<p>这里我们以第一种基数选择方法为例来实现快速排序，但实际上随机选择一个数作为基数的快速排序平均时间复杂度最优，我们将在后面讨论。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> middle = <span class="built_in">partition</span>(arr, start, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, middle - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> pivot = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始</span></span><br><span class="line">    <span class="type">int</span> left = start + <span class="number">1</span>, right = end;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于等于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt; arr[pivot]) ++left;</span><br><span class="line">        <span class="comment">// 找到第一个小于基数的数</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">        <span class="comment">// 交换二者位置，保证左边都是小于基数的数，右边都是大于等于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[left], arr[right]);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出上面的while的时候，left == right，这时left和right同时指向的数还没有和基数做判断</span></span><br><span class="line">    <span class="comment">// 因此要加上这一句判断</span></span><br><span class="line">    <span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br><span class="line">    <span class="comment">// 将基数交换到中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(right != pivot) <span class="built_in">swap</span>(arr[pivot], arr[right]);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的分区函数使用了双指针的方法，这也是容易想到的比较好的实现方法。上面的代码中有一个细节，在while循环结束后，还加了一个额外的判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(left == right &amp;&amp; arr[right] &gt;= arr[pivot]) --right;</span><br></pre></td></tr></table></figure>

<p>这是因为在上面的 while 退出的时候，left 和 right 同时指向的数还没有和基数做判断，所以需要额外做一次判断；同时这行代码还解决了 [start, end] 区间内只有两个数字的情况，这种情况下第一个数字做为基数，那么 [left, right] 区间内就只有一个数字，因此不会进入 while 循环，所以需要判断一次。</p>
<p>另外要注意的是，这里不能用 left 指针来判断，因为 left 指针递加有可能超出数组范围，而 right 指针递减至少也是和 pivot 相等，即指向区间内第一个元素，所以不会出现问题，最后交换和返回也都是用 right 指针更为安全。</p>
<p>双指针实现比较简单直观，但是要写的代码比较多，也要考虑比较多的特殊情况，更为简单的分区函数实现一般是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选择区间的第一个数作为基数</span></span><br><span class="line">    <span class="type">int</span> piovt = start;</span><br><span class="line">    <span class="comment">// ret记录最后基数应该在的位置，初始为我们选择的基数的位置，也就是start</span></span><br><span class="line">    <span class="type">int</span> ret = start;</span><br><span class="line">    <span class="comment">// 从第二个数开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right = start + <span class="number">1</span>; right &lt;= end; ++right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这个数小于基数，ret向后移动一位然后换位，这样保证ret左边都是小于基数的数</span></span><br><span class="line">        <span class="keyword">if</span>(arr[right] &lt; arr[piovt])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="built_in">swap</span>(arr[ret], arr[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把基数放到ret处，返回ret</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[start], arr[ret]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样无需更多的特殊判断，是一种更高效的写法。</p>
<h4 id="2-3-2-算法分析"><a href="#2-3-2-算法分析" class="headerlink" title="2.3.2 算法分析"></a>2.3.2 算法分析</h4><p>快排的平均时间复杂度为 $O(nlogn)$，最坏情况下的时间复杂度为 $O(n^2)$；空间复杂度与递归的层数有关，最好情况下空间复杂度为 $O(logn)$，最坏情况下为 $O(n^2)$，平均空间复杂度为 $O(logn)$。</p>
<p>现在我们来分析以下为什么随机选择基数的平均复杂度更低，首先我们要搞清楚上面说的最坏情况是什么情况。理想中的快速排序在第 k 轮遍历中，可以排好 $2^{k-1}$ 个基数，假设我们用刚才实现的方法，即选择数组第一个数作为基数，考虑下面两种情况：</p>
<ul>
<li><p>数组为正序，比如 <code>nums = [1, 2, 3, 4, 5, 6]</code>，这时第一次分区将原数组分为了 [0, 0] 和 [1, 5] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一次分区也是同样，因此每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，所以总的比较次数为 $(n-1) + (n-2) + …+1 &#x3D; n(n-1)&#x2F;2$ 次，此时快排的时间复杂度就达到了 $O(n^2)$。</p>
</li>
<li><p>数组为逆序，比如 <code>nums = [6, 5, 4, 3, 2, 1]</code>，这时第一次分区将原数组分为了 [0, 4] 和 [5, 5] 两个区间，而 5 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，下一轮分区时数组变为了 <code>nums = [1, 5, 4, 3, 2, 6]</code> ，我们要在 [0, 4] 区间上继续分区，经过这一轮，将区间 [0, 4] 分为了 [0, 0] 和 [1, 4] 两个区间，而 0 是这一轮循环确定的基数的位置，所以相当于有一个区间是空的，以此类推，每次分区都有一个区间是空的，相当于每一轮遍历都只能确定 1 个基数的位置，因此这种情况下快排的时间复杂度也是 $O(n^2)$。</p>
</li>
</ul>
<p>所以为了避免这种情况，我们在数组中随机选择一个数作为基数，这样选到数组中最大值或者最小值的概率就很低，自然可以避免最坏情况的发生。</p>
<h4 id="2-3-3-算法优化"><a href="#2-3-3-算法优化" class="headerlink" title="2.3.3 算法优化"></a>2.3.3 算法优化</h4><p>根据上面的分析，一般来说快速排序前可以对原数组进行“洗牌”，以防止原数组有序的情况，洗牌算法的思想非常简单，从后向前遍历数组，然后随机选择一个数组中的数字与当前元素交换，最终所有元素都被交换一次，就打乱了原数组的顺序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RandIntRange</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">RandIntRange</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(p != i) <span class="built_in">swap</span>(nums[p], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以在排序前对原数组进行一个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。显然洗牌算法的时间复杂度为 $O(n)$。实际实现快速排序的时候我们不需要把数组完整洗牌，每次选择基数的时候随机选择一个基数即可。</p>
<h4 id="2-3-4-快速选择"><a href="#2-3-4-快速选择" class="headerlink" title="2.3.4 快速选择"></a>2.3.4 快速选择</h4><p>基于快速排序的选择算法是面试中的高频考题，我们可以再次回顾一下 TopK 问题。</p>
<h5 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></h5><blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
</blockquote>
<p>之前我们是用堆排序解决的，堆排序的方法时间复杂度为 $O(nlogn)$，空间复杂度为 $O(logn)$。使用基于快速排序的选择算法可以将平均时间复杂度降低至 $O(n)$。</p>
<p>快速选择的思想非常简单，在快速排序中，每一轮都可以确定区间内一个基数的最终位置，partition 函数会返回这个位置，因此我们从小到大进行快速排序，当确定的基数的位置为 <code>nums.size() - k</code> 时，就得到了第 K 个最大的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 随机选择基数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select_piovt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = high - low + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = low + (<span class="built_in">rand</span>() % len);</span><br><span class="line">        <span class="built_in">swap</span>(nums[t], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 分区函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> piovt = <span class="built_in">select_piovt</span>(nums, low, high);</span><br><span class="line">        <span class="type">int</span> ret = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = low + <span class="number">1</span>; right &lt;= high; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] &lt; piovt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++ret], nums[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[ret], nums[low]);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = high - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">partition</span>(nums, low, high);</span><br><span class="line">            <span class="keyword">if</span>(index == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; target) low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high = index - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a>2.4 归并排序</h3><h4 id="2-4-1-算法思想"><a href="#2-4-1-算法思想" class="headerlink" title="2.4.1 算法思想"></a>2.4.1 算法思想</h4><p>归并排序也是一种性能很优秀的排序算法，并且由于它是稳定的排序算法，因此也被广泛应用。归并排序的基本思想是对原数组不停的二分，直到每个区间都只有 1 个数字，这时这个区间可以视为一个有序区间，然后再不停的合并两个有序区间即可。</p>
<p>合并两个有序数组是我们做过的一道题，一般来说可以开辟一个长度为两个区间之和的数组，然后双指针遍历两个数组即可。由此我们可以写出归并排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了节省空间，我们始终在一个额外数组上操作，避免创建很多新的临时变量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间内只有一个数字，开始回溯</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 把[start,mid]的合并结果存到temp的[start,mid]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">    <span class="comment">// 把[mid+1,end]的合并结果存到temp的[mid+1,end]区间上</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">    <span class="comment">// 合并[start, end]区间内两个有序区间</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 第一个区间的指针从start开始</span></span><br><span class="line">    <span class="type">int</span> index1 = start;</span><br><span class="line">    <span class="comment">// 第二个区间的指针从mid+1开始，同时记下第二个区间的开始位置</span></span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">            <span class="comment">// temp数组每次要放的位置是start+(index1-start)+(index2-start2)</span></span><br><span class="line">            <span class="comment">// 展开整理一下就是index1 + index2 - start2</span></span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下没遍历到的元素接到temp末尾</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">        ++index1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">        ++index2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把temp合并的结果放回nums对应区间上，这样nums对应区间就变得有序了，便于下次合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-算法分析"><a href="#2-4-2-算法分析" class="headerlink" title="2.4.2 算法分析"></a>2.4.2 算法分析</h4><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$。空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 temp 数组。</p>
<p>我们在合并数组的时候的判断条件是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[index1] &lt;= nums[index2])</span><br></pre></td></tr></table></figure>

<p>这保证了归并排序是稳定的。如果没有等号则归并排序不再稳定。</p>
<h4 id="2-4-3-相关练习"><a href="#2-4-3-相关练习" class="headerlink" title="2.4.3 相关练习"></a>2.4.3 相关练习</h4><h5 id="合并排序的数组"><a href="#合并排序的数组" class="headerlink" title="合并排序的数组"></a><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/">合并排序的数组</a></h5><blockquote>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
</blockquote>
<p>因为 A 数组末尾提供了足够的空间，我们使用双指针逆序从两个数组末尾取出数字，把最大的放到A的末尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pa = m - <span class="number">1</span>, pb = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa &gt;= <span class="number">0</span> &amp;&amp; pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[pa] &gt;= B[pb])</span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = A[pa];</span><br><span class="line">                --pa;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">                --pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pb &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A[pa + pb + <span class="number">1</span>] = B[pb];</span><br><span class="line">            --pb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h5><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<p>使用暴力法很简单但时间复杂度太高，这道题非常考验对归并排序的理解。</p>
<p>关键在于归并排序中合并有序数组的时候，如果左边数组中当前指针指向的数字 nums[left] 比右边数组中当前指针指向的数字 nums[right] 小，那么就把 nums[left] 加入答案，同时判断右边数组中有多少数字比 nums[left] 小，这就是 nums[left] 对整个数组逆序对数量的贡献，因为右边数组中比 nums[left] 小的数原本排在了 nums[left] 的右边，就构成了一个逆序对。而右边数组中比 nums[left] 小的数字数量刚好就是右边数组的当前指针 right 相对于右边数组起始位置 mid + 1 的偏移，因为在右边数组当前指针之前的数字都已经加入到了结果中，一定比 nums[left] 小。</p>
<p>按照上面的思路，我们只需要在归并排序中加一个统计逆序对数量的变量即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, start, mid, temp);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid + <span class="number">1</span>, end, temp);</span><br><span class="line">        <span class="built_in">merge</span>(nums, start, end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序区间，并统计逆序对数量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> index1 = start;</span><br><span class="line">        <span class="type">int</span> start2 = mid + <span class="number">1</span>, index2 = start2;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid &amp;&amp; index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index1] &lt;= nums[index2]) &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">                ++index1;</span><br><span class="line">                <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">                cnt += index2 - start2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">                ++index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index1 &lt;= mid)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index1];</span><br><span class="line">            ++index1;</span><br><span class="line">            <span class="comment">// 统计贡献了多少逆序对</span></span><br><span class="line">            cnt += index2 - start2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后面的数组没有遍历完，说明剩下的所有数字都比前面的大，没有逆序对贡献</span></span><br><span class="line">        <span class="keyword">while</span>(index2 &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[index1 + index2 - start2] = nums[index2];</span><br><span class="line">            ++index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-时间复杂度为-O-n-的排序"><a href="#3-时间复杂度为-O-n-的排序" class="headerlink" title="3 时间复杂度为 $O(n)$ 的排序"></a>3 时间复杂度为 $O(n)$ 的排序</h2><p>这一类排序算法平均时间复杂度最优，但一般只适用于特定场景，在特定问题下的排序效率将高于其他算法。</p>
<h3 id="3-1-计数排序"><a href="#3-1-计数排序" class="headerlink" title="3.1 计数排序"></a>3.1 计数排序</h3><h4 id="3-1-1-算法思想"><a href="#3-1-1-算法思想" class="headerlink" title="3.1.1 算法思想"></a>3.1.1 算法思想</h4><p>计数排序的思想很简单，假设一个数组只包含 0 ~ 9 范围内的数字，那我们可以建立一个长度为 10 的数组，统计原数组中 0 ~ 9 各出现了几次，统计完成后再按顺序把数字填到数组中即可，整个过程如下图：</p>
<p><img src="https://lz328.github.io/LycTechStack.github.io/2022/04/13/20220413-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1620707085-FdqElS-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="1620707085-FdqElS-计数排序"></p>
<p>但这样排序并不是真正的计数排序，因为我们这样做相当于只是把和原数组中数字相同的值放回了原数组中，而这些值已经不是原来的数字了，这在实际工程中如果待排序的对象有其他属性的话，这样做就会丢掉其他属性，于是我们可以建立一个哈希表，去存储每个数字对应的原来的数字（对象），最后再按顺序放回去即可。</p>
<p>真正的计数排序使用的方法更为巧妙，统计完计数数组后，遍历原数组，对原数组的每一个元素可以根据计数数组的结果得到它排序后应该在的位置，他应该在的位置就是起始位置加上所有比它小的数字之和，因此直接把该数字放到对应的位置上即可。同时为了处理更一般的情况，而不是只有 0 ~ 9，要先统计计数范围，计数范围就是数组中的最小值到最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录前面比自己小的数字的总数</span></span><br><span class="line">    <span class="type">int</span> preCounts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span></span><br><span class="line">        preCounts += counting[i];</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的起始下标位置，即前面比自己小的数字的总数。</span></span><br><span class="line">        counting[i] = preCounts - counting[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        <span class="comment">// counting[element - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[element - min]] = element;</span><br><span class="line">        <span class="comment">// 更新 counting[element - min]，指向此元素的下一个下标</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很好理解，计数排序还有另一种写法，即在统计对应元素所在位置的时候，不统计该元素在结果中起始位置的下标，而是统计最后一个位置的下标，然后遍历原数组的时候从后向前遍历，这样的写法可以避免记录 preCounts，效率更高，一般也常使用这种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到最大值，最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定计数范围</span></span><br><span class="line">    <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(range)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 arr 中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; element : arr) &#123;</span><br><span class="line">        <span class="comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置</span></span><br><span class="line">        <span class="comment">// 这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span></span><br><span class="line">        ++counting[element - min];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个数字在结果中的最后一个下标位置 = 比它小的数字数量 + 该数字的数量 - 1</span></span><br><span class="line">    <span class="comment">// 我们预先对counting[0]减去1，这样之后就不需要每次都减了</span></span><br><span class="line">    counting[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; range; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置</span></span><br><span class="line">        counting[i] += counting[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span></span><br><span class="line">        result[counting[arr[i] - min]] = arr[i];</span><br><span class="line">        <span class="comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span></span><br><span class="line">        counting[arr[i] - min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果赋值回 arr</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在遍历原数组放到结果数组中相应位置的时候，不逆序遍历也可以得到正确的结果，但只有逆序遍历才能保证计数排序的稳定性。</p>
<h4 id="3-1-2-算法分析"><a href="#3-1-2-算法分析" class="headerlink" title="3.1.2 算法分析"></a>3.1.2 算法分析</h4><p>从计数排序的实现代码中可以看到，每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 $O(n + k)$，k 表示数据的范围大小。用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 $O(n + k)$。</p>
<p>需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。并且由此我们可以发现计数排序的一个致命的缺点，如果对下面的数组使用计数排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, INT_MAX&#125;;</span><br></pre></td></tr></table></figure>

<p>我们将会创建一个从 1 到 INT_MAX 的计数数组，C++ 中 int 占 4 字节，一个长度为 $2^{31}$ 的数组要占用 8G 的空间。所以计数排序只适用于数据范围不大的场景，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p>
<p>接下来我们考虑为什么计数排序可以突破 $O(nlogn)$ 的时间复杂度。<strong>因为计数排序不是基于比较的排序算法</strong>。</p>
<p>根据决策树理论可以推导出<strong>所有基于比较的排序算法最坏情况下都要做 $O(nlogn)$ 次比较</strong>，因此所有基于比较的排序算法无论怎么优化都不可能突破 $O(nlogn)$ 的下界，而基数排序不是基于比较的算法，是利用数字本身的属性进行排序，整个算法中没有出现任何一次比较。</p>
<h4 id="3-1-3-相关练习"><a href="#3-1-3-相关练习" class="headerlink" title="3.1.3 相关练习"></a>3.1.3 相关练习</h4><h5 id="数组的相对排序"><a href="#数组的相对排序" class="headerlink" title="数组的相对排序"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">数组的相对排序</a></h5><blockquote>
<p>给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。</p>
<p>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
</blockquote>
<p>我们可以按照计数排序的思想，统计每个数字出现的次数，然后根据 arr2 计算每个数字应该在结果中对应的左右一个下标位置，这样就可以把在 arr2 中出现过的数字排好，剩下没有出现过的放到数组末尾，然后再利用其他排序微调。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr1.<span class="built_in">size</span>(), m = arr2.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">presum</span><span class="params">(m+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            presum[i] = presum[i<span class="number">-1</span>] + countings[arr2[i<span class="number">-1</span>] - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(i + min) != map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = map[i + min];</span><br><span class="line">                countings[i] = countings[i] + presum[t] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = countings[i];</span><br><span class="line">                countings[i] = countings[i] + presum[m] + offset - <span class="number">1</span>;</span><br><span class="line">                offset += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[countings[arr1[i] - min]] = arr1[i];</span><br><span class="line">            countings[arr1[i] - min]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>() + presum[m], res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这样做显然使问题变得更复杂了，上面用到了哈希表、前缀和等复杂的技巧，对于这道简单题来说是完全没有必要的，我们只要用伪计数排序的思想，统计数字出现的次数，然后按照 arr2 提供的顺序找到计数数组中该数字出现的次数，放到结果数组中即可，之后再遍历一次计数数组把出现次数不为 0 的数按顺序放到结果末尾即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = *<span class="built_in">min_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = *<span class="built_in">max_element</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countings</span><span class="params">(range)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++countings[e - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; e : arr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[e - min]) &#123;</span><br><span class="line">                arr1[index] = e;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[e - min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; range; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(countings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                arr1[index] = i + min;</span><br><span class="line">                ++index;</span><br><span class="line">                --countings[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-基数排序"><a href="#3-2-基数排序" class="headerlink" title="3.2 基数排序"></a>3.2 基数排序</h3><h4 id="3-2-1-算法思想"><a href="#3-2-1-算法思想" class="headerlink" title="3.2.1 算法思想"></a>3.2.1 算法思想</h4><p>基数排序是通过对比数字的关键字进行排序的，关键字就称为基数，比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：</p>
<ul>
<li>先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系</li>
<li>再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系</li>
<li>再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999</li>
</ul>
<p>这就是基数排序的思路，上面的过程我们是从数字的最高位开始比较的，这样的基数排序叫做「最高位优先法」，简称 <code>MSD (Most significant digital)</code>，与之对应的还有「最低位优先法」，简称 <code>LSD (Least significant digital)</code>。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。</p>
<p>一般来说 LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。</p>
<p>基数排序可以分为以下三个步骤：</p>
<ul>
<li>找出数组中最大的数字的位数 maxDigitLength</li>
<li>获取数组中每个数字的基数</li>
<li>遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序</li>
</ul>
<p>对基数进行排序最好的办法就是使用计数排序，因为基数只可能在 0 ~ 9 之间，使用计数排序效率会很高，并且还能保证稳定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组中存在负数时，我们可以把计数排序的统计数组改为长度为19，用来统计 -9 ~ 9 出现的次数，但是要注意计算出的基数要加 9，以从 [-9, 9] 映射到计数数组下标 [0, 18]，完整的基数排序算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(value) &gt; max) &#123;</span><br><span class="line">            max = <span class="built_in">abs</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大数字的长度,不需要考虑最大数字为0的情况，因为最大数字为0说明数组已经有序</span></span><br><span class="line">    <span class="type">int</span> maxDigitLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        maxDigitLength++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用计数排序算法对基数进行排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDigitLength; i++) &#123;</span><br><span class="line">        <span class="comment">// 统计基数出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="type">int</span> radix = value / dev % <span class="number">10</span>;</span><br><span class="line">            counting[radix + <span class="number">9</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算在结果数组中应该在的最后下标位置,这里的位置没有减1，放到了下面存结果的时候计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; counting.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            counting[j] += counting[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用倒序遍历的方式完成计数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> radix = arr[j] / dev % <span class="number">10</span>;</span><br><span class="line">            result[--counting[radix + <span class="number">9</span>]] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数排序完成后，将结果拷贝回 arr 数组</span></span><br><span class="line">        arr.<span class="built_in">assign</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 将计数数组重置为 0</span></span><br><span class="line">        counting.<span class="built_in">assign</span>(<span class="number">19</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 取下一位基数</span></span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-算法分析"><a href="#3-2-2-算法分析" class="headerlink" title="3.2.2 算法分析"></a>3.2.2 算法分析</h4><p>基数排序需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。所以基数排序的时间复杂度为 $O(d(n + k))$，其中 d 表示最长数字的位数，k 表示每个基数可能的取值范围大小。</p>
<p>基数排序使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$，其中 k 表示每个基数可能的取值范围大小。</p>
<h4 id="3-2-3-相关练习"><a href="#3-2-3-相关练习" class="headerlink" title="3.2.3 相关练习"></a>3.2.3 相关练习</h4><h5 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>因为要保证线性时间和空间复杂度，因此使用基数排序符合要求，排序后再遍历找到最大差值即可。</p>
<h5 id="数组拆分-I"><a href="#数组拆分-I" class="headerlink" title="数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I</a></h5><blockquote>
<p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p>
<p>返回该最大总和 。</p>
</blockquote>
<p>排序后拆分即可。使用基数排序会使时间复杂度更低。</p>
<h3 id="3-3-桶排序"><a href="#3-3-桶排序" class="headerlink" title="3.3 桶排序"></a>3.3 桶排序</h3><h4 id="3-3-1-算法思想"><a href="#3-3-1-算法思想" class="headerlink" title="3.3.1 算法思想"></a>3.3.1 算法思想</h4><p>桶排序的思想是：</p>
<ul>
<li>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶</li>
<li>遍历数组，将每个数字装入桶中</li>
<li>对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等</li>
<li>最后按照顺序将所有桶内的数字合并起来</li>
</ul>
<p>桶排序一般只能在特定情况下使用，因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。</p>
<p>影响桶排序的效率的因素主要有两个：</p>
<ul>
<li>一个是桶的数量，桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。一般来说设置桶的数量要根据数组的数据量和数组内的最大值和最小值确定，一般用如下公式确定可以保证每个桶内的数字尽量均匀：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个桶的间距</span></span><br><span class="line">gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 桶的数量</span></span><br><span class="line">bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 数组内数字所在的桶的编号</span></span><br><span class="line">index = (nums[i] - min) / gap;</span><br></pre></td></tr></table></figure>

<ul>
<li>桶内排序算法，桶内排序算法可以使用插入排序、快速排序等，可以根据实际需要选择。</li>
</ul>
<p>基于插入排序的桶排序的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxnum = *<span class="built_in">max_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minnum = *<span class="built_in">min_element</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> gap = (maxnum - minnum) / n + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bucketnum = (maxnum - minnum) / gap + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketnum);</span><br><span class="line">    <span class="comment">// 装桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; x : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = (x - minnum) / gap;</span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 桶内排序并放回原数组</span></span><br><span class="line">    arr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertsort</span>(buckets[i]);</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = nums[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-算法分析"><a href="#3-3-2-算法分析" class="headerlink" title="3.3.2 算法分析"></a>3.3.2 算法分析</h4><p>我们逐步分析桶排序的时间复杂度和空间复杂度。</p>
<p>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>第二步：装桶的过程需要遍历一轮数组，时间复杂度 $O(n)$，空间复杂度与$O(n)$。</p>
<p>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 $n&#x2F;k$,</p>
<ul>
<li><p>如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n&#x2F;k)^2)$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k)^2)$，即 $O(n^2 &#x2F; k)$。</p>
</li>
<li><p>如果采用 $O(n\log n)$ 级排序算法，每个桶内排序的时间复杂度 $O((n&#x2F;k) \log (n&#x2F;k))$，所有桶完成排序的时间复杂度为 $O(k(n&#x2F;k) \log (n&#x2F;k))$，即 $O(n \log (n&#x2F;k))$。</p>
</li>
</ul>
<p>在桶的数量合适的情况下，时间复杂度 $O(n^2 &#x2F; k)$ 和 $O(n \log (n&#x2F;k))$ 都约等于 $O(n)$。桶内排序的空间复杂度也和具体的排序算法有关，$O(1)$ 或者 $O(n)$。</p>
<p>第四步：桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 $O(n)$，空间复杂度 $O(1)$。</p>
<p>综上，桶排序的时间复杂度为 $O(n)$，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快。空间复杂度为 $O(n)$。</p>
<h4 id="3-3-3-相关练习"><a href="#3-3-3-相关练习" class="headerlink" title="3.3.3 相关练习"></a>3.3.3 相关练习</h4><h5 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h5><blockquote>
<p>给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。非商业转载请注明出处。</p>
</blockquote>
<p>使用桶排序解决这个问题更加巧妙。甚至不需要真正进行排序，只要把所有数字放到对应的桶里，然后记录每个桶的最大值和最小值，最后从左到右遍历桶，用后一个桶的最小值减去前一个桶的最大值，所有这些差值中最大的就是题目所要求的最大间距。具体证明参考<a href="https://leetcode-cn.com/problems/maximum-gap/solution/zui-da-jian-ju-by-leetcode-solution/">官方题解方法二</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = (maxVal - minVal) / n + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bucketnum = (maxVal - minVal) / gap + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketnum, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> idx = (nums[i] - minVal) / gap;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketnum; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-C-STL-中的-sort-函数"><a href="#4-C-STL-中的-sort-函数" class="headerlink" title="4 C++ STL 中的 sort() 函数"></a>4 C++ STL 中的 sort() 函数</h2><p>STL 中的排序算法是所有算法中最庞大和复杂的一个，结合了上面多种排序算法，利用他们的特点，最大化排序效率。</p>
<h3 id="4-1-插入排序"><a href="#4-1-插入排序" class="headerlink" title="4.1 插入排序"></a>4.1 插入排序</h3><p>首先是插入排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序，两个版本，一个默认使用小于号排序，另一个接受自定义排序函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>; </span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __insertion_sort(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Compare __comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序辅助函数一</span></span><br><span class="line"><span class="comment">// 先判断尾部元素是否比头部元素小，如果是，则直接所有元素右移一位，尾部元素插入到头部</span></span><br><span class="line"><span class="comment">// 否则按照正常插入排序进行</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  _Tp __val = *__last;         <span class="comment">//记录尾部元素</span></span><br><span class="line">  <span class="keyword">if</span> (__val &lt; *__first) &#123;      <span class="comment">//如果尾部元素比头部元素小，一次性解决</span></span><br><span class="line">    <span class="comment">//所有元素右移 </span></span><br><span class="line">    <span class="built_in">copy_backward</span>(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//尾部元素插入到头部</span></span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">//否则，尾部元素不比头部元素小，按照插入排序从后向前找到__val该在的位置并插入</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __linear_insert(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Tp*, _Compare __comp) &#123;</span><br><span class="line">  _Tp __val = *__last;</span><br><span class="line">  <span class="keyword">if</span> (__comp(__val, *__first)) &#123;</span><br><span class="line">    <span class="built_in">copy_backward</span>(__first, __last, __last + <span class="number">1</span>);</span><br><span class="line">    *__first = __val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(__last, __val, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序辅助函数二，正常插入排序步骤</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val) &#123;</span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;</span><br><span class="line">  <span class="keyword">while</span> (__val &lt; *__next) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, </span><br><span class="line">                               _Compare __comp) &#123;</span><br><span class="line">  _RandomAccessIter __next = __last;</span><br><span class="line">  --__next;  </span><br><span class="line">  <span class="keyword">while</span> (__comp(__val, *__next)) &#123;</span><br><span class="line">    *__last = *__next;</span><br><span class="line">    __last = __next;</span><br><span class="line">    --__next;</span><br><span class="line">  &#125;</span><br><span class="line">  *__last = __val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-快速排序"><a href="#4-2-快速排序" class="headerlink" title="4.2 快速排序"></a>4.2 快速排序</h3><p>接下来是快速排序，STL 采用三点中值作为快排的 pivot：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> _Tp&amp; __median(<span class="type">const</span> _Tp&amp; __a, <span class="type">const</span> _Tp&amp; __b, <span class="type">const</span> _Tp&amp; __c) &#123;</span><br><span class="line">  __STL_REQUIRES(_Tp, _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__a &lt; __b)</span><br><span class="line">    <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">      <span class="keyword">return</span> __c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__a &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__b &lt; __c)</span><br><span class="line">    <span class="keyword">return</span> __c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> _Tp&amp;</span><br><span class="line">__median(<span class="type">const</span> _Tp&amp; __a, <span class="type">const</span> _Tp&amp; __b, <span class="type">const</span> _Tp&amp; __c, _Compare __comp) &#123;</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>, _Tp, _Tp);</span><br><span class="line">  <span class="keyword">if</span> (__comp(__a, __b))</span><br><span class="line">    <span class="keyword">if</span> (__comp(__b, __c))</span><br><span class="line">      <span class="keyword">return</span> __b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__a, __c))</span><br><span class="line">      <span class="keyword">return</span> __c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__a, __c))</span><br><span class="line">    <span class="keyword">return</span> __a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__comp(__b, __c))</span><br><span class="line">    <span class="keyword">return</span> __c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分区函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序分区函数，和我们上面实现的基本一致</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line">_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, </span><br><span class="line">                                        _RandomAccessIter __last, </span><br><span class="line">                                        _Tp __pivot) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到第一个大于等于pivot的数</span></span><br><span class="line">    <span class="keyword">while</span> (*__first &lt; __pivot)</span><br><span class="line">      ++__first;</span><br><span class="line">    <span class="comment">// 找到第一个小于等于pivot的数</span></span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__pivot &lt; *__last)</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="comment">// 返回分区点</span></span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    <span class="comment">// 交换，继续循环</span></span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line">_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, </span><br><span class="line">                                        _RandomAccessIter __last, </span><br><span class="line">                                        _Tp __pivot, _Compare __comp) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (__comp(*__first, __pivot))</span><br><span class="line">      ++__first;</span><br><span class="line">    --__last;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__pivot, *__last))</span><br><span class="line">      --__last;</span><br><span class="line">    <span class="keyword">if</span> (!(__first &lt; __last))</span><br><span class="line">      <span class="keyword">return</span> __first;</span><br><span class="line">    <span class="built_in">iter_swap</span>(__first, __last);</span><br><span class="line">    ++__first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-堆排序"><a href="#4-3-堆排序" class="headerlink" title="4.3 堆排序"></a>4.3 堆排序</h3><p>STL 的排序算法还用到了堆排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序，__partial_sort用作内部使用，不以__开头的函数是对外接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle);    <span class="comment">// 默认大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (*__i &lt; *__first) </span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i),</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(_RandomAccessIter __first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,</span><br><span class="line">                    _RandomAccessIter __last, _Tp*, _Compare __comp) &#123;</span><br><span class="line">  <span class="built_in">make_heap</span>(__first, __middle, __comp);</span><br><span class="line">  <span class="keyword">for</span> (_RandomAccessIter __i = __middle; __i &lt; __last; ++__i)</span><br><span class="line">    <span class="keyword">if</span> (__comp(*__i, *__first))</span><br><span class="line">      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,</span><br><span class="line">                 __DISTANCE_TYPE(__first));</span><br><span class="line">  <span class="built_in">sort_heap</span>(__first, __middle, __comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">partial_sort</span><span class="params">(_RandomAccessIter __first,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __middle,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _RandomAccessIter __last, _Compare __comp)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>, </span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-IntroSort"><a href="#4-4-IntroSort" class="headerlink" title="4.4 IntroSort"></a>4.4 IntroSort</h3><p>通过之前的学习我们知道，快速排序时，不当的 pivot 选择，会导致不当的分割，最使得快速排序恶化为 $O(n^2)$。David R. Musser 于 1996 年提出一种混合式排序算法——Introspective Sorting（内省排序）。其行为在大部分情况下几乎与使用中值作为 pivot 的快排完全相同。但是当分割行为有恶化为二次行为倾向时，能自我侦测，转而改用堆排序，使效率维持在 $O(nlogn)$，又比一开始就使用堆排序来得好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> __stl_threshold = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lg控制最大递归层数，找到 2^k &lt;= n 的最大k值作为快排的最大分区次数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Size</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _Size __lg(_Size __n) &#123;</span><br><span class="line">  _Size __k;</span><br><span class="line">  <span class="keyword">for</span> (__k = <span class="number">0</span>; __n != <span class="number">1</span>; __n &gt;&gt;= <span class="number">1</span>) ++__k;</span><br><span class="line">  <span class="keyword">return</span> __k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Introspective Sorting，同样是两个版本，只看第一个版本即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Tp*,</span><br><span class="line">                      _Size __depth_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// __stl_threshold是给定的一个阈值</span></span><br><span class="line">  <span class="comment">// 当待排序的序列长度小于这个阈值就不再进行IntroSort，之后在sort函数源码中可以看到为什么这么做</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;	<span class="comment">//当递归深度为0时，说明发生分割恶化</span></span><br><span class="line">      <span class="built_in">partial_sort</span>(__first, __last, __last);  <span class="comment">//改用堆排序</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    <span class="comment">// 正常的快排流程，首先是分区</span></span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>))));</span><br><span class="line">    <span class="comment">// 递归对右侧分区排序</span></span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit);</span><br><span class="line">    <span class="comment">// 递归对左侧分区排序</span></span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Size</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __introsort_loop(_RandomAccessIter __first,</span><br><span class="line">                      _RandomAccessIter __last, _Tp*,</span><br><span class="line">                      _Size __depth_limit, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">partial_sort</span>(__first, __last, __last, __comp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --__depth_limit;</span><br><span class="line">    _RandomAccessIter __cut =</span><br><span class="line">      __unguarded_partition(__first, __last,</span><br><span class="line">                            _Tp(__median(*__first,</span><br><span class="line">                                         *(__first + (__last - __first)/<span class="number">2</span>),</span><br><span class="line">                                         *(__last - <span class="number">1</span>), __comp)),</span><br><span class="line">       __comp);</span><br><span class="line">    __introsort_loop(__cut, __last, (_Tp*) <span class="number">0</span>, __depth_limit, __comp);</span><br><span class="line">    __last = __cut;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-sort"><a href="#4-5-sort" class="headerlink" title="4.5 sort()"></a>4.5 sort()</h3><p>终于到了 sort 函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// STL 的 sort 函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(_RandomAccessIter __first, _RandomAccessIter __last)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">                 _LessThanComparable);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    <span class="comment">// 首先使用IntroSort，排序后整个序列会被分为多个小于等于16的子序列，这些子序列基本有序</span></span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 此时整个序列处于基本有序状态，进行最后的插入排序，因为插入排序在序列基本有序的情况下效率很高</span></span><br><span class="line">    __final_insertion_sort(__first, __last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(_RandomAccessIter __first, _RandomAccessIter __last,</span></span></span><br><span class="line"><span class="params"><span class="function">                 _Compare __comp)</span> </span>&#123;</span><br><span class="line">  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);</span><br><span class="line">  __STL_BINARY_FUNCTION_CHECK(_Compare, <span class="type">bool</span>,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIter&gt;::value_type);</span><br><span class="line">  <span class="keyword">if</span> (__first != __last) &#123;</span><br><span class="line">    __introsort_loop(__first, __last,</span><br><span class="line">                     __VALUE_TYPE(__first),</span><br><span class="line">                     __lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">                     __comp);</span><br><span class="line">    __final_insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__final_insertion_sort</code> 函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last) &#123;</span><br><span class="line">    <span class="comment">// 序列长度大于16</span></span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="comment">// 对__first到 __first+16 排序</span></span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold);</span><br><span class="line">    <span class="comment">// 直接进入插入排序循环内部对__first+16到__last排序</span></span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 序列长度不足16直接插入排序</span></span><br><span class="line">    __insertion_sort(__first, __last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIter</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="type">void</span> __final_insertion_sort(_RandomAccessIter __first, </span><br><span class="line">                            _RandomAccessIter __last, _Compare __comp) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(__first, __first + __stl_threshold, __comp);</span><br><span class="line">    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(__first, __last, __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>__unguarded_insertion_sort</code> 只是调用了上面插入排序中的辅助函数二  <code>__unguarded_linear_insert</code>。</p>
<h3 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h3><p>通过以上的 STL 源码，可以看出 STL 的 sort 函数首先对整个序列使用 IntroSort 进行排序，如果序列长度不足 16，直接退出 IntroSort，因为对于短序列，快速排序效率可能不如插入排序，所以直接进行插入排序。IntroSort 内部会首先根据序列长度计算快速排序的最大递归层数，当快排递归到最大层数后改用堆排序，经过 IntroSort 后的序列被分为多个长度小于等于 16 的子序列，这些子序列之间有序，子序列内部基本有序，因此整个序列处于基本有序状态。最后调用插入排序对整个序列排序，插入排序在序列基本有序的情况下效率很高。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
